****************************************
LANGUAGE
****************************************
-------------------------------------
#premain ?
-------------------------------------
var lazy evaluation ?
-------------------------------------
callable
https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md
impl AA
{
	func opCall(...)
	{
	}
}
var x: AA
x(10) => x.opCall(10)
-------------------------------------
loop increment ? loop reverse ?
-------------------------------------
is ?
if a is < 2 and > 3
if a is s32
if a is "toto"
if a is in 2..6
-------------------------------------
not au lieu de ! ?
-------------------------------------
x 'in' 0..16
-------------------------------------
`return au lieu de swag.noreturn ?
-------------------------------------
compile time return Array's32 => convertir en tableau static, avec opIndex & opCount ?
-------------------------------------
code en tant que vrai type ?
x := #code a := 6
#mixin x
var v: Array'code
v.add(#code a := 5)
v.add(#code @print(a))
#mixin v[0]
#mixin v[1]
-------------------------------------




****************************************
TODO
****************************************
-------------------------------------
constexpr function qui return un slice dont le contenu est pas géré
-------------------------------------
constexpr function qui renvoie une struct compliquée (array), appeler opDrop à la fin
-------------------------------------
sub func avec param x := Enum.Val (sub func pas exporté comme func, faut faire qqchose !)
oui mais quoi ? les sous trucs sont pas forcément passés par la sémantique (par example si macro)
-------------------------------------
comme examples et std partagent .out, ca merde avec les debug infos des fichiers publiques qui sont regénérés
quand on compile /examples (et differents) du coup test_std a été compilé avec des lignes differentes
-------------------------------------
range dynamic order
-------------------------------------
script, si #main resoud pas, erreur bizarre
-------------------------------------
debugger : print
-------------------------------------
pb des pointers alias avec retval (retval qui pointe sur une variable qu'on utilise dans la fonction elle-même)
-------------------------------------
BIG BIG BIG BIG BIG CHIANT CHIANT CHIANT CHIANT CHIANT
llvm/x64 compatibilité
si llvm appel une lambda local x64 ou l'inverse, abi non compatible => marche si on passe la lambda en #[swag.callback]
que faire ?
-------------------------------------
slice/cstrings and foreign
-------------------------------------
attributes flags qui sont a la fois on et off => error
-------------------------------------
cast any avec struct, ca fait quoi (et avec les using ?)
-------------------------------------
cast interface vers struct (avec safety)
-------------------------------------
x64/llvm debug
- mettre les constants, les enums (void CodeViewDebug::emitStaticConstMemberList())
-------------------------------------
llvm debug, pas à jour
- variables local en #[Swag.global]
-------------------------------------


****************************************
OPTIMS
****************************************
-------------------------------------
optim switch si int/string etc... (table, hash...)
-------------------------------------
x64 binaryop div, transformer en shift si log2
-------------------------------------
BinOpModuloS32/div immediate mode
-------------------------------------
x64 emit_BinOpInt32/64 etc.. faire un mode immediat pour le côté droit 'and cl, 5'
-------------------------------------
Mul64byVB64 a deux registres ! (binOpPlus/Minus inc pointer)
-------------------------------------
makestackpointer suivi de copyrctort, faire une instruction "copy address stack to rt"
-------------------------------------
getfromstackparam8/16/32 pour eviter le cast d'après
-------------------------------------
passer/retourner des structs par value si <= 64 bits
-------------------------------------
detecter les exit (ret) de fonctions dupliquées et faire des jumps (reduction code size)
-------------------------------------
x64: et si les premiers registres étaient des vrais registres x64 volatiles plutot que des accès indirects à la mémoire ?
rc[0] = r12 etc... chiant
-------------------------------------
