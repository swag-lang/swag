****************************************
LANGUAGE
****************************************
-------------------------------------
#premain ?
-------------------------------------
var lazy evaluation ?
-------------------------------------
callable
https://github.com/apple/swift-evolution/blob/master/proposals/0216-dynamic-callable.md
impl AA
{
	func opCall(...)
	{
	}
}
var x: AA
x(10) => x.opCall(10)
-------------------------------------
    a := 0
    switch a
    {
    case 0..10:
    }
-------------------------------------


****************************************
TODO
****************************************
-------------------------------------
maj new pour un module, pas un workspace
-------------------------------------
#if and #import
-------------------------------------
dbg x64, self doit etre comme this (possible ?)
-------------------------------------
self merde : invalid usage : 
var decode_block_func: func(self, s32, s32)
-------------------------------------
debugger : print
-------------------------------------
BIG BIG BIG BIG BIG CHIANT CHIANT CHIANT CHIANT CHIANT
llvm/x64 compatibilité
si llvm appel une lambda local x64 ou l'inverse, abi non compatible => marche si on passe la lambda en #[swag.callback]
que faire ?
-------------------------------------
slice/cstrings and foreign
-------------------------------------
y'a forcement des merdes avec les typeinfo compiler dans leur propre segment
(si on les compare avec un type non compiler, si on les met dans une var any...)
-------------------------------------
attributes flags qui sont a la fois on et off => error
-------------------------------------
cast any avec struct, ca fait quoi (et avec les using ?)
-------------------------------------
cast interface vers struct (avec safety)
-------------------------------------
x64/llvm debug, mettre les constants, les enums
void CodeViewDebug::emitStaticConstMemberList()
-------------------------------------
pointeurs relatifs, mettre le numéro en bits ? *~8 => *~64
-------------------------------------


****************************************
OPTIMS
****************************************
-------------------------------------
x64 binaryop div, transformer en shift si log2
-------------------------------------
BinOpModuloS32/div immediate mode
-------------------------------------
x64 emit_BinOpInt32/64 etc.. faire un mode immediat pour le côté droit 'and cl, 5'
-------------------------------------
Mul64byVB64 a deux registres ! (binOpPlus/Minus inc pointer)
-------------------------------------
makestackpointer suivi de copyrctort, faire un copy address stack to rt
-------------------------------------
getfromstackparam8/16/32 pour eviter le cast d'après
-------------------------------------
passer/retourner des structs par value si <= 64 bits
-------------------------------------
detecter les exit (ret) de fonctions dupliquées et faire des jumps (reduction code size)
-------------------------------------
x64: et si les premiers registres étaient des vrais registres x64 volatiles plutot que des accès indirects à la mémoire ?
rc[0] = r12 etc... chiant
-------------------------------------
