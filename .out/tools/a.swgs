#dependencies
{
    #if #os == "windows"
    {
        #import "core" location="swag@std"
    }
}

using core
///////////////////////

using swag

struct Folder
{
    type: typeinfo
    data: *void
}

struct TweakFile
{
    folders: Array'Folder
}

impl TweakFile
{
    private func setValue(addr: *void, field: const *swag.TypeInfoParam, one: string)->string throw
    {
        patch := cast(*u8) addr + field.offset

        switch field.pointedType
        {
        case s8:
            (val, eat) := try parse.getS8(one)
            :cast(*s8) patch = cast(s8) val
            return parse.moveStart(one, cast(uint) eat)
        case s16:
            (val, eat) := try parse.getS16(one)
            :cast(*s16) patch = cast(s16) val
            return parse.moveStart(one, cast(uint) eat)
        case s32:
            (val, eat) := try parse.getS32(one)
            :cast(*s32) patch = cast(s32) val
            return parse.moveStart(one, cast(uint) eat)
        case s64:
            (val, eat) := try parse.getS64(one)
            :cast(*s64) patch = cast(s64) val
            return parse.moveStart(one, cast(uint) eat)
        case u8:
            (val, eat) := try parse.getU8(one)
            :cast(*u8) patch = cast(u8) val
            return parse.moveStart(one, cast(uint) eat)
        case u16:
            (val, eat) := try parse.getU16(one)
            :cast(*u16) patch = cast(u16) val
            return parse.moveStart(one, cast(uint) eat)
        case u32:
            (val, eat) := try parse.getU32(one)
            :cast(*u32) patch = cast(u32) val
            return parse.moveStart(one, cast(uint) eat)
        case u64:
            (val, eat) := try parse.getU64(one)
            :cast(*u64) patch = cast(u64) val
            return parse.moveStart(one, cast(uint) eat)

        case f32:
            (val, eat) := try parse.getF32(one)
            :cast(*f32) patch = cast(f32) val
            return parse.moveStart(one, cast(uint) eat)
        case f64:
            (val, eat) := try parse.getF64(one)
            :cast(*f64) patch = cast(f64) val
            return parse.moveStart(one, cast(uint) eat)

        default:
            throw format.toString("unsupported type '%'", field.pointedType.flatName)
        }

        return ""
    }

    // Register a new structure to be parsed
    func(T) registerFolder(using self, folder: *T)
    {
        #assert(reflection.isStruct(T), "type should be a struct")
        folders.add(@{@typeof(T), folder})
    }

    // Parse the tweak file
    func parse(using self, fileName: string) throw
    {
        lines := try file.readAllLines(fileName)

        var currentFolder: *Folder
        visit *line, idx: lines
        {
            one := line.toString()
            if @countof(one) == 0 continue
            if one[0] == "#"'u8 continue // comment

            // Folder
            if one[0] == ":"'u8
            {
                one = parse.moveStart(one, 1)
                folderName := catch parse.getIdentifier(one)
                if @err throw format.toString("%:%: invalid folder name", fileName, idx + 1)

                visit *folder: folders
                {
                    if folder.type.flatName == folderName
                    {
                        currentFolder = folder
                        break
                    }
                }

                if !currentFolder throw format.toString("%:%: unknown folder '%'", fileName, idx + 1, folderName)
                continue
            }

            // Value
            if !currentFolder throw format.toString("%:%: value is not associated with a folder", fileName, idx + 1)
            one = parse.eatSpaces(one)
            id := catch parse.getIdentifier(one)
            if @err throw format.toString("%:%: invalid value name", fileName, idx + 1)

            // Search value into folder
            field := reflection.getField(currentFolder.type, id)
            if !field throw format.toString("%:%: value '%' cannot be found in folder '%'", fileName, idx + 1, id, currentFolder.type.flatName)
            one = parse.moveStart(one, @countof(id))
            one = parse.eatSpaces(one)

            // Get value and poke it
            one = catch setValue(currentFolder.data, field, one)
            if @err throw format.toString("%:%: %", fileName, idx + 1, @err)

            // Be sure there's nothing left
            if @countof(one) and !latin1.isSpace(one[0]) and one[0] != "#"'u8
                throw format.toString("%:%: syntax error parsing value", fileName, idx + 1)
            one = parse.eatSpaces(one)
            if @countof(one) and one[0] != "#"'u8
                throw format.toString("%:%: invalid characters found after value", fileName, idx + 1)
        }
    }
}

///////////////////////
struct Test1
{
    coucous32: s32
    coucouu64: u64
}

struct Test2
{
    coucou1: f32
    coucou2: f64
}

#main
{
    var tw: TweakFile
    var t1: Test1
    var t2: Test2
    tw.registerFolder(&t1)
    tw.registerFolder(&t2)
    assume tw.parse("a.ini")
    console.println(t1)
    console.println(t2)
}