#global #[swag.safety("of", false)]
using core

struct Test
{
	in:   s64
	base: int
	out:  string
}

const tests: [] Test = @[
	{0, 10, "0"},
	{1, 10, "1"},
	{-1, 10, "-1"},
	{12345678, 10, "12345678"},
	{-987654321, 10, "-987654321"},
	{(1's64 << 31) - 1, 10, "2147483647"},
	{(-1's64<<31) + 1, 10, "-2147483647"},
	{1's64 << 31, 10, "2147483648"},
	{-1's64 << 31, 10, "-2147483648"},
	{(1's64<<31) + 1, 10, "2147483649"},
	{(-1's64<<31) - 1, 10, "-2147483649"},
	{(1's64<<32) - 1, 10, "4294967295"},
	{(-1's64<<32) + 1, 10, "-4294967295"},
	{1's64 << 32, 10, "4294967296"},
	{-1's64 << 32, 10, "-4294967296"},
	{(1's64<<32) + 1, 10, "4294967297"},
	{(-1's64<<32) - 1, 10, "-4294967297"},
	{1's64 << 50, 10, "1125899906842624"},
	{(1's64<<63) - 1, 10, "9223372036854775807"},
	{(-1's64<<63) + 1, 10, "-9223372036854775807"},
	{-1's64 << 63, 10, "-9223372036854775808"},

	{0, 2, "0"},
	{10, 2, "1010"},
	{1 << 15, 2, "1000000000000000"},
    {(1's64<<63) - 1, 2, "111111111111111111111111111111111111111111111111111111111111111"},

    {16, 16, "10"},

	{1's64, 10, "1"},
	{12's64, 10, "12"},
	{123's64, 10, "123"},
	{1234's64, 10, "1234"},
	{12345's64, 10, "12345"},
	{123456's64, 10, "123456"},
	{1234567's64, 10, "1234567"},
	{12345678's64, 10, "12345678"},
	{123456789's64, 10, "123456789"},
	{1234567890's64, 10, "1234567890"},
	{12345678901's64, 10, "12345678901"},
	{123456789012's64, 10, "123456789012"},
	{1234567890123's64, 10, "1234567890123"},
	{12345678901234's64, 10, "12345678901234"},
	{123456789012345's64, 10, "123456789012345"},
	{1234567890123456's64, 10, "1234567890123456"},
	{12345678901234567's64, 10, "12345678901234567"},
	{123456789012345678's64, 10, "123456789012345678"},
	{1234567890123456789's64, 10, "1234567890123456789"},
]

#test
{
    visit c: tests
    {
        switch c.base
        {
        case 2:
            (value, eat) := assume parse.getB64(c.out)
            @assert(value == c.in)
        case 10:
            (value, eat) := assume parse.getS64(c.out)
            @assert(value == c.in)
        case 16:
            (value, eat) := assume parse.getX64(c.out)
            @assert(value == c.in)
        }
    }

    visit c: tests
    {
        switch c.base
        {
        case 2:
            value := format.toString("%{B}", c.in)
            @assert(value == c.out)
        case 10:
            value := format.toString("%", c.in)
            @assert(value == c.out)
        case 16:
            value := format.toString("%{X}", c.in)
            @assert(value == c.out)
        }
    }
}