#global #[swag.safety("of", false)]
using core

struct Test
{
	in:   s64
	base: int
	out:  string
}

const tests: [] Test = @[
	{0, 10, "0"},
	{1, 10, "1"},
	{-1, 10, "-1"},
	{12345678, 10, "12345678"},
	{-987654321, 10, "-987654321"},
	{(1's64 << 31) - 1, 10, "2147483647"},
	{(-1's64<<31) + 1, 10, "-2147483647"},
	{1's64 << 31, 10, "2147483648"},
	{-1's64 << 31, 10, "-2147483648"},
	{(1's64<<31) + 1, 10, "2147483649"},
	{(-1's64<<31) - 1, 10, "-2147483649"},
	{(1's64<<32) - 1, 10, "4294967295"},
	{(-1's64<<32) + 1, 10, "-4294967295"},
	{1's64 << 32, 10, "4294967296"},
	{-1's64 << 32, 10, "-4294967296"},
	{(1's64<<32) + 1, 10, "4294967297"},
	{(-1's64<<32) - 1, 10, "-4294967297"},
	{1's64 << 50, 10, "1125899906842624"},
	{(1's64<<63) - 1, 10, "9223372036854775807"},
	{(-1's64<<63) + 1, 10, "-9223372036854775807"},
	{-1's64 << 63, 10, "-9223372036854775808"},

	{0, 2, "0"},
	{10, 2, "1010"},
	{1 << 15, 2, "1000000000000000"},
]

#test
{
    visit c: tests
    {
        switch c.base
        {
        case 2:
            (value, eat) := strconv.parseB64(c.out)
            console.print("% %\n", value)//, c.in)
            @assert(value == c.in)
        case 10:
            (value, eat) := strconv.parseS64(c.out)
            @assert(value == c.in)
        }
    }
}