-------------------------------------
if expression/switch expression ?
var a: s32 = if b == 0 6 else 5
-------------------------------------
attribute, erreur si le caller n'utilise pas la valeur de retour du called (attribute de fonction)
-------------------------------------
enumcrc
-------------------------------------
crc value pour chaque field d'une structure en reflection ?
-------------------------------------
ca serait cool que les methods, en reflections, aient une value qui peut être castée en lambda, et donc appelées
-------------------------------------


-------------------------------------
arr[x][y] si arr = array de string
-------------------------------------
var screen: *u8 = acast @alloc(nScreenWidth*nScreenHeight)
loop i: nScreenWidth*nScreenHeight
    screen[i] = " "'u16   CAST !!!
-------------------------------------
c := cast(u32) pField[y*nFieldWidth + x]        <= merde si y'a pas le cast
screen[(y + 2)*nScreenWidth + (x + 2)] = charD[c]  <= ici
-------------------------------------
if str[Rotate(cast(s32) px, cast(s32) py, nCurrentRotation)] != "."'u8
access array par function deconne, faut un concreteType
-------------------------------------



shift left/right doit pas etre supérieur a 255 (a tester en compiler si constant, et safety en runtime)
-------------------------------------
int overflow safety (chiant)
-------------------------------------
slice/cstrings and foreign
-------------------------------------
y'a forcement des merdes avec les typeinfo compiler dans leur propre segment
(si on les compare avec un type non compiler, si on les met dans une var any...)
-------------------------------------
slice, strings & co, passer le count en 64 bits une bonne fois pour toute
-------------------------------------
x64: ByteCodeOp::LambdaCall, mettre des jump 8 bits
-------------------------------------
using après public namespace std.math; c global ca deconne en export
-------------------------------------