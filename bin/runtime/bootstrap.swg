namespace Swag
{
    enum AttributeUsage: u32
    {
        Enum              = 0x00000001     // Attribute can be used on an enum
        EnumValue         = 0x00000002     // Attribute can be used on an enum value
        StructVariable    = 0x00000004     // Attribute can be used on an struct member
        GlobalVariable    = 0x00000008     // Attribute can be used on a global variable
        Variable          = 0x00000010     // Attribute can be used on any variable
        Struct            = 0x00000020     // Attribute can be used on a struct
        Function          = 0x00000040     // Attribute can be used on a function
        FunctionParameter = 0x00000080     // Attribute can be used on a struct parameter
        File              = 0x00000100     // Attribute can be used with '#global'
        Constant          = 0x00000200     // Attribute can be used on a constant

        Multi             = 0x01000000     // Attribute can be used more than once
        Gen               = 0x02000000
        All               = 0x04000000
    }

    // #########################################################
    // Attributes
    // #########################################################

    // Hardcoded usage
    attr AttrUsage(usage: AttributeUsage)
    attr AttrMulti()

    // Can be executed at compile time
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct)]
    attr ConstExpr()

    // On a function or a struct, this will print the associated generated bytecode (after bytecode optimizations)
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.File)]
    attr PrintBc()

    // On a function or a struct, this will print the associated generated bytecode (right after generation, without bytecode optimizations)
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.File)]
    attr PrintBcGen()

    // On a function, this will print the associated asm code (only in SCBE backend)
    #[AttrUsage(AttributeUsage.Function)]
    attr PrintAsm()

    // The following function or variable is only defined at compile time
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.GlobalVariable | AttributeUsage.Constant)]
    attr Compiler()

    // Force a function to be inlined
    #[AttrUsage(AttributeUsage.Function)]
    attr Inline()

    // Never inline the following function.
    // This is a hint for the 'llvm' backend.
    #[AttrUsage(AttributeUsage.Function)]
    attr NoInline()

    // An empty function will be generated
    #[AttrUsage(AttributeUsage.Function)]
    attr PlaceHolder()

    // Disable '@print'
    #[AttrUsage(AttributeUsage.Function)]
    attr NoPrint()

    // The following function is a 'macro'
    #[AttrUsage(AttributeUsage.Function)]
    attr Macro()

    // The following function is a 'mixin'
    #[AttrUsage(AttributeUsage.Function)]
    attr Mixin()

    // Can force an 'opCast' special function to work as implicit
    #[AttrUsage(AttributeUsage.Function)]
    attr Implicit()

    // The following switch must be complete
    #[AttrUsage(AttributeUsage.Function)]
    attr Complete()

    // The following function can be overloaded
    #[AttrUsage(AttributeUsage.Function)]
    attr Overload()

    // A 'return' in the following inlined function must be done in the callee context
    #[AttrUsage(AttributeUsage.Function)]
    attr CalleeReturn()

    // The following function is foreign (imported)
    #[AttrUsage(AttributeUsage.Function)]
    attr Foreign(module: string, function: string = "")

    // The following function accepts that the called does not use its return value
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Variable)]
    attr Discardable()

    // The following definition is deprecated and should not be used
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.Enum | AttributeUsage.EnumValue)]
    attr Deprecated(msg: string = null)

    // The following function is forced to not be generic, even if defined inside a generic 'struct'.
    #[AttrUsage(AttributeUsage.Function)]
    attr NotGeneric()

    // Put the following global variable in the 'tls' segment.
    // A copy of the variable will be available for each thread.
    #[AttrUsage(AttributeUsage.GlobalVariable)]
    attr Tls()

    // 'struct' packing information
    #[AttrUsage(AttributeUsage.Struct)]
    attr Pack(value: u8)

    // The following struct should never be copied
    #[AttrUsage(AttributeUsage.Struct)]
    attr NoCopy()

    // When exporting the following struct,: not export its content
    #[AttrUsage(AttributeUsage.Struct)]
    attr Opaque()

    // Struct field member relocation.
    // The field offset in the struct should be the same as the variable 'name'
    #[AttrUsage(AttributeUsage.StructVariable)]
    attr Offset(name: string)

    // The following enum is a set of flags
    #[AttrUsage(AttributeUsage.Enum)]
    attr EnumFlags()

    // The following enum can be used to index arrays without casting
    #[AttrUsage(AttributeUsage.Enum)]
    attr EnumIndex()

    // The following enum can't have duplicated values
    #[AttrUsage(AttributeUsage.Enum)]
    attr NoDuplicate()

    // The following switch is incomplete
    #[AttrUsage(AttributeUsage.Enum)]
    attr Incomplete()

    #[Swag.EnumFlags]
    enum ExportWhat: u32
    {
        Methods = 0x00000001
        NoZero  = 0x00000002
        None    = 0x00000000
        All     = 0xFFFFFFFF
    }

    #[AttrUsage(AttributeUsage.Struct)]
    attr ExportType(what: ExportWhat)

    // Do not generate documentation.
    #[AttrUsage(AttributeUsage.All | AttributeUsage.File)]
    attr NoDoc()

    // Do not make a sanity pass.
    #[AttrUsage(AttributeUsage.Function)]
    attr Sanity(what: bool)

    // To what context the 'Safety' attribute must be applied
    enum SafetyContext
    {
        Compiler = 0     // Compiler context (during compile)
        ByteCode = 1     // During bytecode generation (dynamic checks)
        Sanity   = 2     // During sanity pass
        All
    }

    // All safety checks
    #[Swag.EnumFlags]
    enum SafetyWhat: u16
    {
        BoundCheck  = 0x0001     // Check out of bound access
        Overflow    = 0x0002     // Check type conversion lost of bits or precision
        Math        = 0x0004     // Check various math operations (like a negative '@sqrt')
        DynCast     = 0x0008     // Check if a cast from a 'any' variable does not match the real underlying type
        Switch      = 0x0010     // Check if an unexpected case value is encountered
        Bool        = 0x0020     // Check if a 'bool' does not have a valid value ('true' or 'false')
        NaN         = 0x0040     // Check if a 'NaN' is used in a float arithmetic operation
        Unreachable = 0x0080     // Check if unreachable is... reached
        Null        = 0x0100     // Check on dereferencing some null pointers
        Memory      = 0x0200     // Check some memory things (mostly in sanity pass)
        None        = 0x0000
        All         = 0xFFFF
    }

    // Enable/Disable one or more safety checks.
    #[AttrUsage(AttributeUsage.All | AttributeUsage.File), AttrMulti]
    attr Safety(context: SafetyContext, what: SafetyWhat, value: bool)

    #[Swag.EnumFlags]
    enum OptimizeWhat: u32
    {
        ByteCode = 0x00000001
        Backend  = 0x00000002
        None     = 0x00000000
        All      = 0xFFFFFFFF
    }

    // Enable/Disable a given function optimization.
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.File), AttrMulti]
    attr Optimize(what: OptimizeWhat, value: bool)

    #[AttrUsage(AttributeUsage.All | AttributeUsage.File)]
    attr CanOverflow(value: bool)

    // Warning behavior for [[Warning]] attribute
    enum WarningLevel: u8
    {
        Enable      // Enable the given warning
        Disable     // Disable the given warning
        Error       // Force the given warning to be raised as an error
    }

    // Change the behavior of a given warning or list of warnings.
    // For example:
    // ```swag
    // #[Swag.Warning("Wrn0006", Swag.WarningLevel.Error)
    // #[Swag.Warning("Wrn0002|Wrn0006", Swag.WarningLevel.Disable)
    // #global #[Swag.Warning("Wrn0005", Swag.WarningLevel.Enable)]
    // ```
    // You can also change the warning behaviors for the whole module in your [[BuildCfg]]
    #[AttrUsage(AttributeUsage.All | AttributeUsage.File), AttrMulti]
    attr Warning(what: string, level: WarningLevel)

    #[Swag.EnumFlags]
    enum MatchWhat: u32
    {
        Where = 0x00000001
        Me    = 0x00000002
        None  = 0x00000000
        All   = 0xFFFFFFFF
    }

    #[AttrUsage(AttributeUsage.All)]
    attr Match(what: MatchWhat, value: bool)

    attr Strict()
    attr Global()
    attr Align(value: u8)

    // #########################################################
    // Constants
    // #########################################################

    namespace S8
    {
        const Min = cast #bit (s8) 0x80
        const Max = cast #bit (s8) 0x7F
    }

    namespace S16
    {
        const Min = cast #bit (s16) 0x8000
        const Max = cast #bit (s16) 0x7FFF
    }

    namespace S32
    {
        const Min = cast #bit (s32) 0x80000000
        const Max = cast #bit (s32) 0x7FFFFFFF
    }

    namespace S64
    {
        const Min = cast #bit (s64) 0x80000000_00000000
        const Max = cast #bit (s64) 0x7FFFFFFF_FFFFFFFF
    }

    namespace U8
    {
        const Min = 0'u8        // Min 'u8' value
        const Max = 0xFF'u8     // Max 'u8' value
    }

    namespace U16
    {
        const Min = 0'u16
        const Max = 0xFFFF'u16
    }

    namespace U32
    {
        const Min = 0'u32
        const Max = 0xFFFFFFFF'u32
    }

    namespace U64
    {
        const Min = 0'u64
        const Max = 0xFFFFFFFF_FFFFFFFF'u64
    }

    namespace F32
    {
        const Min      = 1.17549435082228750797e-38'f32
        const Max      = 3.40282346638528859812e+38'f32
        const NaN      = cast #bit (f32) 0x7F800001
        const Inf      = cast #bit (f32) 0x7F800000
        const NegInf   = cast #bit (f32) 0xFF800000
        const MantBits = 23
        const ExpBits  = 8
        const Bias     = -127
    }

    namespace F64
    {
        const Min      = 2.2250738585072014e-308'f64
        const Max      = 1.79769313486231570815e+308'f64
        const NaN      = cast #bit (f64) 0x7ff8000000000001
        const Inf      = cast #bit (f64) 0x7ff0000000000000
        const NegInf   = cast #bit (f64) 0xfff0000000000000
        const MantBits = 52
        const ExpBits  = 11
        const Bias     = -1023
    }

    // #########################################################
    // Process Infos
    // #########################################################

    // Defined some information about a loaded module
    struct Module
    {
        name:      string                         // Name of the module
        types:     const [..] const *TypeInfo     // All exported types
    }

    // Defined some information about the current process
    struct ProcessInfos
    {
        modules:     const [..] Module     // The list of all modules
        args:        string                // The application arguments, as returned by [[@args]]
    }

    // Defined a global variable that needs to be dropped when exiting
    struct Gvtd
    {
        ptr:        *void           // Pointer to the global variable memory
        opDrop:     func(*void)     // The 'opDrop' function to call when the process must exit
        sizeOf:     u32             // Size of one element
        count:      u32             // Number of elements to drop
    }

    // #########################################################
    // Allocators
    // #########################################################

    // The 'mode' of an [[AllocatorRequest]].
    enum AllocatorMode
    {
        Alloc                 // Allocate a block of memory
        Free                  // Free a block of memory
        Realloc               // Reallocate a block of memory
        FreeAll               // Free all memory allocated with the underlying allocator (ff possible).
        AssertIsAllocated     // The allocator must assert if the address is not currently allocated (if possible).
    }

    // Represents the request for a given allocator.
    //
    // To allocate:
    // * 'mode' must be **AllocatorMode.Alloc**
    // * 'size' must be the size in bytes to allocate
    // * 'alignment' must be the alignment constraint in bytes (or 0)
    // * 'address' will be the returned allocated memory address
    //
    // To free:
    // * 'mode' must be **AllocatorMode.Free**
    // * 'size' must be the original allocated size in bytes of 'address'
    // * 'address' must be the memory address to release
    //
    // To reallocate:
    // * 'mode' must be **AllocatorMode.Realloc**
    // * 'size' must be the original allocated size in bytes of 'address'
    // * 'address' must be the memory address to reallocate
    //
    // See [[IAllocator]]
    struct AllocatorRequest
    {
        callerLoc:     SourceCodeLocation        // The caller code, to help tracking leaks. Optional.
        hint:          string                    // A hint message, to help tracking leaks. Optional.
        address:       *void                     // The returned address or the address to deal with.
        size:          u64                       // The requested size or the size to deal with.
        oldSize:       u64                       // When reallocating.
        mode           = AllocatorMode.Alloc     // Alloc, free, reallocate...
        alignment:     u32                       // Alignment constraint.
    }

    interface IAllocator
    {
        mtd req(request: *AllocatorRequest);
    }

    struct ScratchAllocator
    {
        allocator:     IAllocator
        block:         [*] u8
        capacity:      u64
        used:          u64
        maxUsed:       u64
        firstLeak:     *void
        totalLeak:     u64
        maxLeak:       u64
    }

    // #########################################################
    // Context
    // #########################################################

    #[Swag.EnumFlags]
    enum ContextFlags: u64
    {
        None     = 0x00000000_00000000
        Test     = 0x00000000_00000001
        ByteCode = 0x00000000_00000002
    }

    enum ExceptionKind
    {
        Panic
        Error
        Warning
    }

    const MaxErrors = 32     // Maximum nested errors
    const MaxTraces = 32     // Maximum error traces

    // This is the base of all errors
    struct BaseError
    {
        message: string
    }

    // An error raised by the system
    struct SystemError
    {
        using base:     Swag.BaseError
        errorID:        u64
    }

    // Store a 'throw' error information
    struct ErrorValue
    {
        value:              any     // Error value (or null)
        pushUsedAlloc:      u32     // Internal
        pushTraceIndex:     u32     // Internal
        pushHasError:       u32     // Internal
        padding:            u32
    }

    // Thread context as returned by [@getcontext].
    struct Context
    {
        // Must stay first, in that order, for backend generation

        allocator:     IAllocator              // The current allocator interface
        flags          = ContextFlags.None     // Context flags

        // Other fields, can be in any order

        tempAllocator:       ScratchAllocator                          // A temporary allocator for the user
        errorAllocator:      ScratchAllocator                          // A temporary allocator to store the error values
        debugAllocator:      *void                                     // If defined, the used debug allocator
        runtimeFlags:        RuntimeFlags                              // As initialized by the runtime
        user0:               u64                                       // For user usage
        user1:               u64                                       // For user usage
        user2:               u64                                       // For user usage
        user3:               u64                                       // For user usage
        traces:              [MaxTraces] const *SourceCodeLocation     // Stack trace, in case of errors
        errors:              [MaxErrors] ErrorValue                    // All errors
        exceptionLoc:        SourceCodeLocation                        // When an exception is raised, this is the code location
        exceptionParams:     [4] const *void                           // When an exception is raised, this are the parameters
        panic:               func(string, SourceCodeLocation)          // A function to call if there's a panic
        curError:            any                                       // The current raised error returns by @err
        errorIndex:          u32                                       // Number of errors in the array
        traceIndex:          u32                                       // Number of traces in the array
        hasError:            u32                                       // <> 0 if an error is raised
    }

    // #########################################################
    // Type reflection
    // #########################################################

    #[EnumFlags]
    enum TypeCmpFlags
    {
        Strict   = 0
        CastAny  = 1
        UnScoped = 2
    }

    // The kind of the typeinfo.
    enum TypeInfoKind: u8
    {
        Invalid
        Native            // The typeinfo is a [[TypeInfoNative]]. See [[TypeInfoNativeKind]] for the underlying type.
        Namespace         // The typeinfo is a [[TypeInfoNamespace]]
        Enum              // The typeinfo is a [[TypeInfoEnum]]
        Func              // The typeinfo is a [[TypeInfoFunc]]
        Lambda            // The typeinfo is a [[TypeInfoFunc]], but this is a lambda or a func
        Pointer           // The typeinfo is a [[TypeInfoPointer]]
        Array             // The typeinfo is a [[TypeInfoArray]]
        Slice             // The typeinfo is a [[TypeInfoSlice]]
        TypeListTuple     // The typeinfo is a [[TypeInfoStruct]]
        TypeListArray     // The typeinfo is a [[TypeInfoArray]]
        Variadic          // The typeinfo is a [[TypeInfoVariadic]]
        TypedVariadic     // The typeinfo is a [[TypeInfoVariadic]]
        CVariadic         // The typeinfo is a [[TypeInfoVariadic]]
        Struct            // The typeinfo is a [[TypeInfoStruct]]
        Generic           // The typeinfo is a [[TypeInfoGeneric]]
        Alias             // The typeinfo is a [[TypeInfoAlias]]
        CodeBlock         // The typeinfo is a [[TypeInfoCodeBlock]]
        Interface         // The typeinfo is a [[TypeInfoStruct]], but this is an interface
        Attribute         // The typeinfo is a [[TypeInfoFunc]], but this is an attribute
    }

    // The native type if the type is... native.
    // If the 'kind' of the type is 'TypeInfoKind.Native', then this is the real native type.
    enum TypeInfoNativeKind: u8
    {
        Void
        S8
        S16
        S32
        S64
        U8
        U16
        U32
        U64
        F32
        F64
        Bool
        Rune
        String
        Any
        CString
        Undefined
    }

    // Flags in each [[TypeInfo]]
    #[Swag.EnumFlags]
    enum TypeInfoFlags: u32
    {
        Zero              = 0x00000000
        PointerTypeInfo   = 0x00000001     // This is a pointer to a [[TypeInfo]] struct
        Integer           = 0x00000002     // This is a native integer
        Float             = 0x00000004     // This is a native float
        Unsigned          = 0x00000008     // This is a native unsigned integer
        HasPostCopy       = 0x00000010     // This is a struct with a 'opPostCopy'
        HasPostMove       = 0x00000020     // This is a struct with a 'opPostMove'
        HasDrop           = 0x00000040     // This is a struct with a 'opDrop'
        Strict            = 0x00000080     // This is a alias with the Swag.Strict attribute
        CanCopy           = 0x00000100     // This is a struct that can be copied
        Tuple             = 0x00000200     // This is a tuple
        CString           = 0x00000400     // This is a 'cstring'
        Generic           = 0x00000800     // This is a generic type
        PointerRef        = 0x00001000     // This is a reference
        PointerMoveRef    = 0x00002000     // This is a move reference
        PointerArithmetic = 0x00004000     // This is a pointer to multiple values
        Character         = 0x00008000     // This is a 32 bits character
        Const             = 0x00010000     // This is const
        Nullable          = 0x00020000     // This is a nullable type
    }

    struct Interface
    {
        obj:        *void                  // Pointer to the associated struct instance
        itable:     const [*] [*] void     // Pointer to the virtual table
    }

    struct AttributeParam
    {
        name:      string     // Name of the attribute parameter
        value:     any        // Optional default value
    }

    struct Attribute
    {
        type:       const *TypeInfo
        params:     const [..] AttributeParam     // Attribute parameters
    }

    #[EnumFlags]
    enum TypeValueFlags
    {
        Zero     = 0
        AutoName
        HasUsing
    }

    // Represents a value, like a function parameter or an enum value
    struct TypeValue
    {
        name:            string                   // Name of the value
        pointedType:     const *TypeInfo          // Type of the value
        value:           const *void              // Pointer to the constant value
        attributes:      const [..] Attribute     // Associated attributes
        offset:          u32                      // Offset, in bytes
        crc:             u32                      // Unique CRC
        flags:           TypeValueFlags           // Associated flags
        padding:         u32
    }

    // Will be available for all types
    struct TypeInfo
    {
        fullname:     string                     // The full scoped name of the type
        name:         string                     // The unscoped name
        sizeof:       u32                        // Size in bytes
        crc:          u32                        // A unique CRC to identify the type
        flags         = TypeInfoFlags.Zero       // Some additional flags
        kind          = TypeInfoKind.Invalid     // The kind of the type
        padding:      [3] u8
    }

    struct TypeInfoNative
    {
        using base:     TypeInfo
        nativeKind:     TypeInfoNativeKind = TypeInfoNativeKind.Void
    }

    struct TypeInfoPointer
    {
        using base:      TypeInfo
        pointedType:     const *TypeInfo     // The pointed type
    }

    struct TypeInfoAlias
    {
        using base:     TypeInfo
        rawType:        const *TypeInfo     // The underlying type
    }

    struct TypeInfoCodeBlock
    {
        using base:     TypeInfo
        rawType:        const *TypeInfo     // The underlying type
    }

    struct TypeInfoStruct
    {
        using base:      TypeInfo
        opInit:          func(*void)              // Pointer to the function to initialize an instance of that struct
        opDrop:          func(*void)              // Pointer to the function to drop an instance of that struct
        opPostCopy:      func(*void)              // Pointer to the function to call after a copy
        opPostMove:      func(*void)              // Pointer to the function to call after a move
        structName:      string                   // User name of the struct
        fromGeneric:     const *TypeInfo          // If it comes from a generic instantiation, this is the original generic struct
        generics:        const [..] TypeValue     // Generic parameters
        fields:          const [..] TypeValue     // All the fields
        usingFields:     const [..] TypeValue     // All the fields marked with 'using'
        methods:         const [..] TypeValue     // All the methods, if exported
        interfaces:      const [..] TypeValue     // All the interfaces
        attributes:      const [..] Attribute     // All the attributes
    }

    struct TypeInfoFunc
    {
        using base:     TypeInfo
        generics:       const [..] TypeValue     // Generic parameters
        parameters:     const [..] TypeValue     // Parameters
        returnType:     const *TypeInfo          // The return type, or 'null'
        attributes:     const [..] Attribute     // All the attributes
    }

    struct TypeInfoEnum
    {
        using base:     TypeInfo
        values:         const [..] TypeValue     // All the values
        rawType:        const *TypeInfo          // The underlying enum type
        attributes:     const [..] Attribute     // All the attributes
    }

    struct TypeInfoArray
    {
        using base:      TypeInfo
        pointedType:     const *TypeInfo     // The underlying type
        finalType:       const *TypeInfo     // If this is an array with multiple dimensions, this will be the final type
        count:           u64                 // Number of elements in the array
        totalCount:      u64                 // The total number of elements in case this has multiple dimensions
    }

    struct TypeInfoSlice
    {
        using base:      TypeInfo
        pointedType:     const *TypeInfo     // The underlying type
    }

    struct TypeInfoVariadic
    {
        using base:     TypeInfo
        rawType:        const *TypeInfo     // The underlying type
    }

    struct TypeInfoGeneric
    {
        using base:     TypeInfo
        rawType:        const *TypeInfo
    }

    struct TypeInfoNamespace
    {
        using base: TypeInfo
    }

    // #########################################################
    // Build configuration
    // #########################################################

    #[EnumFlags]
    enum RuntimeFlags: u64
    {
        Zero         = 0
        FromCompiler = 1
    }

    // Target processor
    enum TargetArch
    {
        X86_64
    }

    // The 'OS' to target when generating native code
    enum TargetOs
    {
        Windows     // Windows 10/11
        Linux       // Linux (**unsupported**)
        MaxOSX      // MacOS (**unsupported**)
    }

    // The type of backend to use
    enum Backend
    {
        ByteCode     // Bytecode
        SCBE         // SCBE backend (SwagCustomBackEnd)
        LLVM         // LLVM backend
    }

    // 'LLVM' backend specific options
    struct BuildCfgBackendLLVM
    {
        outputIR:               bool     // Output IR in a file
        fpMathFma:              bool     // true in 'release'
        fpMathNoNaN:            bool     // true in 'release'
        fpMathNoInf:            bool     // true in 'release'
        fpMathNoSignedZero:     bool     // true in 'release'
        fpMathUnsafe:           bool
        fpMathApproxFunc:       bool
    }

    // 'SCBE' backend specific options
    struct BuildCfgBackendSCBE
    {
        unrollMemLimit: u32 // Maximum number of bytes to unroll memset/cpy in optimize mode
    }

    // The kind of native backend to generate.
    enum BuildCfgBackendKind
    {
        None           // Nothing
        Export         // The module is an 'export' module which does not have its own code.
        Executable     // The module needs to be compiled to an executable application.
        Library        // The module needs to be compiled as a library.
    }

    // The native backend sub category.
    // Under windows, by default, the application will be compiled to make a 'windowed' application. But you can
    // change it and force the application to behave like a 'console' one.
    enum BuildCfgBackendSubKind
    {
        Default
        Console
    }

    // These are the optimization levels for the bytecode.
    enum BuildCfgByteCodeOptim
    {
        O0     // No optimization
        O1     // Optimizations level 1
        O2     // Optimizations level 2
        O3     // Optimizations level 3
    }

    // These are the optimization levels for the backend.
    enum BuildCfgBackendOptim
    {
        O0     // No optimization
        O1     // Optimizations level 1
        O2     // Optimizations level 2
        O3     // Optimizations level 3
        Os     // Optim for size level 1
        Oz     // Optim for size level 2
    }

    enum BuildCfgDocKind
    {
        None         // Do not generate documentation for that module
        Api          // Generate 'api like' documentation
        Examples     // Generate 'examples like' documentation
        Pages        // Generate one page per file
    }

    // This contains all options when generating documentation.
    struct BuildCfgGenDoc
    {
        kind                     = BuildCfgDocKind.None     // The kind of documentation to generate
        outputName:              string                     // The name of the output file (without extension)
        outputExtension:         string                     // The output extension
        titleToc:                string                     // Title for the table of content
        titleContent:            string                     // Title for the main document content
        css:                     string                     // The 'css' file to include in generated documentations
        icon:                    string                     // The icon path of the page
        startHead:               string                     // Content to insert at the start of the <head> section
        endHead:                 string                     // Content to insert at the end of the <head> section
        startBody:               string                     // Content to insert at the start of the <body> section
        endBody:                 string                     // Content to insert at the end of the <body> section
        morePages:               string                     // Additional external file pages to process (separated with ';')
        quoteIconNote:           string                     // The icon for the note blockquote
        quoteIconTip:            string                     // The icon for the tip blockquote
        quoteIconWarning:        string                     // The icon for the warning blockquote
        quoteIconAttention:      string                     // The icon for the attention blockquote
        quoteIconExample:        string                     // The icon for the example blockquote
        quoteTitleNote:          string                     // The title for the note blockquote
        quoteTitleTip:           string                     // The title for the tip blockquote
        quoteTitleWarning:       string                     // The title for the warning blockquote
        quoteTitleAttention:     string                     // The title for the attention blockquote
        quoteTitleExample:       string                     // The title for the example blockquote
        syntaxDefaultColor:      u32 = 0x00222222           // Code syntax default color (if not colorized)
        syntaxColorLum:          f32 = 0.5                  // Code syntax color luminosity in range ]0, 1]
        hasFontAwesome           = true                     // Generate a reference to the FontAwesome script (icons)
        hasStyleSection          = true                     // Generate a default <style> section
        hasSwagWatermark         = true                     // Generate a swag watermark at the bottom of each page
    }

    // The current module build configuration.
    // See [[ICompiler]]
    struct BuildCfg
    {
        moduleVersion:                 u32 = 0                              // The module version
        moduleRevision:                u32 = 0                              // The module revision
        moduleBuildNum:                u32 = 0                              // The module build value
        moduleNamespace:               string                               // The namespace name of the module
        embeddedImports                = false                              // Module should embed all its dependencies

        tempAllocatorCapacity          = 4'u32 * 1024 * 1024                // Default capacity of the 'temp' allocator (in bytes)
        errorAllocatorCapacity         = 16'u32 * 1024                      // Default capacity of the 'error' allocator (in bytes)
        safetyGuards                   = SafetyWhat.All                     // Activate specific safety checks
        sanity                         = true                               // Make a sanity pass
        debugAllocator                 = true                               // Use Swag.DebugAllocator by default
        debugAllocatorCaptureStack     = true                               // Capture the call stack for each allocation
        debugAllocatorLeaks            = true                               // Detect memory leaks
        errorStackTrace                = true                               // Add stack trace in case a 'throw' is raised

        warnAsErrors:                  string                               // Force some warnings to be treated as errors. Format is "WrnXXXX|WrnXXXX..."
        warnAsWarning:                 string                               // Override 'warnAsErrors', restoring warnings as warnings
        warnAsDisabled:                string                               // Disable some specific warnings
        warnDefaultDisabled:           bool                                 // All warnings are disabled, except those specified above
        warnDefaultErrors:             bool                                 // All warnings are treated as errors, except those specified above

        byteCodeOptimizeLevel          = BuildCfgByteCodeOptim.O1           // Optimization level of bytecode [0, 1 or 2]
        byteCodeEmitAssume             = true                               // 'assume' will panic if an error is raised
        byteCodeInline                 = true                               // Enable bytecode inlining with #[Swag.Inline]
        byteCodeAutoInline             = true                               // Automatic inlining of some other functions

        backendKind                    = BuildCfgBackendKind.Executable     // Backend type (executable, dynamic lib...)
        backendSubKind                 = BuildCfgBackendSubKind.Console     // Backend sub kind
        backendDebugInformations       = false                              // Output debug information if 'true'
        backendDebugInline             = false                              // Generate specific line information for inline code
        backendOptimize                = BuildCfgBackendOptim.O0            // Backend optimization level
        backendNumCU                   = 0'u32

        linkerArgs:                    string                               // Additional linker arguments

        backendLLVM:                   BuildCfgBackendLLVM                  // Specific LLVM options
        backendSCBE:                   BuildCfgBackendSCBE                  // Specific SCBE options

        repoPath:                      string                               // Repository access path to the module
        resAppIcoFileName:             string                               // For an executable, the associated icon file name
        resAppName:                    string                               // For an executable, the associated application name
        resAppDescription:             string                               // For an executable, the associated application description
        resAppCompany:                 string                               // For an executable, the associated company name
        resAppCopyright:               string                               // For an executable, the associated copyright notice
        genDoc:                        BuildCfgGenDoc                       // Parameters for document generation
    }

    // #########################################################
    // Compiler
    // #########################################################

    // The kind of message in [[CompilerMessage]]
    enum CompilerMsgKind: u32
    {
        PassAfterSemantic         // Called once the program semantic has been done
        PassBeforeRunByteCode     // Called just before running bytecode
        PassBeforeOutput          // Called just before generating the native code
        PassAllDone               // Called when everything has be done
        SemFunctions              // Called for each function in the module
        SemTypes                  // Called for each type in the module
        SemGlobals                // Called for each global variable in the module
        AttributeGen
    }

    // The type of message you want to retreive in a '#message' function.
    //
    // The function could be called for more than one reason, as this is a mask.
    #[EnumFlags]
    enum CompilerMsgMask: u64
    {
        PassAfterSemantic = 1 << cast(u32) CompilerMsgKind.PassAfterSemantic
        PassBeforeRun     = 1 << cast(u32) CompilerMsgKind.PassBeforeRunByteCode
        PassBeforeOutput  = 1 << cast(u32) CompilerMsgKind.PassBeforeOutput
        PassAllDone       = 1 << cast(u32) CompilerMsgKind.PassAllDone
        SemFunctions      = 1 << cast(u32) CompilerMsgKind.SemFunctions
        SemTypes          = 1 << cast(u32) CompilerMsgKind.SemTypes
        SemGlobals        = 1 << cast(u32) CompilerMsgKind.SemGlobals
        AttributeGen      = 1 << cast(u32) CompilerMsgKind.AttributeGen
        All               = 0xFFFFFFFF_FFFFFFFF
    }

    // A message received in a '#message' function.
    //
    // In a '#message' function, you can retreive the associated message by calling 'getMessage' of the
    // interface returned by [[@compiler]]
    struct CompilerMessage
    {
        moduleName:     string                          // Name of the module for which the message is sent.
        name:           string                          // Depends on 'kind'
        type:           const *TypeInfo                 // Depends on 'kind'
        kind:           CompilerMsgKind = undefined     // Kind of the message
    }

    // This is the interface to communicate with the compiler.
    //
    // The intrinsic '@compiler' will return that interface at compile-time, and 'null' at runtime.
    interface ICompiler
    {
        mtd getMessage()->const *CompilerMessage; // Returns the compiler message in a '#message' function
        mtd getBuildCfg()->*BuildCfg; // Returns the build configuration of the current module
        mtd compileString(str: string);
    }

    // Represent a part of a source code file.
    //
    // This is typically what will be returned by '#curlocation' or '#callerlocation'.
    struct SourceCodeLocation
    {
        fileName:      string     // Full path name of the source file
        funcName:      string     // Name of the function
        lineStart:     u32        // Start line (starts at 0)
        colStart:      u32        // Start column
        lineEnd:       u32        // End line
        colEnd:        u32        // End column
    }

    struct CVaList
    {
        buf: [2048] u8
    }
}

// Panic if the expression is false. Typically used in tests.
func @assert(value: bool);
// Stop a bytecode execution, and launch the bytecode debugger.
func @breakpoint();
// Get the current thread context.
func @getcontext()->*Swag.Context;
// Replace the current thread context.
func @setcontext(context: const *Swag.Context);

// Get information about the current process.
func @pinfos()->*Swag.ProcessInfos;
// Returns the list of all loaded modules.
func @modules()->const [..] Swag.Module;
// Returns the list of all global variables.
func @gvtd()->const [..] Swag.Gvtd;
// Returns 'true' is the current execution is bytecode.
func @bytecode()->bool;
// Returns an [[ICompiler]] interface to communicate with the compiler.
func @compiler()->Swag.ICompiler;

// Returns a system allocated memory block of 'size' bytes.
//
// Use [[@free]] to release the allocated memory.
func @alloc(size: u64)->[*] void;

// Realloc a system memory block allocated with [[@alloc]]
func @realloc(ptr: [*] void, size: u64)->[*] void;

// Free a system memory block allocated with [[@alloc]]
func @free(ptr: [*] void);

// Set all bytes of a given memory block to 'value'
func @memset(dst: [*] void, value: u8, size: u64);

// Copy one memory block to another address.
func @memcpy(dst: [*] void, src: const [*] void, size: u64);

// Move one memory block to another address.
func @memmove(dst: [*] void, src: const [*] void, size: u64);

// Compare two memory blocks, and returns -1, 0 if equal, or 1.
func @memcmp(dst, src: const [*] void, size: u64)->s32;

// Returns the length of the given 0 terminated string.
func @strlen(str: cstring)->u64;

// Compare two zero terminated strings, and returns -1, 0 if equal, or 1.
func @strcmp(str1, str2: cstring)->s32;

// Atomic operations
#[Swag.Discardable, Swag.Overload]
{
    // Atomic 'add'
    func @atomadd(addr: *s8, value: s8)->s8;
    func @atomadd(addr: *s16, value: s16)->s16;
    func @atomadd(addr: *s32, value: s32)->s32;
    func @atomadd(addr: *s64, value: s64)->s64;
    func @atomadd(addr: *u8, value: u8)->u8;
    func @atomadd(addr: *u16, value: u16)->u16;
    func @atomadd(addr: *u32, value: u32)->u32;
    func @atomadd(addr: *u64, value: u64)->u64;

    // Atomic 'and'
    func @atomand(addr: *s8, value: s8)->s8;
    func @atomand(addr: *s16, value: s16)->s16;
    func @atomand(addr: *s32, value: s32)->s32;
    func @atomand(addr: *s64, value: s64)->s64;
    func @atomand(addr: *u8, value: u8)->u8;
    func @atomand(addr: *u16, value: u16)->u16;
    func @atomand(addr: *u32, value: u32)->u32;
    func @atomand(addr: *u64, value: u64)->u64;

    // Atomic 'or'
    func @atomor(addr: *s8, value: s8)->s8;
    func @atomor(addr: *s16, value: s16)->s16;
    func @atomor(addr: *s32, value: s32)->s32;
    func @atomor(addr: *s64, value: s64)->s64;
    func @atomor(addr: *u8, value: u8)->u8;
    func @atomor(addr: *u16, value: u16)->u16;
    func @atomor(addr: *u32, value: u32)->u32;
    func @atomor(addr: *u64, value: u64)->u64;

    // Atomic 'xor'
    func @atomxor(addr: *s8, value: s8)->s8;
    func @atomxor(addr: *s16, value: s16)->s16;
    func @atomxor(addr: *s32, value: s32)->s32;
    func @atomxor(addr: *s64, value: s64)->s64;
    func @atomxor(addr: *u8, value: u8)->u8;
    func @atomxor(addr: *u16, value: u16)->u16;
    func @atomxor(addr: *u32, value: u32)->u32;
    func @atomxor(addr: *u64, value: u64)->u64;

    // Atomic 'exchange'
    func @atomxchg(addr: *s8, exchangeWith: s8)->s8;
    func @atomxchg(addr: *s16, exchangeWith: s16)->s16;
    func @atomxchg(addr: *s32, exchangeWith: s32)->s32;
    func @atomxchg(addr: *s64, exchangeWith: s64)->s64;
    func @atomxchg(addr: *u8, exchangeWith: u8)->u8;
    func @atomxchg(addr: *u16, exchangeWith: u16)->u16;
    func @atomxchg(addr: *u32, exchangeWith: u32)->u32;
    func @atomxchg(addr: *u64, exchangeWith: u64)->u64;

    // Atomic 'compare and exchange'
    func @atomcmpxchg(addr: *s8, compareTo, exchangeWith: s8)->s8;
    func @atomcmpxchg(addr: *s16, compareTo, exchangeWith: s16)->s16;
    func @atomcmpxchg(addr: *s32, compareTo, exchangeWith: s32)->s32;
    func @atomcmpxchg(addr: *s64, compareTo, exchangeWith: s64)->s64;
    func @atomcmpxchg(addr: *u8, compareTo, exchangeWith: u8)->u8;
    func @atomcmpxchg(addr: *u16, compareTo, exchangeWith: u16)->u16;
    func @atomcmpxchg(addr: *u32, compareTo, exchangeWith: u32)->u32;
    func @atomcmpxchg(addr: *u64, compareTo, exchangeWith: u64)->u64;
}

// Constant intrinsics
#[Swag.ConstExpr, Swag.Overload]
{
    func @sqrt(value: f32)->f32;
    func @sqrt(value: f64)->f64;

    func @sin(value: f32)->f32;
    func @sin(value: f64)->f64;
    func @cos(value: f32)->f32;
    func @cos(value: f64)->f64;
    func @tan(value: f32)->f32;
    func @tan(value: f64)->f64;

    func @sinh(value: f32)->f32;
    func @sinh(value: f64)->f64;
    func @cosh(value: f32)->f32;
    func @cosh(value: f64)->f64;
    func @tanh(value: f32)->f32;
    func @tanh(value: f64)->f64;

    func @asin(value: f32)->f32;
    func @asin(value: f64)->f64;
    func @acos(value: f32)->f32;
    func @acos(value: f64)->f64;
    func @atan(value: f32)->f32;
    func @atan(value: f64)->f64;

    func @log(value: f32)->f32;
    func @log(value: f64)->f64;
    func @log2(value: f32)->f32;
    func @log2(value: f64)->f64;
    func @log10(value: f32)->f32;
    func @log10(value: f64)->f64;

    func @floor(value: f32)->f32;
    func @floor(value: f64)->f64;
    func @ceil(value: f32)->f32;
    func @ceil(value: f64)->f64;
    func @trunc(value: f32)->f32;
    func @trunc(value: f64)->f64;
    func @round(value: f32)->f32;
    func @round(value: f64)->f64;

    func @abs(value: s8)->s8;
    func @abs(value: s16)->s16;
    func @abs(value: s32)->s32;
    func @abs(value: s64)->s64;
    func @abs(value: f32)->f32;
    func @abs(value: f64)->f64;

    func @exp(value: f32)->f32;
    func @exp(value: f64)->f64;
    func @exp2(value: f32)->f32;
    func @exp2(value: f64)->f64;
    func @pow(value1, value2: f32)->f32;
    func @pow(value1, value2: f64)->f64;
    func @atan2(value1, value2: f32)->f32;
    func @atan2(value1, value2: f64)->f64;

    func @min(value1, value2: s8)->s8;
    func @min(value1, value2: s16)->s16;
    func @min(value1, value2: s32)->s32;
    func @min(value1, value2: s64)->s64;
    func @min(value1, value2: u8)->u8;
    func @min(value1, value2: u16)->u16;
    func @min(value1, value2: u32)->u32;
    func @min(value1, value2: u64)->u64;
    func @min(value1, value2: f32)->f32;
    func @min(value1, value2: f64)->f64;

    func @max(value1, value2: s8)->s8;
    func @max(value1, value2: s16)->s16;
    func @max(value1, value2: s32)->s32;
    func @max(value1, value2: s64)->s64;
    func @max(value1, value2: u8)->u8;
    func @max(value1, value2: u16)->u16;
    func @max(value1, value2: u32)->u32;
    func @max(value1, value2: u64)->u64;
    func @max(value1, value2: f32)->f32;
    func @max(value1, value2: f64)->f64;

    // Count the number of bits set to 1
    func @bitcountnz(value: u8)->u8;
    func @bitcountnz(value: u16)->u16;
    func @bitcountnz(value: u32)->u32;
    func @bitcountnz(value: u64)->u64;

    // Returns the index+1 of the first set bit, starting from right (lsb). 0 if all zero.
    func @bitcounttz(value: u8)->u8;
    func @bitcounttz(value: u16)->u16;
    func @bitcounttz(value: u32)->u32;
    func @bitcounttz(value: u64)->u64;

    // Returns the index+1 of the first set bit, starting from the left (msb). 0 if all zero.
    func @bitcountlz(value: u8)->u8;
    func @bitcountlz(value: u16)->u16;
    func @bitcountlz(value: u32)->u32;
    func @bitcountlz(value: u64)->u64;

    // Reverses the order of bytes in an integer.
    func @byteswap(value: u16)->u16;
    func @byteswap(value: u32)->u32;
    func @byteswap(value: u64)->u64;

    // Rotate bits left
    func @rol(value: u8, num: u8)->u8;
    func @rol(value: u16, num: u8)->u16;
    func @rol(value: u32, num: u8)->u32;
    func @rol(value: u64, num: u8)->u64;

    // Rotate bits right
    func @ror(value: u8, num: u8)->u8;
    func @ror(value: u16, num: u8)->u16;
    func @ror(value: u32, num: u8)->u32;
    func @ror(value: u64, num: u8)->u64;

    // Returns '(val1 * val2) + val3'
    func @muladd(val1, val2, val3: f32)->f32;
    func @muladd(val1, val2, val3: f64)->f64;
}
