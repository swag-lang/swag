namespace Swag
{
    enum AttributeUsage : u32
    {
        Enum              = 0x00000001 // Attribute can be used on an enum
        EnumValue         = 0x00000002 // Attribute can be used on an enum value
        StructVariable    = 0x00000004 // Attribute can be used on an struct member
        GlobalVariable    = 0x00000008 // Attribute can be used on a global variable
        Variable          = 0x00000010 // Attribute can be used on any variable
        Struct            = 0x00000020 // Attribute can be used on a struct
        Function          = 0x00000040 // Attribute can be used on a function
        FunctionParameter = 0x00000080 // Attribute can be used on a struct parameter
        File              = 0x00000100 // Attribute can be used with '#global'
        Constant          = 0x00000200 // Attribute can be used on a constant

        Multi             = 0x01000000 // Attribute can be used more than once
        Gen               = 0x02000000
        All               = 0x04000000
    }

    // #########################################################
    // Attributes
    // #########################################################

    // Hardcoded usage
    attr AttrUsage(usage: AttributeUsage)
    attr AttrMulti()

    // Can be executed at compile time
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct)]
    attr ConstExpr()

    // On a function or a struct, this will print the associated generated bytecode (right after generation, without bytecode optimizations)
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.File)]
    attr PrintGenBc()

    // On a function or a struct, this will print the associated generated bytecode (after bytecode optimizations)
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.File)]
    attr PrintBc()

    // The following function or variable is only defined at compile time
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.GlobalVariable | AttributeUsage.Constant)]
    attr Compiler()

    // Force a function to be inlined
    #[AttrUsage(AttributeUsage.Function)]
    attr Inline()

    // Never inline the following function.
    // This is a hint for the 'llvm' backend.
    #[AttrUsage(AttributeUsage.Function)]
    attr NoInline()

    // The following function is a 'macro'
    #[AttrUsage(AttributeUsage.Function)]
    attr Macro()

    // The following function is a 'mixin'
    #[AttrUsage(AttributeUsage.Function)]
    attr Mixin()

    // Can force an 'opCast' special function to work as implicit
    #[AttrUsage(AttributeUsage.Function)]
    attr Implicit()

    // The following switch must be complete
    #[AttrUsage(AttributeUsage.Function)]
    attr Complete()

    // The following function can be overloaded
    #[AttrUsage(AttributeUsage.Function)]
    attr Overload()

    // A 'return' in the following inlined function must be done in the callee context
    #[AttrUsage(AttributeUsage.Function)]
    attr CalleeReturn()

    // The following function is foreign (imported)
    #[AttrUsage(AttributeUsage.Function)]
    attr Foreign(module: string, function: string = "")

    // The following function accepts that the called does not use its return value
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Variable)]
    attr Discardable()

    // The following definition is deprecated and should not be used
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.Enum | AttributeUsage.EnumValue)]
    attr Deprecated(msg: string = null)

    // The following function is forced to not be generic, even if defined inside a generic 'struct'.
    #[AttrUsage(AttributeUsage.Function)]
    attr NotGeneric()

    // Put the following global variable in the 'tls' segment.
    // A copy of the variable will be available for each thread.
    #[AttrUsage(AttributeUsage.GlobalVariable)]
    attr Tls()

    // 'struct' packing information
    #[AttrUsage(AttributeUsage.Struct)]
    attr Pack(value: u8)

    // The following struct should never be copied
    #[AttrUsage(AttributeUsage.Struct)]
    attr NoCopy()

    // When exporting the following struct, do not export its content
    #[AttrUsage(AttributeUsage.Struct)]
    attr Opaque()

    // Struct field member relocation.
    // The field offset in the struct should be the same as the variable 'name'
    #[AttrUsage(AttributeUsage.StructVariable)]
    attr Offset(name: string)

    // The following enum is a set of flags
    #[AttrUsage(AttributeUsage.Enum)]
    attr EnumFlags()

    // The following enum can be used to index arrays without casting
    #[AttrUsage(AttributeUsage.Enum)]
    attr EnumIndex()

    // The following enum can't have duplicated values
    #[AttrUsage(AttributeUsage.Enum)]
    attr NoDuplicate()

    // The following switch is incomplete
    #[AttrUsage(AttributeUsage.Enum)]
    attr Incomplete()

    #[AttrUsage(AttributeUsage.Struct)]
    attr ExportType(what: string)

    // Do not generate documentation.
    #[AttrUsage(AttributeUsage.All | AttributeUsage.File)]
    attr NoDoc()

    // Enable/Disable one or more safety checks.
    // For example:
    // ```swag
    // #[Swag.Safety("", false)]                    // Disable all
    // #[Swag.Safety("boundcheck|nan", false)]      // Disable 'boundcheck' and 'nan' checks
    // ```
    // Safety checks are:
    // | 'boundcheck'   | Check out of bound access
    // | 'overflow'     | Check type conversion lost of bits or precision
    // | 'math'         | Various math checks (like a negative '@sqrt')
    // | 'switch'       | Check an invalid case in a '#[Swag.Complete]' switch
    // | 'unreachable'  | Panic if an '@unreachable' instruction is executed
    // | 'any'          | Panic if a cast from a 'any' variable does not match the real underlying type
    // | 'bool'         | Panic if a 'bool' does not have a valid value ('true' or 'false')
    // | 'nan'          | Panic if a 'nan' is used in a float arithmetic operation
    // | 'sanity'       | Do a 'sanity' check (per function)
    // | 'null'         | Panic on dereferencing some null pointers
    // If 'what' is null or empty, every options are will be affected.
    #[AttrUsage(AttributeUsage.All | AttributeUsage.File), AttrMulti]
    attr Safety(what: string, value: bool)

    // Enable/Disable a given function optimization.
    // Options are:
    // | 'bytecode'   | Enable/Disable bytecode optimization for the function
    // | 'backend'    | Enable/Disable backend machine code optimization for the function (llvm only)
    // If 'what' is null or empty, every options will be affected.
    #[AttrUsage(AttributeUsage.Function | AttributeUsage.File), AttrMulti]
    attr Optim(what: string, value: bool)

    #[AttrUsage(AttributeUsage.All | AttributeUsage.File)]
    attr Overflow(value: bool)

    // Warning behavior for [[Warn]] attribute
    enum WarnLevel : u8
    {
        Enable  // Enable the given warning
        Disable // Disable the given warning
        Error   // Force the given warning to be raised as an error
    }

    // Change the behavior of a given warning or list of warnings.
    // For example:
    // ```swag
    // #[Swag.Warn("Wrn0006", Swag.WarnLevel.Error)
    // #[Swag.Warn("Wrn0002|Wrn0006", Swag.WarnLevel.Disable)
    // #global #[Swag.Warn("Wrn0005", Swag.WarnLevel.Enable)]
    // ```
    // You can also change the warning behaviors for the whole module in your [[BuildCfg]]
    #[AttrUsage(AttributeUsage.All | AttributeUsage.File), AttrMulti]
    attr Warn(what: string, level: WarnLevel)

    #[AttrUsage(AttributeUsage.All)]
    attr Match(what: string, value: bool)

    attr Strict()
    attr Global()
    attr Align(value: u8)

    // #########################################################
    // Constants
    // #########################################################

    namespace S8
    {
        const Min = cast,bit(s8) 0x80
        const Max = cast,bit(s8) 0x7F
    }

    namespace S16
    {
        const Min = cast,bit(s16) 0x8000
        const Max = cast,bit(s16) 0x7FFF
    }

    namespace S32
    {
        const Min = cast,bit(s32) 0x80000000
        const Max = cast,bit(s32) 0x7FFFFFFF
    }

    namespace S64
    {
        const Min = cast,bit(s64) 0x80000000_00000000
        const Max = cast,bit(s64) 0x7FFFFFFF_FFFFFFFF
    }

    namespace U8
    {
        const Min = 0'u8    // Min 'u8' value
        const Max = 0xFF'u8 // Max 'u8' value
    }

    namespace U16
    {
        const Min = 0'u16
        const Max = 0xFFFF'u16
    }

    namespace U32
    {
        const Min = 0'u32
        const Max = 0xFFFFFFFF'u32
    }

    namespace U64
    {
        const Min = 0'u64
        const Max = 0xFFFFFFFF_FFFFFFFF'u64
    }

    namespace F32
    {
        const Min      = 1.17549435082228750797e-38'f32
        const Max      = 3.40282346638528859812e+38'f32
        const Nan      = cast,bit(f32) 0x7F800001
        const Inf      = cast,bit(f32) 0x7F800000
        const NegInf   = cast,bit(f32) 0xFF800000
        const MantBits = 23
        const ExpBits  = 8
        const Bias     = -127
    }

    namespace F64
    {
        const Min      = 2.2250738585072014e-308'f64
        const Max      = 1.79769313486231570815e+308'f64
        const Nan      = cast,bit(f64) 0x7ff8000000000001
        const Inf      = cast,bit(f64) 0x7ff0000000000000
        const NegInf   = cast,bit(f64) 0xfff0000000000000
        const MantBits = 52
        const ExpBits  = 11
        const Bias     = -1023
    }

    // #########################################################
    // Process Infos
    // #########################################################

    // Defined some information about a loaded module
    struct Module
    {
        name:  string                     // Name of the module
        types: const [..] const *TypeInfo // All exported types
    }

    // Defined some information about the current process
    struct ProcessInfos
    {
        modules: const [..] Module // The list of all modules
        args:    string            // The application arguments, as returned by [[@args]]
    }

    // Defined a global variable that needs to be dropped when exiting
    struct Gvtd
    {
        ptr:    *void       // Pointer to the global variable memory
        opDrop: func(*void) // The 'opDrop' function to call when the process must exit
        sizeOf: u32         // Size of one element
        count:  u32         // Number of elements to drop
    }

    // #########################################################
    // Allocators
    // #########################################################

    // The 'mode' of an [[AllocatorRequest]].
    enum AllocatorMode
    {
        Alloc             // Allocate a block of memory
        Free              // Free a block of memory
        Realloc           // Reallocate a block of memory
        FreeAll           // Free all memory allocated with the underlying allocator (ff possible).
        AssertIsAllocated // The allocator must assert if the address is not currently allocated (if possible).
    }

    // Represents the request for a given allocator.
    //
    // To allocate:
    // * 'mode' must be **AllocatorMode.Alloc**
    // * 'size' must be the size in bytes to allocate
    // * 'alignment' must be the alignment constraint in bytes (or 0)
    // * 'address' will be the returned allocated memory address
    //
    // To free:
    // * 'mode' must be **AllocatorMode.Free**
    // * 'size' must be the original allocated size in bytes of 'address'
    // * 'address' must be the memory address to release
    //
    // To reallocate:
    // * 'mode' must be **AllocatorMode.Realloc**
    // * 'size' must be the original allocated size in bytes of 'address'
    // * 'address' must be the memory address to reallocate
    //
    // See [[IAllocator]]
    struct AllocatorRequest
    {
        callerLoc: SourceCodeLocation    // The caller code, to help tracking leaks. Optional.
        hint:      string                // A hint message, to help tracking leaks. Optional.
        address:   *void                 // The returned address or the address to deal with.
        size:      u64                   // The requested size or the size to deal with.
        oldSize:   u64                   // When reallocating.
        mode       = AllocatorMode.Alloc // Alloc, free, reallocate...
        alignment: u32                   // Alignment constraint.
    }

    interface IAllocator
    {
        mtd req(request: *AllocatorRequest);
    }

    struct ScratchAllocator
    {
        allocator: IAllocator
        block:     ^u8
        capacity:  u64
        used:      u64
        maxUsed:   u64
        firstLeak: *void
        totalLeak: u64
        maxLeak:   u64
    }

    // #########################################################
    // Context
    // #########################################################

    #[Swag.EnumFlags]
    enum ContextFlags : u64
    {
        None                   = 0x00000000_00000000
        Test                   = 0x00000000_00000001
        ByteCode               = 0x00000000_00000002
        PostCopyResetAllocator = 0x00000000_00000004
    }

    enum ExceptionKind
    {
        Panic
        Error
        Warning
    }

    const MaxErrors = 32 // Maximum nested errors
    const MaxTraces = 32 // Maximum error traces

    // This is the base of all errors
    struct BaseError
    {
        message: string
    }

    // An error raised by the system
    struct SystemError
    {
        using base: Swag.BaseError
        errorID:    u64
    }

    // Store a 'throw' error information
    struct ErrorValue
    {
        value:          any // Error value (or null)
        pushUsedAlloc:  u32 // Internal
        pushTraceIndex: u32 // Internal
    }

    // Thread context as returned by [@context].
    struct Context
    {
        // Must stay first, in that order, for backend generation

        allocator: IAllocator          // The current allocator interface
        flags      = ContextFlags.None // Context flags

        // Other fields, can be in any order

        tempAllocator:   ScratchAllocator                      // A temporary allocator for the user
        errorAllocator:  ScratchAllocator                      // A temporary allocator to store the error values
        debugAllocator:  *void                                 // If defined, the used debug allocator
        runtimeFlags:    RuntimeFlags                          // As initialized by the runtime
        user0:           u64                                   // For user usage
        user1:           u64                                   // For user usage
        user2:           u64                                   // For user usage
        user3:           u64                                   // For user usage
        traces:          [MaxTraces] const *SourceCodeLocation // Stack trace, in case of errors
        errors:          [MaxErrors] ErrorValue                // All errors
        exceptionLoc:    SourceCodeLocation                    // When an exception is raised, this is the code location
        exceptionParams: [4] const *void                       // When an exception is raised, this are the parameters
        panic:           func(string, SourceCodeLocation)      // A function to call if there's a panic
        curError:        any                                   // The current raised error returns by @err()
        errorIndex:      u32                                   // Number of errors in the array
        traceIndex:      u32                                   // Number of traces in the array
        hasError:        u32                                   // <> 0 if an error is raised
    }

    // #########################################################
    // Type reflection
    // #########################################################

    #[EnumFlags]
    enum TypeCmpFlags
    {
        Strict  = 0
        CastAny = 1
    }

    // The kind of the typeinfo.
    enum TypeInfoKind : u8
    {
        Invalid
        Native        // The typeinfo is a [[TypeInfoNative]]. See [[TypeInfoNativeKind]] for the underlying type.
        Namespace     // The typeinfo is a [[TypeInfoNamespace]]
        Enum          // The typeinfo is a [[TypeInfoEnum]]
        Func          // The typeinfo is a [[TypeInfoFunc]]
        Lambda        // The typeinfo is a [[TypeInfoFunc]], but this is a lambda or a closure
        Pointer       // The typeinfo is a [[TypeInfoPointer]]
        Array         // The typeinfo is a [[TypeInfoArray]]
        Slice         // The typeinfo is a [[TypeInfoSlice]]
        TypeListTuple // The typeinfo is a [[TypeInfoStruct]]
        TypeListArray // The typeinfo is a [[TypeInfoArray]]
        Variadic      // The typeinfo is a [[TypeInfoVariadic]]
        TypedVariadic // The typeinfo is a [[TypeInfoVariadic]]
        CVariadic     // The typeinfo is a [[TypeInfoVariadic]]
        Struct        // The typeinfo is a [[TypeInfoStruct]]
        Generic       // The typeinfo is a [[TypeInfoGeneric]]
        Alias         // The typeinfo is a [[TypeInfoAlias]]
        Code          // The typeinfo is a [[TypeInfo]]
        Interface     // The typeinfo is a [[TypeInfoStruct]], but this is an interface
        Attribute     // The typeinfo is a [[TypeInfoFunc]], but this is an attribute
    }

    // The native type if the type is... native.
    // If the 'kind' of the type is 'TypeInfoKind.Native', then this is the real native type.
    enum TypeInfoNativeKind : u8
    {
        Void
        S8
        S16
        S32
        S64
        U8
        U16
        U32
        U64
        F32
        F64
        Bool
        Rune
        String
        Any
        CString
        Undefined
    }

    // Flags in each [[TypeInfo]]
    #[Swag.EnumFlags]
    enum TypeInfoFlags : u32
    {
        Zero              = 0x00000000
        PointerTypeInfo   = 0x00000001 // This is a pointer to a [[TypeInfo]] struct
        Integer           = 0x00000002 // This is a native integer
        Float             = 0x00000004 // This is a native float
        Unsigned          = 0x00000008 // This is a native unsigned integer
        HasPostCopy       = 0x00000010 // This is a struct with a 'opPostCopy'
        HasPostMove       = 0x00000020 // This is a struct with a 'opPostMove'
        HasDrop           = 0x00000040 // This is a struct with a 'opDrop'
        Strict            = 0x00000080 // This is a typealias with the Swag.Strict attribute
        CanCopy           = 0x00000100 // This is a struct that can be copied
        Tuple             = 0x00000200 // This is a tuple
        CString           = 0x00000400 // This is a 'cstring'
        Generic           = 0x00000800 // This is a generic type
        PointerRef        = 0x00001000 // This is a reference
        PointerMoveRef    = 0x00002000 // This is a move reference
        PointerArithmetic = 0x00004000 // This is a pointer to multiple values
        Character         = 0x00008000 // This is a 32 bits character
        Const             = 0x00010000 // This is const
    }

    struct Interface
    {
        obj:    *void        // Pointer to the associated struct instance
        itable: const ^^void // Pointer to the virtual table
    }

    struct AttributeParam
    {
        name:  string // Name of the attribute parameter
        value: any    // Optional default value
    }

    struct Attribute
    {
        type:   const *TypeInfo
        params: const [..] AttributeParam // Attribute parameters
    }

    // Represents a value, like a function parameter or an enum value
    struct TypeValue
    {
        name:        string               // Name of the value
        pointedType: const *TypeInfo      // Type of the value
        value:       const *void          // Pointer to the constant value
        attributes:  const [..] Attribute // Associated attributes
        offset:      u32                  // Offset, in bytes
        crc32:       u32                  // Unique crc32
    }

    // Will be available for all types
    struct TypeInfo
    {
        fullname: string                 // The full scoped name of the type
        name:     string                 // The unscoped name
        sizeof:   u32                    // Size in bytes
        crc32:    u32                    // A unique CRC to identify the type
        flags     = TypeInfoFlags.Zero   // Some additional flags
        kind      = TypeInfoKind.Invalid // The kind of the type
        padding:  [3] u8
    }

    struct TypeInfoNative
    {
        using base: TypeInfo
        nativeKind: TypeInfoNativeKind = TypeInfoNativeKind.Void
    }

    struct TypeInfoPointer
    {
        using base:  TypeInfo
        pointedType: const *TypeInfo // The pointed type
    }

    struct TypeInfoAlias
    {
        using base: TypeInfo
        rawType:    const *TypeInfo // The underlying type
    }

    struct TypeInfoStruct
    {
        using base:  TypeInfo
        opInit:      func(*void)          // Pointer to the function to initialize an instance of that struct
        opDrop:      func(*void)          // Pointer to the function to drop an instance of that struct
        opPostCopy:  func(*void)          // Pointer to the function to call after a copy
        opPostMove:  func(*void)          // Pointer to the function to call after a move
        structName:  string               // User name of the struct
        fromGeneric: const *TypeInfo      // If it comes from a generic instantiation, this is the original generic struct
        generics:    const [..] TypeValue // Generic parameters
        fields:      const [..] TypeValue // All the fields
        methods:     const [..] TypeValue // All the methods, if exported
        interfaces:  const [..] TypeValue // All the interfaces
        attributes:  const [..] Attribute // All the attributes
    }

    struct TypeInfoFunc
    {
        using base: TypeInfo
        generics:   const [..] TypeValue // Generic parameters
        parameters: const [..] TypeValue // Parameters
        returnType: const *TypeInfo      // The return type, or 'null'
        attributes: const [..] Attribute // All the attributes
    }

    struct TypeInfoEnum
    {
        using base: TypeInfo
        values:     const [..] TypeValue // All the values
        rawType:    const *TypeInfo      // The underlying enum type
        attributes: const [..] Attribute // All the attributes
    }

    struct TypeInfoArray
    {
        using base:  TypeInfo
        pointedType: const *TypeInfo // The underlying type
        finalType:   const *TypeInfo // If this is an array with multiple dimensions, this will be the final type
        count:       u64             // Number of elements in the array
        totalCount:  u64             // The total number of elements in case this has multiple dimensions
    }

    struct TypeInfoSlice
    {
        using base:  TypeInfo
        pointedType: const *TypeInfo // The underlying type
    }

    struct TypeInfoVariadic
    {
        using base: TypeInfo
        rawType:    const *TypeInfo // The underlying type
    }

    struct TypeInfoGeneric
    {
        using base: TypeInfo
        rawType:    const *TypeInfo
    }

    struct TypeInfoNamespace
    {
        using base: TypeInfo
    }

    // #########################################################
    // Build configuration
    // #########################################################

    #[EnumFlags]
    enum RuntimeFlags : u64
    {
        Zero         = 0
        FromCompiler = 1
    }

    // Target processor
    enum TargetArch
    {
        X86_64
    }

    // The 'OS' to target when generating native code
    enum TargetOs
    {
        Windows // Windows 10/11
        Linux   // Linux (**unsupported**)
        MaxOSX  // MacOS (**unsupported**)
    }

    // The type of backend to use
    enum Backend
    {
        ByteCode // Bytecode
        SCBE     // SCBE backend (SwagCustomBackEnd)
        LLVM     // LLVM backend
    }

    const SafetyBoundCheck  = 0x0001
    const SafetyOverflow    = 0x0002
    const SafetyMath        = 0x0004
    const SafetyAny         = 0x0008
    const SafetySwitch      = 0x0010
    const SafetyBool        = 0x0020
    const SafetyNaN         = 0x0040
    const SafetySanity      = 0x0080
    const SafetyUnreachable = 0x0100
    const SafetyNullCheck   = 0x0200
    const SafetyNone        = 0x0000
    const SafetyAll         = 0xFFFF

    // 'LLVM' backend specific options
    struct BuildCfgBackendLLVM
    {
        outputIR:           bool = false // Output IR in a file

        fpMathFma:          bool = false // true in 'release'
        fpMathNoNaN:        bool = false // true in 'release'
        fpMathNoInf:        bool = false // true in 'release'
        fpMathNoSignedZero: bool = false // true in 'release'
        fpMathUnsafe:       bool = false
        fpMathApproxFunc:   bool = false
    }

    // 'SCBE' backend specific options
    struct BuildCfgBackendSCBE
    {
    }

    // The kind of native backend to generate.
    enum BuildCfgBackendKind
    {
        None       // Nothing
        Export     // The module is an 'export' module which does not have its own code.
        Executable // The module needs to be compiled to an executable application.
        Library    // The module needs to be compiled as a library.
    }

    // The native backend sub category.
    // Under windows, by default, the application will be compiled to make a 'windowed' application. But you can
    // change it and force the application to behave like a 'console' one.
    enum BuildCfgBackendSubKind
    {
        Default
        Console
    }

    // These are the optimization levels for the backend.
    // Only 'LLVM' backend uses this, as the 'X86_64' backend does not have an optimization pass.
    enum BuildCfgBackendOptim
    {
        O0 // No optimization
        O1 // Optimizations level 1
        O2 // Optimizations level 2
        O3 // Optimizations level 3
        Os // Optim for size level 1
        Oz // Optim for size level 2
    }

    enum BuildCfgDocKind
    {
        None     // Do not generate documentation for that module
        Api      // Generate 'api like' documentation
        Examples // Generate 'examples like' documentation
        Pages    // Generate one page per file
    }

    // This contains all options when generating documentation.
    struct BuildCfgGenDoc
    {
        kind                 = BuildCfgDocKind.None // The kind of documentation to generate
        outputName:          string                 // The name of the output file (without extension)
        outputExtension:     string                 // The output extension
        titleToc:            string                 // Title for the table of content
        titleContent:        string                 // Title for the main document content
        css:                 string                 // The 'css' file to include in generated documentations
        icon:                string                 // The icon path of the page
        startHead:           string                 // Content to insert at the start of the <head> section
        endHead:             string                 // Content to insert at the end of the <head> section
        startBody:           string                 // Content to insert at the start of the <body> section
        endBody:             string                 // Content to insert at the end of the <body> section
        morePages:           string                 // Additional external file pages to process (separated with ';')
        quoteIconNote:       string                 // The icon for the note blockquote
        quoteIconTip:        string                 // The icon for the tip blockquote
        quoteIconWarning:    string                 // The icon for the warning blockquote
        quoteIconAttention:  string                 // The icon for the attention blockquote
        quoteIconExample:    string                 // The icon for the example blockquote
        quoteTitleNote:      string                 // The title for the note blockquote
        quoteTitleTip:       string                 // The title for the tip blockquote
        quoteTitleWarning:   string                 // The title for the warning blockquote
        quoteTitleAttention: string                 // The title for the attention blockquote
        quoteTitleExample:   string                 // The title for the example blockquote
        syntaxDefaultColor:  u32 = 0x00222222       // Code syntax default color (if not colorized)
        syntaxColorLum:      f32 = 0.5              // Code syntax color luminosity in range ]0, 1]
        hasFontAwesome       = true                 // Generate a reference to the FontAwesome script (icons)
        hasStyleSection      = true                 // Generate a default <style> section
        hasSwagWatermark     = true                 // Generate a swag watermark at the bottom of each page
    }

    // The current module build configuration.
    // See [[ICompiler]]
    struct BuildCfg
    {
        moduleVersion:             u32 = 0                          // The module version
        moduleRevision:            u32 = 0                          // The module revision
        moduleBuildNum:            u32 = 0                          // The module build value
        moduleNamespace:           string                           // The namespace name of the module
        embeddedImports            = false                          // Module should embed all its dependencies

        tempAllocatorCapacity      = 4'u32 * 1024 * 1024            // Default capacity of the 'temp' allocator (in bytes)
        errorAllocatorCapacity     = 16'u32 * 1024                  // Default capacity of the 'error' allocator (in bytes)
        safetyGuards:              u16 = SafetyAll                  // Activate specific safety checks
        debugAllocator             = true                           // Use Swag.DebugAllocator by default
        debugAllocatorCaptureStack = true                           // Capture the call stack for each allocation
        debugAllocatorLeaks        = true                           // Detect memory leaks
        errorStackTrace            = true                           // Add stack trace in case a 'throw' is raised

        warnAsErrors:              string                           // Force some warnings to be treated as errors. Format is "WrnXXXX|WrnXXXX..."
        warnAsWarning:             string                           // Override 'warnAsErrors', restoring warnings as warnings
        warnAsDisabled:            string                           // Disable some specific warnings
        warnDefaultDisabled:       bool                             // All warnings are disabled, except those specified above
        warnDefaultErrors:         bool                             // All warnings are treated as errors, except those specified above

        byteCodeOptimizeLevel      = 1                              // Optimization level of bytecode [0, 1 or 2]
        byteCodeEmitAssume         = true                           // 'assume' will panic if an error is raised
        byteCodeInline             = true                           // Enable bytecode inlining with #[Swag.Inline]
        byteCodeAutoInline         = true                           // Automatic inlining of some other functions

        backendKind                = BuildCfgBackendKind.Executable // Backend type (executable, dynamic lib...)
        backendSubKind             = BuildCfgBackendSubKind.Console // Backend sub kind
        backendDebugInformations   = false                          // Output debug information if 'true'
        backendDebugInline         = false                          // Generate specific line information for inline code
        backendOptimize            = BuildCfgBackendOptim.O0        // Backend optimization level
        backendNumCU               = 0'u32

        linkerArgs:                string                           // Additional linker arguments

        backendLLVM:               BuildCfgBackendLLVM              // Specific LLVM options
        backendSCBE:               BuildCfgBackendSCBE              // Specific SCBE options

        repoPath:                  string                           // Repository access path to the module

        genDoc:                    BuildCfgGenDoc                   // Parameters for document generation
    }

    // #########################################################
    // Compiler
    // #########################################################

    // The kind of message in [[CompilerMessage]]
    enum CompilerMsgKind : u32
    {
        PassAfterSemantic     // Called once the program semantic has been done
        PassBeforeRunByteCode // Called just before running bytecode
        PassBeforeOutput      // Called just before generating the native code
        PassAllDone           // Called when everything has be done
        SemFunctions          // Called for each function in the module
        SemTypes              // Called for each type in the module
        SemGlobals            // Called for each global variable in the module
        AttributeGen
    }

    // The type of message you want to retreive in a '#message' function.
    //
    // The function could be called for more than one reason, as this is a mask.
    #[EnumFlags]
    enum CompilerMsgMask : u64
    {
        PassAfterSemantic = 1 << cast(u32) CompilerMsgKind.PassAfterSemantic
        PassBeforeRun     = 1 << cast(u32) CompilerMsgKind.PassBeforeRunByteCode
        PassBeforeOutput  = 1 << cast(u32) CompilerMsgKind.PassBeforeOutput
        PassAllDone       = 1 << cast(u32) CompilerMsgKind.PassAllDone
        SemFunctions      = 1 << cast(u32) CompilerMsgKind.SemFunctions
        SemTypes          = 1 << cast(u32) CompilerMsgKind.SemTypes
        SemGlobals        = 1 << cast(u32) CompilerMsgKind.SemGlobals
        AttributeGen      = 1 << cast(u32) CompilerMsgKind.AttributeGen
        All               = 0xFFFFFFFF_FFFFFFFF
    }

    // A message received in a '#message' function.
    //
    // In a '#message' function, you can retreive the associated message by calling 'getMessage' of the
    // interface returned by [[@compiler]]
    struct CompilerMessage
    {
        moduleName: string                      // Name of the module for which the message is sent.
        name:       string                      // Depends on 'kind'
        type:       const *TypeInfo             // Depends on 'kind'
        kind:       CompilerMsgKind = undefined // Kind of the message
    }

    // This is the interface to communicate with the compiler.
    //
    // The intrinsic '@compiler' will return that interface at compile-time, and 'null' at runtime.
    interface ICompiler
    {
        mtd getMessage()->const *CompilerMessage; // Returns the compiler message in a '#message' function
        mtd getBuildCfg()->*BuildCfg; // Returns the build configuration of the current module
        mtd compileString(str: string);
    }

    // Represent a part of a source code file.
    //
    // This is typically what will be returned by '#location' or '#callerlocation'.
    struct SourceCodeLocation
    {
        fileName:  string // Full path name of the source file
        lineStart: u32    // Start line (starts at 0)
        colStart:  u32    // Start column
        lineEnd:   u32    // End line
        colEnd:    u32    // End column
    }

    struct CVaList
    {
        buf: [2048] u8
    }
}

// Panic if the expression is false. Typically used in tests.
func @assert(value: bool);
// Stop a bytecode execution, and launch the bytecode debugger.
func @breakpoint();
// Get the current thread context.
func @getcontext()->*Swag.Context;
// Replace the current thread context.
func @setcontext(context: const *Swag.Context);
// Get information about the current process.
func @pinfos()->*Swag.ProcessInfos;
// Returns 'true' is the current execution is bytecode.
func @isbytecode()->bool;
// Returns the list of all loaded modules.
func @modules()->const [..] Swag.Module;
// Returns the list of all global variables.
func @gvtd()->const [..] Swag.Gvtd;
// Returns an [[ICompiler]] interface to communicate with the compiler.
func @compiler()->Swag.ICompiler;

// Returns a system allocated memory block of 'size' bytes.
//
// Use [[@free]] to release the allocated memory.
func @alloc(size: u64)->^void;

// Realloc a system memory block allocated with [[@alloc]]
func @realloc(ptr: ^void, size: u64)->^void;

// Free a system memory block allocated with [[@alloc]]
func @free(ptr: ^void);

// Set all bytes of a given memory block to 'value'
func @memset(dst: ^void, value: u8, size: u64);

// Copy one memory block to another address.
func @memcpy(dst: ^void, src: const ^void, size: u64);

// Move one memory block to another address.
func @memmove(dst: ^void, src: const ^void, size: u64);

// Compare two memory blocks, and returns -1, 0 if equal, or 1.
func @memcmp(dst, src: const ^void, size: u64)->s32;

// Returns the length of the given 0 terminated string.
func @strlen(str: cstring)->u64;

// Compare two zero terminated strings, and returns -1, 0 if equal, or 1.
func @strcmp(str1, str2: cstring)->s32;

// Atomic operations
#[Swag.Discardable, Swag.Overload]
{
    // Atomic 'add'
    func @atomadd(addr: *s8, value: s8)->s8;
    func @atomadd(addr: *s16, value: s16)->s16;
    func @atomadd(addr: *s32, value: s32)->s32;
    func @atomadd(addr: *s64, value: s64)->s64;
    func @atomadd(addr: *u8, value: u8)->u8;
    func @atomadd(addr: *u16, value: u16)->u16;
    func @atomadd(addr: *u32, value: u32)->u32;
    func @atomadd(addr: *u64, value: u64)->u64;

    // Atomic 'and'
    func @atomand(addr: *s8, value: s8)->s8;
    func @atomand(addr: *s16, value: s16)->s16;
    func @atomand(addr: *s32, value: s32)->s32;
    func @atomand(addr: *s64, value: s64)->s64;
    func @atomand(addr: *u8, value: u8)->u8;
    func @atomand(addr: *u16, value: u16)->u16;
    func @atomand(addr: *u32, value: u32)->u32;
    func @atomand(addr: *u64, value: u64)->u64;

    // Atomic 'or'
    func @atomor(addr: *s8, value: s8)->s8;
    func @atomor(addr: *s16, value: s16)->s16;
    func @atomor(addr: *s32, value: s32)->s32;
    func @atomor(addr: *s64, value: s64)->s64;
    func @atomor(addr: *u8, value: u8)->u8;
    func @atomor(addr: *u16, value: u16)->u16;
    func @atomor(addr: *u32, value: u32)->u32;
    func @atomor(addr: *u64, value: u64)->u64;

    // Atomic 'xor'
    func @atomxor(addr: *s8, value: s8)->s8;
    func @atomxor(addr: *s16, value: s16)->s16;
    func @atomxor(addr: *s32, value: s32)->s32;
    func @atomxor(addr: *s64, value: s64)->s64;
    func @atomxor(addr: *u8, value: u8)->u8;
    func @atomxor(addr: *u16, value: u16)->u16;
    func @atomxor(addr: *u32, value: u32)->u32;
    func @atomxor(addr: *u64, value: u64)->u64;

    // Atomic 'exchange'
    func @atomxchg(addr: *s8, exchangeWith: s8)->s8;
    func @atomxchg(addr: *s16, exchangeWith: s16)->s16;
    func @atomxchg(addr: *s32, exchangeWith: s32)->s32;
    func @atomxchg(addr: *s64, exchangeWith: s64)->s64;
    func @atomxchg(addr: *u8, exchangeWith: u8)->u8;
    func @atomxchg(addr: *u16, exchangeWith: u16)->u16;
    func @atomxchg(addr: *u32, exchangeWith: u32)->u32;
    func @atomxchg(addr: *u64, exchangeWith: u64)->u64;

    // Atomic 'compare and exchange'
    func @atomcmpxchg(addr: *s8, compareTo, exchangeWith: s8)->s8;
    func @atomcmpxchg(addr: *s16, compareTo, exchangeWith: s16)->s16;
    func @atomcmpxchg(addr: *s32, compareTo, exchangeWith: s32)->s32;
    func @atomcmpxchg(addr: *s64, compareTo, exchangeWith: s64)->s64;
    func @atomcmpxchg(addr: *u8, compareTo, exchangeWith: u8)->u8;
    func @atomcmpxchg(addr: *u16, compareTo, exchangeWith: u16)->u16;
    func @atomcmpxchg(addr: *u32, compareTo, exchangeWith: u32)->u32;
    func @atomcmpxchg(addr: *u64, compareTo, exchangeWith: u64)->u64;
}

// Constant intrinsics
#[Swag.ConstExpr, Swag.Overload]
{
    func @sqrt(value: f32)->f32;
    func @sqrt(value: f64)->f64;

    func @sin(value: f32)->f32;
    func @sin(value: f64)->f64;
    func @cos(value: f32)->f32;
    func @cos(value: f64)->f64;
    func @tan(value: f32)->f32;
    func @tan(value: f64)->f64;

    func @sinh(value: f32)->f32;
    func @sinh(value: f64)->f64;
    func @cosh(value: f32)->f32;
    func @cosh(value: f64)->f64;
    func @tanh(value: f32)->f32;
    func @tanh(value: f64)->f64;

    func @asin(value: f32)->f32;
    func @asin(value: f64)->f64;
    func @acos(value: f32)->f32;
    func @acos(value: f64)->f64;
    func @atan(value: f32)->f32;
    func @atan(value: f64)->f64;

    func @log(value: f32)->f32;
    func @log(value: f64)->f64;
    func @log2(value: f32)->f32;
    func @log2(value: f64)->f64;
    func @log10(value: f32)->f32;
    func @log10(value: f64)->f64;

    func @floor(value: f32)->f32;
    func @floor(value: f64)->f64;
    func @ceil(value: f32)->f32;
    func @ceil(value: f64)->f64;
    func @trunc(value: f32)->f32;
    func @trunc(value: f64)->f64;
    func @round(value: f32)->f32;
    func @round(value: f64)->f64;

    func @abs(value: s8)->s8;
    func @abs(value: s16)->s16;
    func @abs(value: s32)->s32;
    func @abs(value: s64)->s64;
    func @abs(value: f32)->f32;
    func @abs(value: f64)->f64;

    func @exp(value: f32)->f32;
    func @exp(value: f64)->f64;
    func @exp2(value: f32)->f32;
    func @exp2(value: f64)->f64;
    func @pow(value1, value2: f32)->f32;
    func @pow(value1, value2: f64)->f64;
    func @atan2(value1, value2: f32)->f32;
    func @atan2(value1, value2: f64)->f64;

    func @min(value1, value2: s8)->s8;
    func @min(value1, value2: s16)->s16;
    func @min(value1, value2: s32)->s32;
    func @min(value1, value2: s64)->s64;
    func @min(value1, value2: u8)->u8;
    func @min(value1, value2: u16)->u16;
    func @min(value1, value2: u32)->u32;
    func @min(value1, value2: u64)->u64;
    func @min(value1, value2: f32)->f32;
    func @min(value1, value2: f64)->f64;

    func @max(value1, value2: s8)->s8;
    func @max(value1, value2: s16)->s16;
    func @max(value1, value2: s32)->s32;
    func @max(value1, value2: s64)->s64;
    func @max(value1, value2: u8)->u8;
    func @max(value1, value2: u16)->u16;
    func @max(value1, value2: u32)->u32;
    func @max(value1, value2: u64)->u64;
    func @max(value1, value2: f32)->f32;
    func @max(value1, value2: f64)->f64;

    // Count the number of bits set to 1
    func @bitcountnz(value: u8)->u8;
    func @bitcountnz(value: u16)->u16;
    func @bitcountnz(value: u32)->u32;
    func @bitcountnz(value: u64)->u64;

    // Returns the index+1 of the first set bit, starting from right (lsb). 0 if all zero.
    func @bitcounttz(value: u8)->u8;
    func @bitcounttz(value: u16)->u16;
    func @bitcounttz(value: u32)->u32;
    func @bitcounttz(value: u64)->u64;

    // Returns the index+1 of the first set bit, starting from the left (msb). 0 if all zero.
    func @bitcountlz(value: u8)->u8;
    func @bitcountlz(value: u16)->u16;
    func @bitcountlz(value: u32)->u32;
    func @bitcountlz(value: u64)->u64;

    // Reverses the order of bytes in an integer.
    func @byteswap(value: u16)->u16;
    func @byteswap(value: u32)->u32;
    func @byteswap(value: u64)->u64;

    // Rotate bits left
    func @rol(value, num: u8)->u8;
    func @rol(value, num: u16)->u16;
    func @rol(value, num: u32)->u32;
    func @rol(value, num: u64)->u64;

    // Rotate bits right
    func @ror(value, num: u8)->u8;
    func @ror(value, num: u16)->u16;
    func @ror(value, num: u32)->u32;
    func @ror(value, num: u64)->u64;

    // Returns '(val1 * val2) + val3'
    func @muladd(val1, val2, val3: f32)->f32;
    func @muladd(val1, val2, val3: f64)->f64;
}
