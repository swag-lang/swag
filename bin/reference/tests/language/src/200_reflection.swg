#test
{
    // You can get the type of an expression with '@typeof' or just with the type itself
    // (in Swag types are values)
    {
        ptr1 := @typeof(s8)
        @assert(ptr1.name == "s8")
        @assert(ptr1 == s8)

        ptr2 := @typeof(s16)
        @assert(ptr2.name == "s16")
        @assert(ptr2 == s16)

        ptr3 := s32
        @assert(ptr3.name == "s32")
        @assert(ptr3 == @typeof(s32))

        ptr4 := s64
        @assert(ptr4.name == "s64")
        @assert(ptr4 == s64)
    }

    // The return result of '@typeof' is a const pointer to a Swag.TypeInfo kind of structure
    // This is an alias for the 'typeinfo' type.
    {
        ptr := bool
        @assert(@typeof(ptr) == @typeof(const *Swag.TypeInfoNative))

        ptr1 := #type [2] s32
        @assert(@typeof(ptr1) == @typeof(const *Swag.TypeInfoArray))
        @assert(ptr1.name == "[2] s32")
    }

    // The TypeInfo structure contains a different enum value for each type
    {
        ptr := f64
        @assert(@typeof(ptr.kind).fullname == "Swag.TypeInfoKind")
        @assert(ptr.sizeof == @sizeof(f64))
    }

    // @mktype can be used to transform a typeinfo to a real compiler type
    // This is the opposite of @typeof or @kindof
    {
        var x: @mktype(@typeof(s32))
        #assert @typeof(x) == s32
    }

    // @mktype can evaluate a constexpr expression that returns a 'typeinfo' to determine the real type
    {
        #[Swag.ConstExpr]
        func getType(str: bool)->typeinfo
        {
            if str return string
            else   return s32
        }

        var x: @mktype(getType(false))
        #assert @typeof(x) == s32
        x = 0

        var x1: @mktype(getType(true))
        #assert @typeof(x1) == string
        x1 = "0"
    }
}
