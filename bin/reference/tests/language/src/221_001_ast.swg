/**
# `#ast` Block
The most simple way to produce a string that contains the Swag code to compile is with an `#ast` block. An `#ast` block is executed at compile time, and the string it returns will be compiled **in place**.
*/

/**
# Basic `#ast` Usage
The `#ast` can be a simple expression that returns the string to compile. This allows you to dynamically generate code at compile time.
*/
#test
{
    #ast "var x = 666"
    @assert(x == 666) // The variable 'x' is generated by the `#ast` block and holds the value 666.
}

/**
# `#ast` Block with `return`
An `#ast` block can also be a more complex block of code, with an explicit `return` statement that returns the string to be compiled.
*/
#test
{
    var cpt = 2
    #ast
    {
        const INC = 5
        return "cpt += " ++ INC // Generates the code 'cpt += 5'.
    }

    @assert(cpt == 7) // The variable 'cpt' is incremented by 5 as generated by the `#ast` block.
}

/**
# `#ast` for Structs and Enums
`#ast` can be used to dynamically generate the content of a `struct` or `enum`. This is useful for creating code based on compile-time conditions or inputs.
*/
#test
{
    struct MyStruct
    {
        #ast
        {
            return "x, y: s32 = 666" // Generates two fields 'x' and 'y', both initialized to 666.
        }
    }

    var v: MyStruct
    @assert(v.x == 666)
    @assert(v.y == 666)
}

/**
# `#ast` with Generics
`#ast` works seamlessly with generics and can be combined with static declarations. This allows for highly flexible and reusable code generation patterns.
*/
#test
{
    struct(T) MyStruct
    {
        #ast
        {
            return "x, y: " ++ @typeof(T).name // Generates fields 'x' and 'y' with the type of the generic parameter 'T'.
        }

        z: string // Additional static declaration.
    }

    var v: MyStruct'bool
    #assert @typeof(v.x) == bool
    #assert @typeof(v.y) == bool
    #assert @typeof(v.z) == string

    var v1: MyStruct'f64
    #assert @typeof(v1.x) == f64
    #assert @typeof(v1.y) == f64
    #assert @typeof(v1.z) == string
}

/**
# Constructing Strings in `#ast`
`#ast` needs to return a *string-like* value, which can be dynamically constructed. In this example, we manually build a string, though typically you would use a more sophisticated method such as `Core.String`.
*/
#test
{
    #[Swag.Compiler]
    func append(buf: ^u8, val: string)
    {
        var len = 0
        while buf[len]:
            len += 1
        @memcpy(buf + len, @dataof(val), cast(u64) @countof(val) + 1)
    }

    struct Vector3
    {
        #ast
        {
            // Construct the code to compile in this local array
            var buf: [256] u8
            append(buf, "x: f32 = 1\n")
            append(buf, "y: f32 = 2\n")
            append(buf, "z: f32 = 3\n")

            // Return the constructed code to the compiler
            return cast(string) buf
        }
    }

    var v: Vector3
    @assert(v.x == 1)
    @assert(v.y == 2)
    @assert(v.z == 3)
}

/**
# Real-World Example
Here is a real-life example of `#ast` usage from the `Std.Core` module. This code generates a structure that contains all the fields of another structure, but where the types are forced to be `bool`.
```swag
struct(T) IsSet
{
    #ast
    {
        // A `StringBuilder` is used to manipulate dynamic strings.
        var str = StrConv.StringBuilder{}

        // We get the type of the generic parameter 'T'
        let typeof = @typeof(T)

        // Then we visit all the fields, assuming the type is a struct (or this will not compile).
        // For each original field, we create one with the same name, but with a `bool` type.
        visit f in typeof.fields:
            str.appendFormat("%: bool\n", f.name)

        // Then we return the constructed source code.
        // It will be used by the compiler to generate the content of the `IsSet` struct.
        return str.toString()
    }
}
```
*/

/**
# `#ast` at global scope
`#ast` can also be called at the global scope, allowing you to generate global variables, constants, or other declarations dynamically.
*/
#ast
{
    const value = 666
    return "const myGeneratedConst = " ++ value
}

/**
But be aware that you must use `#placeholder` in case you are generating global symbols that can be used by something else in the code. This will tell Swag that *this symbol* will exist at some point, so please wait for it to *exist* before complaining.
*/
#placeholder myGeneratedConst // Symbol `myGeneratedConst` will be generated

/**
Here for example, thanks to the `#placeholder`, the `#assert` will wait for the symbol `myGeneratedConst` to be replaced with its real content.
*/
#assert myGeneratedConst == 666
