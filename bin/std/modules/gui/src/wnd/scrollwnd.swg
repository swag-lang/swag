using Core, Pixel

#[Swag.EnumFlags]
public enum ScrollWndFlags
{
    None
    SmallBar
    ForceHorizontal
    ForceVertical
    TransparentBar
}

public struct ScrollWnd
{
    using frameWnd: FrameWnd

    scrollIncrementV: f32 = 50
    scrollIncrementH: f32 = 50

    scrollSize:     Math.Point
    scrollWndFlags  = ScrollWndFlags.None

    sigScrollPosChanged:    SigArray'closure(*Self, Math.Point, Math.Point)
    sigScrollSizeChanged:   SigArray'closure(*Self, Math.Point, Math.Point)

    oldMouseCapture:    *Wnd

    scrollSmoothPos:    Math.Point
    scrollRequestPos:   Math.Point
    smoothScroll:       bool

    showBarV:       bool
    needV:          bool
    posBoxV:        f32
    sizeBoxV:       f32
    isHotV:         bool
    isPressedV:     bool

    showBarH:       bool
    needH:          bool
    posBoxH:        f32
    sizeBoxH:       f32
    isHotH:         bool
    isPressedH:     bool

    isMoving:       bool
    isGrabbing:     bool
    correcMoving:   f32
    offsetClientV:  f32
    offsetClientH:  f32
    paddingZ:       f32
    paddingW:       f32

    grabbingPos:    Math.Point
}

public impl IWnd for ScrollWnd
{
    mtd onResizeEvent(evt: *ResizeEvent)
    {
        computeLayout()
        if !view
            return
        rect := getClientRectPadding()
        rect.width -= paddingZ
        rect.height -= paddingW
        rect.applyPadding(view.margin)
        view.setPosition(rect)
    }

    mtd onMouseEvent(evt: *MouseEvent)
    {
        clientRect := getClientRect()
        pos := surfaceToLocal(evt.surfacePos)

        switch evt.kind
        {
        case MouseWheel:
            if evt.modifiers & .Control or !showBarV
                setScrollPos(view.scrollPos.x - (evt.move.y * scrollIncrementH), view.scrollPos.y)
            else
                setScrollPos(view.scrollPos.x, view.scrollPos.y - (evt.move.y * scrollIncrementV))

        case MouseLeave:
            isHotV, isHotH = false
            invalidate()

        case MouseMove:
            if isGrabbing
            {
                move := evt.surfacePos - grabbingPos
                scroll := scrollRequestPos - move
                scrollRequestPos = getScrollPosPrivate(scroll.x, scroll.y)
                smoothScroll = true
                grabbingPos = evt.surfacePos
                invalidate()
                break
            }

            if !isMoving
            {
                hitTest(evt.surfacePos)
                break
            }

            if isPressedV
            {
                vh := position.height - paddingW
                f := (pos.y - correcMoving) / (vh - offsetClientV)
                f *= scrollSize.y
                setScrollPos(view.scrollPos.x, f)
            }
            elif isPressedH
            {
                vh := position.width - paddingZ
                f := (pos.x - correcMoving) / (vh - offsetClientH)
                f *= scrollSize.x
                setScrollPos(f, view.scrollPos.y)
            }

            invalidate()

        case MousePressed:
            if evt.button == .Middle
            {
                scrollSmoothPos = view.scrollPos
                isGrabbing = true
                grabbingPos = evt.surfacePos
                oldMouseCapture = getMouseCapture()
                captureMouse()
                invalidate()
            }
            elif evt.button == .Left
            {
                isMoving = true
                if isHotV
                {
                    isPressedV = true
                    correcMoving = pos.y - posBoxV
                }
                elif isHotH
                {
                    isPressedH = true
                    correcMoving = pos.x - posBoxH
                }
                elif pos.x > clientRect.right() - paddingZ
                {
                    correcMoving = 0
                    isPressedV = true
                    f := pos.y / clientRect.height
                    f *= scrollSize.y
                    setScrollPos(view.scrollPos.x, f)
                }
                elif pos.y > clientRect.bottom() - paddingW
                {
                    correcMoving = 0
                    isPressedH = true
                    f := pos.x / clientRect.width
                    f *= scrollSize.x
                    setScrollPos(f, view.scrollPos.y)
                }

                oldMouseCapture = getMouseCapture()
                captureMouse()
                invalidate()
            }

        case MouseReleased:
            if isGrabbing and evt.button == .Middle
            {
                releaseMouse()
                if oldMouseCapture
                    oldMouseCapture.captureMouse()
                hitTest(evt.surfacePos)
                invalidate()
                isGrabbing = false
            }
            elif isMoving and evt.button == .Left
            {
                releaseMouse()
                if oldMouseCapture
                    oldMouseCapture.captureMouse()
                isPressedV, isPressedH, isMoving = false
                hitTest(evt.surfacePos)
                invalidate()
            }
        }
    }

    mtd onPaintEvent(evt: *PaintEvent)
    {
        if smoothScroll
        {
            dt := getApp().getDt()
            if  !Math.isEqualEpsilon(scrollRequestPos.x, view.scrollPos.x) or
                !Math.isEqualEpsilon(scrollRequestPos.y, view.scrollPos.y)
            {
                scrollSmoothPos.x = Math.lerp(scrollSmoothPos.x, scrollRequestPos.x, 10*dt)
                scrollSmoothPos.y = Math.lerp(scrollSmoothPos.y, scrollRequestPos.y, 10*dt)
                discard setScrollPosPrivate(scrollSmoothPos.x, scrollSmoothPos.y)
                invalidate()
            }
            else
                smoothScroll = false
        }

        bc      := evt.bc
        theme   := getTheme()
        metrics := getThemeMetrics()
        colors  := getThemeColors()
        rects   := getThemeRects()

        var colorBk: Color
        switch
        {
            case scrollWndFlags & .TransparentBar:
                break
            case bc.isDisabled:
                colorBk = colors.scrollBar_DisabledBk
            default:
                colorBk = colors.scrollBar_Bk
        }

        // Vertical bar
        if showBarV
        {
            clientRect := getClientRect()
            clientRect.x = clientRect.right() - paddingZ
            clientRect.width = paddingZ
            if showBarH
                clientRect.height -= paddingW
            theme.drawSubRect(bc.painter, clientRect, &rects.scrollBar_BkV, colorBk)

            if needV
            {
                clientRect.y = posBoxV
                clientRect.height = sizeBoxV

                var colorBox: Color = ?
                if isHotV and isPressedV
                    colorBox = colors.scrollBar_PressedBox
                elif isHotV
                    colorBox = colors.scrollBar_HotBox
                else
                    colorBox = colors.scrollBar_Box
                clientRect.inflate(-metrics.scrollBar_BoxPadding)
                theme.drawSubRect(bc.painter, clientRect, &rects.scrollBar_BoxV, colorBox)
            }
        }

        // Horizontal bar
        if showBarH
        {
            clientRect := getClientRect()
            clientRect.y = clientRect.bottom() - paddingW
            clientRect.height = paddingW
            if showBarV
                clientRect.width -= paddingW
            theme.drawSubRect(bc.painter, clientRect, &rects.scrollBar_BkH, colorBk)

            if needH
            {
                clientRect.x = posBoxH
                clientRect.width = sizeBoxH

                var colorBox: Color = ?
                if isHotH and isPressedH
                    colorBox = colors.scrollBar_PressedBox
                elif isHotH
                    colorBox = colors.scrollBar_HotBox
                else
                    colorBox = colors.scrollBar_Box
                clientRect.inflate(-metrics.scrollBar_BoxPadding)
                theme.drawSubRect(bc.painter, clientRect, &rects.scrollBar_BoxH, colorBox)
            }
        }

        // Corner
        if showBarV and showBarH
        {
            clientRect := getClientRect()
            clientRect.x = clientRect.right() - paddingZ
            clientRect.y = clientRect.bottom() - paddingW
            clientRect.width = paddingZ
            clientRect.height = paddingW
            theme.drawSubRect(bc.painter, clientRect, &rects.scrollBar_Corner, colors.scrollBar_Bk)
        }
    }
}

impl ScrollWnd
{
    mtd hitTest(surfacePos: Math.Point)
    {
        pos := surfaceToLocal(surfacePos)
        if isHotV or isHotH
        {
            invalidate()
            isHotV, isHotH = false
        }

        rect := getPosBoxV()
        if rect.contains(pos)
        {
            isHotV = true
            invalidate()
            return
        }

        rect = getPosBoxH()
        if rect.contains(pos)
        {
            isHotH = true
            invalidate()
        }
    }

    mtd getPosBoxV()->Math.Rectangle
    {
        var result: retval = getClientRect()
        result.x = result.right() - paddingZ
        result.width = paddingZ
        result.y = posBoxV
        result.height = sizeBoxV
        return result
    }

    mtd getPosBoxH()->Math.Rectangle
    {
        var result: retval = getClientRect()
        result.y = result.bottom() - paddingW
        result.height = paddingW
        result.x = posBoxH
        result.width = sizeBoxH
        return result
    }

    mtd computeLayout()
    {
        if position.width == 0 or position.height == 0
            return
        clientRect := getClientRectPadding()
        sx := Math.max(scrollSize.x, clientRect.width)
        sy := Math.max(scrollSize.y, clientRect.height)
        sx = Math.max(sx, 1)
        sy = Math.max(sy, 1)

        metrics := getThemeMetrics()

        showBarV, showBarH = false
        needH, needV = false

        if sy > clientRect.height
            needV = true
        if needV or scrollWndFlags & .ForceVertical
            showBarV = true

        if sx > clientRect.width
            needH = true
        if needH or scrollWndFlags & .ForceHorizontal
            showBarH = true

        barSize := (scrollWndFlags & .SmallBar) ? metrics.scrollBar_SmallSize : metrics.scrollBar_NormalSize

        paddingZ, paddingW = 0
        if showBarV
            paddingZ = barSize
        if showBarH
            paddingW = barSize

        if showBarV
        {
            vh0 := clientRect.height - paddingW
            vh1 := position.height - paddingW
            sizeBoxV = (vh0 / sy) * vh1
            if sizeBoxV < metrics.scrollBar_BoxMinSize
            {
                offsetClientV = metrics.scrollBar_BoxMinSize - sizeBoxV
                vh1 -= offsetClientV
                sizeBoxV = metrics.scrollBar_BoxMinSize
            }

            posBoxV = view.scrollPos.y / sy
            posBoxV *= vh1
        }

        if showBarH
        {
            vh0 := clientRect.width - paddingZ
            vh1 := position.width - paddingZ
            sizeBoxH = (vh0 / sx) * vh1
            if sizeBoxH < metrics.scrollBar_BoxMinSize
            {
                offsetClientH = metrics.scrollBar_BoxMinSize - sizeBoxH
                vh1 -= offsetClientH
                sizeBoxH = metrics.scrollBar_BoxMinSize
            }

            posBoxH = view.scrollPos.x / sx
            posBoxH *= vh1
        }

        invalidate()
    }
}

public impl ScrollWnd
{
    // Get the current scroll position
    mtd getScrollPos()->Math.Point
    {
        return view.scrollPos
    }

    private mtd getScrollPosPrivate(x, y: f32)->Math.Point
    {
        var newSP: Math.Point = ?

        clientRect := view.getClientRect()
        newSP.x = Math.max(x, 0)
        newSP.y = Math.max(y, 0)
        newSP.x = Math.min(newSP.x, scrollSize.x - clientRect.width)
        newSP.y = Math.min(newSP.y, scrollSize.y - clientRect.height)
        newSP.x = Math.max(newSP.x, 0)
        newSP.y = Math.max(newSP.y, 0)
        newSP.x = Math.round(newSP.x)
        newSP.y = Math.round(newSP.y)

        return newSP
    }

    private mtd setScrollPosPrivate(x, y: f32)->Math.Point
    {
        newSP := getScrollPosPrivate(x, y)
        if newSP == view.scrollPos
            return newSP
        oldPos := view.scrollPos
        view.scrollPos = newSP
        sigScrollPosChanged.call(self, oldPos, newSP)
        computeLayout()
        return newSP
    }

    // Set the current scroll position
    mtd setScrollPos(pt: Math.Point)
    {
        setScrollPos(pt.x, pt.y)
    }

    mtd setScrollPos(x, y: f32)
    {
        newSP := setScrollPosPrivate(x, y)
        scrollRequestPos = newSP
        smoothScroll = false
    }

    // Set the scroll size (window virtual size)
    mtd setScrollSize(x, y: f32)
    {
        if scrollSize.x == x and scrollSize.y == y
            return

        oldScrollSize := scrollSize
        scrollSize = @{x, y}
        setScrollPos(view.scrollPos.x, view.scrollPos.y)
        sigScrollSizeChanged.call(self, oldScrollSize, scrollSize)
        sendResizeEvent()
    }

    mtd getClientScrollRect()->Math.Rectangle
    {
        var result: retval
        result.width  = Math.max(scrollSize.x, view.position.width)
        result.height = Math.max(scrollSize.y, view.position.height)
        return result
    }
}