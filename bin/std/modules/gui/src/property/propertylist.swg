#global public
using Core, Pixel

impl PropertyList
{
    attr Name(name: string)
    attr Description(desc: string)
}

struct PropertyList
{
    using frameWnd: FrameWnd

    nameMarginBefore:   s32 = 25
    nameHeight:         s32 = 25
    maxSizeCombo:       s32 = 200
    maxSizeEditValue:   s32 = 200

    fontBig:        FontFamily
    scrollWnd:      *ScrollWnd
    edView:         *PropertyListView
    items:          ArrayPtr'PropertyListItem
}

struct PropertyListItem
{
    filter:     String
    line:       *Wnd
    ptrData:    *u8
    typeValue:  Swag.TypeValue
    forceShow:  *Wnd

    label:      *Label
    editBox:    *EditBox
    checkBox:   *CheckButton
    comboBox:   *ComboBox
}

private impl PropertyList
{
    mtd addItem(f: Swag.TypeValue, ptrData: *u8, canDesc = true)->*PropertyListItem
    {
        line := StackLayoutCtrl.create(edView, .TopAutoSize)
        item := items.addNewPtr()
        item.line = line
        item.typeValue = f
        item.ptrData = ptrData

        // Name
        var dispName: String
        attrName := Reflection.getAttributeValue(f, PropertyList.Name, "name")
        if attrName != null
            dispName = cast(string) attrName
        else
            dispName = Format.toString("<b>%<b>", f.name)
        label := Label.create(line, dispName, @{0, 0, position.width, nameHeight})
        label.labelFlags |= .WordWrap | .AutoHeight
        label.horzAlignmentText = .Justify
        label.margin.y = nameMarginBefore
        item.label = label
        item.filter = dispName

        // Description
        dispDesc := Reflection.getAttributeValue(f, PropertyList.Description, "desc")
        if dispDesc != null
        {
            item.filter += " "
            item.filter += cast(string) dispDesc
            if canDesc
            {
                labelDesc := Label.create(line, "", @{0, 0, position.width, 0})
                labelDesc.labelFlags |= .WordWrap | .AutoHeight
                labelDesc.horzAlignmentText = .Justify
                labelDesc.setText(dispDesc)
                labelDesc.margin.w = 5
            }
        }

        return item
    }

    mtd refreshEnumFlags(using item: *PropertyListItem)
    {
        var val1, val2: u64
        switch typeValue.pointedType.sizeof
        {
        case 1:
            val1 = cast(u64) dref cast(*u8) ptrData
            val2 = cast(u64) dref cast(const *u8) typeValue.value
        case 2:
            val1 = cast(u64) dref cast(*u16) ptrData
            val2 = cast(u64) dref cast(const *u16) typeValue.value
        case 4:
            val1 = cast(u64) dref cast(*u32) ptrData
            val2 = cast(u64) dref cast(const *u32) typeValue.value
        case 8:
            val1 = cast(u64) dref cast(*u64) ptrData
            val2 = cast(u64) dref cast(const *u64) typeValue.value
        }

        checkBox.checked = val1 & val2 ? .Checked : .UnChecked
    }

    mtd refreshEnum(using item: *PropertyListItem)
    {
        typeEnum := cast(const *Swag.TypeInfoEnum) typeValue.pointedType

        var val1, val2: u64
        var val1s, val2s: string
        switch typeEnum.rawType.sizeof
        {
        case 1:  val1 = cast(u64) dref cast(*u8) ptrData
        case 2:  val1 = cast(u64) dref cast(*u16) ptrData
        case 4:  val1 = cast(u64) dref cast(*u32) ptrData
        case 8:  val1 = cast(u64) dref cast(*u64) ptrData
        case 16: val1s = dref cast(*string) ptrData
        }

        idxSel := 0'uint
        visit v, idx: typeEnum.values
        {
            switch typeEnum.rawType.sizeof
            {
            case 1:  val2 = cast(u64) dref cast(const *u8) v.value
            case 2:  val2 = cast(u64) dref cast(const *u16) v.value
            case 4:  val2 = cast(u64) dref cast(const *u32) v.value
            case 8:  val2 = cast(u64) dref cast(const *u64) v.value
            case 16: val2s = dref cast(const *string) v.value
            }

            if val1 == val2 and val1s == val2s
                idxSel = idx
        }

        comboBox.selectItem(acast idxSel)
    }

    mtd addEnum(f: Swag.TypeValue, typeEnum: const *Swag.TypeInfoEnum, ptrData: *u8)
    {
        item := addItem(f, ptrData)
        line := item.line

        if Reflection.hasAttribute(typeEnum, Swag.EnumFlags)
        {
            visit v: typeEnum.values
            {
                itemB := items.addNewPtr()
                itemB.typeValue = dref v
                itemB.ptrData = ptrData

                dispDesc := Reflection.getAttributeValue(v, PropertyList.Description, "desc")
                line1 := Wnd.create'Wnd(edView)

                ed := CheckButton.create(line1, "", @{0, 0, 30, 0})
                ed.dockStyle = .Left

                label1 := Label.create(line1, "", @{30, 0, position.width - 30})
                label1.dockStyle = .Center
                label1.labelFlags |= .WordWrap | .AutoHeight
                label1.horzAlignmentText = .Justify
                label1.setText(dispDesc)
                line1.position.height = Math.max(ed.position.height, label1.position.height)

                itemB.filter = dispDesc
                itemB.line = line1
                itemB.forceShow = item.line
                itemB.checkBox = ed

                refreshEnumFlags(itemB)
            }
        }
        else
        {
            ed := ComboBox.create(line, kind: .CheckBox)
            ed.maxSize.x = maxSizeCombo
            ed.anchorStyle = .X
            item.comboBox = ed

            visit v, idx: typeEnum.values
            {
                ed.addItem(v.name)
            }

            refreshEnum(item)
        }
    }

    mtd refreshNative(item: *PropertyListItem)
    {
        nativeType := cast(const *Swag.TypeInfoNative) item.typeValue.pointedType
        ptrData    := item.ptrData
        ed         := item.editBox

        switch nativeType.nativeKind
        {
        case U8:
            p := cast(^u8) ptrData
            ed.setText(Format.toString("%", dref p))
        case U16:
            p := cast(^u16) ptrData
            ed.setText(Format.toString("%", dref p))
        case U32:
            p := cast(^u32) ptrData
            ed.setText(Format.toString("%", dref p))
        case U64, UInt:
            p := cast(^u64) ptrData
            ed.setText(Format.toString("%", dref p))
        case S8:
            p := cast(^s8) ptrData
            ed.setText(Format.toString("%", dref p))
        case S16:
            p := cast(^s16) ptrData
            ed.setText(Format.toString("%", dref p))
        case S32:
            p := cast(^s32) ptrData
            ed.setText(Format.toString("%", dref p))
        case S64, Int:
            p := cast(^s64) ptrData
            ed.setText(Format.toString("%", dref p))
        case F32:
            p := cast(^f32) ptrData
            ed.setText(Format.toString("%", dref p))
        case F64:
            p := cast(^f64) ptrData
            ed.setText(Format.toString("%", dref p))
        }
    }

    mtd addBool(f: Swag.TypeValue, nativeType: const *Swag.TypeInfoNative, ptrData: *u8)
    {
        item := addItem(f, ptrData, false)

        dispDesc := Reflection.getAttributeValue(f, PropertyList.Description, "desc")
        line1 := Wnd.create'Wnd(item.line)

        ed := CheckButton.create(line1, "", @{0, 0, 30, 0})
        ed.dockStyle = .Left

        label1 := Label.create(line1, "", @{30, 0, position.width - 30})
        label1.dockStyle = .Center
        label1.labelFlags |= .WordWrap | .AutoHeight
        label1.horzAlignmentText = .Justify
        label1.setText(dispDesc)
        line1.position.height = Math.max(ed.position.height, label1.position.height)

        item.checkBox = ed
        if dref cast(*bool) ptrData
            ed.checked = .Checked
    }

    mtd addNative(f: Swag.TypeValue, nativeType: const *Swag.TypeInfoNative, ptrData: *u8)
    {
        item := addItem(f, ptrData)
        line := item.line
        ed := EditBox.create(line, f.name)
        ed.maxSize.x = maxSizeEditValue
        ed.anchorStyle = .X
        item.editBox = ed

        switch nativeType.nativeKind
        {
        case U8:
            ed.setInputU64(acast Swag.U8.Min, acast Swag.U8.Max)
        case U16:
            ed.setInputU64(acast Swag.U16.Min, acast Swag.U16.Max)
        case U32:
            ed.setInputU64(acast Swag.U32.Min, acast Swag.U32.Max)
        case U64, UInt:
            ed.setInputU64(acast Swag.U64.Min, acast Swag.U64.Max)
        case S8:
            ed.setInputS64(acast Swag.S8.Min, acast Swag.S8.Max)
        case S16:
            ed.setInputS64(acast Swag.S16.Min, acast Swag.S16.Max)
        case S32:
            ed.setInputS64(acast Swag.S32.Min, acast Swag.S32.Max)
        case S64, Int:
            ed.setInputS64(acast Swag.S64.Min, acast Swag.S64.Max)
        case F32, F64:
            ed.setInputF64()
        }

        refreshNative(item)
    }

    mtd refreshItem(using item: *PropertyListItem)
    {
        if Reflection.isEnum(typeValue.pointedType)
        {
            if Reflection.hasAttribute(typeValue, Swag.EnumFlags)
            {
                if checkBox
                {
                    refreshEnumFlags(item)
                    checkBox.invalidate()
                }
            }
            else
            {
                if comboBox
                {
                    refreshEnum(item)
                    comboBox.invalidate()
                }
            }
        }
        elif typeValue.pointedType == Core.String
        {
            if editBox
            {
                editBox.setText(dref cast(*String) ptrData)
            }
        }
        elif Reflection.isBool(typeValue.pointedType)
        {
            if checkBox
            {
                checkBox.checked = dref cast(*bool) ptrData ? .Checked : .UnChecked
                checkBox.invalidate()
            }
        }
        elif Reflection.isInteger(typeValue.pointedType) or Reflection.isFloat(typeValue.pointedType)
        {
            if editBox
            {
                refreshNative(item)
                editBox.invalidate()
            }
        }
    }

    mtd addStruct(addr: ^u8, typeStruct: const *Swag.TypeInfoStruct)
    {
        visit f: typeStruct.fields
        {
            ptrData := addr + f.offset

            if Reflection.isEnum(f.pointedType)
            {
                typeEnum := cast(const *Swag.TypeInfoEnum) f.pointedType
                addEnum(f, typeEnum, ptrData)
            }
            elif f.pointedType == Core.String
            {
                item := addItem(f, ptrData)
                ed := EditBox.create(item.line, dref cast(*String) ptrData)
                item.editBox = ed
            }
            elif Reflection.isBool(f.pointedType)
            {
                nativeType := cast(const *Swag.TypeInfoNative) f.pointedType
                addBool(f, nativeType, ptrData)
            }
            elif Reflection.isInteger(f.pointedType) or Reflection.isFloat(f.pointedType)
            {
                nativeType := cast(const *Swag.TypeInfoNative) f.pointedType
                addNative(f, nativeType, ptrData)
            }
            elif Reflection.isStruct(f.pointedType)
            {
                item := addItem(f, ptrData)
                item.label.setFont(&fontBig)
                typeSubStruct := cast(const *Swag.TypeInfoStruct) f.pointedType
                addStruct(ptrData, typeSubStruct)
            }
        }
    }
}

impl PropertyList
{
    #[Swag.Discardable]
    func create(parent: *Wnd, position: Math.Rectangle = @{}, id: WndId = null)->*PropertyList
    {
        ed := Wnd.create'PropertyList(parent, "", position, id)

        with ed
        {
            .scrollWnd = .createView'ScrollWnd()
            .scrollWnd.dockStyle = .Center
            .scrollWnd.focusStrategy = .None
            .scrollWnd.padding = 10
            .scrollWnd.scrollWndFlags |= .TransparentBar
            .edView = .scrollWnd.createView'PropertyListView()
            .edView.ed = ed
            .edView.wndFlags |= .NoScroll
            .edView.layoutKind = .Top
            .edView.spacing = 0

            const BigFontSize = 30'u32
            theme := parent.getTheme()
            .fontBig.regular = Font.create(theme.res.defaultTypeFaceR, BigFontSize)
            .fontBig.bold = Font.create(theme.res.defaultTypeFaceB, BigFontSize)
            .fontBig.italic = Font.create(theme.res.defaultTypeFaceI, BigFontSize)
            .fontBig.boldItalic = Font.create(theme.res.defaultTypeFaceBI, BigFontSize)
        }

        return ed
    }

    // Add a new struct to display
    mtd addItem(val: any)
    {
        dataof := @dataof(val)
        typeof := @kindof(val)
        Debug.assert(typeof.kind == .Struct)
        typeStruct := cast(const *Swag.TypeInfoStruct) typeof
        addStruct(dataof, typeStruct)

        edView.sendResizeEvent()
    }

    // Refresh displayed values
    mtd refresh()
    {
        visit it: items
        {
            refreshItem(it)
        }
    }

    // Show hiden content depending on the input filter
    mtd setStringFilter(filter: string)
    {
        visit it: items
        {
            if filter == null or @countof(filter) == 0
                it.line.show()
            elif Utf8.indexOf(it.filter.toSlice(), filter, comparisonType: Utf8.ComparisonType.Latin1NoCase) != Swag.UInt.Max
            {
                it.line.show()
                if it.forceShow
                    it.forceShow.show()
            }
            else
                it.line.hide()
        }

        applyLayout()
    }
}