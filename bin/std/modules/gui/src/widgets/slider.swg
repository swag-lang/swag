#global public
using Core, Pixel

#[Swag.EnumFlags]
enum SliderFlags
{
    None
    Range
    HilightBar
    Vertical
}

struct Slider
{
    using wnd: Wnd

    value1:         f32
    value2:         f32
    min:            f32
    max:            f32 = 1.0
    steps:          f32
    sliderFlags     = SliderFlags.HilightBar
    sigStartChange: SigArray'closure(*Self)
    sigChanged:     SigArray'closure(*Self)
    sigEndChange:   SigArray'closure(*Self)

    isMoving:       bool
    isPressed1:     bool
    isPressed2:     bool
    isHot1:         bool
    isHot2:         bool
    hasValue1:      bool
    hasValue2:      bool
    correcMoving:   f32
}

impl IWnd for Slider
{
    mtd onPaintEvent(evt: *PaintEvent)
    {
        bc     := evt.bc
        theme   := getTheme()
        metrics := getThemeMetrics()
        colors  := getThemeColors()
        rects   := getThemeRects()

        var colorBkLeft:   Color = ?
        var colorBkMiddle: Color = ?
        var colorBkRight:  Color = ?
        var colorMark1:    Color = ?
        var colorMark2:    Color = ?

        if bc.isDisabled
        {
            colorBkLeft   = colors.slider_DisabledBk
            colorBkMiddle = colors.slider_DisabledBk
            colorBkRight  = colors.slider_DisabledBk
            colorMark1    = colors.slider_DisabledMark
            colorMark2    = colors.slider_DisabledMark
        }
        else
        {
            colorBkRight  = colors.slider_BkRight
            if !(sliderFlags & .Range) and (sliderFlags & .HilightBar)
                colorBkLeft = colors.slider_HilightBk
            else
                colorBkLeft = colors.slider_BkLeft
            if (sliderFlags & .Range) and (sliderFlags & .HilightBar)
                colorBkMiddle = colors.slider_HilightBk
            else
                colorBkMiddle = colors.slider_BkMiddle

            if isPressed1
                colorMark1 = colors.slider_PressedMark
            elif isHot1
                colorMark1 = colors.slider_HotMark
            else
                colorMark1 = colors.slider_Mark

            if isPressed2
                colorMark2 = colors.slider_PressedMark
            elif isHot2
                colorMark2 = colors.slider_HotMark
            else
                colorMark2 = colors.slider_Mark

        }

        // Pos box
        posBox1 := getPosBox1()
        posBox2 := getPosBox2()

        clientRect := getClientRect()

        isVertical := sliderFlags & .Vertical
        if isVertical
        {
            clientRect.y += (posBox1.height * 0.5)
            clientRect.height -= posBox1.height
        }
        else
        {
            clientRect.x += (posBox1.width * 0.5)
            clientRect.width -= posBox1.width
        }

        // Bar left
        left := clientRect
        if isVertical
        {
            left.height = (clientRect.height * value1)
            theme.drawSubRect(bc.painter, left, &rects.slider_BkLeftVert, colorBkLeft)
        }
        else
        {
            left.width = (clientRect.width * value1)
            theme.drawSubRect(bc.painter, left, &rects.slider_BkLeft, colorBkLeft)
        }

        // Bar right
        valueRight := sliderFlags & .Range ? value2 : value1
        right := clientRect
        if isVertical
        {
            right.y += (clientRect.height * valueRight)
            right.height -= (clientRect.height * valueRight)
            theme.drawSubRect(bc.painter, right, &rects.slider_BkRightVert, colorBkRight)
        }
        else
        {
            right.x += (clientRect.width * valueRight)
            right.width -= (clientRect.width * valueRight)
            theme.drawSubRect(bc.painter, right, &rects.slider_BkRight, colorBkRight)
        }

        // Bar middle
        if sliderFlags & .Range
        {
            middle := clientRect
            if isVertical
            {
                middle.y = left.bottom()
                middle.setBottom(right.y)
                theme.drawSubRect(bc.painter, middle, &rects.slider_BkMiddleVert, colorBkMiddle)
            }
            else
            {
                middle.x = left.right()
                middle.setRight(right.x)
                theme.drawSubRect(bc.painter, middle, &rects.slider_BkMiddle, colorBkMiddle)
            }
        }

        // Display steps
        if steps > 0
        {
            for x := 0'f32; x < 1 + steps; x += steps
            {
                posStep := clientRect
                if isVertical
                {
                    posStep.y = clientRect.y + (clientRect.height * x) - clientRect.width * 0.5
                    posStep.height = posStep.width
                }
                else
                {
                    posStep.x = clientRect.x + (clientRect.width * x) - clientRect.height * 0.5
                    posStep.width = posStep.height
                 }

                var colorStep: Color = ?
                if isHot1 or isHot2 or isMoving
                    colorStep = colors.slider_HotStepBk
                elif x <= value1 and (sliderFlags & .HilightBar)
                    colorStep = colors.slider_HilightStepBk
                elif x >= value1 and x <= value2 and (sliderFlags & .HilightBar) and (sliderFlags & .Range)
                    colorStep = colors.slider_HilightStepBk
                else
                    colorStep = colors.slider_StepBk

                theme.drawSubRect(bc.painter, posStep, &rects.slider_Step, colorStep)
            }
        }

        // Box value1
        theme.drawSubRect(bc.painter, posBox1, &rects.slider_Mark, colorMark1)
        if sliderFlags & .Range
            theme.drawSubRect(bc.painter, posBox2, &rects.slider_Mark, colorMark2)
    }

    mtd onMouseEvent(evt: *MouseEvent)
    {
        pos := surfaceToLocal(evt.surfacePos)
        isVertical := sliderFlags & .Vertical

        switch evt.kind
        {
        case MouseLeave:
            isHot1, isHot2 = false
            invalidate()

        case MouseMove:
            if !isMoving
            {
                hitTest(evt.surfacePos)
                break
            }

            clientRect := getOffsetedClientRect()
            var f: f32
            if isVertical
            {
                diff := (pos.y - correcMoving) - clientRect.y
                f    = diff / clientRect.height
            }
            else
            {
                diff := (pos.x - correcMoving) - clientRect.x
                f    = diff / clientRect.width
            }
            if isPressed1
                setValue1(f)
            elif isPressed2
                setValue2(f)
            invalidate()

        case MousePressed:
            if evt.button == .Left
            {
                isMoving = true
                startChange()
                if isHot1
                {
                    isPressed1 = true
                    posBox := getPosBox1()
                    if isVertical
                        correcMoving = pos.y - posBox.vertCenter()
                    else
                        correcMoving = pos.x - posBox.horzCenter()
                }
                elif isHot2
                {
                    isPressed2 = true
                    posBox := getPosBox2()
                    if isVertical
                        correcMoving = pos.y - posBox.vertCenter()
                    else
                        correcMoving = pos.x - posBox.horzCenter()
                }
                elif !(sliderFlags & .Range)
                {
                    correcMoving = 0
                    isPressed1 = true
                    clientRect := getOffsetedClientRect()
                    if isVertical
                    {
                        diff := pos.y - clientRect.y
                        setValue1(diff / clientRect.height)
                    }
                    else
                    {
                        diff := pos.x - clientRect.x
                        setValue1(diff / clientRect.width)
                    }
                }
                else
                {
                    correcMoving = 0
                    clientRect := getOffsetedClientRect()
                    var f: f32
                    if isVertical
                    {
                        diff := pos.y - clientRect.y
                        f = diff / clientRect.height
                    }
                    else
                    {
                        diff := pos.x - clientRect.x
                        f = diff / clientRect.width
                    }

                    m := (value1 + value2) * 0.5
                    if f <= m
                    {
                        isPressed1 = true
                        setValue1(f)
                    }
                    else
                    {
                        isPressed2 = true
                        setValue2(f)
                    }
                }

                captureMouse()
                invalidate()
            }

        case MouseReleased:
            if isMoving and evt.button == .Left
            {
                releaseMouse()
                isPressed1, isPressed2, isMoving = false
                hitTest(evt.surfacePos)
                invalidate()
                endChange()
            }
        }
    }
}

private impl Slider
{
    mtd clamp(f: f32)->f32
    {
        if steps > 0
        {
            r := cast(s32) ((f / steps) + 0.5)
            return r * steps
        }

        return f
    }

    mtd setValue1(f: f32)
    {
        fc := clamp(Math.clamp(f, 0, 1))
        if sliderFlags & .Range
            fc = Math.min(fc, value2)
        if fc == value1 and hasValue1
            return
        hasValue1 = true
        value1 = fc
        sigChanged.call(self)
        invalidate()
    }

    mtd setValue2(f: f32)
    {
        fc := clamp(Math.clamp(f, 0, 1))
        if sliderFlags & .Range
            fc = Math.max(fc, value1)
        if fc == value2 and hasValue2
            return
        hasValue2 = true
        value2 = fc
        sigChanged.call(self)
        invalidate()
    }

    mtd hitTest(surfacePos: Math.Point)
    {
        pos := surfaceToLocal(surfacePos)
        if isHot1 or isHot2
        {
            invalidate()
            isHot1, isHot2 = false
        }

        if sliderFlags & .Range
        {
            rect := getPosBox2()
            if rect.contains(pos)
            {
                isHot2 = true
                invalidate()
                return
            }
        }

        rect := getPosBox1()
        if rect.contains(pos)
        {
            isHot1 = true
            invalidate()
        }
    }

    mtd getOffsetedClientRect()->Math.Rectangle
    {
        var result: retval = getClientRect()

        if sliderFlags & .Vertical
        {
            result.y += (result.width * 0.5)
            result.height -= result.width
        }
        else
        {
            result.x += (result.height * 0.5)
            result.width -= result.height
        }

        return result
    }

    mtd getPosBox1()->Math.Rectangle
    {
        var result: retval = getOffsetedClientRect()

        if sliderFlags & .Vertical
        {
            result.y += result.height * value1
            result.y -= (result.width * 0.5)
            result.x = result.horzCenter() - (result.width * 0.5)
            result.height = result.width
        }
        else
        {
            result.x += result.width * value1
            result.x -= (result.height * 0.5)
            result.y = result.vertCenter() - (result.height * 0.5)
            result.width = result.height
        }

        return result
    }

    mtd getPosBox2()->Math.Rectangle
    {
        var result: retval = getOffsetedClientRect()

        if sliderFlags & .Vertical
        {
            result.y += result.height * value2
            result.y -= (result.width * 0.5)
            result.x = result.horzCenter() - (result.width * 0.5)
            result.height = result.width
        }
        else
        {
            result.x += result.width * value2
            result.x -= (result.height * 0.5)
            result.y = result.vertCenter() - (result.height * 0.5)
            result.width = result.height
        }

        return result
    }

    mtd startChange()
    {
        sigStartChange.call(self)
    }

    mtd endChange()
    {
        sigEndChange.call(self)
    }
}

impl Slider
{
    mtdc getValue()->f32        => getValueLeft()
    mtdc getValueLeft()->f32    => min + (max - min) * value1
    mtdc getValueRight()->f32   => min + (max - min) * value2
    mtd  setValue(f: f32)       { setValueLeft(f); }

    mtd setValueLeft(f: f32)
    {
        startChange()
        setValue1((f - min) / (max - min))
        endChange()
    }

    mtd setValueRight(f: f32)
    {
        startChange()
        setValue2((f - min) / (max - min))
        endChange()
    }

    func setMinMax(self, min, max: f32, steps: f32 = 0)
    {
        Debug.assert(min < max)
        Debug.assert(steps < (max - min))
        self.min = min
        self.max = max
        self.steps = steps
    }

    // Set left and right values, for a range
    mtd setRangeValues(left, right: f32)
    {
        Debug.assert(left < right)
        Debug.assert(cast(bool) (sliderFlags & .Range))
        diff := max - min
        value1 = (left - min) / diff
        value2 = (right - min) / diff
        setValue1(value1)
        setValue2(value2)
    }

    #[Swag.Discardable]
    func create(parent: *Wnd, position: Math.Rectangle = @{}, id: WndId = null, range = false, vertical = false)->*Slider
    {
        Debug.assert(parent != null)
        pos := position

        if pos.height == 0
        {
            if vertical
                pos.height = parent.getThemeMetrics().slider_Width
            else
                pos.height = parent.getThemeMetrics().slider_Height
        }

        if pos.width == 0
        {
            if vertical
                pos.width = parent.getThemeMetrics().slider_Height
            else
                pos.width = parent.getThemeMetrics().slider_Width
        }

        res := Wnd.create'Slider(parent, null, pos, id)
        if range
            res.sliderFlags |= .Range
        if vertical
            res.sliderFlags |= .Vertical
        return res
    }
}