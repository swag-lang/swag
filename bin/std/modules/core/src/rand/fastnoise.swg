/*
    :LICENCE
    This code is based on FastNoise by Jordan Peck (https://github.com/Auburn/FastNoiseLite/tree/FastNoise-Legacy)
    See LICENCE.md for the corresponding licence.
*/

#global marked
#global namespace Noise
#global #[Swag.Safety("", false)]

// Types of noise that can be generated by FastNoise.
public enum FastNoiseKind
{
    Perlin                      // Basic Perlin noise.
    PerlinFractalFBM            // Fractal Brownian Motion using Perlin noise.
    PerlinFractalBillow         // Billow-style fractal using Perlin noise.
    PerlinFractalRigidMulti     // Rigid multi-fractal using Perlin noise.
    Value                       // Basic value noise.
    ValueFractalFBM             // Fractal Brownian Motion using value noise.
    ValueFractalBillow          // Billow-style fractal using value noise.
    ValueFractalRigidMulti      // Rigid multi-fractal using value noise.
}

// FastNoise structure for generating different types of noise based on user-defined parameters.
public struct FastNoise
{
    kind                = FastNoiseKind.Perlin     // Type of noise to generate.
    seed                = 1337                     // Seed value for noise generation.
    octaves             = 3                        // The number of layers of noise. More self.octaves create a more varied look but are also more resource-intensive to calculate.
    frequency           = 0.01                     // The period in which we sample the noise. A higher self.frequency results in more frequent noise change.
    lacunarity          = 2.0                      // The rate of change of the self.frequency for each successive octave. A 'lacunarity' value of 1 results in each octave having the same self.frequency.
    gain                = 0.5                      // The scaling factor applied to each octave. 'gain' is only used when 'octaves' is set to a value higher than 1.
    fractalBounding     = 1.0                      // Normalization factor used to keep the noise within bounds for fractal types.
}

impl FastNoise
{
    // Calculates the fractal bounding factor to normalize amplitude across self.octaves.
    mtd calculateFractalBounding()
    {
        if self.octaves == 1
        {
            self.fractalBounding = 1.0
            return
        }

        var amp        = self.gain
        var ampFractal = 1.0

        for i in self.octaves - 1
        {
            ampFractal += amp
            amp *= self.gain
        }

        self.fractalBounding = 1.0 / ampFractal
    }

    // Update internal values.
    // Should be called each time an internal parameter has been changed.
    public mtd update()
    {
        self.calculateFractalBounding()
    }

    // Computes fractal Brownian Motion using Perlin noise.
    public mtd const perlinFractalFBM(x, y: f32)->f32
    {
        var xi  = x
        var yi  = y
        var sum = perlin(xi, yi, self.seed)
        var amp = 1.0

        for i in self.octaves
        {
            xi, yi *= self.lacunarity
            amp *= self.gain
            sum += perlin(xi, yi, self.seed) * amp
        }

        return sum * self.fractalBounding
    }

    // Computes billow-style fractal using Perlin noise.
    public mtd const perlinFractalBillow(x, y: f32)->f32
    {
        var xi  = x
        var yi  = y
        var sum = Math.abs(perlin(xi, yi, self.seed)) * 2 - 1
        var amp = 1.0

        for i in self.octaves
        {
            xi, yi *= self.lacunarity
            amp *= self.gain
            sum += (Math.abs(perlin(xi, yi, self.seed)) * 2 - 1) * amp
        }

        return sum * self.fractalBounding
    }

    // Computes rigid multi-fractal using Perlin noise.
    public mtd const perlinFractalRigidMulti(x, y: f32)->f32
    {
        var xi  = x
        var yi  = y
        var sum = 1 - Math.abs(perlin(xi, yi, self.seed))
        var amp = 1.0

        for i in self.octaves
        {
            xi, yi *= self.lacunarity
            amp *= self.gain
            sum += (1 - Math.abs(perlin(xi, yi, self.seed))) * amp
        }

        return sum * self.fractalBounding
    }

    // Computes fractal Brownian Motion using value noise.
    public mtd const valueFractalFBM(x, y: f32)->f32
    {
        var xi  = x
        var yi  = y
        var sum = Noise.value(xi, yi, self.seed)
        var amp = 1.0

        for i in self.octaves
        {
            xi, yi *= self.lacunarity
            amp *= self.gain
            sum += Noise.value(xi, yi, self.seed) * amp
        }

        return sum * self.fractalBounding
    }

    // Computes billow-style fractal using value noise.
    public mtd const valueFractalBillow(x, y: f32)->f32
    {
        var xi  = x
        var yi  = y
        var sum = Math.abs(Noise.value(xi, yi, self.seed)) * 2 - 1
        var amp = 1.0

        for i in self.octaves
        {
            xi, yi *= self.lacunarity
            amp *= self.gain
            sum += (Math.abs(Noise.value(xi, yi, self.seed)) * 2 - 1) * amp
        }

        return sum * self.fractalBounding
    }

    // Computes rigid multi-fractal using value noise.
    public mtd const valueFractalRigidMulti(x, y: f32)->f32
    {
        var xi  = x
        var yi  = y
        var sum = 1 - Math.abs(Noise.value(xi, yi, self.seed))
        var amp = 1.0

        for i in self.octaves
        {
            xi, yi *= self.lacunarity
            amp *= self.gain
            sum += (1 - Math.abs(Noise.value(xi, yi, self.seed))) * amp
        }

        return sum * self.fractalBounding
    }

    // Get a noise result.
    public mtd const noise(x, y: f32)->f32
    {
        var result: f32 = undefined

        let xi = x * self.frequency
        let yi = y * self.frequency

        #[Swag.Complete]
        switch self.kind
        {
        case Perlin:
            result = Noise.perlin(xi, yi, self.seed)
        case PerlinFractalFBM:
            result = self.perlinFractalFBM(xi, yi)
        case PerlinFractalBillow:
            result = self.perlinFractalBillow(xi, yi)
        case PerlinFractalRigidMulti:
            result = self.perlinFractalRigidMulti(xi, yi)
        case Value:
            result = Noise.value(xi, yi, self.seed)
        case ValueFractalFBM:
            result = self.valueFractalFBM(xi, yi)
        case ValueFractalBillow:
            result = self.valueFractalBillow(xi, yi)
        case ValueFractalRigidMulti:
            result = self.valueFractalRigidMulti(xi, yi)
        }

        return Math.clamp(result, -1.0, 1.0)
    }
}
