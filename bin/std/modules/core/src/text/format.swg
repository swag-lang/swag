#global public
#global namespace Format
using Swag

// Check if this is a valid 'fmt' 'values' pair, coherent with 'format' specification
func checkFormat(fct: string, fmt: string, values: ...)
{
    cptPercent := countPercent(fmt)
    if cptPercent != @countof(values)
    {
        #[SelectIf(false)]
        str := toString("bad number of arguments to '%' ('%' requested, '%' provided)", fct, cptPercent, @countof(values))
        @errormsg(str, #location(values))
    }
}

// Count the number of valid '%' placeholders in the string format
// Note that %% will not be counted, as this represents the '%' character
#[Swag.ConstExpr]
func countPercent(fmt: string)->u32
{
    cptPercent := 0'u32
    for i := 0; i < @countof(fmt); i += 1
    {
        if fmt[i] != "%"'u8
            continue

        if i == @countof(fmt) - 1 or fmt[i + 1] != "%"'u8
            cptPercent += 1
        else
            i += 1
    }

    return cptPercent
}

// Format a string in 'dest'
// Can be lot faster than the convenient version which returns a string
func replaceString(dest: *String, fmt: string, values: ...)
    #checkif
    {
        if !@isconstexpr(fmt) return true
        checkFormat(@nameof(#self), fmt, values)
        return true
    }
{
    var buf: ConcatBuffer

    buf.setFirstBucket(@mkslice(dest.buffer, dest.capacity))

    #[SelectIf(false)]
    append(&buf, fmt, values)

    buf.makeLinear()
    (data, count, capacity) := buf.eatBuffer()

    dest.buffer   = data
    dest.length   = count
    dest.capacity = capacity
}

// Format a string and returns the result as a String
func toString(fmt: string, values: ...)->String
    #checkif
    {
        if !@isconstexpr(fmt) return true
        checkFormat(@nameof(#self), fmt, values)
        return true
    }
{
    var buf: ConcatBuffer

    #[SelectIf(false)]
    append(&buf, fmt, values)

    return buf.toString()
}

// Format a string and put the result in a ConcatBuffer
func append(buf: *ConcatBuffer, fmt: string, values: ...)
    #checkif
    {
        if !@isconstexpr(fmt) or !@isconstexpr(values) return true
        checkFormat(@nameof(#self), fmt, values)
        return true
    }
{
    ptr := @dataof(fmt)
    cpt := @countof(fmt)

    idx := 0'u32
    nextIdx := 0'u32
    paramIdx := 0'u32
    numParams := @countof(values)

    while nextIdx < cpt
    {
        if ptr[nextIdx] == "%"'u8
        {
            // Add remaining text, and starts again after the mark
            buf.addBytes(cast(const [..] u8) @mkslice(ptr + idx, cast(uint) (nextIdx - idx)))
            idx = nextIdx + 1
            nextIdx = idx

            // Deal with the parameter. %% is for one % only
            if ptr[nextIdx] == "%"'u8
            {
                buf.addNative("%"'u8)
                nextIdx += 1
                idx += 1
                continue
            }

            // Optional string format, like '%{whatever}'
            var strFormat: const [..] u8
            if ptr[nextIdx] == "{"'u8
            {
                nextIdx += 1
                ptrFormat := ptr + nextIdx
                countFormat := 0'u32
                while ptr[nextIdx] and ptr[nextIdx] != "}"'u8
                {
                    countFormat += 1
                    nextIdx += 1
                }

                if ptr[nextIdx]
                    nextIdx += 1
                idx = nextIdx
                strFormat = @mkslice(ptrFormat, cast(uint) countFormat)
            }

            // Deal with the parameter
            Debug.assert(paramIdx < numParams, "not enough 'format' parameters")
            StrConv.convertAny(buf, values[paramIdx], cast(string) strFormat)
            paramIdx += 1
        }
        else
        {
            nextIdx += 1
        }
    }

    // Add remaining text
    if idx < nextIdx
        buf.addBytes(cast(const [..] u8) @mkslice(ptr + idx, cast(uint) nextIdx - idx))
}

// String interolation
// Format is "my {value} to print" or "my {value}{printFormat} to print"
#[Swag.Macro]
func toInterp(#[Swag.ConstExpr] exp: string)->String
{
    var buf: ConcatBuffer

    #ast
    {
        var sb: StrConv.StringBuilder

        idx := 0'uint
        while idx != @countof(exp)
        {
            idxE := Utf8.indexOf(exp, "{", startByteIndex: idx)
            if idxE == Swag.UInt.Max
            {
                sb.appendFormat("buf.addBytes(\"%\")\n", exp[idx..@countof(exp)-1])
                break
            }

            if idx != idxE
                sb.appendFormat("buf.addBytes(\"%\")\n", exp[idx..idxE-1])

            idx = idxE + 1
            idxE = Utf8.indexOf(exp, "}", startByteIndex: idx)
            if idxE == Swag.UInt.Max
            {
                sb.appendFormat("buf.addBytes(\"%\")\n", exp[idx-1..@countof(exp)-1])
                break
            }

            sb.appendFormat("StrConv.convertAny(&buf, `%, null)\n", exp[idx..idxE-1])
            idx = idxE + 1
        }

        return sb.toString()
    }

    return buf.toString()
}