#global public
#global namespace Format
using Swag

// Check if this is a valid 'fmt' 'values' pair, coherent with 'format' specification
func checkFormat(fct: string, fmt: string, values: ...)
{
    cptPercent := countPercent(fmt)
    if cptPercent != @countof(values)
    {
        #[SelectIf(false)]
        str := toString("bad number of arguments to '%' ('%' requested, '%' provided)", fct, cptPercent, @countof(values))
        @compilererror(str, @location(values))
    }
}

// Count the number of valid '%' placeholders in the string format
// Note that %% will not be counted, as this represents the '%' character
#[ConstExpr]
func countPercent(fmt: string)->u32
{
    cptPercent := 0'u32
    for i := 0; i < @countof(fmt); i += 1
    {
        if fmt[i] != "%"'u8
            continue

        if i == @countof(fmt) - 1 or fmt[i + 1] != "%"'u8
            cptPercent += 1
        else
            i += 1
    }

    return cptPercent
}

// Format a string in 'dest'
// Can be lot faster than the convenient version which returns a string
func replaceString(dest: *String, fmt: string, values: ...)
    #selectif
    {
        if !@isconstexpr(fmt) return true
        checkFormat(@nameof(#self), fmt, values)
        return true
    }
{
    var buf: ConcatBuffer

    buf.setFirstBucket(@mkslice(dest.buffer, dest.capacity))

    #[SelectIf(false)]
    append(&buf, fmt, values)

    buf.makeLinear()
    (data, count, capacity) := buf.eatBuffer()

    dest.buffer   = data
    dest.length   = count
    dest.capacity = capacity
}

// Format a string and returns the result as a String
func toString(fmt: string, values: ...)->String
    #selectif
    {
        if !@isconstexpr(fmt) return true
        checkFormat(@nameof(#self), fmt, values)
        return true
    }
{
    var buf: ConcatBuffer

    #[SelectIf(false)]
    append(&buf, fmt, values)

    return buf.toString()
}

// Format a string and put the result in a ConcatBuffer
func append(buf: *ConcatBuffer, fmt: string, values: ...)
    #selectif
    {
        if !@isconstexpr(fmt) or !@isconstexpr(values) return true
        checkFormat(@nameof(#self), fmt, values)
        return true
    }
{
    ptr := @dataof(fmt)
    cpt := @countof(fmt)

    idx := 0'u32
    nextIdx := 0'u32
    paramIdx := 0'u32
    numParams := @countof(values)

    while nextIdx < cpt
    {
        if ptr[nextIdx] == "%"'u8
        {
            // Add remaining text, and starts again after the mark
            buf.addBytes(cast(const [..] u8) @mkslice(ptr + idx, cast(uint) (nextIdx - idx)))
            idx = nextIdx + 1
            nextIdx = idx

            // Deal with the parameter. %% is for one % only
            if ptr[nextIdx] == "%"'u8
            {
                buf.addNative("%"'u8)
                nextIdx += 1
                idx += 1
                continue
            }

            // Optional string format, like '%{whatever}'
            var strFormat: const [..] u8
            if ptr[nextIdx] == "{"'u8
            {
                nextIdx += 1
                ptrFormat := ptr + nextIdx
                countFormat := 0'u32
                while ptr[nextIdx] and ptr[nextIdx] != "}"'u8
                {
                    countFormat += 1
                    nextIdx += 1
                }

                if ptr[nextIdx]
                    nextIdx += 1
                idx = nextIdx
                strFormat = @mkslice(ptrFormat, cast(uint) countFormat)
            }

            // Deal with the parameter
            Debug.assert(paramIdx < numParams, "not enough 'format' parameters")
            StrConv.convertAny(buf, values[paramIdx], cast(string) strFormat)
            paramIdx += 1
        }
        else
        {
            nextIdx += 1
        }
    }

    // Add remaining text
    if idx < nextIdx
        buf.addBytes(cast(const [..] u8) @mkslice(ptr + idx, cast(uint) nextIdx - idx))
}

// String interolation
// Format is "my {<value to interpolate>:format}
#[Macro]
func toInterp(buf: *ConcatBuffer, exp: string)
    #selectif
    {
        if !@isconstexpr(exp)
            @compilererror("expression should be constant", @location(exp))
        return true
    }
{
    #ast
    {
        var sb: StrConv.StringBuilder

        idx := 0'uint
        while idx != @countof(exp)
        {
            // To the interpolated string if it exists
            idxE := Utf8.indexOf(exp, "{"'rune, startByteIndex: idx)
            if idxE == Swag.UInt.Max
            {
                sb.appendFormat("buf.addBytes(\"%\")\n", exp[idx..])
                break
            }

            if idx != idxE
                sb.appendFormat("buf.addBytes(\"%\")\n", exp[idx..<idxE])

            // Find the end of the interpolated string, or the start of the format
            idx = idxE + 1
            idxE = Utf8.indexOf(exp, ["}"'rune, ":"'rune], startByteIndex: idx)
            if idxE == Swag.UInt.Max
            {
                sb.appendFormat("buf.addBytes(\"%\")\n", exp[idx-1..])
                break
            }

            value := exp[idx..<idxE]
            idx = idxE + 1

            // Format
            var format: string
            if exp[idxE] == ":"'u8
            {
                idxE = Utf8.indexOf(exp, "}", startByteIndex: idx)
                if idxE != Swag.UInt.Max
                {
                    format = exp[idx..<idxE]
                    idx = idxE + 1
                }
            }

            sb.appendFormat("StrConv.convert(buf, `%, \"%\")\n", value, format)
        }

        return sb.moveToString()
    }
}

// String interolation
// Format is "my {<value to interpolate>:format}
#[Mixin]
func toInterp(exp: string)->String
    #selectif
    {
        if !@isconstexpr(exp)
            @compilererror("expression should be constant", @location(exp))
        return true
    }
{
    var @mixin0: ConcatBuffer
    toInterp(&@mixin0, exp)
    return @mixin0.moveToString()
}