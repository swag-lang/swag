#global public
#global namespace Parse
using Globalization, Swag

// Convert an utf8 buffer in hexadecimal to an unsigned integer value
// Returns the value and the number of bytes used to make the conversion
func getX64(str: string) -> {value: u64, eat: u32} throw
{
    var result: retval

    countof := @countof(str)
    if !countof throw "invalid"

    buffer := @dataof(str)
    cpt := 0'u32
    value := 0'u64

    if !Latin1.isHexDigit(dref buffer) throw "invalid"
    while cpt < countof and Latin1.isHexDigit(dref buffer)
    {
        if value & 0xF0000000_00000000 throw "overflow"
        value <<= 4
        c := dref buffer
        if Latin1.isDigit(c)
            value += cast(u64) (c - "0"'u8)
        else if c <= "F"'u8
            value += cast(u64) 10 + (c - "A"'u8)
        else
            value += cast(u64) 10 + (c - "a"'u8)
        buffer, cpt += 1
    }

    result.value = value
    result.eat = cpt
    return result
}

// Convert an utf8 buffer in binary to an unsigned integer value
// Returns the value and the number of bytes used to make the conversion
func getB64(str: string) -> {value: u64, eat: u32} throw
{
    var result: retval

    countof := @countof(str)
    if !countof throw "invalid"

    buffer := @dataof(str)
    cpt := 0'u32
    value := 0'u64

    if !Latin1.isBinDigit(dref buffer) throw "invalid"
    while cpt < countof and Latin1.isBinDigit(dref buffer)
    {
        if value & 0x80000000_00000000 throw "overflow"
        value <<= 1
        value += cast(u64) (dref buffer - "0"'u8)
        buffer, cpt += 1
    }

    result.value = value
    result.eat = cpt
    return result
}

// Convert an utf8 buffer in decimal to an unsigned integer value
// Returns the value and the number of bytes used to make the conversion
func getU8(str: string) -> {value: u8, eat: u32} throw
{
    (res, eat) := try getU64(str)
    if res > Swag.U8.Max throw "out of range"
    return @{cast(u8) res, eat}
}

func getU16(str: string) -> {value: u16, eat: u32} throw
{
    (res, eat) := try getU64(str)
    if res > Swag.U16.Max throw "out of range"
    return @{cast(u16) res, eat}
}

func getU32(str: string) -> {value: u32, eat: u32} throw
{
    (res, eat) := try getU64(str)
    if res > Swag.U32.Max throw "out of range"
    return @{cast(u32) res, eat}
}

func getU64(str: string) -> {value: u64, eat: u32} throw
{
    var result: retval

    countof := @countof(str)
    if !countof throw "invalid"

    // Detect 0x for hexa, 0b for binary
    if countof > 2 and str[0] == "0"'u8
    {
        c := str[1]|32
        if c == "x"'u8
        {
            one := Tokenize.eatCount(str, 2)
            (result.value, result.eat) = try getX64(one)
            result.eat += 2
            return result
        }

        if c == "b"'u8
        {
            one := Tokenize.eatCount(str, 2)
            (result.value, result.eat) = try getB64(one)
            result.eat += 2
            return result
        }
    }

    buffer := @dataof(str)
    cpt := 0'u32
    value := 0'u64

    if !Latin1.isDigit(dref buffer) throw "invalid"
    while cpt < countof and Latin1.isDigit(dref buffer)
    {
        value *= 10
        add := cast(u64) (dref buffer - "0"'u8)
        if value +,safe add < value throw "overflow"
        value += add
        buffer, cpt += 1
    }

    result.value = value
    result.eat = cpt
    return result
}

// Convert an utf8 buffer to an signed integer value
// Returns the value and the number of bytes used to make the conversion
func getS8(str: string) -> {value: s8, eat: u32} throw
{
    (res, eat) := try getS64(str)
    if res < Swag.S8.Min or res > Swag.S8.Max throw "out of range"
    return @{cast(s8) res, eat}
}

func getS16(str: string) -> {value: s16, eat: u32} throw
{
    (res, eat) := try getS64(str)
    if res < Swag.S16.Min or res > Swag.S16.Max throw "out of range"
    return @{cast(s16) res, eat}
}

func getS32(str: string) -> {value: s32, eat: u32} throw
{
    (res, eat) := try getS64(str)
    if res < Swag.S32.Min or res > Swag.S32.Max throw "out of range"
    return @{cast(s32) res, eat}
}

func getS64(str: string) -> {value: s64, eat: u32} throw
{
    var result: retval

    countof := @countof(str)
    if !countof throw "invalid"

    buffer := @dataof(str)
    value := 0'u64
    cpt := 0'u32

    // Does the number starts with the negative/positive sign ?
    signed := false
    c := dref str
    maxValue := cast(u64) Swag.S64.Max
    if c == g_CultureInfo.numberFormat.negativeSign
    {
        buffer, cpt += 1
        signed = true
        maxValue += 1
    }
    else if c == g_CultureInfo.numberFormat.positiveSign
    {
        buffer, cpt += 1
    }

    // Parse the rest
    if !Latin1.isDigit(dref buffer) throw "invalid"
    while cpt < countof and Latin1.isDigit(dref buffer)
    {
        value *= 10
        value += cast(u64) (dref buffer - "0"'u8)
        if value > maxValue throw "overflow"
        buffer, cpt += 1
    }

    if signed
    {
        if value == maxValue
            result.value = Swag.S64.Min
        else
            result.value = -cast(s64) value
    }
    else
        result.value = cast(s64) value

    result.eat = cpt
    return result
}

// Convert an utf8 buffer to a floating point value
// Returns the value and the number of bytes used to make the conversion
func getF32(str: string) -> {value: f32, eat: u32} throw
{
    (res, eat) := try getF64(str)
    if res < Swag.F32.Min or res > Swag.F64.Max throw "out of range"
    return @{cast(f32) res, eat}
}

func getF64(str: string) -> {value: f64, eat: u32} throw
{
    return try StrConv.atod(str)
}

// Convert an utf8 buffer to a boolean
// Returns the value and the number of bytes used to make the conversion
func getBool(str: string) -> {value: bool, eat: u32} throw
{
    var result: retval

    countof := @countof(str)
    sub := try Tokenize.getToSpace(str)
    switch sub
    {
    case "1", "true", "TRUE", "True":       result.value = true
    case "0", "false", "FALSE", "False":    result.value = false
    default:                                throw "invalid"
    }

    result.eat = cast(u32) @countof(sub)
    return result
}

// Convert an utf8 buffer to a simple rune
func getRune(str: string) -> {value: rune, eat: u32} throw
{
    countof := @countof(str)
    if !countof throw "invalid"
    return Utf8.decodeRune(str)
}

// Parse an identifier name in the sens of swag (ascii)
func getIdentifier(str: string)->string throw
{
    countof := @countof(str)
    if !countof throw "invalid"

    if str[0] != "_"'u8 and !Latin1.isLetter(str[0]) throw "invalid"

    cpt := 1'uint
    while cpt < countof and (str[cpt] == "_"'u8 or Latin1.isLetterOrDigit(str[cpt]))
        cpt += 1
    return @mkstring(@dataof(str), cpt)
}

// Convert an utf8 buffer to a string
// String in the buffer can be quoted (but the result will not be in that case)
func getString(str: string) -> {value: String, eat: u32} throw
{
    var result: retval

    countof := @countof(str)
    if !countof
        throw "invalid"

    isQuoted := false
    cpt := 0
    if str[0] == "\""'u8
    {
        isQuoted = true
        cpt += 1
    }

    while cpt < countof
    {
        // End dilimiter
        if str[cpt] == "\""'u8 and isQuoted
            break

        // Escape character
        if str[cpt] == "\\"'u8
        {
            cpt += 1
            if cpt == countof
                throw "invalid"
            switch str[cpt]
            {
            case "t"'u8:    result.value += "\t"'u8
            case "n"'u8:    result.value += "\n"'u8
            default:        result.value += str[cpt]
            }
        }
        else
            result.value += str[cpt]

        cpt += 1
    }

    if cpt == countof and isQuoted
        throw "missing end delimiter"
    if isQuoted
        cpt += 1
    result.eat = cpt
    return result
}
