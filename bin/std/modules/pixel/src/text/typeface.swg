using Core, FreeType

var g_FT: FT_Library
#init
{
    catch FT_Init_FreeType(&g_FT)
}

public struct TypeFace
{
    fullname:       string
    buffer:         Array'u8
    face:           FT_Face
    forceItalic:    bool
    forceBold:      bool
}

impl TypeFace
{
    var hashTypeFace: HashTable'(String, *TypeFace)
    var lock:         Sync.Mutex

    func moveTo(to: const *FT_Vector, pathList: *LinePathList)->s32
    {
        path := pathList.newPath()
        path.start(to.x / 64.0, -to.y / 64.0)
        return 0
    }

    func lineTo(to: const *FT_Vector, pathList: *LinePathList)->s32
    {
        path := pathList.paths[pathList.paths.count - 1]
        path.lineTo(to.x / 64.0, -to.y / 64.0)
        return 0
    }

    func conicTo(ctrl, to: const *FT_Vector, pathList: *LinePathList)->s32
    {
        path := pathList.paths[pathList.paths.count - 1]
        path.bezierTo(to.x / 64.0, -to.y / 64.0, ctrl.x / 64.0, -ctrl.y / 64.0)
        return 0
    }

    func bezierTo(ctrl1, ctrl2, to: const *FT_Vector, pathList: *LinePathList)->s32
    {
        path := pathList.paths[pathList.paths.count - 1]
        path.bezierTo(to.x / 64.0, -to.y / 64.0, ctrl1.x / 64.0, -ctrl1.y / 64.0, ctrl2.x / 64.0, -ctrl2.y / 64.0)
        return 0
    }
}

public impl TypeFace
{
    // Returns true if the typeface is bold
    mtdc isBold()->bool
    {
        return cast(bool) (face.style_flags & FT_STYLE_FLAG_BOLD)
    }

    // Returns true if the typeface is italic
    mtdc isItalic()->bool
    {
        return cast(bool) (face.style_flags & FT_STYLE_FLAG_ITALIC)
    }

    // Returns the underlying font family name
    mtdc getFamilyName()->string
    {
        defname := @mkstring(face.family_name, @strlen(face.family_name))
        return defname
    }

    // Create a new typeface
    func create(fullname: string, bytes: const [..] u8)->*TypeFace throw
    {
        tf := Memory.new'TypeFace()
        tf.fullname = fullname
        tf.buffer = bytes
        FT_New_Memory_Face(g_FT, tf.buffer.buffer, cast(FT_Long) tf.buffer.count, 0, &tf.face)
        return tf
    }

    // Get or load a new typeface
    func load(fullname: string)->*TypeFace throw
    {
        Sync.scopedLock(&lock)

        str := String.from(fullname)
        here := hashTypeFace.find(str)
        if here
            return here.value

        tf := Memory.new'TypeFace()
        tf.fullname = fullname

        // If file does not exist, try the system folder
        if !File.exists(fullname)
        {
            p := Env.getSpecialDirectory(.Font)
            p += "/"
            p += fullname
            tf.buffer = File.readAllBytes(p)
        }
        else
        {
            tf.buffer = File.readAllBytes(fullname)
        }

        FT_New_Memory_Face(g_FT, tf.buffer.buffer, cast(FT_Long) tf.buffer.count, 0, &tf.face)

        hashTypeFace.add(str, tf)
        return tf
    }

    private mtd transform(embolden: u32 = 0) throw
    {
        emb := forceBold ? 4 : 0
        emb += embolden
        if emb
            FT_Outline_Embolden(&face.glyph.outline, cast(FT_Pos) emb * 64)
        if forceItalic
            FT_GlyphSlot_Oblique(face.glyph)
    }

    // Render one glyph
    mtd renderGlyph(c: rune, size: u32)->const *FT_Bitmap throw
    {
        FT_Set_Pixel_Sizes(face, 0, size)
        FT_Load_Char(face, cast(FT_ULong) c, FT_LOAD_DEFAULT)
        transform()
        FT_Render_Glyph(face.glyph, .FT_RENDER_MODE_NORMAL)
        return &face.glyph.bitmap
    }

    // Convert a rune to its outline, at a given size
    #[Swag.Discardable]
    mtd getRuneOutline(pathList: *LinePathList, c: rune, size: u32, embolden: u32 = 0)->f32 throw
    {
        var itf: FT_Outline_Funcs

        pathList.clear()
        itf.move_to  = cast(*void) @mkcallback(&moveTo)
        itf.line_to  = cast(*void) @mkcallback(&lineTo)
        itf.conic_to = cast(*void) @mkcallback(&conicTo)
        itf.cubic_to = cast(*void) @mkcallback(&bezierTo)

        FT_Set_Pixel_Sizes(face, 0, size)
        FT_Load_Char(face, cast(FT_ULong) c, FT_LOAD_NO_BITMAP)
        transform(embolden)

        prevIdx := pathList.paths.count
        FT_Outline_Decompose(&face.glyph.outline, &itf, pathList)

        if prevIdx != pathList.paths.count
        {
            loop i: prevIdx..pathList.paths.count-1
                pathList.paths[i].isClosed = true
        }

        return embolden + (face.glyph.advance.x / 64.0)
    }

    // Convert a string to its outline, at a given size
    mtd getStringOutline(pathList: *LinePathList, text: string, size: u32, embolden: u32 = 0) throw
    {
        var itf: FT_Outline_Funcs

        pathList.clear()
        itf.move_to  = cast(*void) @mkcallback(&moveTo)
        itf.line_to  = cast(*void) @mkcallback(&lineTo)
        itf.conic_to = cast(*void) @mkcallback(&conicTo)
        itf.cubic_to = cast(*void) @mkcallback(&bezierTo)

        try FT_Set_Pixel_Sizes(face, 0, size)

        serial := 0
        x := 0

        Utf8.visitRunes(|c| text)
        {
            FT_Load_Char(face, cast(FT_ULong) c, FT_LOAD_NO_BITMAP)
            transform(embolden)

            FT_Outline_Translate(face.glyph.outline, x, 0)

            prevIdx := pathList.paths.count
            FT_Outline_Decompose(&face.glyph.outline, &itf, pathList)

            if prevIdx != pathList.paths.count
            {
                loop i: prevIdx..pathList.paths.count-1
                {
                    pathList.paths[i].isClosed = true
                    pathList.paths[i].serial = serial
                }

                serial += 1
            }

            x += face.glyph.advance.x
        }
    }
}