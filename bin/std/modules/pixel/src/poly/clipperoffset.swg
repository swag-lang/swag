/*
    :LICENCE
    This code is based on the Clipper library (http://www.angusj.com)
    The original code has been modified for Swag
    See LICENCE.md for the corresponding licence.
*/

#global namespace Clipper
using Core

const DefaultArcTolerance = 0.25'f64 // Default tolerance for arc approximation in polygon offsetting

// Used internally for high precision geometric calculations during offsetting operations.
struct DoublePoint { x, y: f64 }

// Polygon offset processor for creating parallel curves and outlines.
// Handles the creation of offset polygons with different join types and miter limits.
struct Offset
{
    miterLimit:       f64 = 2                       // Maximum ratio of miter length to offset distance before square join is used
    arcTolerance:     f64 = DefaultArcTolerance     // Maximum allowed distance between true arc and approximating line segments
    destPolys:        ClipperPaths                  // Output collection of offset polygons
    srcPoly:          ClipperPath                   // Current source polygon being processed
    destPoly:         ClipperPath                   // Current destination polygon being built
    normals:          Array'DoublePoint             // Unit normal vectors for each edge of the source polygon
    deltaVal:         f64                           // Current offset distance (positive for outward, negative for inward)
    sinaVal:          f64                           // Sine of angle between adjacent edge normals
    sinVal:           f64                           // Sine value for arc step calculations
    cosVal:           f64                           // Cosine value for arc step calculations
    miterLim:         f64                           // Computed miter limit threshold for join type switching
    stepsPerRad:      f64                           // Number of steps per radian for arc approximation
    lowest:           IntPoint = {-1, 0}            // Index of polygon and vertex with lowest Y coordinate (leftmost if tied)
    polyNodes:        PolyNode                      // Tree structure holding all input polygons with their join types
}

impl Offset
{
    // Clean up resources when the offset processor is destroyed.
    // Ensures all dynamically allocated polygon nodes are properly freed.
    mtd opDrop()
    {
        clear()
    }

    // Clear all stored polygons and reset the processor state.
    // Deallocates all polygon nodes and resets the lowest point tracking.
    mtd clear()
    {
        foreach node in polyNodes.childs:
            Memory.delete(node)
        polyNodes.childs.clear()
        lowest.x = -1
    }

    // Add a polygon path to be processed with the specified join type.
    // Removes duplicate points and tracks the bottommost point for orientation determination.
    mtd addPath(path: ClipperPath, joinType: JoinType)
    {
        var highI = path.count - 1
        if highI < 0:
            return
        while highI > 0 and path.buffer[0] == path.buffer[highI]:
            highI -= 1

        let newNode = Memory.new'PolyNode()
        newNode.jointype = joinType
        newNode.contour.reserve(highI + 1)
        newNode.contour.add(path.buffer[0])

        var j, k: s32
        for i in 1 to highI
        {
            if newNode.contour.buffer[j] != path.buffer[i]
            {
                j += 1
                newNode.contour.add(path.buffer[i])
                var kC = newNode.contour[k]
                if path[i].y > kC.y or (path[i].y == kC.y and path[i].x < kC.x):
                    k = j
            }
        }

        if j < 2
        {
            Memory.delete(newNode)
            return
        }

        polyNodes.addChild(newNode)

        if lowest.x < 0:
            lowest = IntPoint{polyNodes.childs.count - 1, k}
        else
        {
            var ip = polyNodes.childs[cast(s32) lowest.x].contour[cast(s32) lowest.y]
            if newNode.contour[k].y > ip.y or (newNode.contour[k].y == ip.y and newNode.contour[k].x < ip.x):
                lowest = IntPoint{polyNodes.childs.count - 1, k}
        }
    }

    // Execute the offset operation and return the resulting polygons.
    // Processes all added paths with the specified 'delta' offset distance.
    mtd execute(solution: *ClipperPaths, delta: f64, reverseNeg: bool = false)
    {
        solution.clear()
        fixOrientations()
        doOffset(delta)

        var clpr: Transform
        foreach &p in destPolys:
            clpr.addPath(p, PolyType.Subject)

        if delta > 0
        {
            clpr.execute(ClipType.Union, solution, PolyFillType.Positive, PolyFillType.Positive)
        }
        else
        {
            var r      = clpr.getBounds()
            var outer: ClipperPath
            outer.add(IntPoint{r.left - 10, r.bottom + 10})
            outer.add(IntPoint{r.right + 10, r.bottom + 10})
            outer.add(IntPoint{r.right + 10, r.top - 10})
            outer.add(IntPoint{r.left - 10, r.top - 10})

            clpr.addPath(&outer, PolyType.Subject)
            clpr.reverseOutput = reverseNeg
            clpr.execute(ClipType.Union, solution, PolyFillType.Negative, PolyFillType.Negative)
            if solution.count > 0:
                solution.removeAt(0)
        }
    }

    // Calculate the signed area of a polygon.
    // Returns positive area for counter-clockwise polygons, negative for clockwise.
    func area(poly: ClipperPath)->f64
    {
        let size = cast(s32) poly.count
        if size < 3:
            return 0

        var a  = 0'f64
        var j  = size - 1
        var pJ = poly[j]
        for i in size
        {
            var pI = poly[i]
            a += (cast(f64) pJ.x + pI.x) * (cast(f64) pJ.y - pI.y)
            j  = i
            pJ = pI
        }

        return -a * 0.5
    }

    // Determine the orientation of a polygon based on its signed area.
    // Returns true for counter-clockwise (positive area), false for clockwise.
    #[Swag.Inline]
    func orientation(poly: ClipperPath)->bool
    {
        return area(poly) >= 0
    }

    // Ensure all polygons have consistent orientation for proper offsetting.
    // Reverses polygon vertex order if the bottommost polygon has incorrect orientation.
    mtd fixOrientations()
    {
        if lowest.x >= 0 and !orientation(polyNodes.childs[lowest.x].contour)
        {
            foreach node in polyNodes.childs:
                Slice.reverse(node.contour.toSlice())
        }
    }

    // Calculate the unit normal vector perpendicular to the line segment from 'pt1' to 'pt2'.
    // The normal points to the left of the line direction (counter-clockwise 90Â° rotation).
    func getUnitNormal(pt1, pt2: const &IntPoint)->DoublePoint
    {
        var result: retval
        if pt2.x == pt1.x and pt2.y == pt1.y:
            return result

        var dx = cast(f64) (pt2.x - pt1.x)
        var dy = cast(f64) (pt2.y - pt1.y)
        let f  = 1.0 / Math.sqrt(dx * dx + dy * dy)
        dx *= f
        dy *= f
        result.x = dy
        result.y = -dx
        return result
    }

    // Round a floating-point value to the nearest integer for coordinate conversion.
    // Used to convert double precision calculations back to integer coordinates.
    #[Swag.Inline]
    func cround(val: f64) => cast(CInt) Math.round(val)

    // Perform the actual offset operation on all added polygons.
    // Calculates offset parameters and processes each polygon with appropriate join handling.
    mtd doOffset(delta: f64)
    {
        using Math

        destPolys.clear()
        deltaVal = delta

        if Math.isZeroEpsilon(delta)
        {
            destPolys.reserve(polyNodes.childs.count)
            foreach node in polyNodes.childs:
                destPolys.add(node.contour)
            return
        }

        if miterLimit > 2:
            miterLim = 2 / (miterLimit * miterLimit)
        else:
            miterLim = 0.5

        var arcT: f64 = undefined
        if arcTolerance <= 0.0:
            arcT = DefaultArcTolerance
        elif arcTolerance > abs(delta) * DefaultArcTolerance:
            arcT = abs(delta) * DefaultArcTolerance
        else:
            arcT = arcTolerance

        const Pi    = ConstF64.Pi
        const TwoPi = ConstF64.TwoPi
        var steps   = Pi / acos(1 - arcT / abs(delta))
        if steps > abs(delta) * Pi:
            steps = abs(delta) * Pi
        sinVal      = sin(TwoPi / steps)
        cosVal      = cos(TwoPi / steps)
        stepsPerRad = steps / TwoPi
        if delta < 0.0:
            sinVal = -sinVal

        destPolys.reserve(polyNodes.childs.count * 2)
        foreach node, i in polyNodes.childs
        {
            srcPoly = node.contour

            let len = cast(s32) srcPoly.count
            if len == 0 or (delta <= 0 and len < 3):
                continue

            destPoly.clear()
            if len == 1
            {
                if node.jointype == .Round
                {
                    var x = 1.0'f64
                    var y = 0.0'f64
                    for var j = 1; j <= steps; j += 1
                    {
                        let r1 = cround(srcPoly[0].x + x * delta)
                        let r2 = cround(srcPoly[0].y + y * delta)
                        destPoly.add(IntPoint{r1, r2})
                        let x2 = x
                        x = x * cosVal - sinVal * y
                        y = x2 * sinVal + y * cosVal
                    }
                }
                else
                {
                    var x = -1.0'f64
                    var y = -1.0'f64
                    for j in 4
                    {
                        let r1 = cround(srcPoly[0].x + x * delta)
                        let r2 = cround(srcPoly[0].y + y * delta)
                        destPoly.add(IntPoint{r1, r2})
                        if x < 0:
                            x = 1
                        elif y < 0:
                            y = 1
                        else:
                            x = -1
                    }
                }

                destPolys.add(destPoly)
                continue
            }

            // Build normals
            normals.clear()
            normals.reserve(cast(u64) len)
            for j in len - 1:
                normals.add(getUnitNormal(srcPoly[j], srcPoly[j + 1]))
            normals.add(getUnitNormal(srcPoly[len - 1], srcPoly[0]))

            var k = len - 1
            for j in len:
                offsetPoint(j, &k, node.jointype)
            destPolys.add(destPoly)
        }
    }

    // Process a single vertex offset with appropriate join handling.
    // Determines the offset position based on adjacent edge normals and join type.
    mtd offsetPoint(j: s32, ptrk: *s32, jointype: JoinType)
    {
        let k = dref ptrk

        var kN = normals[k]
        var jN = normals[j]
        var jP = srcPoly[j]

        sinaVal = (kN.x * jN.y - jN.x * kN.y)
        if Math.abs(sinaVal * deltaVal) < 1.0
        {
            let cosA = (kN.x * jN.x + jN.y * kN.y)
            if cosA > 0
            {
                let r1 = cround(jP.x + kN.x * deltaVal)
                let r2 = cround(jP.y + kN.y * deltaVal)
                destPoly.add(IntPoint{r1, r2})
                return
            }
        }
        elif sinaVal > 1.0:
            sinaVal = 1.0
        elif sinaVal < -1.0:
            sinaVal = -1.0

        if sinaVal * deltaVal < 0
        {
            var r1 = cround(jP.x + kN.x * deltaVal)
            var r2 = cround(jP.y + kN.y * deltaVal)
            destPoly.add(IntPoint{r1, r2})
            destPoly.add(jP)
            r1 = cround(jP.x + jN.x * deltaVal)
            r2 = cround(jP.y + jN.y * deltaVal)
            destPoly.add(IntPoint{r1, r2})
        }
        else
        {
            switch jointype
            {
            case Miter:
                let r = 1 + (jN.x * kN.x + jN.y * kN.y)
                if r >= miterLim:
                    doMiter(j, k, r)
                else:
                    doSquare(j, k)
            case Square:
                doSquare(j, k)
            case Round:
                doRound(j, k)
            }
        }

        dref ptrk = j
    }

    // Create a square join between two offset edges.
    // Extends the offset lines and connects them with a perpendicular segment.
    mtd doSquare(j, k: s32)
    {
        let kN = normals[k]
        let jN = normals[j]
        let jP = srcPoly[j]

        let dx = Math.tan(Math.atan2(sinaVal, kN.x * jN.x + kN.y * jN.y) / 4)
        var r1 = cround(jP.x + deltaVal * (kN.x - kN.y * dx))
        var r2 = cround(jP.y + deltaVal * (kN.y + kN.x * dx))
        destPoly.add(IntPoint{r1, r2})

        r1 = cround(jP.x + deltaVal * (jN.x + jN.y * dx))
        r2 = cround(jP.y + deltaVal * (jN.y - jN.x * dx))
        destPoly.add(IntPoint{r1, r2})
    }

    // Create a miter join by extending offset edges until they intersect.
    // Used when the miter length is within acceptable limits.
    mtd doMiter(j, k: s32, r: f64)
    {
        let kN = normals[k]
        let jN = normals[j]
        let jP = srcPoly[j]

        let q  = deltaVal / r
        let r1 = cround(jP.x + (kN.x + jN.x) * q)
        let r2 = cround(jP.y + (kN.y + jN.y) * q)
        destPoly.add(IntPoint{r1, r2})
    }

    // Create a rounded join by approximating a circular arc.
    // Connects offset edges with line segments that approximate the curve.
    mtd doRound(j, k: s32)
    {
        var kN = normals[k]
        var jN = normals[j]
        var jP = srcPoly[j]

        let a     = Math.atan2(sinaVal, kN.x * jN.x + kN.y * jN.y)
        let steps = Math.max(cast(s32) cround(stepsPerRad * Math.abs(a)), 1)

        var x = kN.x
        var y = kN.y
        for i in steps
        {
            let r1 = cround(jP.x + x * deltaVal)
            let r2 = cround(jP.y + y * deltaVal)
            destPoly.add(IntPoint{r1, r2})
            let x2 = x
            x = x * cosVal - sinVal * y
            y = x2 * sinVal + y * cosVal
        }

        let r1 = cround(jP.x + jN.x * deltaVal)
        let r2 = cround(jP.y + jN.y * deltaVal)
        destPoly.add(IntPoint{r1, r2})
    }
}
