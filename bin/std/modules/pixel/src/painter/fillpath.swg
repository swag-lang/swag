using Core, Math

public impl Painter
{
    private mtd fillPath(t: *Poly2Tri.Tesselate, p: *LinePath, bvMin, bvMax: Vector2, brush: Brush)
    {
        setTexture0(bvMin, bvMax, brush)
        resetTextureFont()

        // Triangulation
        if p.triangles.count == 0
        {
            t.triangulate()

            // "Eat" points, triangles and edges
            p.points =,move t.points
            p.points.add(t.head); t.head = null
            p.points.add(t.tail); t.tail = null
            p.triangles =,move t.triangles
            p.edgeList  =,move t.edgeList

            // t.triangles only contains 'interior' triangles, so we need to delete all other
            // allocated triangles to avoid a leak
            visit tri: t.map
            {
                if !tri.interior
                    Memory.delete(tri)
            }

            t.map.clear()
            t.clear()
        }

        // Paint
        visit tri, ii: p.triangles
        {
            prim := pushTriangle(tri.points[0].v, tri.points[1].v, tri.points[2].v, brush.color)
            if curState.paintParams & .Antialiased
            {
                e := tri.points[0].border[0]
                if e addEdgeAA(prim, e.p.x, e.p.y, e.q.x, e.q.y)
                e = tri.points[0].border[1]
                if e addEdgeAA(prim, e.p.x, e.p.y, e.q.x, e.q.y)

                e = tri.points[1].border[0]
                if e addEdgeAA(prim, e.p.x, e.p.y, e.q.x, e.q.y)
                e = tri.points[1].border[1]
                if e addEdgeAA(prim, e.p.x, e.p.y, e.q.x, e.q.y)

                e = tri.points[2].border[0]
                if e addEdgeAA(prim, e.p.x, e.p.y, e.q.x, e.q.y)
                e = tri.points[2].border[1]
                if e addEdgeAA(prim, e.p.x, e.p.y, e.q.x, e.q.y)
            }
        }
    }

    // Fill the line path
    mtd fillPath(pathList: *LinePathList, color: Color)
    {
        if !pathList.paths.count
            return
        sharedSolidBrush.type = .SolidColor
        sharedSolidBrush.color = color
        fillPath(pathList, sharedSolidBrush)
    }

    // Fill the line path with the given 'brush'
    mtd fillPath(path: *LinePath, brush: Brush)
    {
        path.flatten(curState.paintQuality)
        if Math.isZeroEpsilon(path.polygon.totalLen)
            return

        polygon := &path.polygon

        // Convex shape : faster
        if polygon.isConvex
        {
            setTexture0(path.bvMin, path.bvMax, brush)
            resetTextureFont()

            count := path.polygon.points.count - 1

            // Convex shape : 1 triangle
            if count == 3
            {
                v0 := polygon.getPoint(0)
                v1 := polygon.getPoint(1)
                v2 := polygon.getPoint(2)
                prim := pushTriangle(v0, v1, v2, brush.color)
                if curState.paintParams & .Antialiased
                {
                    addEdgeAA(prim, v0, v1)
                    addEdgeAA(prim, v1, v2)
                    addEdgeAA(prim, v2, v0)
                }
            }

            // Convex shape : 2 triangles
            else if count == 4
            {
                v0 := polygon.getPoint(0)
                v1 := polygon.getPoint(1)
                v2 := polygon.getPoint(2)
                v3 := polygon.getPoint(3)
                prim0 := pushTriangle(v0, v1, v2, brush.color)
                prim1 := pushTriangle(v0, v2, v3, brush.color)
                if curState.paintParams & .Antialiased
                {
                    addEdgeAA(prim0, v0, v1)
                    addEdgeAA(prim0, v1, v2)
                    addEdgeAA(prim0, v2, v3)
                    addEdgeAA(prim0, v3, v0)
                    addEdgeAA(prim1, v0, v1)
                    addEdgeAA(prim1, v1, v2)
                    addEdgeAA(prim1, v2, v3)
                    addEdgeAA(prim1, v3, v0)
                }
            }

            // Convex shape: add a triangle from the center of the shape to each pair of
            // vertices
            else
            {
                center := Vector2{path.bvMin.x + (path.bvMax.x - path.bvMin.x) * 0.5, path.bvMin.y + (path.bvMax.y - path.bvMin.y) * 0.5}
                loop i: count
                {
                    v0 := polygon.getPoint(i)
                    v1 := polygon.getPoint((i + 1) % count)
                    prim := pushTriangle(center, v0, v1, brush.color)

                    if curState.paintParams & .Antialiased
                    {
                        v2 := polygon.getPoint((i + 2) % count)
                        vp := polygon.getPoint((i + count - 1) % count)
                        addEdgeAA(prim, v0, v1)
                        addEdgeAA(prim, v1, v2)
                        addEdgeAA(prim, vp, v0)
                    }
                }
            }
        }

        // Non convex shape: complex painting (triangulation)
        else
        {
            sharedLinePathList.paths.add(path)
            fillPath(&sharedLinePathList, brush)
            sharedLinePathList.paths.count = 0
        }
    }

    // Fill the line path
    mtd fillPath(path: *LinePath, color: Color)
    {
        sharedSolidBrush.type = .SolidColor
        sharedSolidBrush.color = color
        fillPath(path, sharedSolidBrush)
    }

    // Fill the list of paths
    // clockwise = fill, anti-clockwise = hole
    mtd fillPath(pathList: *LinePathList, brush: Brush)
    {
        // Flatten all paths
        pathList.flatten(curState.paintQuality)

        var flush: *LinePath

        // Everything in the cache ?
        serial := 0
        dirty := false
        visit p: pathList.paths
        {
            if (p.polygon.isClockwise or serial != p.serial) and flush
            {
                if !flush.triangles.count
                {
                    dirty = true
                    break
                }

                serial = p.serial
                flush = null
            }

            if p.polygon.points.count >= 3
            {
                flush = p
            }
        }

        if flush and !flush.triangles.count
            dirty = true

        serial = 0
        flush = null

        // If everything has been computed, then just paint them (no need to generate polylines as 'triangulate' will not use them)
        if !dirty
        {
            visit p: pathList.paths
            {
                if (p.polygon.isClockwise or serial != p.serial) and flush
                {
                    serial = p.serial
                    fillPath(null, flush, pathList.bvMin, pathList.bvMax, brush)
                    flush = null
                }

                if p.polygon.points.count >= 3
                {
                    flush = p
                }
            }

            if flush
                fillPath(null, flush, pathList.bvMin, pathList.bvMax, brush)
        }

        // Full compute (triangulation)
        else
        {
            var t: Poly2Tri.Tesselate
            visit p: pathList.paths
            {
                if (p.polygon.isClockwise or serial != p.serial) and flush
                {
                    serial = p.serial
                    fillPath(&t, flush, pathList.bvMin, pathList.bvMax, brush)
                    flush = null
                }

                if p.polygon.points.count >= 3
                {
                    flush = p
                    t.startPolyLine()
                    loop i: 0..p.polygon.points.count-2
                    {
                        pt := p.polygon.getPoint(i)
                        t.addPoint(pt.x, pt.y)
                    }

                    t.endPolyLine()
                }
            }

            if flush
                fillPath(&t, flush, pathList.bvMin, pathList.bvMax, brush)
        }
    }

    // Fill the polygon with the given color
    mtd fillPolygon(path: *LinePath, color: Color)
    {
        sharedSolidBrush.type = .SolidColor
        sharedSolidBrush.color = color
        fillPolygon(path, sharedSolidBrush)
    }

    // Fill the polygon with the given 'brush'
    mtd fillPolygon(path: *LinePath, brush: Brush)
    {
        path.flatten(curState.paintQuality)
        if path.polygon.isConvex
        {
            fillPath(path, brush)
        }
        else
        {
            path.polygon.isClockwise = true
            res := path.polygon.getClean()
            visit p: res.paths
                fillPath(p, brush)
        }
    }
}