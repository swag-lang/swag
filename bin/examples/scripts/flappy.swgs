/**
![](imgs/flappy.png)

Here is a very simple script that implements the [Flappy Bird](https://en.wikipedia.org/wiki/Flappy_Bird) game. To have some fun and play, go to the `bin/examples/scripts` folder, and type :

    $ swag flappy.swgs

Instead of mainly explaining the game, the aim here is to describe the language. Note also that this page has been generated with Swag directly from the [source code](https://github.com/swag-lang/swag/blob/master/bin/examples/scripts/flappy.swgs).

So, let's begin.

# Dependencies

Normally, you'd put the '#dependency' block in the 'module.swg' file of a module. But if it's a script and there's no 'module.swg' file, you just put it at the top of the script file.

This special compiler block is used to specify :
* **External dependencies**, i.e. other modules you depend on. For example for Flappy, we will use the 'gui' module.
* **Additional files**. In case of scripts, you can add more files to compile with the '#load' directive.
* **Module configuration**. If present, a special '#run' block will be executed by the compiler at the very beginning of the compilation stage. It gives the opportunity to change some build configurations.

So in our case, we need to import the module 'gui'. This module is used to create windows and widgets, and will bring other modules like 'core' and 'pixel' (2D painting).
*/
#dependencies
{
    // The location "swag@std" tells swag that 'gui' is a standard module that is located
    // with the compiler.
    #import "gui" location="swag@std"

    // This is the optional '#run' block executed by the compiler before compiling the script itself.
    // We define it just to make the point because Flappy does not really need one.
    #run
    {
        // Get the compiler interface to communicate with the compiler.
        let itf = @compiler()

        // Get the build configuration
        let cfg = itf.getBuildCfg()

        // Change something...
        // Here, for example, we force all safety guards to be present in 'debug', and we remove all
        // of them in 'release'.
        #if #cfg == "debug"
            cfg.safetyGuards = Swag.SafetyAll
        #else
            cfg.safetyGuards = Swag.SafetyNone
    }
}

/**
Every module has its individual namespace. To avoid the necessity of mentioning it each time we wish to reference something, we include a global 'using' statement immediately after the '#dependency' block.

The 'gui' module depends on 'pixel' which depends on 'core'. So we bring all the three namespaces into the file scope.
*/
using Core, Pixel, Gui

/**
# Entry point

The compiler's '#run' function serves as the initial execution point for the script. This category of block is executed by the compiler while it's compiling. While it's possible to include multiple '#run' blocks, a single one is sufficient for the Flappy application.

> NOTE:
> You might observe that the arrangement of global declarations doesn't make a difference, as we're using the 'onEvent' function before even defining it. Swag does not bother about the global declaration order.
*/
#run
{
    // From the command line, if the script is run with '--arg:swag.test', then we force the application
    // to exit after 100 frames. This is usefull for batch testing.
    func test(app: *Application) = if Env.hasArg("swag.test") app.maxRunFrame = 100

    // Creates and run one surface (i.e. window) at the given position and with the given size and title.
    // 'hook' defines a lambda that will receive and treat all gui events
    // 'init' defines a lambda that will be called for surface initialization
    Application.runSurface(100, 100, 300, 512, title: "Flappy Bird", hook: &onEvent, init: &test)
}

/**
# Global definitions
## Constants
We declare global constants with 'const'. Note that we do not specify types for thoses constants. They will be deduced thanks to the affection.
*/
const Gravity      = 2.5        // 2.5 is a 32 bits float, so the type of Gravity is 'f32'
const GroundHeight = 40.0
const SpeedHorz    = 100.0
const BirdImpulseY = 350        // 350 is an integer, so the type of BirdImpulseY is 's32'

/**
## Variables
*/

var g_Bird:      Bird
var g_Pipes:     Array'Pipe
var g_Rect:      Math.Rectangle
var g_Dt:        f32
var g_Time:      f32
var g_BasePos:   f32
var g_Score:     s32
var g_GameOver:  bool
var g_Start:     bool
var g_FirstStart = true

// Texture assets
var g_DigitTexture: [10] Texture    // A static array of 10 textures
var g_BirdTexture:  [3] Texture     // A static array of 3 textures
var g_BackTexture:  Texture
var g_OverTexture:  Texture
var g_BaseTexture:  Texture
var g_PipeTextureU: Texture
var g_PipeTextureD: Texture
var g_MsgTexture:   Texture

// A pointer to the score font
var g_Font: *Font

/**
## Types
*/

// Defines the Bird
struct Bird
{
    pos:        Math.Vector2    // Position of the bird
    speed:      Math.Vector2    // Speed of the bird
    frame:      f32             // Sprite frame
}

// Defines one Pipe
struct Pipe
{
    rectUp:     Math.Rectangle  // Position of the up part of the Pipe
    rectDown:   Math.Rectangle  // Position of the down part of the Pipe
    distToNext: f32             // Distance to the next Pipe
    scored:     bool            // 'true' if the Bird has passed that Pipe
}

/**
# The actual code

This is the callback that will deal with all gui events.
*/

func onEvent(wnd: *Wnd, evt: *Event)->bool
{
    switch evt.kind
    {
    case Create:
        g_Rect = wnd.getClientRect()
        assume loadAssets(wnd)
        start()

    case Resize:
        g_Rect = wnd.getClientRect()

    case Paint:
        let paintEvt = cast(*PaintEvent) evt
        let painter = paintEvt.bc.painter
        g_Dt     = wnd.getApp().getDt()

        input(wnd)
        paint(painter)
        move()

        wnd.invalidate()
    }

    return false
}

/**
*/

func paint(painter: *Painter)
{
    var pt: Math.Point

    // Background
    painter.drawTexture(pt.x, pt.y, g_BackTexture)

    // Bird
    if !g_FirstStart
    {
        painter.pushState()
        let frame = (cast(s32) g_Bird.frame) % 3

        var trf = painter.getTransform()

        painter.resetTransform()
        let speed = Math.clamp(g_Bird.speed.y, -200, 200)
        let angle = Math.map(speed, -200, 200, -Math.ConstF32.PiBy6, Math.ConstF32.PiBy6)
        painter.rotateTransform(angle)

        painter.translateTransform(g_Bird.pos.x + trf.tx, g_Bird.pos.y + trf.ty)

        pt.x = -g_BirdTexture[frame].width * 0.5
        pt.y = -g_BirdTexture[frame].height * 0.5

        // Add a little sin
        if !g_Start
        {
            pt.y += 5 * Math.sin(g_Time)
            g_Time += 5 * g_Dt
        }

        painter.drawTexture(pt.x, pt.y, g_BirdTexture[frame])
        painter.popState()
    }

    // Pipes
    visit pipe: g_Pipes
    {
        painter.drawTexture(pipe.rectUp, g_PipeTextureU)
        painter.drawTexture(pipe.rectDown, g_PipeTextureD)
    }

    // Base
    painter.drawTexture(-g_BasePos, g_Rect.bottom() - GroundHeight, cast(f32) g_BaseTexture.width, GroundHeight, g_BaseTexture)
    painter.drawTexture(-g_BasePos + g_BaseTexture.width, g_Rect.bottom() - GroundHeight, cast(f32) g_BaseTexture.width, GroundHeight, g_BaseTexture)
    if !g_GameOver
        g_BasePos += SpeedHorz*g_Dt
    if g_BasePos >= g_BaseTexture.width
        g_BasePos = 0

    // Gameover
    if g_GameOver
    {
        pt.x = g_Rect.horzCenter() - g_OverTexture.width/2
        pt.y = g_Rect.vertCenter() - g_OverTexture.height/2
        painter.drawTexture(pt.x, pt.y, g_OverTexture)
    }

    // Score
    if !g_FirstStart
    {
        painter.drawStringCenter(g_Rect.horzCenter(), 50, Format.toString("%", g_Score), g_Font, Argb.White)
    }

    // Message
    if g_FirstStart
    {
        pt.x = g_Rect.horzCenter() - g_MsgTexture.width/2
        pt.y = g_Rect.vertCenter() - g_MsgTexture.height/2
        painter.drawTexture(pt.x, pt.y, g_MsgTexture)
    }
}

/**
*/

func input(wnd: *Wnd)
{
    let kb = wnd.getApp().getKeyboard()

    if g_GameOver or g_FirstStart
    {
        if kb.isKeyJustPressed(.Space)
        {
            start()
            g_FirstStart = false
        }
        return
    }
    elif kb.isKeyJustPressed(.Up)
    {
        g_Start = true
        g_Bird.speed.y = -BirdImpulseY
    }
}

/**
*/

func birdInRect(rect: Math.Rectangle)->bool
{
    var rectBird: Math.Rectangle
    rectBird.x = g_Bird.pos.x - g_BirdTexture[0].width/2
    rectBird.y = g_Bird.pos.y - g_BirdTexture[0].height/2
    rectBird.width = g_BirdTexture[0].width
    rectBird.height = g_BirdTexture[0].height
    return rect.intersectWith(rectBird)
}

/**
*/

func move()
{
    if g_GameOver
        return

    g_Bird.pos += g_Bird.speed * g_Dt
    g_Bird.pos.y = Math.max(g_Bird.pos.y, 0)
    if g_Start
        g_Bird.speed += {0, Gravity}

    g_Bird.frame += 10 * g_Dt

    // Be sure to have at least one pipe
    if g_Pipes.count == 0
        createPipe()

    // Move each pipe, and test collisions against the bird
    if g_Start
    {
        visit &pipe: g_Pipes
        {
            pipe.rectUp.x -= SpeedHorz * g_Dt
            pipe.rectDown.x -= SpeedHorz * g_Dt
            if birdInRect(pipe.rectUp) or birdInRect(pipe.rectDown)
                g_GameOver = true

            if g_Bird.pos.x > pipe.rectUp.right() and !pipe.scored
            {
                pipe.scored = true
                g_Score += 1
            }
        }
    }

    // If the first pipe is out of screen, remove it
    if g_Pipes[0].rectUp.right() < 0
        g_Pipes.removeAt(0)

    // If the last pipe is enough inside, create a new one
    if g_Rect.width - g_Pipes.back().rectUp.right() > g_Pipes.back().distToNext
        createPipe()

    if g_Bird.pos.y + g_BirdTexture[0].height > g_Rect.bottom() - GroundHeight
        g_GameOver = true
}

/**
*/

func createPipe()
{
    var pipe: Pipe

    let pos = g_Rect.width
    let sizePassage = Random.shared().nextF32(70, 150)
    let heightUp = Random.shared().nextF32(50, g_Rect.height - sizePassage - 50)
    let heightDown = g_Rect.height - heightUp - GroundHeight - sizePassage

    pipe.rectUp.x = pos
    pipe.rectUp.y = heightUp - g_PipeTextureU.height
    pipe.rectUp.width = g_PipeTextureU.width
    pipe.rectUp.height = g_PipeTextureU.height

    pipe.rectDown.x = pos
    pipe.rectDown.y = g_Rect.bottom() - heightDown - GroundHeight
    pipe.rectDown.width = g_PipeTextureU.width
    pipe.rectDown.height = g_PipeTextureU.height

    pipe.distToNext = Random.shared().nextF32(100, 200)

    g_Pipes.add(pipe)
}

/**
*/

func start()
{
    @init(&g_Bird)
    g_Bird.pos.x = g_Rect.horzCenter()
    g_Bird.pos.y = g_Rect.vertCenter()
    g_Score = 0
    g_Pipes.clear()
    g_GameOver = false
    g_Start = false
}

/**
*/

func loadAssets(wnd: *Wnd) throw
{
    let render = &wnd.getApp().renderer

    var dataPath: String = Path.getDirectoryName(#location.fileName)
    dataPath = Path.combine(dataPath, "datas")
    dataPath = Path.combine(dataPath, "flappy")

    g_BirdTexture[0] = render.addImage(Path.combine(dataPath, "yellowbird-upflap.png"))
    g_BirdTexture[1] = render.addImage(Path.combine(dataPath, "yellowbird-midflap.png"))
    g_BirdTexture[2] = render.addImage(Path.combine(dataPath, "yellowbird-downflap.png"))
    g_OverTexture    = render.addImage(Path.combine(dataPath, "gameover.png"))
    g_BaseTexture    = render.addImage(Path.combine(dataPath, "base.png"))
    g_BackTexture    = render.addImage(Path.combine(dataPath, "background-day.png"))
    g_MsgTexture     = render.addImage(Path.combine(dataPath, "message.png"))

    var img = Image.load(Path.combine(dataPath, "pipe-green.png"))
    g_PipeTextureD = render.addImage(img)
    img.flip()
    g_PipeTextureU = render.addImage(img)

    g_Font = Font.create(Path.combine(dataPath, "FlappyBirdy.ttf"), 50)
}