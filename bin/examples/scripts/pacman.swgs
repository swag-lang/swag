// Based on the pacman project by Alex Macpherson at https://github.com/alexjamesmacpherson/pacman/blob/master.
// Original code has been modified for Swag.

/*
BSD 3-Clause License

Copyright (c) 2017, Alex Macpherson
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#dependencies
{
    #import "gui" location="swag@std"
}

using Gui, Core, Pixel
const Scale = 3.0

var g_MapTex:       Texture
var g_PillTex:      Texture
var g_BigPillTex:   [2] Texture
var g_Pac0Tex:      Texture
var g_Pac1Tex:      Texture
var g_Pac2Tex:      Texture
var g_ReadyTex:     Texture
var g_PauseTex:     Texture
var g_PauseAltTex:  Texture
var g_QuitTex:      Texture
var g_HelpTex:      Texture
var g_ScoreTex:     Texture
var g_Num0Tex:      Texture
var g_Num1Tex:      Texture
var g_Num2Tex:      Texture
var g_Num3Tex:      Texture
var g_Num4Tex:      Texture
var g_Num5Tex:      Texture
var g_Num6Tex:      Texture
var g_Num7Tex:      Texture
var g_Num8Tex:      Texture
var g_Num9Tex:      Texture
var g_GhostTexR:    [2] Texture    // Array storing red        ghost sprites
var g_GhostTexP:    [2] Texture    // Array storing pink       ghost sprites
var g_GhostTexB:    [2] Texture    // Array storing blue       ghost sprites
var g_GhostTexY:    [2] Texture    // Array storing yellow     ghost sprites
var g_GhostTexF:    [4] Texture    // Array storing frightened ghost sprites
var g_EyeTexU:      Texture
var g_EyeTexR:      Texture
var g_EyeTexD:      Texture
var g_EyeTexL:      Texture

var g_Wnd:          *Wnd
var g_DataPath:     String
var g_Painter:      *Painter
var g_Mode:         GameMode = READY
var g_TempMode:     GameMode = READY
var g_LastTime:     u64

var g_Score:        s32
var g_HighScore:    s32
var g_PillsLeft     = 244

// Ghost AI targeting is wave-based, varying between CHASE and SCATTER over time
var g_Wave = Movement.SCATTER

// Game ticks, effectively enacting a frame counter
var g_Ticks:        s32

/**
 * Timestamp represents symbolic points in the game, allowing specific frame-based timing from a certain tick:
 *      -1: default, unset state
 * Set to current ticks in a number of situations, effecting a short pause in the game
 * Set to current ticks on entering DEATH-mode, ensuring READY-mode is entered a given number of ticks later
 */
var g_TimeStamp = -1

var g_PacMan: Pacman
var g_Ghosts: [4] Ghost = [
    {13.5, 30-19, GhostColor.RED},
    {13.5, 30-16, GhostColor.PINK},
    {11.5, 30-16, GhostColor.BLUE},
    {15.5, 30-16, GhostColor.YELLOW}
]

struct Pacman
{
    x           = 13.5      // X position relative to map - float allows for smooth movement between tiles
    y           = 30-7.0       // Y position relative to map - float allows for smooth movement between tiles
    dir:        Direction   // Direction of movement
    tempDir:    Direction   // Temporary direction storage
    saveDir:    Direction   // Secondary direction storage for stopping and starting animation
    texCount    = 10        // Counter to determine which texture to draw
    ready       = false     // Flag prevents incorrect Pac-Man texture or position rounding at start of game
}

struct Ghost
{
    xInit:  f32   // Initial X position stored for later resets
    yInit:  f32   // Initial Y position stored for later resets
    colour: GhostColor  // Colour of ghost

    x:      f32     // X position relative to map - float allows for smooth movement between tiles
    y:      f32     // Y position relative to map - float allows for smooth movement between tiles

    dPos:   f32     // Delta position - the amount the ghost should move each tick

    dir: Direction      // Direction of movement
    texCount: s32       // Counter to determine which texture to draw

    ai:         Movement    // Movement AI type
    reverse:    bool        // Flag determining whether to reverse the ghost
    timeout:    s32         // Timeout used to determine when to leave FRIGHTENED mode AI, -1 = default
    drawScore:  bool        // Flag determining whether to draw the score for eating this ghost
}

// Enum defines possible ghost colours
enum GhostColor {RED; PINK; BLUE; YELLOW;}

// Enum defines possible ghost movement types
enum Movement {CHASE; SCATTER; FRIGHTENED; DEAD; LEAVE; SPAWN;}

/**
 * Game modes defined as enum:
 *      READY:    Set game to starting state, display READY! text until game begins
 *      PLAY:     Game is in play
 *      FRUIT:    Pause game briefly during play upon eating a fruit
 *      EAT:      Pause game briefly during play upon eating a ghost - the two differ only in what is drawn
 *      PAUSE:    Game is paused, draw help screen
 *      DEATH:    Pac-Man has been eaten, play death sequence
 *      GAMEOVER: Game is over, display GAME OVER text until quit/restart
 * Gamemode is defined as new type for ease of use.
 * Default starting mode is READY
 */
enum GameMode
{
    NONE
    READY
    PLAY
    FRUIT
    EAT
    PAUSE
    DEATH
    GAMEOVER
}

/**
 * Tile types defined as enum:
 *      W: Wall
 *      G: Gate
 *      P: Portal
 *      n: Non-Filled Path
 *      o: Pill
 *      e: Eaten Pill
 *      O: Big Pill
 *      E: Eaten Big Pill
 *      F: Fruit
 * Tile is defined as new type for ease of use.
 * Each tile-type is used to determine behaviour of Pac-Man & Ghosts.
 */
enum Tile {W; G; P; n; o; e; O; E; F;}

// Enum defines possible movement directions
enum Direction {NONE; UP; RIGHT; DOWN; LEFT;}

var g_Map: [28, 31] Tile = [
    [W,W,W,W,W,W,W,W,W,W,W,W,n,n,n,W,P,W,n,n,n,W,W,W,W,W,W,W,W,W,W],
    [W,o,o,o,o,W,W,O,o,o,o,W,n,n,n,W,n,W,n,n,n,W,o,o,o,o,O,o,o,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,W,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,W,W,W,o,W,W,W,W,W,n,W,W,W,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,W],
    [W,o,W,W,W,W,W,o,W,W,o,W,W,W,W,W,n,W,W,W,W,W,W,W,W,o,W,W,W,o,W],
    [W,o,W,W,W,W,W,o,W,W,o,W,W,W,W,W,n,W,W,W,W,W,W,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,W,W,o,n,n,n,n,n,n,n,n,n,W,W,o,o,o,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,W,n,W,W,W,W,W,n,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,W,n,W,W,n,n,W,n,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,o,o,o,W,W,o,o,o,o,W,W,n,W,W,n,n,W,n,n,n,o,W,W,o,o,o,o,o,W],
    [W,o,W,W,W,W,W,n,W,W,W,W,W,n,W,W,n,n,G,n,W,W,W,W,W,o,W,W,W,W,W],
    [W,o,W,W,W,W,W,n,W,W,W,W,W,n,W,W,n,n,G,n,W,W,W,W,W,o,W,W,W,W,W],
    [W,o,o,o,o,W,W,o,o,o,o,W,W,n,W,W,n,n,W,n,n,n,o,W,W,o,o,o,o,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,W,n,W,W,n,n,W,n,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,W,n,W,W,W,W,W,n,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,W,W,o,n,n,n,n,n,n,n,n,n,W,W,o,o,o,o,W,W,W,o,W],
    [W,o,W,W,W,W,W,o,W,W,o,W,W,W,W,W,n,W,W,W,W,W,W,W,W,o,W,W,W,o,W],
    [W,o,W,W,W,W,W,o,W,W,o,W,W,W,W,W,n,W,W,W,W,W,W,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,W],
    [W,o,W,W,o,W,W,W,W,W,o,W,W,W,W,W,n,W,W,W,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,W,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,o,o,o,W,W,O,o,o,o,W,n,n,n,W,n,W,n,n,n,W,o,o,o,o,O,o,o,o,W],
    [W,W,W,W,W,W,W,W,W,W,W,W,n,n,n,W,P,W,n,n,n,W,W,W,W,W,W,W,W,W,W]
]

impl Ghost
{
    mtd reset()
    {
        x = xInit
        y = yInit
        dPos = 0.1
        texCount = 0
        reverse = false
        timeout = -1
        drawScore = false

        // Reset starting direction and movement type based on colour
        switch colour
        {
        case RED:
            dir = .LEFT
            ai = g_Wave         // RED starts outside the pen and is immediately in the first targeting mode defined by wave
        case PINK:
            dir = .DOWN
            ai = .LEAVE         // PINK starts in LEAVE mode, leaving the SPAWN pen straight away
        case BLUE, YELLOW:      // YELLOW and BLUE both start facing UP, trapped within the SPAWN
            dir = .UP
            ai = .SPAWN
        }
    }

    mtd checkSpecialCases()
    {
    }

    /**
     * Special movement behaviour:
     *      Very simply move ghost up and down within the SPAWN pen
     */
    mtd aiSpawn()
    {
        setSpeed(50)   // Set movement speed to 50%
        if cast(s32)(y * 10.0) % 10 == 5 and cast(s32)(x * 10.0) % 10 == 5 and isImpassible(getNextTile(dir))
        {
            switch dir // Switch direction upon hitting a WALL
            {
            case UP:    dir = DOWN
            case DOWN:  dir = UP
            }
        }
    }

    /**
     * Special movement behaviour:
     *      If within SPAWN pen and not heading down, move towards the center of the enclosure
     *      Once at center of pen, head up until exited PEN
     *      Immediately head LEFT and set speed to 100%
     *      Once the first tile center is reached, enter AI of current wave
     */
    mtd aiLeave()
    {
        if y < 19 and dir != .DOWN
        {
            setSpeed(50) // Set movement speed to 50%
            if x < 13.4  // Move towards the center
                dir = .RIGHT
            elif x > 13.6
                dir = .LEFT
            else
            {
                x = 13.5   // Truly center position when center of pen is reached
                dir = .UP   // Then set direction to move out of the SPAWN
            }
        }
        elif y >= 19 // Once out of the SPAWN, act as a normal ghost
        {
            dir = .LEFT    // Begin heading LEFT
            ai = g_Wave    // Enter the current AI wave
            setSpeed(100)  // Ensure speed is correctly set to 100%
        }
        elif cast(s32)(y * 10.0) % 10 == 5 and isImpassible(getNextTile(dir))
            dir = .UP
    }

    mtd aiScatter()
    {
    }

    mtd aiChase(redGhost: Ghost)
    {
    }

    mtd aiFrightened()
    {
    }

    mtd aiDead()
    {
    }

    mtd reverseDirection()
    {
        switch dir
        {
        case UP:    dir = DOWN
        case RIGHT: dir = LEFT
        case DOWN:  dir = UP
        case LEFT:  dir = RIGHT
        }

        reverse = false
    }

    mtd turnCorner()
    {
        if dir != .DOWN and !isImpassible(getNextTile(.UP))
            dir = .UP
        elif dir != .LEFT and !isImpassible(getNextTile(.RIGHT))
            dir = .RIGHT
        elif dir != .UP and !isImpassible(getNextTile(.DOWN))
            dir = .DOWN
        elif dir != .RIGHT and !isImpassible(getNextTile(.LEFT))
            dir = .LEFT
    }

    /**
     * When setting the speed of a ghost, it is necessary to round the ghost's coordinates to the correct degree of precision
     *
     * Rounding prevents errors such as being unable to recognise the center of a tile or overshooting a junction when changing speeds
     *      EXAMPLE CASE:   Ghost is travelling at 50% speed (FRIGHTENED) so increases position by 0.05 each tick
     *                      Upon death, its speed is incremented to 200%, moving by 0.2 tiles each tick
     *                      Suppose the ghost was eaten at x=12.05 - possible when moving at 50% speed
     *                      Its position will now be unable to round to x=12.0 to ascertain it is at the center of a tile
     *
     * Because of cases like the above, position rounding is necessary when changing speeds
     */
    mtd roundPosition()
    {
        x = Math.round(x / dPos) * dPos
        y = Math.round(y / dPos) * dPos
    }

    /**
     * Set the speed of the ghost and round the position to account for movement precision inaccuracies
     *
     * @param percentage - Float representing speed. 100% sets d_pos=0.1f (normal playing speed)
     */
    mtd setSpeed(percentage: f32)
    {
        dPos = percentage / 1000
        roundPosition()
    }

    mtd countExits()->s32
    {
        var exits = 0
        if atTileCenter()
        {
            if !isImpassible(getNextTile(.UP))
                exits += 1
            if !isImpassible(getNextTile(.RIGHT))
                exits += 1
            if !isImpassible(getNextTile(.DOWN))
                exits += 1
            if !isImpassible(getNextTile(.LEFT))
                exits += 1
        }

        return exits
    }

    /**
     * Determines and returns absolute X coordinate of map tile on which ghost resides
     *
     * @return - integer, X coordinate of current tile
     */
    mtd getX() => cast(s32) Math.round(x)

    /**
     * Determines and returns absolute Y coordinate of map tile on which ghost resides
     *
     * @return - integer, Y coordinate of current tile
     */
    mtd getY() => cast(s32) Math.round(y)

    /**
     * Determines and returns the next tile in the given direction of movement
     *
     * @param d - direction of movement in which to check to the next tile
     * @return -  next tile in direction d
     */
    mtd getNextTile(d: Direction)->Tile
    {
        // Return next tile in given direction
        switch d
        {
        case UP:    return getTile(getX(), getY()+1)
        case RIGHT: return getTile(getX()+1, getY())
        case DOWN:  return getTile(getX(), getY()-1)
        case LEFT:  return getTile(getX()-1, getY())
        default:    return getTile(getX(), getY())  // If d=NONE, return current tile
        }
    }

    /**
     * Determines whether ghost is currently at the center of a tile
     * Expression basically validates that the first decimal point of each coordinate is a zero
     * If each is a zero, ghost is at the center of his tile
     *
     * @return - boolean, true if at center
     */
    mtd atTileCenter()->bool
    {
        let mod = cast(s32) (1/dPos)
        return cast(s32) Math.round(y * mod) % mod == 0 and cast(s32) Math.round(x * mod) % mod == 0
    }

    mtd move(redGhost: Ghost)
    {
        // Check any special case AI behaviour
        checkSpecialCases()

        // Handle special case movement behaviours
        if ai == .SPAWN     // Behaviour within SPAWN pen
            aiSpawn()
        elif ai == .LEAVE   // AI to LEAVE SPAWN pen
            aiLeave()
        // Handle PORTAL collision - only teleport if at center of tile
        elif atTileCenter() and getTile(getX(), getY()) == .P
        {
            if dir == .RIGHT
                x = 1
            else
                x = 26
        }
        // If the a new AI mode has been set, reverse the current direction
        elif reverse
            reverseDirection()
        // If no special case exists, direction can only be changed when 2 or more exits exist
        elif countExits() == 2 and isImpassible(getNextTile(dir))    // Ghost is at corner so must turn
            turnCorner()
        elif countExits() > 2   // Ghost is at junction - run targeting AI and update direction
        {
            @breakpoint()
            switch ai
            {
            case SCATTER:       // Scatter all ghosts to each of the four corners
                aiScatter()
            case CHASE:         // Target and hunt Pac-Man, passing RED ghost for BLUE's AI
                aiChase(redGhost)
            case FRIGHTENED:    // Flee from Pac-Man randomly
                aiFrightened()
            case DEAD:
                aiDead()
            }
        }

        // Half speed when travelling down PORTAL corridors
        if getY() == 16 and (getX() < 6 or getX() > 21) and ai != .DEAD
            setSpeed(50)

        // Perform smooth movement between tiles in the current direction of movement
        // Round the unchanging position coordinate, preventing directional query mishaps
        switch dir
        {
        case LEFT:
            x -= dPos
            if ai != .LEAVE
                y = Math.round(y)
        case RIGHT:
            x += dPos
            if ai != .LEAVE
                y = Math.round(y)
        case UP:
            y += dPos
            if ai != .SPAWN and ai != .LEAVE and ai != .DEAD
                x = Math.round(x)
        case DOWN:
            y -= dPos
            if ai != .SPAWN and ai != .LEAVE and ai != .DEAD
                x = Math.round(x)
        }
    }

    mtd draw()
    {
        g_Painter.pushTransform()

        translateMapOrigin()               // Translate to map origin
        translateMapCoords(x,y)            // Translate to current (x,y)
        g_Painter.translateTransform(7, 7)
        //glTranslatef(-3.0f, -3.0f, 0.0f);   // Account for over-sized sprite (14x14 on 8x8 tile)

        // Determine which colour ghost to draw and whether it is the alternate texture (wiggle animation)
        var ghostTex: Texture
        let ghostAlt = cast(s32) Math.floor(texCount % 20 / 10.0)

        if ai == .FRIGHTENED    // If in FRIGHTENED mode, draw the correct skin
        {
            if timeout >= 480 and texCount % 30 >= 15   // Draw white (flashing) skin when FRIGHTENED mode is nearing its end
                ghostTex = g_GhostTexF[ghostAlt + 2]
            else
                ghostTex = g_GhostTexF[ghostAlt]
        }
        else if ai != .DEAD
        {
            switch colour // If not in FRIGHTENED or DEAD AI, draw the ghost according to colour
            {
                case RED:       ghostTex = g_GhostTexR[ghostAlt]
                case PINK:      ghostTex = g_GhostTexP[ghostAlt]
                case BLUE:      ghostTex = g_GhostTexB[ghostAlt]
                case YELLOW:    ghostTex = g_GhostTexY[ghostAlt]
            }
        }

        // Draw ghost sprite with determined texture at current location only if not DEAD
        if ai != .DEAD
            g_Painter.drawTexture(-7, -7, 14, 14, ghostTex)

        // Only draw the ghost's eyes if it's not FRIGHTENED
        if ai != .FRIGHTENED
        {
            // Determine which way the ghost's eyes should be facing
            var eyesTex: Texture
            switch dir
            {
            case UP:    eyesTex = g_EyeTexU
            case RIGHT: eyesTex = g_EyeTexR
            case DOWN:  eyesTex = g_EyeTexD
            case LEFT:  eyesTex = g_EyeTexL
            }

            // Draw direction-based eyes sprite atop ghost body
            g_Painter.drawTexture(-7, -7, 14, 14, eyesTex)
        }

        // Increment texture counter every frame
        texCount += 1

        g_Painter.popTransform()
    }
}

impl Pacman
{
    /**
     * Determines whether Pac-Man is currently at the center of a tile
     * Expression basically validates that the first decimal point of each coordinate is a zero
     * If each is a zero, Pac-Man is at the center of his tile
     *
     * @return - boolean, true if at center
     */
    mtd atTileCenter()->bool
    {
        return cast(s32) Math.round(y * 10.0) % 10 == 0 and cast(s32) Math.round(x * 10.0) % 10 == 0
    }

    /**
     * Determines and returns absolute X coordinate of map tile on which Pac-Man resides
     *
     * @return - integer, X coordinate of current tile
     */
    mtd getX()->s32
    {
        return cast(s32) Math.round(x)
    }

    /**
     * Determines and returns absolute Y coordinate of map tile on which Pac-Man resides
     *
     * @return - integer, Y coordinate of current tile
     */
    mtd getY()->s32
    {
        return cast(s32) Math.round(y)
    }

    mtd eat()->s32
    {
        if !atTileCenter()
            return 0

        switch getTile(getX(), getY())
        {
        case o:
            setTile(getX(),getY(),e)
            g_PillsLeft -= 1
            return 10
        case O:
            setTile(getX(),getY(),E)
            g_PillsLeft -= 1
            return 50
        case P:
            if dir == .RIGHT
                x = 1
            else
                x = 26
            return 0
        /*case F:
            setTile(getX(),getY(),e)
            fruitSpawned = false
            switch fruits++
            {
                case 0:
                    return 100;
                case 1:
                    return 300;
                case 2:
                    return 500;
                case 3:
                    return 700;
                case 4:
                    return 1000;
                case 5:
                    return 2000;
                case 6:
                    return 3000;
                case 7:
                    return 5000;
            }*/
        }

        return 0
    }

    /**
     * Determines and returns the next tile in the given direction of movement
     *
     * @param d - direction of movement in which to check to the next tile
     * @return -  next tile in direction d
     */
    mtd getNextTile(d: Direction)->Tile
    {
        // Return next tile in given direction
        switch d
        {
        case UP:    return getTile(getX(), getY()+1)
        case RIGHT: return getTile(getX()+1, getY())
        case DOWN:  return getTile(getX(), getY()-1)
        case LEFT:  return getTile(getX()-1, getY())
        default:    return getTile(getX(), getY())  // If d=NONE, return current tile
        }
    }

    mtd move()
    {
        // Ascertain whether direction can be changed
        // Direction can only be changed at the center of a tile
        if atTileCenter()
        {
            if !isImpassible(getNextTile(tempDir)) // If the proposed direction is not impassible, update direction
                dir = tempDir
            elif isImpassible(getNextTile(dir)) // If the current direction is impassible, set dir=NONE
                dir = .NONE
        }

        // The only exception to the above rule is at game start (when ready=false), as Pac-Man starts between two tiles
        if !ready and tempDir != .NONE and !isImpassible(getNextTile(tempDir))
        {
            dir = tempDir
            if !ready
                ready = true   // Ready flag is set to true, enabling position rounding when dir=NONE and correct texture drawing
        }

        // Perform smooth movement between tiles in the current direction of movement
        // While moving, round the unchanging position coordinate, preventing directional query mishaps
        switch dir
        {
        case LEFT:
            x -= 0.1
            y = Math.round(y)
        case RIGHT:
            x += 0.1
            y = Math.round(y)
        case UP:
            y += 0.1
            x = Math.round(x)
        case DOWN:
            y -= 0.1
            x = Math.round(x)
        default:                // If not moving, round both coordinates, centering Pac-Man within the tile
            if ready            // Only do if Pac-Man has already moved (ready=true)
            {                   // This allows starting X position to be non-rounded
                x = Math.round(x)
                y = Math.round(y)
            }
        }
    }

    mtd draw()
    {
        g_Painter.pushTransform()
        translateMapOrigin()
        translateMapCoords(x,y)
        g_Painter.translateTransform(-2*Scale,-2*Scale)
        g_Painter.translateTransform(6.5*Scale,6.5*Scale)

        // Determine rotation angle of sprite based on direction
        var angle: f32
        switch dir
        {
        case UP:    angle = 270.0
        case RIGHT: angle = 180.0
        case DOWN:  angle = 90.0
        case LEFT:  angle = 0.0
        }

        g_Painter.rotateTransformInPlace(Math.toRadians(angle))

        // Determine which texture to draw based on tick-incremented counter
        var pacmanTex: Texture
        if texCount % 20 < 5
            pacmanTex = g_Pac0Tex
        elif texCount % 20 < 10 or texCount % 20 >= 15
            pacmanTex = g_Pac1Tex
        else
            pacmanTex = g_Pac2Tex

        // Draw Pac-Man sprite with determined texture at determined angle
        g_Painter.drawTexture(-6.5, -6.5, 13, 13, pacmanTex)

        // Increment texture counter only if moving
        // If stationary, continue until sprite animation cycle is complete
        if !(dir == .NONE and texCount % 20 < 5) and ready
            texCount += 1

        g_Painter.popTransform()
    }
}

func invY(y: f32)                   => 30.0-y
func translateMapOrigin()           = g_Painter.translateTransform(38.0, 26.0)
func translateMapCoords(x, y: f32)  = g_Painter.translateTransform(x*8*Scale, y*8*Scale)
func getTile(x, y: s32)->Tile       => g_Map[x, 30-y]
func setTile(x, y: s32, t: Tile)    = g_Map[x, 30-y] = t
func isImpassible(t: Tile)          => t == .W or t == .G

func drawMap()
{
    g_Painter.pushTransform()
    translateMapOrigin()

    // Map
    g_Painter.drawTexture(0, 0, 224, 248, g_MapTex)

    // Content
    loop x: 28
    {
        g_Painter.pushTransform()
        loop y: 31
        {
            // Determine size of big pills to draw depending on ticks
            let bigPill = cast(s32) Math.floor((g_Ticks%40) / 20.0)

            switch getTile(x,y) // Draw pills as sprites
            {
                case o:
                    g_Painter.drawTexture(0, 0, 8, 8, g_PillTex)
                case O:
                    g_Painter.drawTexture(0, 0, 8, 8, g_BigPillTex[bigPill]) // Draw big pill of determined size
                //case F:
                    //drawFruit(x,y); break;  // Method to determine which fruit should be drawn at current location
            }

            translateMapCoords(0,1) // Increment Y pos
        }

        g_Painter.popTransform()
        translateMapCoords(1,0) // Increment X pos
    }

    g_Painter.popTransform()
}

func drawLevel()
{
}

/**
 * Draws a number as a set of sprites
 *
 * @param number - integer number to draw
 */
func drawNumberAsSprite(number: s32)
{
    g_Painter.pushTransform()

    let str = Format.toString("%", number) // Convert number to string to allow iteration
    loop i: str.length-1..0
    {
        switch str[i]
        {
        case "0"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num0Tex)     // Draw number 0 sprite at current location
        case "1"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num1Tex);    // Draw number 1 sprite at current location
        case "2"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num2Tex)     // Draw number 2 sprite at current location
        case "3"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num3Tex)     // Draw number 3 sprite at current location
        case "4"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num4Tex)     // Draw number 4 sprite at current location
        case "5"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num5Tex)     // Draw number 5 sprite at current location
        case "6"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num6Tex)     // Draw number 6 sprite at current location
        case "7"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num7Tex)     // Draw number 7 sprite at current location
        case "8"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num8Tex)     // Draw number 8 sprite at current location
        case "9"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num9Tex)     // Draw number 9 sprite at current location
        }

        translateMapCoords(-1,0)    // Translate one tile left for next digit
    }

    // If number is a single digit, justify with another zero
    if str.length == 1
        g_Painter.drawTexture(0, 0, 8, 8, g_Num0Tex)

    g_Painter.popTransform()
}

func drawScore()
{
    g_Painter.pushTransform()

    translateMapOrigin()                            // Translate to map origin
    translateMapCoords(6.5, invY(32.5))             // Translate to point above map at which the score tooltip should be drawn
    g_Painter.drawTexture(0, 0, 80, 8, g_ScoreTex)  // Draw SCORE tooltip at current location

    translateMapCoords(4,-1)                        // Translate to point above map at which the high score should be drawn
    drawNumberAsSprite(Math.min(g_HighScore,99999)) // Draw high score sprites at current location
    translateMapCoords(6,0)                         // Translate to point above map at which the score should be drawn
    drawNumberAsSprite(Math.min(g_Score,99999))     // Draw score sprites at current location

    g_Painter.popTransform()
}

func drawLives()
{
}

func drawFruits()
{
}

func drawCharacters()
{
    g_PacMan.draw();
    loop i: 4
        g_Ghosts[i].draw()
}

func drawHelp()
{
    g_Painter.pushTransform()
    translateMapOrigin()      // Translate to map origin
    translateMapCoords(19,invY(32)) // Translate to point above map at which the HELP tooltip should be drawn
    g_Painter.drawTexture(0, 0, 64, 8, g_HelpTex) // Draw HELP tooltip at current location
    g_Painter.popTransform()
}

func drawReady()
{
    g_Painter.pushTransform()
    translateMapOrigin()      // Translate to map origin
    translateMapCoords(11,invY(13)) // Translate to point within map at which READY! tooltip should be drawn
    g_Painter.drawTexture(0, 0, 48, 8, g_ReadyTex) // Draw READY! sprite at current location
    g_Painter.popTransform()
}

func drawPause(gameover: bool)
{
    g_Painter.pushTransform()
    translateMapOrigin()      // Translate to map origin
    if !gameover
        g_Painter.drawTexture(0, 0, 224, 248, g_PauseTex) // Draw PAUSE screen as a sprite
    else
        g_Painter.drawTexture(0, 0, 224, 248, g_PauseAltTex) // Draw alternate PAUSE screen as a sprite (restart text only when mode=GAMEOVER)
    g_Painter.popTransform()
}

func drawQuit()
{
    g_Painter.pushTransform()
    translateMapOrigin()      // Translate to map origin
    translateMapCoords(19,invY(32)) // Translate to point above map at which the QUIT tooltip should be drawn
    g_Painter.drawTexture(0, 0, 64, 8, g_QuitTex) // Draw QUIT tooltip at current location
    g_Painter.popTransform()
}

func drawPlayScreen()
{
    drawMap()
    drawLevel()
    drawScore()
    drawLives()
    drawFruits()
    drawHelp()
}

func display()
{
    let rect = g_Wnd.getClientRect()
    g_Painter.fillRect(rect, Argb.Black)
    g_Painter.scaleTransform(Scale, Scale)

    switch g_Mode
    {
    case READY:
        drawPlayScreen()
        drawCharacters()
        drawReady()

    case PLAY:
        drawPlayScreen()
        drawCharacters()

    case PAUSE:
        drawPause(g_TempMode == GAMEOVER)
        drawLevel()
        drawScore()
        drawLives()
        drawFruits()
        drawQuit()
    }
}

/**
 * Check all possible collisions:
 *      Call Pac-Man to eat its current tile, incrementing score accordingly
 *       - If all pills are eaten, move to the next level
 *       - Once score exceeds 10,000, award a bonus life
 *       - On eating a big pill, set ghosts to FRIGHTENED
 *       - Release ghosts from the SPAWN pen after a specific number of pills have been eaten
 *       - If a fruit is eaten, pause the game briefly to display the score for eating it
 *      Check whether Pac-Man has collided with a ghost
 *       - Set mode=DEATH if collision has occurred with alive ghost
 *       - If the ghost is frightened, eat it (set AI=DEAD)
 */
func checkCollisions()
{
    // Eat current tile, increment score
    let scoreIncrement = g_PacMan.eat()
    g_Score += scoreIncrement
}

func gameLoop()
{
    let curTime = Time.nowMilliseconds()
    if curTime - g_LastTime < 16
    {
        let delay = cast(u32) (16 - (curTime - g_LastTime))
        Threading.Thread.sleep(Time.Duration.fromMs(delay))
    }

    g_LastTime = curTime

    switch g_Mode
    {
    case READY: // After 240 ticks, enter PLAY mode
        //if g_Ticks > 240
            g_Mode = PLAY

    case PLAY: // Main play loop
        if g_TimeStamp == -1
        {
            checkCollisions()
            g_PacMan.move()
            checkCollisions()
            // Move each ghost - pass RED ghost for BLUE's CHASE mode AI
            loop i: 4
                g_Ghosts[i].move(g_Ghosts[0])

        }
        else
        {
            //...
        }

        break
    }

    // Increment game ticks once the frame is drawn, but only if not paused
    if g_Mode != .NONE
        g_Ticks += 1
}

func resetMap()
{
    loop x: 28
    {
        loop y: 31
        {
            switch getTile(x,y)
            {
            case F, e: // Fruits only spawn on empty pill tiles, not empty big pill tiles - if it still exists on map reset, reset to pill
                setTile(x,y,.o)
            case E:
                setTile(x,y,.O)
            }
        }
    }
}

func resetLevel()
{
    loop i: 4
        g_Ghosts[i].reset()
}

func restartGame()
{

    /*
    level = 1
    lives = 2
    extraLife = false
    fruits = 0*/

    g_Score = 0
    g_PillsLeft = 244
    resetMap()
    resetLevel()
}

func onEvent(wnd: *Wnd, evt: *Event)->bool
{
    switch evt.kind
    {
    case Create:
        restartGame()
        g_Wnd = wnd
        loadBindTextures()

    case Paint:
        let paintEvt = cast(*PaintEvent) evt
        g_Painter = paintEvt.bc.painter
        gameLoop()
        display()
        wnd.invalidate()

    case KeyPressed:
        let keyEvt = cast(*KeyEvent) evt
        switch keyEvt.key
        {
        case Escape:
            if g_Mode != .PAUSE
            {
                g_TempMode = g_Mode // Save gamemode to re-enter on unpausing game
                g_Mode = .PAUSE
            }
            elif g_Mode == .PAUSE
            {
                g_Wnd.postQuitEvent()
            }

        case Left:  g_PacMan.tempDir = .LEFT
        case Right: g_PacMan.tempDir = .RIGHT
        case Down:  g_PacMan.tempDir = .UP
        case Up:    g_PacMan.tempDir = .DOWN

        default:
            if g_Mode == .PAUSE and g_TempMode != .GAMEOVER
                g_Mode = g_TempMode
            elif g_Mode == .GAMEOVER or g_Mode == .PAUSE
                restartGame()
        }

        break
    }

    return false
}

func loadBindTextures()
{
    func loadAndBindTexture(name: string)->Texture
    {
        let img = assume Image.load(Path.combine(g_DataPath, name))
        return g_Wnd.getApp().getRenderer().addImage(img)
    }

    g_DataPath = Path.getDirectoryName(#location.fileName)
    g_DataPath = Path.combine(g_DataPath, "datas")
    g_DataPath = Path.combine(g_DataPath, "pacman")

    // Bind map textures
    g_MapTex        = loadAndBindTexture("map/map.png")
    g_PillTex       = loadAndBindTexture("map/pill.png")
    g_BigPillTex[0] = loadAndBindTexture("map/big-0.png")
    g_BigPillTex[1] = loadAndBindTexture("map/big-1.png")
    // Bind Pac-Man textures
    g_Pac0Tex       = loadAndBindTexture("pacman/0.png")
    g_Pac1Tex       = loadAndBindTexture("pacman/1.png")
    g_Pac2Tex       = loadAndBindTexture("pacman/2.png")
    // Bind ghost textures
    g_GhostTexR[0]  = loadAndBindTexture("ghosts/r-0.png")
    g_GhostTexR[1]  = loadAndBindTexture("ghosts/r-1.png")
    g_GhostTexP[0]  = loadAndBindTexture("ghosts/p-0.png")
    g_GhostTexP[1]  = loadAndBindTexture("ghosts/p-1.png")
    g_GhostTexB[0]  = loadAndBindTexture("ghosts/b-0.png")
    g_GhostTexB[1]  = loadAndBindTexture("ghosts/b-1.png")
    g_GhostTexY[0]  = loadAndBindTexture("ghosts/y-0.png")
    g_GhostTexY[1]  = loadAndBindTexture("ghosts/y-1.png")
    g_GhostTexF[0]  = loadAndBindTexture("ghosts/f-0.png")
    g_GhostTexF[1]  = loadAndBindTexture("ghosts/f-1.png")
    g_GhostTexF[2]  = loadAndBindTexture("ghosts/f-2.png")
    g_GhostTexF[3]  = loadAndBindTexture("ghosts/f-3.png")
    // Bind ghost eye textures
    g_EyeTexU       = loadAndBindTexture("eyes/u.png");
    g_EyeTexR       = loadAndBindTexture("eyes/r.png");
    g_EyeTexD       = loadAndBindTexture("eyes/d.png");
    g_EyeTexL       = loadAndBindTexture("eyes/l.png");
    // Bind UI textures
    g_Num0Tex       = loadAndBindTexture("ui/0.png")
    g_Num1Tex       = loadAndBindTexture("ui/1.png")
    g_Num2Tex       = loadAndBindTexture("ui/2.png")
    g_Num3Tex       = loadAndBindTexture("ui/3.png")
    g_Num4Tex       = loadAndBindTexture("ui/4.png")
    g_Num5Tex       = loadAndBindTexture("ui/5.png")
    g_Num6Tex       = loadAndBindTexture("ui/6.png")
    g_Num7Tex       = loadAndBindTexture("ui/7.png")
    g_Num8Tex       = loadAndBindTexture("ui/8.png")
    g_Num9Tex       = loadAndBindTexture("ui/9.png")
    g_ReadyTex      = loadAndBindTexture("ui/ready.png")
    g_PauseTex      = loadAndBindTexture("ui/pause.png")
    g_PauseAltTex   = loadAndBindTexture("ui/pause_alt.png")
    g_QuitTex       = loadAndBindTexture("ui/quit.png")
    g_HelpTex       = loadAndBindTexture("ui/help.png")
    g_ScoreTex      = loadAndBindTexture("ui/score.png")
}

#run
{
    Application.runSurface(100, 100, cast(s32) (300 * Scale), cast(s32) (340 * Scale), title = "Pacman", hook = &onEvent)
}