// Based on the pacman project by Alex Macpherson at https://github.com/alexjamesmacpherson/pacman/blob/master.
// Original code has been modified for Swag.

/*
BSD 3-Clause License

Copyright (c) 2017, Alex Macpherson
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#dependencies
{
    #import "gui" location="swag@std"
}

using Gui, Core, Pixel
const Scale = 3.0

var g_MapTex:       Texture
var g_PillTex:      Texture
var g_BigPillTex:   [2] Texture
var g_Pac0Tex:      Texture
var g_Pac1Tex:      Texture
var g_Pac2Tex:      Texture
var g_ReadyTex:     Texture
var g_PauseTex:     Texture
var g_PauseAltTex:  Texture
var g_QuitTex:      Texture
var g_HelpTex:      Texture
var g_ScoreTex:     Texture
var g_Num0Tex:      Texture
var g_Num1Tex:      Texture
var g_Num2Tex:      Texture
var g_Num3Tex:      Texture
var g_Num4Tex:      Texture
var g_Num5Tex:      Texture
var g_Num6Tex:      Texture
var g_Num7Tex:      Texture
var g_Num8Tex:      Texture
var g_Num9Tex:      Texture
var g_DeadTex:      [11] Texture // Array storing all death animation frames
var g_GhostTexR:    [2] Texture    // Array storing red        ghost sprites
var g_GhostTexP:    [2] Texture    // Array storing pink       ghost sprites
var g_GhostTexB:    [2] Texture    // Array storing blue       ghost sprites
var g_GhostTexY:    [2] Texture    // Array storing yellow     ghost sprites
var g_GhostTexF:    [4] Texture    // Array storing frightened ghost sprites
var g_EyeTexU:      Texture
var g_EyeTexR:      Texture
var g_EyeTexD:      Texture
var g_EyeTexL:      Texture
var g_LifeTex:      Texture
var g_OneUpTex:     Texture
var g_FruitsTex:    [8] Texture     // Array storing all fruit textures
var g_FScoreTex:    [8] Texture     // Array storing all fruit score textures
var g_GScoreTex:    [4] Texture     // Array storing all ghosts score textures
var g_GameOverTex:  Texture

var g_Wnd:          *Wnd
var g_DataPath:     String
var g_Painter:      *Painter
var g_Mode:         GameMode = READY
var g_TempMode:     GameMode = READY
var g_LastTime:     u64

var g_Score:        s32
var g_HighScore:    s32
var g_Level         = 1
var g_Lives         = 2
var g_PillsLeft     = 244
var g_Fruits:       s32
var g_ExtraLife:    bool // True if received
var g_FruitSpawned  = false
var g_GhostsEaten:  s32 // Counts how many ghosts have been eaten since consuming the last big pill

// Fruit timer incremented with each frame - fruit is removed after approx 10s if not eaten
var g_FruitTimer = -1

// Ghost AI targeting is wave-based, varying between CHASE and SCATTER over time
var g_Wave = Movement.SCATTER

// Game ticks, effectively enacting a frame counter
var g_Ticks:        s32

/**
 * Timestamp represents symbolic points in the game, allowing specific frame-based timing from a certain tick:
 *      -1: default, unset state
 * Set to current ticks in a number of situations, effecting a short pause in the game
 * Set to current ticks on entering DEATH-mode, ensuring READY-mode is entered a given number of ticks later
 */
var g_TimeStamp = -1

var g_PacMan: Pacman
var g_Ghosts: [4] Ghost = [
    {13.5, 19, GhostColor.RED},
    {13.5, 16, GhostColor.PINK},
    {11.5, 16, GhostColor.BLUE},
    {15.5, 16, GhostColor.YELLOW}
]

struct Dest
{
    x, y: s32
}

struct Pacman
{
    x           = 13.5      // X position relative to map - float allows for smooth movement between tiles
    y           = 7.0       // Y position relative to map - float allows for smooth movement between tiles
    dir:        Direction   // Direction of movement
    tempDir:    Direction   // Temporary direction storage
    saveDir:    Direction   // Secondary direction storage for stopping and starting animation
    texCount    = 10        // Counter to determine which texture to draw
    ready       = false     // Flag prevents incorrect Pac-Man texture or position rounding at start of game
    dead_tex_count: f32   // Counter to determine which sprite of death animation sequence to draw
    angle:      f32
}

struct Ghost
{
    xInit:  f32   // Initial X position stored for later resets
    yInit:  f32   // Initial Y position stored for later resets
    colour: GhostColor  // Colour of ghost

    x:      f32     // X position relative to map - float allows for smooth movement between tiles
    y:      f32     // Y position relative to map - float allows for smooth movement between tiles

    dPos:   f32     // Delta position - the amount the ghost should move each tick

    dir: Direction      // Direction of movement
    texCount: s32       // Counter to determine which texture to draw

    ai:         Movement    // Movement AI type
    reverse:    bool        // Flag determining whether to reverse the ghost
    timeout:    s32         // Timeout used to determine when to leave FRIGHTENED mode AI, -1 = default
    drawScore:  bool        // Flag determining whether to draw the score for eating this ghost
}

// Enum defines possible ghost colours
enum GhostColor {RED; PINK; BLUE; YELLOW;}

// Enum defines possible ghost movement types
enum Movement {CHASE; SCATTER; FRIGHTENED; DEAD; LEAVE; SPAWN;}

/**
 * Game modes defined as enum:
 *      READY:    Set game to starting state, display READY! text until game begins
 *      PLAY:     Game is in play
 *      FRUIT:    Pause game briefly during play upon eating a fruit
 *      EAT:      Pause game briefly during play upon eating a ghost - the two differ only in what is drawn
 *      PAUSE:    Game is paused, draw help screen
 *      DEATH:    Pac-Man has been eaten, play death sequence
 *      GAMEOVER: Game is over, display GAME OVER text until quit/restart
 * Gamemode is defined as new type for ease of use.
 * Default starting mode is READY
 */
enum GameMode
{
    NONE
    READY
    PLAY
    FRUIT
    EAT
    PAUSE
    DEATH
    GAMEOVER
}

/**
 * Tile types defined as enum:
 *      W: Wall
 *      G: Gate
 *      P: Portal
 *      n: Non-Filled Path
 *      o: Pill
 *      e: Eaten Pill
 *      O: Big Pill
 *      E: Eaten Big Pill
 *      F: Fruit
 * Tile is defined as new type for ease of use.
 * Each tile-type is used to determine behaviour of Pac-Man & Ghosts.
 */
enum Tile {W; G; P; n; o; e; O; E; F;}

// Enum defines possible movement directions
enum Direction {NONE; UP; RIGHT; DOWN; LEFT;}

var g_Map: [28, 31] Tile = [
    [W,W,W,W,W,W,W,W,W,W,W,W,n,n,n,W,P,W,n,n,n,W,W,W,W,W,W,W,W,W,W],
    [W,o,o,o,o,W,W,O,o,o,o,W,n,n,n,W,n,W,n,n,n,W,o,o,o,o,O,o,o,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,W,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,W,W,W,o,W,W,W,W,W,n,W,W,W,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,W],
    [W,o,W,W,W,W,W,o,W,W,o,W,W,W,W,W,n,W,W,W,W,W,W,W,W,o,W,W,W,o,W],
    [W,o,W,W,W,W,W,o,W,W,o,W,W,W,W,W,n,W,W,W,W,W,W,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,W,W,o,n,n,n,n,n,n,n,n,n,W,W,o,o,o,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,W,n,W,W,W,W,W,n,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,W,n,W,W,n,n,W,n,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,o,o,o,W,W,o,o,o,o,W,W,n,W,W,n,n,W,n,n,n,o,W,W,o,o,o,o,o,W],
    [W,o,W,W,W,W,W,n,W,W,W,W,W,n,W,W,n,n,G,n,W,W,W,W,W,o,W,W,W,W,W],
    [W,o,W,W,W,W,W,n,W,W,W,W,W,n,W,W,n,n,G,n,W,W,W,W,W,o,W,W,W,W,W],
    [W,o,o,o,o,W,W,o,o,o,o,W,W,n,W,W,n,n,W,n,n,n,o,W,W,o,o,o,o,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,W,n,W,W,n,n,W,n,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,W,n,W,W,W,W,W,n,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,W,W,o,n,n,n,n,n,n,n,n,n,W,W,o,o,o,o,W,W,W,o,W],
    [W,o,W,W,W,W,W,o,W,W,o,W,W,W,W,W,n,W,W,W,W,W,W,W,W,o,W,W,W,o,W],
    [W,o,W,W,W,W,W,o,W,W,o,W,W,W,W,W,n,W,W,W,W,W,W,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,o,W],
    [W,o,W,W,o,W,W,W,W,W,o,W,W,W,W,W,n,W,W,W,W,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,W,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,o,o,o,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,W,W,o,W,W,o,W,W,o,W,n,n,n,W,n,W,n,n,n,W,o,W,W,o,W,W,W,o,W],
    [W,o,o,o,o,W,W,O,o,o,o,W,n,n,n,W,n,W,n,n,n,W,o,o,o,o,O,o,o,o,W],
    [W,W,W,W,W,W,W,W,W,W,W,W,n,n,n,W,P,W,n,n,n,W,W,W,W,W,W,W,W,W,W]
]

impl Ghost
{
    mtd reset()
    {
        x = xInit
        y = yInit
        dPos = 0.1
        texCount = 0
        reverse = false
        timeout = -1
        drawScore = false

        // Reset starting direction and movement type based on colour
        switch colour
        {
        case RED:
            dir = .LEFT
            ai = g_Wave         // RED starts outside the pen and is immediately in the first targeting mode defined by wave
        case PINK:
            dir = .DOWN
            ai = .LEAVE         // PINK starts in LEAVE mode, leaving the SPAWN pen straight away
        case BLUE, YELLOW:      // YELLOW and BLUE both start facing UP, trapped within the SPAWN
            dir = .UP
            ai = .SPAWN
        }
    }

    /**
     * Update the ghost's AI movement mode, reversing its direction on doing so if required
     *
     * @param newAI - AI movement type for ghost to now use
     */
    mtd setAI(newAI: Movement, switchDir: bool)
    {
        ai = newAI
        reverse = switchDir

        // Some AI modes have additional cases to account for
        if newAI == .FRIGHTENED
        {
            setSpeed(40)       // FRIGHTENED ghosts also move at 50% speed
        }
        elif newAI == .DEAD
        {
            setSpeed(200)      // DEAD ghosts move at 200% speed, racing back to the SPAWN pen
            drawScore = true   // Flag also ensures the score for eating a ghost is displayed during the short pause
        }
    }

    /**
     * Timeout set independently from AI, ensuring all ghosts carry the same timeout value
     *
     * This is necessary for how timeout is reset - take the following scenario:
     *      Pac-Man eats a big pill and all ghosts enter FRIGHTENED
     *      A ghost is eaten and will no longer register as FRIGHTENED
     *      Another big pill is eaten while this ghost is dead, timeout is set to 0 for all living ghosts as they enter/remain FRIGHTENED
     *      When the ghost respawns, it's timer is now ahead of all other FRIGHTENED ghosts
     *      When its timer expires, the eaten ghost count is reset, removing any score multiplier accrued even though other ghosts remain FRIGHTENED
     *
     * Obviously, this is a very rare case, but separating the timeout being set to zero prevents it occurring
     */
    mtd zeroTimeout()
    {
        timeout = 0;    // FRIGHTENED mode requires a timeout to ensure ghosts don't remain FRIGHTENED indefinitely
    }

    mtd checkSpecialCases()
    {
        if timeout >= 600      // Timeout exceeds max time to be in FRIGHTENED mode
        {
            if ai == .FRIGHTENED
            {
                ai = g_Wave     // If FRIGHTENED, enter wave-based AI
                setSpeed(100)   // Ensure speed is correctly reset to 100%
            }
            timeout = -1       // Reset timeout
            g_GhostsEaten = 0    // Reset eaten ghosts count to zero as effects of big pill have ended - score bonus should not carry
        }
        elif timeout != -1  // If not at max timeout, increment counter
            timeout += 1

        if ai == .DEAD
        {
            if x >= 13.4 and x <= 13.6  // Check X position to check centrality
            {
                if getY() == 19    // Check ghost is also directly above the SPAWN pen
                {
                    x = 13.5       // Correctly center X coordinate
                    dir = .DOWN     // Set ghost to enter the SPAWN pen
                    setSpeed(50)
                }
                elif getY() < 17 and getY() >= 15
                {
                    ai = .LEAVE     // Once far enough into the pen, set AI to LEAVE to 'respawn' the ghost
                }
            }
        }
    }

    /**
     * Special movement behaviour:
     *      Very simply move ghost up and down within the SPAWN pen
     */
    mtd aiSpawn()
    {
        setSpeed(50)   // Set movement speed to 50%
        if cast(s32)(y * 10.0) % 10 == 5 and cast(s32)(x * 10.0) % 10 == 5 and isImpassible(getNextTile(dir))
        {
            switch dir // Switch direction upon hitting a WALL
            {
            case UP:    dir = DOWN
            case DOWN:  dir = UP
            }
        }
    }

    /**
     * Special movement behaviour:
     *      If within SPAWN pen and not heading down, move towards the center of the enclosure
     *      Once at center of pen, head up until exited PEN
     *      Immediately head LEFT and set speed to 100%
     *      Once the first tile center is reached, enter AI of current wave
     */
    mtd aiLeave()
    {
        if y < 19 and dir != .DOWN
        {
            setSpeed(50) // Set movement speed to 50%
            if x < 13.4  // Move towards the center
                dir = .RIGHT
            elif x > 13.6
                dir = .LEFT
            else
            {
                x = 13.5   // Truly center position when center of pen is reached
                dir = .UP   // Then set direction to move out of the SPAWN
            }
        }
        elif y >= 19 // Once out of the SPAWN, act as a normal ghost
        {
            dir = .LEFT    // Begin heading LEFT
            ai = g_Wave    // Enter the current AI wave
            setSpeed(100)  // Ensure speed is correctly set to 100%
        }
        elif cast(s32)(y * 10.0) % 10 == 5 and isImpassible(getNextTile(dir))
            dir = .UP
    }

    mtd aiScatter()
    {
        var target: Dest
        switch colour              // Each colour selects a unique corner to target
        {
        case RED:
            target = {25, 33}
        case PINK:
            target = {2, 33}
        case BLUE:
            target = {27, -2}
        case YELLOW:
            target = {0, -2}
        }

        dir = targetTile(target) // Set direction at junction to head towards SCATTER point
        setSpeed(100) // Ensure movement speed is set to 100%
    }

    /**
     * Calculate a target as Pac-Man's position +- an offset of given size in Pac-Man's direction of movement
     *
     * @param offsetSize - Size of offset to apply
     * @return -           New target vector, accounting for offset
     */
    func targetPacmanOffsetBy(offsetSize: s32)->Dest
    {
        var offset: retval = {g_PacMan.getX(), g_PacMan.getY()}
        switch g_PacMan.dir   // Apply offset to correct coordinate based on Pacman's direction
        {
        case UP:    offset.y += offsetSize
        case RIGHT: offset.x += offsetSize
        case DOWN:  offset.y -= offsetSize
        case LEFT:  offset.x -= offsetSize
        }

        return offset  // Return the new target vector, accounting for the offset
    }

    /**
     * CHASE mode AI is different for every ghost colour:
     *      RED:    Targets and chases Pac-Man
     *      PINK:   Targets four tiles ahead of Pac-Man in his direction of movement, attempting an ambush tactic
     *      BLUE:   The most complex AI type (explained below) often acts somewhat erratically
     *              However, if RED is closely chasing Pac-Man, BLUE will generally also be in pursuit:
     *                      Find point two tiles ahead of Pac-Man
     *                      Find vector from RED ghost to this point
     *                      Double this vector - the point at the end of this doubled vector is the target
     *      YELLOW: Targets and chases Pac-Man as RED does until within 8 tiles range, then emulating SCATTER behaviour
     */
    mtd aiChase(redGhost: Ghost)
    {
        var target: Dest = {g_PacMan.getX(), g_PacMan.getY()}   // Default target for RED and (sometimes) YELLOW
        var current_pos: Dest = {getX(), getY()}            // Current position, stored as vector
        var d_x: s32    // Delta X initialised for use in BLUE's targeting
        var d_y: s32    // Delta Y initialised for use in BLUE's targeting

        // Determine ghost chasing behaviour based on their colour
        switch colour
        {
        case PINK:                            // PINK looks ahead of Pac-Man and tries to ambush him
            target = targetPacmanOffsetBy(4)   // Update target to reflect offset in Pac-Man's direction of movement
        case BLUE:
            target = targetPacmanOffsetBy(2)   // Start by finding the point 2 tiles ahead of Pac-Man in his direction of movement
            d_x = target.x - redGhost.getX()  // Find the X difference between this point and RED ghost
            d_y = target.y - redGhost.getY()  // Find the Y difference between this point and RED ghost
            // BLUE's target is then twice the change in X and Y from RED's position
            target = {redGhost.getX() + 2 * d_x, redGhost.getY() + 2 * d_y}
        case YELLOW:
            if distanceBetween(current_pos, target) <= 8   // If YELLOW is closer than 8 tiles to Pac-Man, he chases as RED does
                target = {0, -2}                           // If closer than 8 tiles, it emulates SCATTER AI behaviour
        }

        dir = targetTile(target)   // Set direction to that of least straight line distance to target
        setSpeed(100)              // Set movement speed to 100%
    }

    /**
     * FRIGHTENED mode AI chooses a direction randomly at each junction, moving at half speed
     */
    mtd aiFrightened()
    {
        var newDir: Direction
        loop
        {
            newDir = cast(Direction) ((Random.shared().nextU32() % cast(u32) Direction.LEFT) + 1)   // Choose random direction from UP, RIGHT, DOWN or LEFT
            // Ensure random direction is traversible
            if !isImpassible(getNextTile(newDir))
            {
                dir = newDir   // Set new direction
                setSpeed(40)   // Set movement speed to 50%
                break
            }
        }
    }

    /**
     * DEAD mode AI races back to the SPAWN pen at 200% speed
     */
    mtd aiDead()
    {
        let target: Dest = {14, 19}     // Coordinate directly above SPAWN entrance
        dir = targetTile(target)
        setSpeed(200)
    }

    /**
     * Calculate and return the straight line distance between two points (tiles) in the map
     *
     * @param p1 - Vector storing the x,y map coordinates of the first point
     * @param p2 - Vector storing the x,y map coordinates of the second point
     * @return -   Straight line distance between p1 and p2, floating point precision
     */
    func distanceBetween(p1, p2: Dest)->f32
    {
        let d_x = cast(f32) p1.x - p2.x
        let d_y = cast(f32) p1.y - p2.y
        return Math.sqrt((d_x * d_x) + (d_y * d_y)) // Simple pythagorean calculation
    }

    /**
     * Determine the direction from the current junction which yields the closest straight line distance to a target tile
     *      Method checks the next tile in every traversible direction from the junction
     *      The optimal direction is only updated should it prove closer than previously checked exits
     *
     * Note: this does not always give the shortest PATH to the target
     *      However, this behaviour is as the original Pac-Man was designed
     *
     * @param target - Vector storing the x,y map coordinates of the target tile
     * @return -       Direction of shortest straight line distance to target
     */
    mtd targetTile(target: Dest)->Direction
    {
        var next_pos: Dest    // Initialise next position, updated in each possible direction
        var distance = 999.0    // Set max distance to unreachable value
        var newDir: Direction       // Initialise returned direction

        // Check UP exit
        // UP exits have an additional condition such that, at 4 specific intersections, the ghost cannot opt to travel UP
        if !(getY() == 19 and (getX() == 12 or getX() == 15)) and !(getY() == 7 and (getX() == 12 or getX() == 15))
        {
            if dir != .DOWN and !isImpassible(getNextTile(.UP))   // Prevent direction reversing and ensure exit is traversible
            {
                next_pos = {getX(), getY() + 1}
                let d = distanceBetween(next_pos, target)    // Get distance between target and next tile in exit direction
                if d < distance                                // If distance is shorter than any previously found, update direction to be returned
                {                                               // Also update lowest found distance for future checks
                    distance = d
                    newDir = .UP                                // This process is repeated for all traversible exits from the current junction
                }
            }
        }

        // Check RIGHT exit
        if dir != .LEFT and !isImpassible(getNextTile(.RIGHT))
        {
            next_pos = {getX() + 1, getY()};
            let d = distanceBetween(next_pos, target)
            if d < distance
            {
                distance = d;
                newDir = .RIGHT
            }
        }

        // Check DOWN exit
        if dir != .UP and !isImpassible(getNextTile(.DOWN))
        {
            next_pos = {getX(), getY() - 1}
            let d = distanceBetween(next_pos, target)
            if d < distance
            {
                distance = d
                newDir = .DOWN
            }
        }

        // Check LEFT exit
        if dir != .RIGHT and !isImpassible(getNextTile(.LEFT))
        {
            next_pos = {getX() - 1, getY()}
            let d = distanceBetween(next_pos, target)
            if d < distance
            {
                distance = d
                newDir = .LEFT
            }
        }

        return newDir  // Return newly found direction, yielding lowest straight line distance to target
    }

    mtd reverseDirection()
    {
        switch dir
        {
        case UP:    dir = DOWN
        case RIGHT: dir = LEFT
        case DOWN:  dir = UP
        case LEFT:  dir = RIGHT
        }

        reverse = false
    }

    mtd turnCorner()
    {
        if dir != .DOWN and !isImpassible(getNextTile(.UP))
            dir = .UP
        elif dir != .LEFT and !isImpassible(getNextTile(.RIGHT))
            dir = .RIGHT
        elif dir != .UP and !isImpassible(getNextTile(.DOWN))
            dir = .DOWN
        elif dir != .RIGHT and !isImpassible(getNextTile(.LEFT))
            dir = .LEFT
    }

    /**
     * When setting the speed of a ghost, it is necessary to round the ghost's coordinates to the correct degree of precision
     *
     * Rounding prevents errors such as being unable to recognise the center of a tile or overshooting a junction when changing speeds
     *      EXAMPLE CASE:   Ghost is travelling at 50% speed (FRIGHTENED) so increases position by 0.05 each tick
     *                      Upon death, its speed is incremented to 200%, moving by 0.2 tiles each tick
     *                      Suppose the ghost was eaten at x=12.05 - possible when moving at 50% speed
     *                      Its position will now be unable to round to x=12.0 to ascertain it is at the center of a tile
     *
     * Because of cases like the above, position rounding is necessary when changing speeds
     */
    mtd roundPosition()
    {
        x = Math.round(x / dPos) * dPos
        y = Math.round(y / dPos) * dPos
    }

    /**
     * Set the speed of the ghost and round the position to account for movement precision inaccuracies
     *
     * @param percentage - Float representing speed. 100% sets d_pos=0.1f (normal playing speed)
     */
    mtd setSpeed(percentage: f32)
    {
        dPos = percentage / 1000
        roundPosition()
    }

    mtd countExits()->s32
    {
        var exits = 0
        if atTileCenter()
        {
            if !isImpassible(getNextTile(.UP))
                exits += 1
            if !isImpassible(getNextTile(.RIGHT))
                exits += 1
            if !isImpassible(getNextTile(.DOWN))
                exits += 1
            if !isImpassible(getNextTile(.LEFT))
                exits += 1
        }

        return exits
    }

    /**
     * Determines and returns absolute X coordinate of map tile on which ghost resides
     *
     * @return - integer, X coordinate of current tile
     */
    mtd const getX() => cast(s32) Math.round(x)

    /**
     * Determines and returns absolute Y coordinate of map tile on which ghost resides
     *
     * @return - integer, Y coordinate of current tile
     */
    mtd const getY() => cast(s32) Math.round(y)

    /**
     * Determines and returns the next tile in the given direction of movement
     *
     * @param d - direction of movement in which to check to the next tile
     * @return -  next tile in direction d
     */
    mtd getNextTile(d: Direction)->Tile
    {
        // Return next tile in given direction
        switch d
        {
        case UP:    return getTile(getX(), getY()+1)
        case RIGHT: return getTile(getX()+1, getY())
        case DOWN:  return getTile(getX(), getY()-1)
        case LEFT:  return getTile(getX()-1, getY())
        default:    return getTile(getX(), getY())  // If d=NONE, return current tile
        }
    }

    /**
     * Determines whether ghost is currently at the center of a tile
     * Expression basically validates that the first decimal point of each coordinate is a zero
     * If each is a zero, ghost is at the center of his tile
     *
     * @return - boolean, true if at center
     */
    mtd atTileCenter()->bool
    {
        let mod = cast(s32) (1/dPos)
        return cast(s32) Math.round(y * mod) % mod == 0 and cast(s32) Math.round(x * mod) % mod == 0
    }

    mtd move(redGhost: Ghost)
    {
        // Check any special case AI behaviour
        checkSpecialCases()

        // Handle special case movement behaviours
        if ai == .SPAWN     // Behaviour within SPAWN pen
            aiSpawn()
        elif ai == .LEAVE   // AI to LEAVE SPAWN pen
            aiLeave()
        // Handle PORTAL collision - only teleport if at center of tile
        elif atTileCenter() and getTile(getX(), getY()) == .P
        {
            if dir == .RIGHT
                x = 1
            else
                x = 26
        }
        // If the a new AI mode has been set, reverse the current direction
        elif reverse
            reverseDirection()
        // If no special case exists, direction can only be changed when 2 or more exits exist
        elif countExits() == 2 and isImpassible(getNextTile(dir))    // Ghost is at corner so must turn
            turnCorner()
        elif countExits() > 2   // Ghost is at junction - run targeting AI and update direction
        {
            switch ai
            {
            case SCATTER:       // Scatter all ghosts to each of the four corners
                aiScatter()
            case CHASE:         // Target and hunt Pac-Man, passing RED ghost for BLUE's AI
                aiChase(redGhost)
            case FRIGHTENED:    // Flee from Pac-Man randomly
                aiFrightened()
            case DEAD:
                aiDead()
            }
        }

        // Half speed when travelling down PORTAL corridors
        if getY() == 16 and (getX() < 6 or getX() > 21) and ai != .DEAD
            setSpeed(50)

        // Perform smooth movement between tiles in the current direction of movement
        // Round the unchanging position coordinate, preventing directional query mishaps
        switch dir
        {
        case LEFT:
            x -= dPos
            if ai != .LEAVE
                y = Math.round(y)
        case RIGHT:
            x += dPos
            if ai != .LEAVE
                y = Math.round(y)
        case UP:
            y += dPos
            if ai != .SPAWN and ai != .LEAVE and ai != .DEAD
                x = Math.round(x)
        case DOWN:
            y -= dPos
            if ai != .SPAWN and ai != .LEAVE and ai != .DEAD
                x = Math.round(x)
        }
    }

    /**
     * If ghost has just been eaten, draw the score for eating it, otherwise draw as normal
     */
    mtd drawEaten()
    {
        if drawScore
        {
            g_Painter.pushTransform()

            translateMapOrigin()               // Translate to map origin
            translateMapCoords(x,y)            // Translate to current (x,y)
            //glTranslatef(-4.0f, 0.0f, 0.0f);    // Account for over-sized sprite (16x8 on 8x8 tile)

            // Determine which score sprite to draw based on the number of ghosts eaten since the last big pill was eaten
            let ghostScore = Math.min(g_GhostsEaten - 1, 3)

            // Draw correct score sprite at current location
            g_Painter.drawTexture(0, 0, 16, 8, g_GScoreTex[ghostScore])

            g_Painter.popTransform()
        }
        else
            draw()     // If the ghost hasn't just been eaten, draw it as normal
    }

    mtd draw()
    {
        // Reset drawScore flag - when eaten, drawEaten() is called during pause, do not draw score again
        drawScore = false

        g_Painter.pushTransform()

        translateMapOrigin()               // Translate to map origin
        translateMapCoords(x,y)            // Translate to current (x,y)
        g_Painter.translateTransform(-3*Scale, -3*Scale)// Account for over-sized sprite (14x14 on 8x8 tile)
        g_Painter.translateTransform(7*Scale, 7*Scale)

        // Determine which colour ghost to draw and whether it is the alternate texture (wiggle animation)
        var ghostTex: Texture
        let ghostAlt = cast(s32) Math.floor(texCount % 20 / 10.0)

        if ai == .FRIGHTENED    // If in FRIGHTENED mode, draw the correct skin
        {
            if timeout >= 480 and texCount % 30 >= 15   // Draw white (flashing) skin when FRIGHTENED mode is nearing its end
                ghostTex = g_GhostTexF[ghostAlt + 2]
            else
                ghostTex = g_GhostTexF[ghostAlt]
        }
        else if ai != .DEAD
        {
            switch colour // If not in FRIGHTENED or DEAD AI, draw the ghost according to colour
            {
                case RED:       ghostTex = g_GhostTexR[ghostAlt]
                case PINK:      ghostTex = g_GhostTexP[ghostAlt]
                case BLUE:      ghostTex = g_GhostTexB[ghostAlt]
                case YELLOW:    ghostTex = g_GhostTexY[ghostAlt]
            }
        }

        // Draw ghost sprite with determined texture at current location only if not DEAD
        if ai != .DEAD
            g_Painter.drawTexture(-7, -7, 14, 14, ghostTex)

        // Only draw the ghost's eyes if it's not FRIGHTENED
        if ai != .FRIGHTENED
        {
            // Determine which way the ghost's eyes should be facing
            var eyesTex: Texture
            switch dir
            {
            case UP:    eyesTex = g_EyeTexU
            case RIGHT: eyesTex = g_EyeTexR
            case DOWN:  eyesTex = g_EyeTexD
            case LEFT:  eyesTex = g_EyeTexL
            }

            // Draw direction-based eyes sprite atop ghost body
            g_Painter.drawTexture(-7, -7, 14, 14, eyesTex)
        }

        // Increment texture counter every frame
        texCount += 1

        g_Painter.popTransform()
    }
}

impl Pacman
{
    mtd reset()
    {
        x = 13.5
        y = 7.0
        angle = 0.0
        dir = .NONE
        tempDir = .NONE
        texCount = 10
        dead_tex_count = 0
        ready = false
    }

    /**
     * Determines whether Pac-Man is currently at the center of a tile
     * Expression basically validates that the first decimal point of each coordinate is a zero
     * If each is a zero, Pac-Man is at the center of his tile
     *
     * @return - boolean, true if at center
     */
    mtd atTileCenter()->bool
    {
        return cast(s32) Math.round(y * 10.0) % 10 == 0 and cast(s32) Math.round(x * 10.0) % 10 == 0
    }

    /**
     * Determines and returns absolute X coordinate of map tile on which Pac-Man resides
     *
     * @return - integer, X coordinate of current tile
     */
    mtd getX()->s32
    {
        return cast(s32) Math.round(x)
    }

    /**
     * Determines and returns absolute Y coordinate of map tile on which Pac-Man resides
     *
     * @return - integer, Y coordinate of current tile
     */
    mtd getY()->s32
    {
        return cast(s32) Math.round(y)
    }

    mtd eat()->s32
    {
        if !atTileCenter()
            return 0

        switch getTile(getX(), getY())
        {
        case o:
            setTile(getX(),getY(),e)
            g_PillsLeft -= 1
            return 10
        case O:
            setTile(getX(),getY(),E)
            g_PillsLeft -= 1
            return 50
        case P:
            if dir == .RIGHT
                x = 1
            else
                x = 26
            return 0
        case F:
            setTile(getX(),getY(),.e)
            g_FruitSpawned = false
            g_Fruits += 1
            switch g_Fruits-1
            {
                case 0: return 100
                case 1: return 300
                case 2: return 500
                case 3: return 700
                case 4: return 1000
                case 5: return 2000
                case 6: return 3000
                case 7: return 5000
            }
        }

        return 0
    }

    /**
     * Determines and returns the next tile in the given direction of movement
     *
     * @param d - direction of movement in which to check to the next tile
     * @return -  next tile in direction d
     */
    mtd getNextTile(d: Direction)->Tile
    {
        // Return next tile in given direction
        switch d
        {
        case UP:    return getTile(getX(), getY()+1)
        case RIGHT: return getTile(getX()+1, getY())
        case DOWN:  return getTile(getX(), getY()-1)
        case LEFT:  return getTile(getX()-1, getY())
        default:    return getTile(getX(), getY())  // If d=NONE, return current tile
        }
    }

    mtd move()
    {
        // Ascertain whether direction can be changed
        // Direction can only be changed at the center of a tile
        if atTileCenter()
        {
            if !isImpassible(getNextTile(tempDir)) // If the proposed direction is not impassible, update direction
                dir = tempDir
            elif isImpassible(getNextTile(dir)) // If the current direction is impassible, set dir=NONE
                dir = .NONE
        }

        // The only exception to the above rule is at game start (when ready=false), as Pac-Man starts between two tiles
        if !ready and tempDir != .NONE and !isImpassible(getNextTile(tempDir))
        {
            dir = tempDir
            if !ready
                ready = true   // Ready flag is set to true, enabling position rounding when dir=NONE and correct texture drawing
        }

        // Perform smooth movement between tiles in the current direction of movement
        // While moving, round the unchanging position coordinate, preventing directional query mishaps
        switch dir
        {
        case LEFT:
            x -= 0.1
            y = Math.round(y)
        case RIGHT:
            x += 0.1
            y = Math.round(y)
        case UP:
            y += 0.1
            x = Math.round(x)
        case DOWN:
            y -= 0.1
            x = Math.round(x)
        default:                // If not moving, round both coordinates, centering Pac-Man within the tile
            if ready            // Only do if Pac-Man has already moved (ready=true)
            {                   // This allows starting X position to be non-rounded
                x = Math.round(x)
                y = Math.round(y)
            }
        }
    }

    /**
     * Stop Pac-Man's eating animation when he dies/completes level or pause it upon eating a ghost - also save tempDir
     */
    mtd stopChomping()
    {
        saveDir = tempDir
        tempDir = .NONE
        ready = false
    }

    /**
     * Restart Pac-Man's eating animation, resetting tempDir if it hasn't since been changed
     */
    mtd startChomping()
    {
        if tempDir == .NONE
            tempDir = saveDir
        ready = true
    }

    /**
     * Draw Pac-Man's death animation sequence at his current location
     */
    mtd drawDead()
    {
        g_Painter.pushTransform()

        translateMapOrigin()               // Translate to map origin
        translateMapCoords(x,y)            // Translate to current (x,y)
        g_Painter.translateTransform(-3*Scale, -4*Scale) // Account for over-sized sprite (15x15 on 8x8 tile)
        g_Painter.translateTransform(7.5*Scale, 7.5*Scale)

        // Determine which texture to draw based on tick-incremented counter
        let deadFrame = cast(s32) Math.floor(dead_tex_count / 5)

        // Draw current sprite of Pac-Man's death animation sequence
        if dead_tex_count < 55
        {
            let pacman_tex = g_DeadTex[deadFrame]
            g_Painter.drawTexture(-7.5, -7.5, 15, 15, pacman_tex)
        }

        // Increment dead texture counter
        dead_tex_count += 1

        g_Painter.popTransform()
    }

    /**
     * Upon eating a fruit, draw the score for eating said fruit during the short pause INSTEAD of drawing Pac-Man
     */
    mtd drawFruitScore()
    {
        g_Painter.pushTransform()

        translateMapOrigin()               // Translate to map origin
        translateMapCoords(x,y)            // Translate to current (x,y)
        g_Painter.translateTransform(-6*Scale, 0)   // Account for over-sized sprite (20x8 on 8x8 tile)
        g_Painter.translateTransform(10*Scale, 4*Scale)

        // Determine which fruit score texture to draw based on how many fruits have been eaten
        g_Painter.drawTexture(-10, -4, 20, 8, g_FScoreTex[g_Fruits - 1])

        g_Painter.popTransform()
    }

    mtd draw()
    {
        g_Painter.pushTransform()
        translateMapOrigin()
        translateMapCoords(x,y)
        g_Painter.translateTransform(-2*Scale,-2*Scale)
        g_Painter.translateTransform(6.5*Scale,6.5*Scale)

        // Determine rotation angle of sprite based on direction
        switch dir
        {
        case UP:    angle = 270.0
        case RIGHT: angle = 180.0
        case DOWN:  angle = 90.0
        case LEFT:  angle = 0.0
        }

        g_Painter.rotateTransformInPlace(Math.toRadians(angle))

        // Determine which texture to draw based on tick-incremented counter
        var pacmanTex: Texture
        if texCount % 20 < 5
            pacmanTex = g_Pac0Tex
        elif texCount % 20 < 10 or texCount % 20 >= 15
            pacmanTex = g_Pac1Tex
        else
            pacmanTex = g_Pac2Tex

        // Draw Pac-Man sprite with determined texture at determined angle
        g_Painter.drawTexture(-6.5, -6.5, 13, 13, pacmanTex)

        // Increment texture counter only if moving
        // If stationary, continue until sprite animation cycle is complete
        if !(dir == .NONE and texCount % 20 < 5) and ready
            texCount += 1

        g_Painter.popTransform()
    }
}

func translateMapOrigin()           = g_Painter.translateTransform(38.0, 26.0)
func translateMapCoords(x, y: f32)  = g_Painter.translateTransform(x*8*Scale, y*8*Scale)
func getTile(x, y: s32)->Tile       => g_Map[x, y]
func setTile(x, y: s32, t: Tile)    = g_Map[x, y] = t
func isImpassible(t: Tile)          => t == .W or t == .G

func drawMap()
{
    g_Painter.pushTransform()
    translateMapOrigin()

    // Map
    g_Painter.drawTexture(0, 0, 224, 248, g_MapTex)

    // Content
    loop x: 28
    {
        g_Painter.pushTransform()
        loop y: 31
        {
            // Determine size of big pills to draw depending on ticks
            let bigPill = cast(s32) Math.floor((g_Ticks%40) / 20.0)

            switch getTile(x,y) // Draw pills as sprites
            {
                case o:
                    g_Painter.drawTexture(0, 0, 8, 8, g_PillTex)
                case O:
                    g_Painter.drawTexture(0, 0, 8, 8, g_BigPillTex[bigPill]) // Draw big pill of determined size
                case F:
                    drawFruit(x,y)  // Method to determine which fruit should be drawn at current location
            }

            translateMapCoords(0,1) // Increment Y pos
        }

        g_Painter.popTransform()
        translateMapCoords(1,0) // Increment X pos
    }

    g_Painter.popTransform()
}

func drawLevel()
{
    g_Painter.pushTransform()
    translateMapOrigin()               // Translate to map origin
    translateMapCoords(1,32.5)         // Translate to point above map at which the 1UP tooltip should be drawn
    g_Painter.drawTexture(0, 0, 24, 8, g_OneUpTex)   // Draw 1UP tooltip at current location
    translateMapCoords(3,-1)           // Translate to point above map at which the level should be drawn
    drawNumberAsSprite(g_Level)          // Draw level sprites at new location
    g_Painter.popTransform()
}

/**
 * Draws a number as a set of sprites
 *
 * @param number - integer number to draw
 */
func drawNumberAsSprite(number: s32)
{
    g_Painter.pushTransform()

    let str = Format.toString("%", number) // Convert number to string to allow iteration
    loop i: str.length-1..0
    {
        switch str[i]
        {
        case "0"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num0Tex)     // Draw number 0 sprite at current location
        case "1"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num1Tex);    // Draw number 1 sprite at current location
        case "2"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num2Tex)     // Draw number 2 sprite at current location
        case "3"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num3Tex)     // Draw number 3 sprite at current location
        case "4"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num4Tex)     // Draw number 4 sprite at current location
        case "5"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num5Tex)     // Draw number 5 sprite at current location
        case "6"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num6Tex)     // Draw number 6 sprite at current location
        case "7"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num7Tex)     // Draw number 7 sprite at current location
        case "8"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num8Tex)     // Draw number 8 sprite at current location
        case "9"'u8:    g_Painter.drawTexture(0, 0, 8, 8, g_Num9Tex)     // Draw number 9 sprite at current location
        }

        translateMapCoords(-1,0)    // Translate one tile left for next digit
    }

    // If number is a single digit, justify with another zero
    if str.length == 1
        g_Painter.drawTexture(0, 0, 8, 8, g_Num0Tex)

    g_Painter.popTransform()
}

func drawScore()
{
    g_Painter.pushTransform()

    translateMapOrigin()                            // Translate to map origin
    translateMapCoords(6.5, 32.5)             // Translate to point above map at which the score tooltip should be drawn
    g_Painter.drawTexture(0, 0, 80, 8, g_ScoreTex)  // Draw SCORE tooltip at current location

    translateMapCoords(4,-1)                        // Translate to point above map at which the high score should be drawn
    drawNumberAsSprite(Math.min(g_HighScore,99999)) // Draw high score sprites at current location
    translateMapCoords(6,0)                         // Translate to point above map at which the score should be drawn
    drawNumberAsSprite(Math.min(g_Score,99999))     // Draw score sprites at current location

    g_Painter.popTransform()
}

func drawLives()
{
    g_Painter.pushTransform()

    translateMapOrigin();                   // Translate to map origin
    translateMapCoords(1,-2.5)              // Translate to point beneath map, from which lives should be drawn
    loop i: g_Lives
    {
        g_Painter.drawTexture(0, 0, 14, 14, g_LifeTex)    // Draw life counter sprite at current location
        translateMapCoords(2,0)            // Translate to right where next life counter sprite should be drawn
    }

    g_Painter.popTransform()
}

func drawFruits()
{
    g_Painter.pushTransform()

    translateMapOrigin()                       // Translate to map origin
    translateMapCoords(25,-2.5)                // Translate to point beneath map, from which lives should be drawn
    loop i: g_Fruits
    {
        g_Painter.drawTexture(0, 0, 14, 14, g_FruitsTex[i])   // Draw life counter sprite at current location
        translateMapCoords(-2,0)               // Translate to right where next life counter sprite should be drawn
    }

    g_Painter.popTransform()
}

func drawCharacters()
{
    g_PacMan.draw();
    loop i: 4
        g_Ghosts[i].draw()
}

func drawHelp()
{
    g_Painter.pushTransform()
    translateMapOrigin()      // Translate to map origin
    translateMapCoords(19,32) // Translate to point above map at which the HELP tooltip should be drawn
    g_Painter.drawTexture(0, 0, 64, 8, g_HelpTex) // Draw HELP tooltip at current location
    g_Painter.popTransform()
}

func drawGameover()
{
    g_Painter.pushTransform()
    translateMapOrigin()               // Translate to map origin
    translateMapCoords(9,13)           // Translate to point within map at which GAME OVER tooltip should be drawn
    g_Painter.drawTexture(0, 0, 80, 8, g_GameOverTex) // Draw GAME OVER sprite at current location
    g_Painter.popTransform()
}

func drawReady()
{
    g_Painter.pushTransform()
    translateMapOrigin()      // Translate to map origin
    translateMapCoords(11,13) // Translate to point within map at which READY! tooltip should be drawn
    g_Painter.drawTexture(0, 0, 48, 8, g_ReadyTex) // Draw READY! sprite at current location
    g_Painter.popTransform()
}

func drawPause(gameover: bool)
{
    g_Painter.pushTransform()
    translateMapOrigin()      // Translate to map origin
    if !gameover
        g_Painter.drawTexture(0, 0, 224, 248, g_PauseTex) // Draw PAUSE screen as a sprite
    else
        g_Painter.drawTexture(0, 0, 224, 248, g_PauseAltTex) // Draw alternate PAUSE screen as a sprite (restart text only when mode=GAMEOVER)
    g_Painter.popTransform()
}

func drawQuit()
{
    g_Painter.pushTransform()
    translateMapOrigin()      // Translate to map origin
    translateMapCoords(19,32) // Translate to point above map at which the QUIT tooltip should be drawn
    g_Painter.drawTexture(0, 0, 64, 8, g_QuitTex) // Draw QUIT tooltip at current location
    g_Painter.popTransform()
}

func drawPlayScreen()
{
    drawMap()
    drawLevel()
    drawScore()
    drawLives()
    drawFruits()
    drawHelp()
}

func display()
{
    let rect = g_Wnd.getClientRect()
    g_Painter.fillRect(rect, Argb.Black)
    g_Painter.scaleTransform(Scale, Scale)

    switch g_Mode
    {
    case READY:
        drawPlayScreen()
        drawCharacters()
        drawReady()

    case PLAY:
        drawPlayScreen()
        drawCharacters()

    case FRUIT:
        drawPlayScreen()
        loop i: 4
            g_Ghosts[i].draw()
        g_PacMan.drawFruitScore()

    case EAT:
        drawPlayScreen()
        loop i: 4
            g_Ghosts[i].drawEaten()

    case PAUSE:
        drawPause(g_TempMode == GAMEOVER)
        drawLevel()
        drawScore()
        drawLives()
        drawFruits()
        drawQuit()

    case DEATH:
        drawPlayScreen()
        g_PacMan.drawDead()

    case GAMEOVER:
        drawPlayScreen()
        drawGameover()
    }
}

/**
 * Check all possible collisions:
 *      Call Pac-Man to eat its current tile, incrementing score accordingly
 *       - If all pills are eaten, move to the next level
 *       - Once score exceeds 10,000, award a bonus life
 *       - On eating a big pill, set ghosts to FRIGHTENED
 *       - Release ghosts from the SPAWN pen after a specific number of pills have been eaten
 *       - If a fruit is eaten, pause the game briefly to display the score for eating it
 *      Check whether Pac-Man has collided with a ghost
 *       - Set mode=DEATH if collision has occurred with alive ghost
 *       - If the ghost is frightened, eat it (set AI=DEAD)
 */
func checkCollisions()
{
    // Eat current tile, increment score
    let scoreIncrement = g_PacMan.eat()
    g_Score += scoreIncrement

    if scoreIncrement == 50        // If score is increased by 50, a big pill has been eaten - set ghosts to FRIGHTENED
    {
        loop i: 4
        {
            g_Ghosts[i].zeroTimeout()    // Reset ghost FRIGHT timeout
            if g_Ghosts[i].ai == g_Wave or g_Ghosts[i].ai == .FRIGHTENED
                g_Ghosts[i].setAI(.FRIGHTENED, true)  // Set AI to FRIGHTENED if possible
        }
    }
    elif scoreIncrement >= 100  // If score is increased by more than 100, a fruit has been eaten, pause game briefly to show score
    {
        g_TimeStamp = g_Ticks
        g_PacMan.stopChomping()
        g_Mode = .FRUIT
    }

    // Award extra life for reaching 10000 points
    if !g_ExtraLife and g_Score > 10000
    {
        g_Lives += 1
        g_ExtraLife = true
    }

    // If all pills have been eaten, stop Pac-Man's animation and set timestamp to restart level after short pause
    if g_PillsLeft == 0
    {
        g_TimeStamp = g_Ticks
        g_PacMan.stopChomping()
    }
    // Ghosts exit SPAWN pen when a certain number of pills have been eaten
    // To prevent all piling out at once after a death, tick timers only allow the ghosts to leave after a certain point
    elif g_Ghosts[2].ai == .SPAWN and g_PillsLeft <= 244 - 30 and g_Ticks >= 300    // BLUE leaves after 30 pills are eaten
        g_Ghosts[2].setAI(.LEAVE, false)
    elif g_Ghosts[3].ai == .SPAWN and g_PillsLeft <= 244 * 2/3 and g_Ticks >= 420   // YELLOW leaves after 1/3 of the pills are eaten
        g_Ghosts[3].setAI(.LEAVE, false)

    // Check for ghost collisions
    loop i: 4
    {
        if g_Ghosts[i].getX() == g_PacMan.getX() and g_Ghosts[i].getY() == g_PacMan.getY()
        {
            if g_Ghosts[i].ai == g_Wave   // If the ghost is alive and not FRIGHTENED, Pac-Man will die
            {                               // Begin DEATH procedure by setting timestamp and stopping Pac-Man's animation
                g_TimeStamp = g_Ticks
                g_PacMan.stopChomping()
                break
            }
            elif g_Ghosts[i].ai == .FRIGHTENED    // If ghost is FRIGHTENED, it can be eaten itself
            {                                           // Set ghost AI to DEAD, increasing the score and count of ghosts eaten since the last big pill
                g_Ghosts[i].setAI(.DEAD, false)            // Briefly pause the game to show score for eating ghost
                g_GhostsEaten += 1
                g_Score += 200 * cast(s32) Math.pow(2.0, cast(f32) Math.min(g_GhostsEaten, 3))
                g_TimeStamp = g_Ticks
                g_PacMan.stopChomping()
                g_Mode = .EAT
            }
        }
    }
}

/**
 * Ghost AI targeting mode is set in waves, adding small respite where all enemies back off for a short period
 * Timings of each wave are calculated as tick approximations of seconds, based on a performance-capped 30fps tick rate
 * Tick count is adjusted as game does not begin until 240 ticks have passed
 *      SCATTER:    420  ticks      approx.  7 seconds
 *                      Above level 5, this decreases to 300 ticks      approx. 5 seconds
 *      CHASE:      1200 ticks      approx. 20 seconds
 *      SCATTER:    420  ticks      approx.  7 seconds
 *                      Above level 5, this decreases to 300 ticks      approx. 5 seconds
 *      CHASE:      1200 ticks      approx. 20 seconds
 *      SCATTER:    300  ticks      approx.  5 seconds
 *      CHASE:      1200 ticks      approx. 20 seconds
 *                      Above level 2, this extends to 61980 ticks      approx. 1033s/17m13s
 *                      Above level 5, this increases to 62220 ticks    approx. 1037s/17m17s
 *      SCATTER:    300  ticks      approx.  5 seconds
 *                      Above level 2, this decreases to 1 tick         approx. 1/60th of a second
 *      CHASE:      indefintely beyond this point
 * On changing wave, the ghost's direction is reversed
 */
func aiWave()
{
    // Account for game not entering PLAY-mode until ticks=240
    let playTicks = g_Ticks - 240
    // SCATTER: 7s, or 5s if level 2+
    var wave1: s32
    if g_Level >= 5
        wave1 = 5*60
    else
        wave1 = 7*60
    // CHASE: 20s
    let wave2 = wave1 + 20*60
    // SCATTER: 7s, or 5s if level 2+
    var wave3: s32
    if g_Level >= 5
        wave3 = wave2 + 5*60
    else
        wave3 = wave2 + 7*60
    // CHASE: 20s
    let wave4 = wave3 + 20*60
    // SCATTER: 5s
    let wave5 = wave4 + 5*60
    // CHASE: 20s, or 17m13s if level 2+, or 17m17s if level 5+
    var wave6: s32
    if g_Level >= 5
        wave6 = wave5 + 1037*60
    elif g_Level >= 2
        wave6 = wave5 + 1033*60
    else
        wave6 = wave5 + 20*60
    // SCATTER: 5s, or 1/60s (one frame - simply forces direction switch) if level 2+
    var wave7: s32
    if g_Level >= 2
        wave7 = wave6 + 1
    else
        wave7 = wave6 + 5*60
    // CHASE permanently beyond this point

    // Change AI wave based on game ticks (performance-capped approximation of time)
    if playTicks <= wave1
        g_Wave = .SCATTER
    elif playTicks <= wave2
        g_Wave = .CHASE
    elif playTicks <= wave3
        g_Wave = .SCATTER
    elif playTicks <= wave4
        g_Wave = .CHASE
    elif playTicks <= wave5
        g_Wave = .SCATTER
    elif playTicks <= wave6
        g_Wave = .CHASE
    elif playTicks <= wave7
        g_Wave = .SCATTER
    else
        g_Wave = .CHASE

    // Update ghost AI to new wave only if they are in CHASE/SCATTER mode
    // Checked every frame to ensure ghost AI correctly reset following FRIGHTENED mode
    loop i: 4
    {
        let ai = g_Ghosts[i].ai
        if (ai == .SCATTER or ai == .CHASE) and ai != g_Wave
            g_Ghosts[i].setAI(g_Wave, true)
    }
}

func gameLoop()
{
    let curTime = Time.nowMilliseconds()
    if curTime - g_LastTime < 16
    {
        let delay = cast(u32) (16 - (curTime - g_LastTime))
        Threading.Thread.sleep(Time.Duration.fromMs(delay))
    }

    g_LastTime = curTime

    switch g_Mode
    {
    case READY: // After 240 ticks, enter PLAY mode
        if g_Ticks > 240
            g_Mode = PLAY

    case PLAY: // Main play loop
        if g_TimeStamp == -1
        {
            checkCollisions()
            g_PacMan.move()
            checkCollisions()
            aiWave()               // Update the ghost AI targeting wave
            // Move each ghost - pass RED ghost for BLUE's CHASE mode AI
            loop i: 4
                g_Ghosts[i].move(g_Ghosts[0])
            // If no fruit is currently spawned, enough pills have been eaten,
            // The eaten fruit count doesn't exceed the level and a random quantifier is satisfied, spawn a fruit
            if !g_FruitSpawned and g_Fruits < g_Level and g_PillsLeft <= 240 - 30 and Random.shared().nextU32() % 1500 == 0
                spawnFruit()

        }
        elif g_Ticks == g_TimeStamp + 90    // If timestamp is set, incur a short pause
        {                               // Timestamp is only set in PLAY-mode when Pac-Man dies or level is complete
            if g_PillsLeft == 0          // If no pills remain, level is complete
            {                           // Reset map & pill count and enter READY-mode for next level
                g_PillsLeft = 244
                g_Level += 1
                resetMap()
                resetLevel()
            }
            else                        // If there are still pills remaining, Pac-Man has died
            {
                g_TimeStamp = g_Ticks      // Set timestamp for correct death animation timing
                g_Mode = .DEATH           // Enter DEATH-mode
            }
        }

    // Pause the game briefly on eating a fruit
    // Also pause on eating a ghost - logical behaviour is identical so overflow switch case
    case FRUIT, EAT:
        if g_Ticks == g_TimeStamp + 90
        {
            g_TimeStamp = -1
            g_PacMan.startChomping()
            g_Mode = .PLAY
        }

    case DEATH:     // 180 ticks after death, enter READY (reset level) or GAMEOVER mode depending on remaining lives
        if g_Ticks > g_TimeStamp + 180
        {
            if g_Lives == 0
            {
                g_Mode = .GAMEOVER
                if g_Score > g_HighScore
                {
                    g_HighScore = g_Score
                    //setHighscore();
                }
            }
            else
            {
                g_Lives -= 1   // Decrease remaining lives on death
                resetFruit()   // Remove any spawned fruits
                resetLevel()   // Reset characters and variables to retry level
            }
        }
    }

    // Increment game ticks once the frame is drawn, but only if not paused
    if g_Mode != .NONE
        g_Ticks += 1
}

/**
 * Determine which fruit to draw based on how many have already been consumed
 * If the timer exceeds 600 ticks (approx 15s) remove the fruit and reset the timer
 */
func drawFruit(x, y: s32)
{
    if g_FruitTimer <= 900
    {
        g_Painter.pushTransform()
        g_Painter.translateTransform(-3*Scale, -3*Scale)   // Account for over-sized sprite (14x14 on 8x8 tile)
        g_Painter.translateTransform(7*Scale, 7*Scale)
        // Determine which fruit sprite to draw from the array based on current fruit consumption count
        g_Painter.drawTexture(-7, -7, 14, 14, g_FruitsTex[g_Fruits])  // Draw fruit at current location
        g_Painter.popTransform()
        g_FruitTimer += 1
    }
    else
    {
        setTile(x,y,.e)
        g_FruitTimer = -1
    }
}

/**
 * Randomly spawn a fruit in the lower third of the map
 */
func spawnFruit()
{
    loop
    {
        let x = cast(s32) Random.shared().nextU32(0, 27) + 1    // Generate random X within the map (excluding outer walls)
        let y = cast(s32) Random.shared().nextU32(0, 10) + 1    // Generate random Y within the lower third of the map (excluding outer walls)
        // Randomly selected tile must be empty
        if getTile(x, y) == .e
        {
            // Once randomly selected tile is empty, spawn fruit and set timer to 0
            setTile(x,y,.F)
            g_FruitSpawned = true
            g_FruitTimer = 0
            break
        }
    }
}

func resetMap()
{
    loop x: 28
    {
        loop y: 31
        {
            switch getTile(x,y)
            {
            // Fruits only spawn on empty pill tiles, not empty big pill tiles - if it still exists on map reset, reset to pill
            case F, e:
                setTile(x,y,.o)
            case E:
                setTile(x,y,.O)
            }
        }
    }
}

/**
 * When Pac-Man dies, remove any spawned fruits from the map
 */
func resetFruit()
{
    loop x: 28
    {
        loop y: 31
        {
            switch getTile(x,y)
            {
                // Fruits only spawn on empty pill tiles, not empty big pill tiles - if it still exists on map reset, reset to pill
                case F:
                    setTile(x,y,.e)
            }
        }
    }
}

func resetLevel()
{
    g_Ticks = 0
    g_TimeStamp = -1
    g_PacMan.reset()
    g_Wave = .SCATTER
    g_GhostsEaten = 0
    g_FruitSpawned = false
    loop i: 4
        g_Ghosts[i].reset()
    g_Mode = .READY
}

func restartGame()
{
    g_Level = 1
    g_Lives = 2
    g_ExtraLife = false
    g_Fruits = 0
    g_Score = 0
    g_PillsLeft = 244
    resetMap()
    resetLevel()
}

func onEvent(wnd: *Wnd, evt: *Event)->bool
{
    switch evt.kind
    {
    case Create:
        g_Wnd = wnd
        loadBindTextures()
        restartGame()

    case Paint:
        let paintEvt = cast(*PaintEvent) evt
        g_Painter = paintEvt.bc.painter
        gameLoop()
        display()
        wnd.invalidate()

    case KeyPressed:
        let keyEvt = cast(*KeyEvent) evt
        switch keyEvt.key
        {
        case Escape:
            if g_Mode != .PAUSE
            {
                g_TempMode = g_Mode // Save gamemode to re-enter on unpausing game
                g_Mode = .PAUSE
            }
            elif g_Mode == .PAUSE
            {
                g_Wnd.postQuitEvent()
            }

        case Left:  g_PacMan.tempDir = .LEFT
        case Right: g_PacMan.tempDir = .RIGHT
        case Down:  g_PacMan.tempDir = .UP
        case Up:    g_PacMan.tempDir = .DOWN

        default:
            if g_Mode == .PAUSE and g_TempMode != .GAMEOVER
                g_Mode = g_TempMode
            elif g_Mode == .GAMEOVER or g_Mode == .PAUSE
                restartGame()
        }

        break
    }

    return false
}

func loadBindTextures()
{
    func loadAndBindTexture(name: string)->Texture
    {
        let img = assume Image.load(Path.combine(g_DataPath, name))
        return g_Wnd.getApp().getRenderer().addImage(img)
    }

    g_DataPath = Path.getDirectoryName(#location.fileName)
    g_DataPath = Path.combine(g_DataPath, "datas")
    g_DataPath = Path.combine(g_DataPath, "pacman")

    // Bind map textures
    g_MapTex        = loadAndBindTexture("map/map.png")
    g_PillTex       = loadAndBindTexture("map/pill.png")
    g_BigPillTex[0] = loadAndBindTexture("map/big-0.png")
    g_BigPillTex[1] = loadAndBindTexture("map/big-1.png")
    // Bind Pac-Man textures
    g_Pac0Tex       = loadAndBindTexture("pacman/0.png")
    g_Pac1Tex       = loadAndBindTexture("pacman/1.png")
    g_Pac2Tex       = loadAndBindTexture("pacman/2.png")
    // Bind Pac-Man Death textures
    g_DeadTex[0]    = loadAndBindTexture("pacman/d-0.png")
    g_DeadTex[1]    = loadAndBindTexture("pacman/d-1.png")
    g_DeadTex[2]    = loadAndBindTexture("pacman/d-2.png")
    g_DeadTex[3]    = loadAndBindTexture("pacman/d-3.png")
    g_DeadTex[4]    = loadAndBindTexture("pacman/d-4.png")
    g_DeadTex[5]    = loadAndBindTexture("pacman/d-5.png")
    g_DeadTex[6]    = loadAndBindTexture("pacman/d-6.png")
    g_DeadTex[7]    = loadAndBindTexture("pacman/d-7.png")
    g_DeadTex[8]    = loadAndBindTexture("pacman/d-8.png")
    g_DeadTex[9]    = loadAndBindTexture("pacman/d-9.png")
    g_DeadTex[10]   = loadAndBindTexture("pacman/d-10.png")
    // Bind ghost textures
    g_GhostTexR[0]  = loadAndBindTexture("ghosts/r-0.png")
    g_GhostTexR[1]  = loadAndBindTexture("ghosts/r-1.png")
    g_GhostTexP[0]  = loadAndBindTexture("ghosts/p-0.png")
    g_GhostTexP[1]  = loadAndBindTexture("ghosts/p-1.png")
    g_GhostTexB[0]  = loadAndBindTexture("ghosts/b-0.png")
    g_GhostTexB[1]  = loadAndBindTexture("ghosts/b-1.png")
    g_GhostTexY[0]  = loadAndBindTexture("ghosts/y-0.png")
    g_GhostTexY[1]  = loadAndBindTexture("ghosts/y-1.png")
    g_GhostTexF[0]  = loadAndBindTexture("ghosts/f-0.png")
    g_GhostTexF[1]  = loadAndBindTexture("ghosts/f-1.png")
    g_GhostTexF[2]  = loadAndBindTexture("ghosts/f-2.png")
    g_GhostTexF[3]  = loadAndBindTexture("ghosts/f-3.png")
    // Bind ghost eye textures
    g_EyeTexU       = loadAndBindTexture("eyes/u.png");
    g_EyeTexR       = loadAndBindTexture("eyes/r.png");
    g_EyeTexD       = loadAndBindTexture("eyes/d.png");
    g_EyeTexL       = loadAndBindTexture("eyes/l.png");
    // Bind fruit textures
    g_FruitsTex[0]  = loadAndBindTexture("fruits/cherry.png");
    g_FruitsTex[1]  = loadAndBindTexture("fruits/strawberry.png");
    g_FruitsTex[2]  = loadAndBindTexture("fruits/orange.png");
    g_FruitsTex[3]  = loadAndBindTexture("fruits/apple.png");
    g_FruitsTex[4]  = loadAndBindTexture("fruits/melon.png");
    g_FruitsTex[5]  = loadAndBindTexture("fruits/boss.png");
    g_FruitsTex[6]  = loadAndBindTexture("fruits/bell.png");
    g_FruitsTex[7]  = loadAndBindTexture("fruits/key.png");
    g_FScoreTex[0]  = loadAndBindTexture("ui/100.png");
    g_FScoreTex[1]  = loadAndBindTexture("ui/300.png");
    g_FScoreTex[2]  = loadAndBindTexture("ui/500.png");
    g_FScoreTex[3]  = loadAndBindTexture("ui/700.png");
    g_FScoreTex[4]  = loadAndBindTexture("ui/1000.png");
    g_FScoreTex[5]  = loadAndBindTexture("ui/2000.png");
    g_FScoreTex[6]  = loadAndBindTexture("ui/3000.png");
    g_FScoreTex[7]  = loadAndBindTexture("ui/5000.png");
    // Bind UI textures
    g_Num0Tex       = loadAndBindTexture("ui/0.png")
    g_Num1Tex       = loadAndBindTexture("ui/1.png")
    g_Num2Tex       = loadAndBindTexture("ui/2.png")
    g_Num3Tex       = loadAndBindTexture("ui/3.png")
    g_Num4Tex       = loadAndBindTexture("ui/4.png")
    g_Num5Tex       = loadAndBindTexture("ui/5.png")
    g_Num6Tex       = loadAndBindTexture("ui/6.png")
    g_Num7Tex       = loadAndBindTexture("ui/7.png")
    g_Num8Tex       = loadAndBindTexture("ui/8.png")
    g_Num9Tex       = loadAndBindTexture("ui/9.png")
    g_ReadyTex      = loadAndBindTexture("ui/ready.png")
    g_PauseTex      = loadAndBindTexture("ui/pause.png")
    g_PauseAltTex   = loadAndBindTexture("ui/pause_alt.png")
    g_QuitTex       = loadAndBindTexture("ui/quit.png")
    g_HelpTex       = loadAndBindTexture("ui/help.png")
    g_ScoreTex      = loadAndBindTexture("ui/score.png")
    g_LifeTex       = loadAndBindTexture("ui/life.png")
    g_OneUpTex      = loadAndBindTexture("ui/1up.png")
    g_GameOverTex   = loadAndBindTexture("ui/gameover.png")
    g_GScoreTex[0]  = loadAndBindTexture("ui/200.png");
    g_GScoreTex[1]  = loadAndBindTexture("ui/400.png");
    g_GScoreTex[2]  = loadAndBindTexture("ui/800.png");
    g_GScoreTex[3]  = loadAndBindTexture("ui/1600.png");
}

#run
{
    Application.runSurface(100, 100, cast(s32) (300 * Scale), cast(s32) (340 * Scale), title = "Pacman", hook = &onEvent)
}