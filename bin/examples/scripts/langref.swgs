/*
    This script is used to generate the documentation you can see at swag-lang.org.

    It takes the content of the swag-lang/swag/bin/reference/tests folders, and generates the
    corresponding documentations.
*/

#dependencies
{
    #import "gui" location="swag@std"
}

using Core, Gui

enum State
{
    Paragraph
    Code
    Test
    Blockquote
}

var g_Buf:  String  // Will contain the html page
var g_Toc:  String  // Will contain the left part, i.e. the table of content
var g_Code: String

var g_State:            Array'State
var g_CptBrace:         s32
var g_SubTitle:         bool

func stateEnter(st: State)
{
    switch st
    {
    case Paragraph:
        g_Buf += "<div>"

    case Blockquote:
        g_Buf += "<div class=\"blockquote\">"
    }
}

func stateLeave(st: State)
{
    switch st
    {
    case Paragraph, Blockquote:
        g_Buf += "</div>\n"

    case Code, Test:
        flushCode()
    }
}

func pushState(st: State)
{
    stateLeave(g_State.back())
    stateEnter(st)
    g_State.add(st)
}

func popState()
{
    stateLeave(g_State.back())
    g_State.removeBack()
    stateEnter(g_State.back())
}

// Add one line of 'text'
func addLine(line: string)
{
    var lineTrim: String = line
    lineTrim.trim()

    // Sub title if text has the form '# text'
    if Utf8.startsWith(lineTrim, "# ")
    {
        lineTrim.remove(0, 2)
        g_Buf += Format.toString("<h% id=\"%\">", g_SubTitle ? 4 : 3, lineTrim)
        addLine(lineTrim)
        g_Buf += g_SubTitle ? "</h4>" : "</h3>"

        g_Toc += Format.toString("<li><a href=\"#%\">%</a></li>\n", lineTrim, lineTrim);
        return
    }

    stateBold   := false
    stateItalic := false
    stateCode   := false

    // Process character by character, in order to detect some 'markdown' stuff
    for i := 0; i < @countof(line); i += 1
    {
        // Bold with '**'
        if line[i] == "*"'u8 and line[i+1] == "*"'u8
        {
            g_Buf += stateBold ? "</b>" : "<b>"
            stateBold = !stateBold
            i += 1
            continue
        }

        // Italic with '*'
        if line[i] == "*"'u8
        {
            if !stateItalic and Latin1.isLetterOrDigit(line[i+1])
            {
                stateItalic = true
                g_Buf += "<i>"
                continue
            }

            if stateItalic
            {
                g_Buf += "</i>"
                stateItalic = false
                continue
            }
        }

        // Inlined code with '`'
        if line[i] == "`"'u8
        {
            if !stateCode
            {
                stateCode = true
                g_Buf += "<code class=\"incode\">"
                continue
            }

            if stateCode
            {
                g_Buf += "</code>"
                stateCode = false
                continue
            }
        }

        g_Buf += line[i]
    }

    g_Buf += "</br>\n"
}

func flushCode()
{
    // Remove empty lines before and after the code block
    while g_Code.length and g_Code[0] == "\n"'u8
        g_Code.remove(0, 1)
    while g_Code.length and g_Code.back() == "\n"'u8
        g_Code.removeBack()
    if g_Code.length == 0
        return

    g_Buf += "<div class=\"code\">"
    g_Buf += "<code style=\"white-space: break-spaces\">"

    var g_Edit:      RichEditCtrl
    var g_LexerSwag: RichEditLexerSwag

    g_Edit.setLexer(cast(IRichEditLexer) g_LexerSwag)
    g_Edit.setText(g_Code)
    g_Edit.lexAll()

    res := g_Edit.getTextAndStyles()

    g_Edit.styles[0].colFg = Pixel.Argb.White
    lastStyle := -1
    loop i: res.text
    {
        if res.styles[i] != lastStyle
        {
            if lastStyle != -1
                g_Buf += "</span>"
            lastStyle = res.styles[i]
            g_Buf += Format.toString("<span style=\"color:#%{X}\">", g_Edit.styles[lastStyle].colFg.argb & 0xFFFFFF)
        }

        g_Buf += res.text[i]
    }

    g_Buf += "</span>"
    g_Buf += "</code>"
    g_Buf += "</div>"

    g_Code.clear()
}

// Add one line of code
func addLineCode(l: string)
{
    g_Code += l
    g_Code += "\n"
}

func processFile(fileName: string)
{
    lines := assume File.readAllLines(fileName)

    stateEnter(.Code)
    g_State.add(State.Code)

    visit l: lines
    {
        lineTrim := l
        lineTrim.trim()

        curState := g_State.back()

        // Some state changes
        if Utf8.startsWith(lineTrim, "/**")
        {
            pushState(.Paragraph)
            continue
        }

        if curState == .Paragraph and Utf8.startsWith(lineTrim, ">")
        {
            pushState(.Blockquote)
            curState = g_State.back()
        }

        if curState == .Blockquote and !Utf8.startsWith(lineTrim, ">")
        {
            popState()
            curState = g_State.back()
        }

        switch curState
        {
        //////////////////////////////////
        case Blockquote:
            lineTrim.remove(0, 1)
            lineTrim.trim()
            addLine(lineTrim)

        //////////////////////////////////
        case Paragraph:
            if Utf8.startsWith(lineTrim, "```")
                pushState(.Code)
            elif Utf8.startsWith(lineTrim, "*/")
                popState()
            else
                addLine(lineTrim)

        //////////////////////////////////
        case Test:
            if lineTrim == "{"
            {
                g_CptBrace += 1
                if g_CptBrace == 1
                    continue
            }
            elif lineTrim == "}"
            {
                g_CptBrace -= 1
                if g_CptBrace == 0
                {
                    popState()
                    continue
                }
            }

            var nextLine: String
            if @index != lines.count - 1
            {
                nextLine = lines[@index+1]
                nextLine.trim()
            }

            if g_CptBrace == 1 and Utf8.startsWith(lineTrim, "//") and nextLine == "{"
            {
                lineTrim.remove(0, 2)
                popState()
                pushState(.Paragraph)
                addLine("\n")
                addLine(lineTrim)
                popState()
                pushState(.Test)
                continue
            }

            lineLine := l
            if Utf8.startsWith(lineLine, "    ")
                lineLine.remove(0, 4)
            addLineCode(lineLine)

        //////////////////////////////////
        case Code:
            if Utf8.startsWith(l, "```")
                popState()
            elif Utf8.startsWith(l, "#test")
                pushState(.Test)
            else
                addLineCode(l)
        }
    }

    // Unstack all states
    while g_State.count
        stateLeave(g_State.popBack())
}

func generate(in, out: string)
{
    files := assume Directory.enumerateFiles(in, ".swg", recurse: true)
    files.sort(func(a, b) => a.fullname <=> b.fullname)

    g_Buf += "<html lang=\"en\">\n"
    g_Buf += "<body>\n"

    // Create styles
    g_Buf += """
        <style>
        .code {
            background-color: #333333;
            border: 1px solid LightGrey;
            margin: 20px;
            padding: 20px;
        }

        .blockquote {
            border-left: 2px solid Orange;
            margin-left: 10px;
            padding-left: 10px;
        }

        .incode {
            background-color: #eeeeee;
            padding: 2px;
            border: 1px dotted #cccc00;
        }

        .container {
            display:        flex;
            flex-wrap:      nowrap;
            flex-direction: row;
            height:         100%;
            font-family:    arial;
            line-height:    1.3em;
        }

        .left {
            display:    block;
            overflow-y: scroll;
            width:      450;
            height:     100%;
        }

        .right {
            display:     block;
            overflow-y:  scroll;
            width:       100%;
            font-family: arial;
            line-height: 1.3em;
            height:      100%;
        }

        .page {
            width:       1000;
            margin:      0 auto;
        }

        </style>
    """

    // Main page (left and right parts, left is for table of content, right is for content)
    g_Buf += "<div class=\"container\">\n"
    g_Buf += "<div class=\"left\">\n"
    seekToc := g_Buf.length // This will be the place where we will insert the 'g_Toc' table of content
    g_Buf += "</div>\n"

    // Right page start
    g_Buf += "<div class=\"right\">\n"
    g_Buf += "<div class=\"page\">\n"
    g_Buf += "<h1>Swag language reference</h1>\n"

    // Table of content start
    g_Toc += "<h1>Table of content</h1>\n"
    g_Toc += "<ul>\n"

    visit v: files
    {
        if Path.getExtensionLowerCase(v.fullname) != ".swg"
            continue

        var title: String = Path.getFileNameWithoutExtension(v.fullname)
        fileName := title
        title = title[4..]

        // If there's an additional '_' after 'NNN_', then this is a 'sub part'.
        wasSubTitle := g_SubTitle
        g_SubTitle = title[0] == "_"'u8
        if g_SubTitle
            title = title[1..]
        if !wasSubTitle and g_SubTitle
            g_Toc += "<ul>\n"
        else if wasSubTitle and !g_SubTitle
            g_Toc += "</ul>\n"

        // Normalize filename as a title
        title[0] = Latin1.toUpper(title[0])
        title.replace("_", " ")

        // Add title to output
        g_Buf += "\n"
        g_Buf += Format.toString("<h% id=\"%\">", g_SubTitle ? 3 : 2, fileName)
        g_Buf += title
        g_Buf += g_SubTitle ? "</h3>\n" : "</h2>\n"

        // Add title to table of content
        g_Toc += Format.toString("<li><a href=\"#%\">%</a></li>\n", fileName, title);
        g_Toc += "<ul>\n"

        processFile(v.fullname)

        g_Toc += "</ul>\n"
    }

    g_Toc += "</ul>\n"

    // Close html page
    g_Buf +=
        """
        </div>
        </div>
        </div>
        </body>
        </html>
        """

    g_Buf.insert(seekToc, g_Toc)

    assume File.writeAllBytes(out, g_Buf)
}

#run
{
    generate("../../reference/tests/language/src", "../../../web/language.html")
}