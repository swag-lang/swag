#dependencies
{
    #import "gui" location="swag@std"
}

using Core, Gui, Pixel

const GridSize = 60

var g_Grid:     [2, GridSize, GridSize] bool
var g_CurGen:   s32

func onEvent(wnd: *Wnd, evt: *Event)->bool
{
    leftPressed  := wnd.getApp().mouse.isButtonPressed(.Left)
    rightPressed := wnd.getApp().mouse.isButtonPressed(.Right)
    cellSize    := Math.min(wnd.position.width, wnd.position.height) / GridSize

    switch evt.kind
    {
    case MousePressed, MouseMove:
        if leftPressed or rightPressed
        {
            mouseEvt := cast(*MouseEvent) evt
            pos      := wnd.surfaceToLocal(mouseEvt.surfacePos)

            x := cast(s32) (pos.x / cellSize)
            y := cast(s32) (pos.y / cellSize)
            if x < 1 or x >= GridSize - 1 or y < 1 or y >= GridSize - 1
                break
            g_Grid[g_CurGen, x, y] = leftPressed ? true : false
        }

        return true

    case Create:
        // Initial population
        var rng: Random.DefaultRng
        loop i: 1..GridSize-2
        {
            loop j: 1..GridSize-2
            {
                g_Grid[g_CurGen, i, j] = rng.nextBool()
            }
        }

    case Paint:
        paintEvt := cast(*PaintEvent) evt
        painter  := paintEvt.bc.painter
        nextGen  := (g_CurGen + 1) % 2

        // Compute next generation, except if user is painting
        if !leftPressed and !rightPressed
        {
            loop i: 1..GridSize-2
            {
                loop j: 1..GridSize-2
                {
                    // Count cell neighbours
                    cpt := 0
                    loop x: -1..1
                    {
                        loop y: -1..1
                        {
                            if x == 0 and y == 0
                                continue
                            cpt += g_Grid[g_CurGen,i+x,j+y] ? 1 : 0
                        }
                    }

                    // Game of life rules
                    if !g_Grid[g_CurGen, i, j] and cpt == 3
                        g_Grid[nextGen, i, j] = true
                    elif g_Grid[g_CurGen, i, j] and (cpt == 2 or cpt == 3)
                        g_Grid[nextGen, i, j] = true
                    else
                        g_Grid[nextGen, i, j] = false
                }
            }

            g_CurGen = nextGen
        }

        // Paint grid
        painter.clear(Argb.White)
        loop i: 1..GridSize-2
        {
            x := i * cellSize
            w := Math.min(wnd.position.width, wnd.position.height) - (2 * cellSize)
            painter.drawRect(cellSize, x, w, cellSize, Argb.Black)
            painter.drawRect(x, cellSize, cellSize, w, Argb.Black)
        }

        // Paint generation
        loop i: 1..GridSize-1
        {
            loop j: 1..GridSize-1
            {
                if g_Grid[g_CurGen, i, j]
                {
                    x := i * cellSize
                    y := j * cellSize
                    painter.fillRect(x + 1, y + 1, cellSize-2, cellSize-2, Argb.Black)
                }
            }
        }

        wnd.invalidate()
    }

    return false
}

#run
{
    var app: Application
    try app.runSurface(100, 100, 1024, 1024, title: "Game of Life", hook: &onEvent)
}