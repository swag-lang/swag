enum FormImageKind
{
    Image
    Blur
    Pixelate
    Zoom
}

enum FormImagePlacement
{
    Frame
    Center
    Free
}

struct FormImage
{
    using base: BaseForm
    image:      Image
    kind:       FormImageKind = .Image
    strength:   s32 = 50
    place:      FormImagePlacement = .Center
    freePos:    Math.Rectangle

    #[Serialization.NoSerialize]
    {
        editInside:     bool
        dirty:          bool
        serial:         u32
        stc:            s32
        xc, yc:         s32
        wc, hc:         s32
        texture:        Texture
        gizmo:          GizmoRect
        textureKind:    FormImageKind = .Image
    }
}

impl FormImage
{
    mtd opPostCopy()
    {
        @init(&texture)
    }
}

impl IForm for FormImage
{
    mtd isSame(ptr: *BaseForm)->bool
    {
        other := cast(*FormImage) ptr
        if kind == .Image and backColor != other.backColor
            return false
        return  borderColor == other.borderColor and
                borderSize  == other.borderSize and
                alpha       == other.alpha and
                kind        == other.kind and
                paintShadow == other.paintShadow and
                strength    == other.strength
    }

    mtd copy(dst, src: *BaseForm)
    {
        dstf := cast(*FormImage) dst
        srcf := cast(*FormImage) src
        dstf.borderColor = srcf.borderColor
        dstf.borderSize  = srcf.borderSize
        dstf.backColor   = srcf.backColor
        dstf.alpha       = srcf.alpha
        dstf.kind        = srcf.kind
        dstf.paintShadow = srcf.paintShadow
        dstf.strength    = srcf.strength
        if srcf.image.isValid()
            dstf.image = srcf.image
    }

    mtd edit(evt: *MouseEvent, paintRect: Math.Rectangle, movingStart: Math.Point, localPos: Math.Point, zoom: f32)->bool
    {
        xa := cast(s32) ((movingStart.x - paintRect.x) / zoom)
        ya := cast(s32) ((movingStart.y - paintRect.y) / zoom)
        xb := cast(s32) ((localPos.x - paintRect.x) / zoom)
        yb := cast(s32) ((localPos.y - paintRect.y) / zoom)
        setBaseForm(xa, ya, xb - xa, yb - ya)
        if evt.kind == .MouseReleased and evt.button == .Left
            return false
        return true
    }

    mtd mustEditInside() => kind == .Image and place == .Free and editInside

    mtd moveBaseForm(newPosX, newPosY, newSizeX, newSizeY: s32)
    {
        if mustEditInside()
        {
            freePos.x += newPosX
            freePos.y += newPosY
            freePos.width += newSizeX
            freePos.height += newSizeY
        }
        else
        {
            x += newPosX
            y += newPosY
            w += newSizeX
            h += newSizeY
        }
    }

    mtd setBaseForm(newPosX, newPosY, newSizeX, newSizeY: s32)
    {
        if mustEditInside()
        {
            if newSizeX < 0
            {
                freePos.x = newPosX + newSizeX
                freePos.width = -newSizeX
            }
            else
            {
                freePos.x = newPosX
                freePos.width = newSizeX
            }

            if newSizeY < 0
            {
                freePos.y = newPosY + newSizeY
                freePos.height = -newSizeY
            }
            else
            {
                freePos.y = newPosY
                freePos.height = newSizeY
            }
        }
        else
        {
            if newSizeX < 0
            {
                x = newPosX + newSizeX
                w = -newSizeX
            }
            else
            {
                x = newPosX
                w = newSizeX
            }

            if newSizeY < 0
            {
                y = newPosY + newSizeY
                h = -newSizeY
            }
            else
            {
                y = newPosY
                h = newSizeY
            }
        }
    }

    mtd moveForm(newPosX, newPosY: s32)
    {
        if mustEditInside()
        {
            freePos.x += newPosX
            freePos.y += newPosY
        }
        else
        {
            x += newPosX
            y += newPosY
        }
    }

    mtd movePoint(pt: u32, newPosX, newPosY: s32)
    {
    }

    mtd boundRect(raw: bool)->Math.Rectangle
    {
        return Math.Rectangle{x, y, w, h}
    }

    mtd mouse(view: *EditView, pos: Math.Point, evt: *MouseEvent)->bool
    {
        if kind == .Image and place == .Free and evt.kind == .MouseDoubleClick and evt.button == .Left
        {
            editInside = !editInside
            return true
        }

        if mustEditInside()
        {
            evt.modifiers ^= .Shift
        }

        return gizmo.mouse(view, pos, evt)
    }

    mtd paintGizmo(painter: *Painter, z: f32, flags: FormFlags)
    {
        if flags & (.Hot | .Selected)
        {
            gizmo.rect = paintPos

            if mustEditInside()
            {
                gizmo.rect.offset(freePos.x*z, freePos.y*z)
                gizmo.rect.width = freePos.width*z
                gizmo.rect.height = freePos.height*z
                gizmo.paint(painter, flags & .Selected ? false : true, Argb.Yellow)
            }
            else
            {
                gizmo.paint(painter, flags & .Selected ? false : true)
            }
        }
        else
        {
            editInside = false
        }
    }

    mtd hitTest(pt: Math.Point, z: f32)->bool
    {
        if mustEditInside()
        {
            pp := Math.Rectangle{paintPos.x, paintPos.y, paintPos.width, paintPos.height}
            pp.offset(freePos.x*z, freePos.y*z)
            pp.width = freePos.width*z
            pp.height = freePos.height*z
            return pp.contains(pt)
        }

        return true
    }

    mtd paint(app: *Application, painter: *Painter, z: f32, quickMode: bool)
    {
        bSize := adaptSize(borderSize, MinBorderSize, MaxBorderSize, z, quickMode)
        pp    := Math.Rectangle{0, 0, paintPos.width, paintPos.height}
        pen   := Pen.createSolid(borderColor, bSize)

        if !quickMode
        {
            renderer := app.getRenderer()
            x1 := cast(s32) (x - capture.backImagePos.x)
            y1 := cast(s32) (y - capture.backImagePos.y)

            switch kind
            {
            case Image:
                if (!texture.isValid() or textureKind != kind or dirty) and image.isValid()
                {
                    dirty = false
                    textureKind = kind
                    renderer.removeTexture(&texture)
                    texture = renderer.addImage(image)
                    if !freePos.width
                        freePos.width = image.width
                    if !freePos.height
                        freePos.height = image.height
                }

            case Blur, Pixelate:
                if  !texture.isValid() or
                    xc != x or yc != y or wc != w or hc != h or
                    textureKind != kind or
                    dirty or
                    stc != strength or
                    serial != capture.serialBackTexture
                {
                    if w > 1 and h > 1
                    {
                        dirty = false
                        serial = capture.serialBackTexture
                        textureKind = kind
                        stc = strength
                        xc = x; yc = y; wc = w; hc = h
                        renderer.removeTexture(&texture)
                        img := capture.backImg.toCrop(x1, y1, w, h)
                        st := Math.map(cast(f32) strength, 0, 100, 1, 16)
                        nw := Math.max(cast(s32) (img.width / st), 4)
                        nh := Math.max(cast(s32) (img.height / st), 4)
                        img.resize(nw, nh, .Quadratic)
                        img.resize(w, h, kind == .Pixelate ? .Raw : .Quadratic)
                        texture = app.getRenderer().addImage(img)
                    }
                }

            case Zoom:
                if  !texture.isValid() or
                    xc != x or yc != y or wc != w or hc != h or
                    textureKind != kind or
                    dirty or
                    stc != strength or
                    serial != capture.serialBackTexture
                {
                    if w > 1 and h > 1
                    {
                        dirty = false
                        serial = capture.serialBackTexture
                        textureKind = kind
                        stc = strength
                        xc = x; yc = y; wc = w; hc = h
                        renderer.removeTexture(&texture)
                        const ZoomFactor = 2.5
                        stw := cast(s32) Math.map(cast(f32) strength, 1, 100, 1, w / ZoomFactor)
                        sth := cast(s32) Math.map(cast(f32) strength, 1, 100, 1, h / ZoomFactor)
                        img := capture.backImg.toCrop(x1+stw, y1+sth, w-stw*2, h-sth*2)
                        img.resize(w, h, .Raw)
                        texture = app.getRenderer().addImage(img)
                    }
                }
            }
        }

        if borderColor.a and (pp.width <= 2*bSize or pp.height < 2*bSize)
            painter.fillRect(pp, borderColor)
        else
        {
            if quickMode
            {
                var icon: Icon
                switch kind
                {
                case Image:
                    painter.fillRect(pp, backColor)
                    icon = Icon.from(&g_Main.icons48, 13)
                case Blur:
                    icon = Icon.from(&g_Main.icons48, 14)
                case Pixelate:
                    icon = Icon.from(&g_Main.icons48, 15)
                case Zoom:
                    icon = Icon.from(&g_Main.icons48, 16)
                }

                icon.sizeX, icon.sizeY = 32
                icon.paint(painter, pp.horzCenter() - icon.sizeX*0.5, pp.vertCenter() - icon.sizeY*0.5, Argb.White)
            }
            elif kind == .Image and !image.isValid()
            {
                painter.fillRect(pp, backColor)
                icon := Icon.from(&g_Main.icons48, 13)
                icon.paint(painter, pp.horzCenter() - icon.sizeX*0.5, pp.vertCenter() - icon.sizeY*0.5, Argb.White)
            }
            elif kind == .Image
            {
                painter.fillRect(pp, backColor)
                switch place
                {
                case Frame:
                    painter.drawTexture(pp, texture)
                case Center:
                    pp1 := pp
                    pp1.x = pp.horzCenter() - texture.width / 2
                    pp1.y = pp.vertCenter() - texture.height / 2
                    pp1.width = texture.width
                    pp1.height = texture.height
                    painter.drawTexture(pp1, texture)
                case Free:
                    pp1 := pp
                    pp1.offset(freePos.x*z, freePos.y*z)
                    pp1.width = freePos.width*z
                    pp1.height = freePos.height*z
                    painter.drawTexture(pp1, texture)
                }
            }
            else
            {
                painter.drawTexture(pp, texture)
            }

            pp.inflate(-bSize * 0.5)
            painter.drawRect(pp, pen)
        }
    }

    mtd setup(capt: *Capture)
    {
        capture = capt

        with gizmo
        {
            .roundShape = true
            .anchorSize = 10
            .trackChange = true
            .paintSimpleBorder = false
            .paintBigBorder = true
        }

        gizmo.sigChanged = @|self|(g, first, hitMove) {
            g.apply(self, first, hitMove)
        }
    }
}