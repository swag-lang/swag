#include "pch.h"
#include "SemanticJob.h"
#include "ByteCodeGenJob.h"
#include "Ast.h"
#include "Workspace.h"
#include "Generic.h"
#include "TypeManager.h"
#include "ThreadManager.h"
#include "Module.h"
#include "ErrorIds.h"
#include "LanguageSpec.h"
#include "AstOutput.h"

void SemanticJob::checkDeprecated(SemanticContext* context, AstNode* identifier)
{
    auto node = identifier->resolvedSymbolOverload->node;
    if (!(node->attributeFlags & ATTRIBUTE_DEPRECATED))
        return;
    auto symbol = identifier->resolvedSymbolOverload->symbol;

    const ComputedValue* v = nullptr;
    switch (node->kind)
    {
    case AstNodeKind::FuncDecl:
    {
        auto typeInfo = CastTypeInfo<TypeInfoFuncAttr>(node->typeInfo, TypeInfoKind::FuncAttr);
        v             = typeInfo->attributes.getValue(g_LangSpec->name_Swag_Deprecated, g_LangSpec->name_msg);
        break;
    }
    case AstNodeKind::EnumDecl:
    {
        auto typeInfo = CastTypeInfo<TypeInfoEnum>(node->typeInfo, TypeInfoKind::Enum);
        v             = typeInfo->attributes.getValue(g_LangSpec->name_Swag_Deprecated, g_LangSpec->name_msg);
        break;
    }
    case AstNodeKind::StructDecl:
    {
        auto typeInfo = CastTypeInfo<TypeInfoStruct>(node->typeInfo, TypeInfoKind::Struct);
        v             = typeInfo->attributes.getValue(g_LangSpec->name_Swag_Deprecated, g_LangSpec->name_msg);
        break;
    }
    case AstNodeKind::InterfaceDecl:
    {
        auto typeInfo = CastTypeInfo<TypeInfoStruct>(node->typeInfo, TypeInfoKind::Interface);
        v             = typeInfo->attributes.getValue(g_LangSpec->name_Swag_Deprecated, g_LangSpec->name_msg);
        break;
    }
    case AstNodeKind::EnumValue:
    {
        auto typeInfo = CastAst<AstEnumValue>(node, AstNodeKind::EnumValue);
        v             = typeInfo->attributes.getValue(g_LangSpec->name_Swag_Deprecated, g_LangSpec->name_msg);
        break;
    }
    }

    Diagnostic diag{identifier, Fmt(Err(Err0083), SymTable::getNakedKindName(symbol->kind), identifier->resolvedSymbolOverload->symbol->name.c_str()), DiagnosticLevel::Warning};
    Diagnostic note1{node, Nte(Nte0031), DiagnosticLevel::Note};
    if (v && v->text.empty())
    {
        context->report(diag, &note1);
    }
    else
    {
        Diagnostic note2({v->text, DiagnosticLevel::Note});
        context->report(diag, &note1, &note2);
    }
}

Utf8 SemanticJob::getNiceArgumentRank(int idx)
{
    switch (idx)
    {
    case 1:
        return "first argument";
    case 2:
        return "second argument";
    case 3:
        return "third argument";
    }
    return Fmt("argument `%d`", idx);
}

Utf8 SemanticJob::getTheNiceArgumentRank(int idx)
{
    switch (idx)
    {
    case 1:
    case 2:
    case 3:
        return "the " + getNiceArgumentRank(idx);
    }
    return Fmt("parameter `%d`", idx);
}

Utf8 SemanticJob::getNiceParameterRank(int idx)
{
    switch (idx)
    {
    case 1:
        return "first parameter";
    case 2:
        return "second parameter";
    case 3:
        return "third parameter";
    }
    return Fmt("parameter `%d`", idx);
}

Utf8 SemanticJob::getTheNiceParameterRank(int idx)
{
    switch (idx)
    {
    case 1:
    case 2:
    case 3:
        return "the " + getNiceParameterRank(idx);
    }
    return Fmt("parameter `%d`", idx);
}

static int getBadParamIdx(OneTryMatch& oneTry, AstNode* callParameters)
{
    BadSignatureInfos bi = oneTry.symMatchContext.badSignatureInfos;

    // If the first parameter of the call has been generated by ufcs, then decrease the call parameter index by 1, so
    // that the message is more relevant
    int badParamIdx = bi.badSignatureParameterIdx;
    if (badParamIdx && callParameters && !callParameters->childs.empty() && callParameters->childs.front()->flags & (AST_FROM_UFCS | AST_TO_UFCS) && !(callParameters->childs.front()->flags & AST_UFCS_FCT))
        badParamIdx--;
    else if (badParamIdx && oneTry.ufcs)
        badParamIdx--;
    // This is a closure with a generated first parameter
    if (oneTry.symMatchContext.flags & SymbolMatchContext::MATCH_CLOSURE_PARAM)
        badParamIdx--;

    return badParamIdx;
}

void SemanticJob::getDiagnosticForMatch(SemanticContext* context, OneTryMatch& oneTry, vector<const Diagnostic*>& result0, vector<const Diagnostic*>& result1)
{
    auto              node              = context->node;
    BadSignatureInfos bi                = oneTry.symMatchContext.badSignatureInfos;
    auto              symbol            = oneTry.overload->symbol;
    SymbolOverload*   overload          = oneTry.overload;
    auto              genericParameters = oneTry.genericParameters;
    auto              callParameters    = oneTry.callParameters;
    auto&             match             = oneTry.symMatchContext;
    AstFuncCallParam* failedParam       = nullptr;

    int badParamIdx = getBadParamIdx(oneTry, callParameters);

    // Get the call parameter that failed
    if (oneTry.callParameters && badParamIdx >= 0 && badParamIdx < callParameters->childs.size())
        failedParam = static_cast<AstFuncCallParam*>(callParameters->childs[badParamIdx]);

    badParamIdx += 1;

    // Nice name to reference it
    Utf8 refNiceName;
    if (overload->typeInfo->isTuple())
        refNiceName = "the tuple";
    else if (overload->typeInfo->isLambda())
        refNiceName = Fmt("the lambda `%s`", symbol->name.c_str());
    else if (overload->typeInfo->isClosure())
        refNiceName = Fmt("the closure `%s`", symbol->name.c_str());
    else
        refNiceName = Fmt("%s `%s`", SymTable::getNakedKindName(symbol->kind), symbol->name.c_str());

    // Get parameters of destination symbol
    AstFuncDecl* destFuncDecl = nullptr;
    if (overload->node->kind == AstNodeKind::FuncDecl)
        destFuncDecl = CastAst<AstFuncDecl>(overload->node, AstNodeKind::FuncDecl);

    Diagnostic* diag = nullptr;
    Diagnostic* note = nullptr;

    // In case it's generic, and we have real types
    bi.badSignatureRequestedType = Generic::doTypeSubstitution(oneTry.symMatchContext.genericReplaceTypes, bi.badSignatureRequestedType);

    // See if it would have worked with an explicit cast, to give a hint in the error message
    Utf8 explicitCastHint;
    switch (match.result)
    {
    case MatchResult::BadGenericMatch:
    case MatchResult::BadSignature:
    case MatchResult::BadGenericSignature:
        if (bi.badSignatureRequestedType->isPointer() ||
            bi.badSignatureGivenType->isPointer())
            break;

        if (bi.badSignatureRequestedType->isNative())
        {
            if (TypeManager::makeCompatibles(context, bi.badSignatureRequestedType, bi.badSignatureGivenType, nullptr, nullptr, CASTFLAG_TRY_COERCE | CASTFLAG_JUST_CHECK | CASTFLAG_NO_ERROR))
            {
                explicitCastHint = Fmt(Hnt(Hnt0025), bi.badSignatureRequestedType->name.c_str());
                break;
            }
        }

        if (bi.badSignatureRequestedType->isStruct())
        {
            if (TypeManager::makeCompatibles(context, bi.badSignatureRequestedType, bi.badSignatureGivenType, nullptr, nullptr, CASTFLAG_EXPLICIT | CASTFLAG_JUST_CHECK | CASTFLAG_NO_ERROR))
            {
                explicitCastHint = Fmt(Hnt(Hnt0025), bi.badSignatureRequestedType->name.c_str());
                break;
            }
        }

        break;
    }

    switch (match.result)
    {
    default:
        SWAG_ASSERT(false);
        return;

    case MatchResult::SelectIfFailed:
    {
        SWAG_ASSERT(destFuncDecl);
        diag = new Diagnostic{node, Fmt(Err(Err0004), destFuncDecl->token.ctext(), destFuncDecl->selectIf->token.ctext())};
        result0.push_back(diag);
        note = new Diagnostic{destFuncDecl->selectIf, Fmt(Nte(Nte0007), destFuncDecl->selectIf->token.ctext()), DiagnosticLevel::Note};
        result1.push_back(note);
        return;
    }

    case MatchResult::MissingNamedParameter:
    {
        SWAG_ASSERT(failedParam);
        diag = new Diagnostic{failedParam, Fmt(Err(Err0006), getTheNiceParameterRank(badParamIdx).c_str())};
        result0.push_back(diag);
        return;
    }

    case MatchResult::InvalidNamedParameter:
    {
        SWAG_ASSERT(failedParam);
        diag = new Diagnostic{failedParam->namedParamNode ? failedParam->namedParamNode : failedParam, Fmt(Err(Err0008), failedParam->namedParam.c_str())};
        result0.push_back(diag);
        if (!(overload->node->flags & AST_GENERATED))
        {
            note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
            result1.push_back(note);
        }

        return;
    }

    case MatchResult::DuplicatedNamedParameter:
    {
        SWAG_ASSERT(failedParam);
        diag = new Diagnostic{failedParam->namedParamNode ? failedParam->namedParamNode : failedParam, Fmt(Err(Err0011), failedParam->namedParam.c_str())};
        result0.push_back(diag);
        return;
    }

    case MatchResult::MissingParameters:
    {
        diag       = new Diagnostic{callParameters ? callParameters : node, Fmt(Err(Err0020), refNiceName.c_str())};
        diag->hint = Hnt(Hnt0044);
        note       = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
        result0.push_back(diag);
        result1.push_back(note);
        return;
    }

    case MatchResult::MissingSomeParameters:
    {
        if (!callParameters)
        {
            diag       = new Diagnostic{node, Fmt(Err(Err0020), refNiceName.c_str())};
            diag->hint = Hnt(Hnt0044);
        }
        else if (destFuncDecl)
        {
            diag = new Diagnostic{callParameters,
                                  Fmt(Err(Err0188),
                                      refNiceName.c_str(),
                                      destFuncDecl->parameters->childs[match.cptResolved]->token.ctext(),
                                      destFuncDecl->parameters->childs[match.cptResolved]->typeInfo->getDisplayNameC())};
        }
        else
        {
            diag = new Diagnostic{callParameters, Fmt(Err(Err0016), refNiceName.c_str())};
        }

        if (destFuncDecl && callParameters)
            note = new Diagnostic{destFuncDecl->parameters->childs[match.cptResolved], Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
        else
            note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
        result0.push_back(diag);
        result1.push_back(note);
        return;
    }

    case MatchResult::NotEnoughParameters:
    {
        if (!callParameters)
        {
            diag       = new Diagnostic{node, Fmt(Err(Err0020), refNiceName.c_str())};
            diag->hint = Hnt(Hnt0044);
        }
        else
            diag = new Diagnostic{callParameters, Fmt(Err(Err0016), refNiceName.c_str())};
        note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
        result0.push_back(diag);
        result1.push_back(note);
        return;
    }

    case MatchResult::NotEnoughGenericParameters:
    {
        AstNode* errNode = genericParameters;
        if (!errNode)
            errNode = node;
        if (!errNode)
            errNode = context->node;
        if (destFuncDecl && destFuncDecl->isSpecialFunctionName())
            diag = new Diagnostic{errNode, Fmt(Err(Err0352), refNiceName.c_str())};
        else if (genericParameters)
            diag = new Diagnostic{errNode, Fmt(Err(Err0035), refNiceName.c_str())};
        else
            diag = new Diagnostic{errNode, Fmt(Err(Err0049), refNiceName.c_str())};
        note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
        result0.push_back(diag);
        result1.push_back(note);
        return;
    }

    case MatchResult::TooManyParameters:
    {
        AstNode* site = failedParam;
        if (!site)
            site = callParameters;
        SWAG_ASSERT(site);
        diag = new Diagnostic{site,
                              Fmt(Err(Err0026),
                                  refNiceName.c_str(),
                                  match.badSignatureInfos.badSignatureNum2,
                                  match.badSignatureInfos.badSignatureNum1)};
        note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
        result0.push_back(diag);
        result1.push_back(note);
        return;
    }

    case MatchResult::TooManyGenericParameters:
    {
        AstNode* errNode = genericParameters;
        if (!errNode)
            errNode = node;
        if (!errNode)
            errNode = context->node;
        if (!match.badSignatureInfos.badSignatureNum2)
        {
            diag = new Diagnostic{errNode, Fmt(Err(Err0135), SymTable::getNakedKindName(symbol->kind), symbol->name.c_str())};
        }
        else
        {
            if (genericParameters)
                errNode = genericParameters->childs[match.badSignatureInfos.badSignatureNum2];
            diag = new Diagnostic{errNode,
                                  Fmt(Err(Err0044),
                                      SymTable::getNakedKindName(symbol->kind),
                                      symbol->name.c_str(),
                                      match.badSignatureInfos.badSignatureNum2,
                                      match.badSignatureInfos.badSignatureNum1)};
        }

        note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
        result0.push_back(diag);
        result1.push_back(note);
        return;
    }

    case MatchResult::MismatchGenericValue:
    {
        diag = new Diagnostic{bi.badNode,
                              Fmt(Err(Err0123),
                                  bi.badGenMatch.c_str(),
                                  Ast::literalToString(bi.badSignatureGivenType, *bi.badGenValue1).c_str(),
                                  Ast::literalToString(bi.badSignatureGivenType, *bi.badGenValue2).c_str())};
        result0.push_back(diag);
        return;
    }

    case MatchResult::BadSignature:
    {
        auto paramNode = destFuncDecl ? destFuncDecl->parameters->childs[bi.badSignatureParameterIdx] : nullptr;

        // In case of lambda, replace undefined with the corresponding match, if possible
        if (bi.badSignatureRequestedType->isLambdaClosure() && bi.badSignatureGivenType->isLambdaClosure())
        {
            auto type1 = CastTypeInfo<TypeInfoFuncAttr>(bi.badSignatureRequestedType, TypeInfoKind::LambdaClosure);
            auto type2 = CastTypeInfo<TypeInfoFuncAttr>(bi.badSignatureGivenType, TypeInfoKind::LambdaClosure);
            for (int i = 0; i < min(type1->parameters.count, type2->parameters.count); i++)
            {
                if (type2->parameters[i]->typeInfo->isNative(NativeTypeKind::Undefined))
                    type2->parameters[i]->typeInfo = type1->parameters[i]->typeInfo;
            }

            if (type2->returnType && type1->returnType && type2->returnType->isNative(NativeTypeKind::Undefined))
                type2->returnType = type1->returnType;
        }

        SWAG_ASSERT(callParameters);
        auto diagNode = match.parameters[bi.badSignatureParameterIdx];
        if (overload->typeInfo->isStruct())
        {
            auto typeStruct = CastTypeInfo<TypeInfoStruct>(overload->typeInfo, TypeInfoKind::Struct);
            diag            = new Diagnostic{diagNode,
                                  Fmt(Err(Err0050),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      typeStruct->fields[badParamIdx - 1]->namedParam.c_str(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }
        else if (paramNode && paramNode->typeInfo->flags & TYPEINFO_SELF && bi.badSignatureParameterIdx == 0)
        {
            if (diagNode->kind == AstNodeKind::FuncDeclParam)
                diagNode = node;
            diag = new Diagnostic{diagNode,
                                  Fmt(Err(Err0106),
                                      refNiceName.c_str(),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }
        else if (oneTry.ufcs && bi.badSignatureParameterIdx == 0)
        {
            diag = new Diagnostic{diagNode,
                                  Fmt(Err(Err0095),
                                      refNiceName.c_str(),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }
        else
        {
            diag = new Diagnostic{diagNode,
                                  Fmt(Err(Err0053),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }

        diag->hint = explicitCastHint;
        if (paramNode && paramNode->specFlags & AST_SPEC_DECLPARAM_GENERATED_SELF)
        {
            note                        = new Diagnostic{destFuncDecl, destFuncDecl->token, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
            note->showRange             = false;
            note->showMultipleCodeLines = false;
        }
        else if (destFuncDecl && bi.badSignatureParameterIdx < destFuncDecl->parameters->childs.size())
        {
            auto reqParam = destFuncDecl->parameters->childs[bi.badSignatureParameterIdx];
            note          = new Diagnostic{reqParam, Fmt(Nte(Nte0066), reqParam->token.ctext(), refNiceName.c_str()), DiagnosticLevel::Note};
        }
        else
            note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};

        result0.push_back(diag);

        // Generic types
        auto remark = Ast::computeGenericParametersReplacement(match.genericReplaceTypes);
        if (!remark.empty())
            note->remarks.insert(note->remarks.end(), remark.begin(), remark.end());

        // A more specific message ?
        Utf8 castMsg, castHint;
        TypeManager::getCastErrorMsg(castMsg, castHint, bi.castErrorToType, bi.castErrorFromType, bi.castErrorFlags);
        if (!castMsg.empty())
        {
            auto note1  = new Diagnostic{diag->sourceNode, castMsg, DiagnosticLevel::Note};
            note1->hint = castHint;
            result1.push_back(note1);
        }

        result1.push_back(note);
        return;
    }

    case MatchResult::BadGenericType:
    {
        SWAG_ASSERT(callParameters);
        diag = new Diagnostic{match.parameters[bi.badSignatureParameterIdx],
                              Fmt(Err(Err0777),
                                  getTheNiceParameterRank(badParamIdx).c_str(),
                                  refNiceName.c_str(),
                                  bi.badSignatureGivenType->getDisplayNameC(),
                                  bi.badSignatureRequestedType->getDisplayNameC())};

        result0.push_back(diag);
        return;
    }

    case MatchResult::BadGenericMatch:
    {
        SWAG_ASSERT(callParameters);
        diag       = new Diagnostic{match.parameters[bi.badSignatureParameterIdx],
                              Fmt(Err(Err0047),
                                  bi.badGenMatch.c_str(),
                                  bi.badSignatureRequestedType->getDisplayNameC(),
                                  bi.badSignatureGivenType->getDisplayNameC())};
        diag->hint = explicitCastHint;

        if (destFuncDecl && bi.badSignatureParameterIdx < destFuncDecl->parameters->childs.size())
        {
            auto reqParam = destFuncDecl->parameters->childs[bi.badSignatureParameterIdx];
            note          = new Diagnostic{reqParam, Fmt(Nte(Nte0066), reqParam->token.ctext(), refNiceName.c_str()), DiagnosticLevel::Note};
        }
        else
            note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};

        result0.push_back(diag);
        result1.push_back(note);
        return;
    }

    case MatchResult::BadGenericSignature:
    {
        SWAG_ASSERT(genericParameters);
        if (match.flags & SymbolMatchContext::MATCH_ERROR_VALUE_TYPE)
        {
            diag = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0054),
                                      getNiceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str())};
        }
        else if (match.flags & SymbolMatchContext::MATCH_ERROR_TYPE_VALUE)
        {
            diag = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0057),
                                      getNiceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str())};
        }
        else
        {
            diag = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0070),
                                      getNiceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str(),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};

            diag->hint = explicitCastHint;
        }

        if (destFuncDecl && bi.badSignatureParameterIdx < destFuncDecl->genericParameters->childs.size())
        {
            auto reqParam = destFuncDecl->genericParameters->childs[bi.badSignatureParameterIdx];
            note          = new Diagnostic{reqParam, Fmt(Nte(Nte0068), reqParam->token.ctext(), refNiceName.c_str()), DiagnosticLevel::Note};
        }
        else
            note = new Diagnostic{overload->node, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
        result0.push_back(diag);
        result1.push_back(note);
        return;
    }
    }
}

void SemanticJob::symbolErrorNotes(SemanticContext* context, VectorNative<OneTryMatch*>& overloads, AstNode* node, Diagnostic* diag, vector<const Diagnostic*>& notes)
{
    if (!node)
        return;
    if (node->kind != AstNodeKind::Identifier && node->kind != AstNodeKind::FuncCall)
        return;
    auto identifier = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);

    // Symbol has been found with a using : display it
    if (overloads.size() == 1 && overloads[0]->dependentVar)
    {
        // Do not generate a note if this is a generated 'using' in case of methods
        if (overloads[0]->dependentVar->kind != AstNodeKind::FuncDeclParam || !(overloads[0]->dependentVar->specFlags & AST_SPEC_DECLPARAM_GENERATED_SELF))
        {
            auto note = new Diagnostic{overloads[0]->dependentVar, Nte(Nte0013), DiagnosticLevel::Note};
            notes.push_back(note);
        }
    }

    // Additional error if the first parameter does not match, or if nothing matches
    bool badUfcs = overloads.empty();
    for (auto over : overloads)
    {
        if (over->symMatchContext.result == MatchResult::BadSignature && over->symMatchContext.badSignatureInfos.badSignatureParameterIdx == 0)
        {
            badUfcs = true;
            break;
        }
    }

    if (badUfcs && !identifier->identifierRef->startScope)
    {
        // There's something before (identifier is not the only one in the identifierRef).
        if (identifier->childParentIdx)
        {
            auto prev = identifier->identifierRef->childs[identifier->childParentIdx - 1];
            if (prev->resolvedSymbolName)
            {
                if (prev->extension && prev->extension->misc->resolvedUserOpSymbolOverload)
                {
                    auto typeInfo = TypeManager::concreteType(prev->extension->misc->resolvedUserOpSymbolOverload->typeInfo);
                    auto note     = new Diagnostic{prev, Fmt(Nte(Nte0018), prev->extension->misc->resolvedUserOpSymbolOverload->symbol->name.c_str(), typeInfo->getDisplayNameC()), DiagnosticLevel::Note};
                    note->hint    = Hint::isType(typeInfo);
                    notes.push_back(note);
                    return;
                }

                if (prev->kind == AstNodeKind::ArrayPointerIndex)
                {
                    auto api = CastAst<AstArrayPointerIndex>(prev, AstNodeKind::ArrayPointerIndex);
                    prev     = api->array;
                }

                if (prev->typeInfo)
                {
                    auto note = new Diagnostic{prev, Fmt(Nte(Nte0001), prev->token.ctext(), SymTable::getArticleKindName(prev->resolvedSymbolName->kind), prev->typeInfo->getDisplayNameC()), DiagnosticLevel::Note};
                    notes.push_back(note);
                }
                else
                {
                    auto note = new Diagnostic{prev, Fmt(Nte(Nte0010), prev->token.ctext(), SymTable::getArticleKindName(prev->resolvedSymbolName->kind)), DiagnosticLevel::Note};
                    notes.push_back(note);
                }

                if (prev->resolvedSymbolOverload)
                {
                    auto note = new Diagnostic{prev->resolvedSymbolOverload->node, Nte(Nte0000), DiagnosticLevel::Note};
                    notes.push_back(note);
                }
            }
        }
    }
}

void SemanticJob::symbolErrorRemarks(SemanticContext* context, VectorNative<OneTryMatch*>& overloads, AstNode* node, Diagnostic* diag)
{
    if (!node)
        return;
    if (node->kind != AstNodeKind::Identifier && node->kind != AstNodeKind::FuncCall)
        return;

    auto identifier = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);
    if (identifier->identifierRef->startScope)
    {
        // If we have an ufcs call, and the match does not come from its symtable, then that means that we have not found the
        // symbol in the original struct also.
        int notFound = 0;
        for (auto overload : overloads)
        {
            if (overload->overload->typeInfo->flags & TYPEINFO_GENERIC)
                continue;

            if (overload->overload->symbol->ownerTable != &identifier->identifierRef->startScope->symTable && overload->ufcs)
                notFound++;
        }

        if (notFound && notFound == overloads.size())
        {
            if (identifier->identifierRef->typeInfo)
                diag->remarks.push_back(Fmt(Nte(Nte0043), node->token.ctext(), identifier->identifierRef->typeInfo->getDisplayNameC()));
            for (auto s : identifier->identifierRef->startScope->childScopes)
            {
                if (s->kind == ScopeKind::Impl)
                {
                    if (s->symTable.find(node->token.text))
                    {
                        diag->remarks.push_back(Fmt(Nte(Nte0044), node->token.ctext(), s->getFullName().c_str()));
                    }
                }
            }
        }
    }
}

bool SemanticJob::cannotMatchIdentifierError(SemanticContext* context, VectorNative<OneTryMatch*>& overloads, AstNode* node)
{
    AstIdentifier* identifier        = nullptr;
    AstNode*       genericParameters = nullptr;
    AstNode*       callParameters    = nullptr;

    // node can be null when we try to resolve a userOp
    if (node && (node->kind == AstNodeKind::Identifier || node->kind == AstNodeKind::FuncCall))
    {
        identifier        = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);
        genericParameters = identifier->genericParameters;
        callParameters    = identifier->callParameters;
    }
    else
        node = context->node;

    // Take non generic errors in priority
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : overloads)
        {
            auto& one = *oneMatch;
            switch (one.symMatchContext.result)
            {
            case MatchResult::BadSignature:
            case MatchResult::DuplicatedNamedParameter:
            case MatchResult::InvalidNamedParameter:
            case MatchResult::MissingNamedParameter:
            case MatchResult::MissingParameters:
            case MatchResult::NotEnoughParameters:
            case MatchResult::MissingSomeParameters:
            case MatchResult::TooManyParameters:
            case MatchResult::SelectIfFailed:
            case MatchResult::NotEnoughGenericParameters:
                n.push_back(oneMatch);
                break;
            }
        }
        if (!n.empty())
            overloads = n;
    }

    // MatchResult::MissingSomeParameters is a correct match, but not enough parameters
    // We take it in priority
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : overloads)
        {
            auto& one = *oneMatch;
            switch (one.symMatchContext.result)
            {
            case MatchResult::MissingSomeParameters:
                n.push_back(oneMatch);
                break;
            }
        }
        if (!n.empty())
            overloads = n;
    }

    // If we do not have generic parameters, then eliminate generic fail
    if (!genericParameters)
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : overloads)
        {
            auto& one = *oneMatch;
            if (!(one.overload->flags & OVERLOAD_GENERIC))
                n.push_back(oneMatch);
        }
        if (!n.empty())
            overloads = n;
    }

    // If we have generic parameters, then eliminate non generic fail
    if (genericParameters)
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : overloads)
        {
            auto& one = *oneMatch;
            if (one.overload->flags & OVERLOAD_GENERIC)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            overloads = n;
    }

    // Take selectif if failed in priority
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : overloads)
        {
            auto& one = *oneMatch;
            if (one.symMatchContext.result == MatchResult::SelectIfFailed)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            overloads = n;
    }

    // Take bad signature in priority
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : overloads)
        {
            auto& one = *oneMatch;
            if (one.symMatchContext.result == MatchResult::BadGenericSignature || one.symMatchContext.result == MatchResult::BadSignature)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            overloads = n;
    }

    // One single overload
    if (overloads.size() == 1)
    {
        // Be sure this is not because of an invalid special function signature
        if (overloads[0]->overload->node->kind == AstNodeKind::FuncDecl)
            SWAG_CHECK(checkFuncPrototype(context, CastAst<AstFuncDecl>(overloads[0]->overload->node, AstNodeKind::FuncDecl)));

        vector<const Diagnostic*> errs0, errs1;
        getDiagnosticForMatch(context, *overloads[0], errs0, errs1);
        SWAG_ASSERT(!errs0.empty());
        symbolErrorRemarks(context, overloads, node, const_cast<Diagnostic*>(errs0[0]));
        symbolErrorNotes(context, overloads, node, const_cast<Diagnostic*>(errs0[0]), errs1);
        return context->report(*errs0[0], errs1);
    }

    // Multiple overloads
    Diagnostic diag{node, Fmt(Err(Err0113), overloads.size(), overloads[0]->overload->symbol->name.c_str())};
    symbolErrorRemarks(context, overloads, node, &diag);

    vector<const Diagnostic*> notes;

    int  badParamIdx, bestBadParamIdx;
    int  badGenParamIdx, bestBadGenParamIdx;
    bool sameBadParamIdx, sameBadGenParamIdx;
    bool sameBadResult = true;
    auto badResult     = MatchResult::Ok;

    for (int pass = 0; pass < 2; pass++)
    {
        badParamIdx        = -1;
        bestBadParamIdx    = -1;
        sameBadParamIdx    = true;
        badGenParamIdx     = -1;
        bestBadGenParamIdx = -1;
        sameBadGenParamIdx = true;

        for (auto& one : overloads)
        {
            if (badResult != MatchResult::Ok && badResult != one->symMatchContext.result)
                sameBadResult = false;
            badResult = one->symMatchContext.result;

            // If this is the same parameter that fails for every overloads, remember it
            if (one->symMatchContext.result == MatchResult::BadSignature)
            {
                sameBadResult      = false;
                sameBadGenParamIdx = false;
                auto ep            = getBadParamIdx(*one, callParameters);
                if (badParamIdx == -1)
                {
                    badParamIdx     = ep;
                    bestBadParamIdx = ep;
                }

                if (ep != badParamIdx)
                    sameBadParamIdx = false;
                if (ep > bestBadParamIdx)
                    bestBadParamIdx = ep;
            }
            else
                sameBadParamIdx = false;

            if (one->symMatchContext.result == MatchResult::BadGenericSignature)
            {
                sameBadResult   = false;
                sameBadParamIdx = false;
                auto ep         = one->symMatchContext.badSignatureInfos.badSignatureParameterIdx;
                if (badGenParamIdx == -1)
                {
                    badGenParamIdx     = ep;
                    bestBadGenParamIdx = ep;
                }
                if (ep != badGenParamIdx)
                    sameBadGenParamIdx = false;
                if (ep > bestBadGenParamIdx)
                    bestBadGenParamIdx = ep;
            }
            else
                sameBadGenParamIdx = false;
        }

        if (pass == 1)
            break;

        // If all fail on the same parameter, we do not display the list of overloads
        if (sameBadParamIdx || sameBadGenParamIdx || sameBadResult)
        {
            static const int MAX_OVERLOADS = 5;
            Diagnostic*      diagRemarks   = &diag;

            switch (badResult)
            {
            case MatchResult::TooManyParameters:
                diagRemarks = new Diagnostic(Fmt("too many parameters"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            case MatchResult::TooManyGenericParameters:
                diagRemarks = new Diagnostic(Fmt("too many generic parameters"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            case MatchResult::NotEnoughParameters:
                diagRemarks = new Diagnostic(Fmt("not enough parameters"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            case MatchResult::NotEnoughGenericParameters:
                diagRemarks = new Diagnostic(Fmt("not enough generic parameters"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            }

            Concat                   concat;
            AstOutput::OutputContext outCxt;
            concat.init(10 * 1024);

            for (int i = 0; i < min(overloads.size(), MAX_OVERLOADS); i++)
            {
                auto funcNode = CastAst<AstFuncDecl>(overloads[i]->overload->node, AstNodeKind::FuncDecl);
                AstOutput::outputFuncSignature(outCxt, concat, funcNode, funcNode->genericParameters, funcNode->parameters, nullptr);
                Utf8 n = Utf8{(const char*) concat.firstBucket->datas, concat.bucketCount(concat.firstBucket)};
                if (n.back() == '\n')
                    n.count--;
                if (n.back() == ';')
                    n.count--;
                Utf8 fn = Fmt("%d: %s", i + 1, n.c_str());
                diagRemarks->remarks.push_back(fn);
                concat.clear();
            }

            if (overloads.size() >= MAX_OVERLOADS)
                diagRemarks->remarks.push_back("...");

            overloads.clear();
            break;
        }

        // Remove overloads with a less accurate match
        for (int i = 0; i < overloads.size(); i++)
        {
            auto one = overloads[i];

            if (one->symMatchContext.result == MatchResult::BadSignature)
            {
                auto ep = getBadParamIdx(*one, callParameters);
                if (ep < bestBadParamIdx)
                {
                    overloads.erase(i);
                    i--;
                    continue;
                }
            }

            if (one->symMatchContext.result == MatchResult::BadGenericSignature)
            {
                auto ep = one->symMatchContext.badSignatureInfos.badSignatureParameterIdx;
                if (ep < bestBadGenParamIdx)
                {
                    overloads.erase(i);
                    i--;
                    continue;
                }
            }
        }
    }

    int overIdx = 1;
    for (auto& one : overloads)
    {
        vector<const Diagnostic*> errs0, errs1;
        getDiagnosticForMatch(context, *one, errs0, errs1);

        SWAG_ASSERT(!errs0.empty());
        auto note = const_cast<Diagnostic*>(errs0[0]);
        if (overloads.size() > 1)
            note->noteHeader = Fmt("overload %d", overIdx++);
        note->showFileName          = false;
        note->showMultipleCodeLines = false;

        switch (one->symMatchContext.result)
        {
        case MatchResult::MissingSomeParameters:
        case MatchResult::BadSignature:
        case MatchResult::BadGenericSignature:
            // Get location from the note
            if (errs1.size())
            {
                note->startLocation = errs1[0]->startLocation;
                note->endLocation   = errs1[0]->endLocation;
            }

            note->hint = "";
            break;

        default:
            note->showRange = false;
            break;
        }

        // Get the overload site
        if (!errs1.empty())
        {
            note->sourceFile    = errs1[0]->sourceFile;
            note->startLocation = errs1[0]->startLocation;
            note->endLocation   = errs1[0]->startLocation;
        }

        note->errorLevel = DiagnosticLevel::Note;
        notes.push_back(errs0[0]);
    }

    if (sameBadParamIdx && badParamIdx != -1 && callParameters && badParamIdx < (int) callParameters->childs.size())
    {
        diag.startLocation = callParameters->childs[badParamIdx]->token.startLocation;
        diag.endLocation   = callParameters->childs[badParamIdx]->token.endLocation;
        diag.hint          = Fmt(Hnt(Hnt0048), callParameters->childs[badParamIdx]->typeInfo->getDisplayNameC());
    }
    else if (sameBadGenParamIdx && badGenParamIdx != -1 && genericParameters && badGenParamIdx < (int) genericParameters->childs.size())
    {
        diag.startLocation = genericParameters->childs[badGenParamIdx]->token.startLocation;
        diag.endLocation   = genericParameters->childs[badGenParamIdx]->token.endLocation;
        diag.hint          = Fmt(Hnt(Hnt0048), genericParameters->childs[badGenParamIdx]->typeInfo->getDisplayNameC());
    }

    symbolErrorNotes(context, overloads, node, &diag, notes);
    return context->report(diag, notes);
}

void SemanticJob::findClosestMatches(SemanticContext* context, const Utf8& searchName, const vector<Utf8>& searchList, vector<Utf8>& result)
{
    uint32_t bestScore = UINT32_MAX;
    result.clear();

    auto searchName1 = searchName;
    searchName1.makeLower();

    for (uint32_t i = 0; i < (uint32_t) searchList.size(); i++)
    {
        auto searchName2 = searchList[i];
        searchName2.makeLower();

        auto score = Utf8::fuzzyCompare(searchName1, searchName2);

        // If number of changes is too big considering the size of the text, cancel
        if (score > (uint32_t) searchName.count / 2)
            continue;
        // If too much changes, cancel
        if (score > 2)
            continue;

        if (score < bestScore)
            result.clear();
        if (score <= bestScore)
        {
            // Be sure it's not already in the best list
            bool here = false;
            for (auto& n : result)
            {
                if (n == searchName)
                {
                    here = true;
                    break;
                }
            }

            if (!here)
                result.push_back(searchList[i]);
            bestScore = score;
        }
    }
}

void SemanticJob::findClosestMatches(SemanticContext* context, IdentifierSearchFor searchFor, AstNode* node, VectorNative<AlternativeScope>& scopeHierarchy, vector<Utf8>& best)
{
    // Do not take some time if file is supposed to fail, in test mode
    if (context->sourceFile->numTestErrors)
        return;

    vector<Utf8> searchList;
    for (auto& as : scopeHierarchy)
    {
        auto s = as.scope;
        for (uint32_t i = 0; i < s->symTable.mapNames.allocated; i++)
        {
            auto one = s->symTable.mapNames.buffer[i];
            if (!one.symbolName)
                continue;

            // Filter to try to be as relevant as possible
            if (searchFor == IdentifierSearchFor::Function &&
                one.symbolName->kind != SymbolKind::Function)
                continue;
            if (searchFor != IdentifierSearchFor::Function &&
                one.symbolName->kind == SymbolKind::Function)
                continue;
            if (searchFor == IdentifierSearchFor::Type &&
                one.symbolName->kind != SymbolKind::TypeAlias &&
                one.symbolName->kind != SymbolKind::Enum &&
                one.symbolName->kind != SymbolKind::GenericType &&
                one.symbolName->kind != SymbolKind::Struct &&
                one.symbolName->kind != SymbolKind::Interface)
                continue;

            searchList.push_back(one.symbolName->name);
        }
    }

    findClosestMatches(context, node->token.text, searchList, best);
}

Utf8 SemanticJob::findClosestMatchesMsg(SemanticContext* context, vector<Utf8>& best)
{
    Utf8 appendMsg;
    switch (best.size())
    {
    case 1:
        appendMsg = Fmt("do you mean `%s` ?", best[0].c_str());
        break;
    case 2:
        appendMsg = Fmt("do you mean `%s` or `%s` ?", best[0].c_str(), best[1].c_str());
        break;
    case 3:
        appendMsg = Fmt("do you mean `%s`, `%s` or `%s` ?", best[0].c_str(), best[1].c_str(), best[2].c_str());
        break;
    }

    return appendMsg;
}

void SemanticJob::unknownIdentifier(SemanticContext* context, AstIdentifierRef* identifierRef, AstIdentifier* node)
{
    auto  job            = context->job;
    auto& scopeHierarchy = job->cacheScopeHierarchy;

    // What kind of thing to we search for ?
    auto searchFor = IdentifierSearchFor::Whatever;
    if (node->parent->parent && node->parent->parent->kind == AstNodeKind::TypeExpression && node->parent->childs.back() == node)
        searchFor = IdentifierSearchFor::Type;
    else if (node->callParameters)
        searchFor = IdentifierSearchFor::Function;

    // Find best matches
    vector<Utf8> best;
    if (identifierRef->startScope)
    {
        scopeHierarchy.clear();
        addAlternativeScopeOnce(scopeHierarchy, identifierRef->startScope);
    }

    findClosestMatches(context, searchFor, node, scopeHierarchy, best);
    Utf8 appendMsg;
    Utf8 bestMatch = findClosestMatchesMsg(context, best);
    if (!bestMatch.empty())
        appendMsg = " (" + bestMatch + ")";

    vector<const Diagnostic*> notes;
    Diagnostic*               diag = nullptr;

    // Message
    switch (searchFor)
    {
    case IdentifierSearchFor::Function:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0228), node->token.ctext())};
        break;
    case IdentifierSearchFor::Type:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0165), node->token.ctext())};
        break;
    default:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0122), node->token.ctext())};
        break;
    }

    // Error in scope context
    if (identifierRef->startScope)
    {
        auto typeRef = TypeManager::concreteType(identifierRef->typeInfo);
        if (typeRef && typeRef->isPointer())
            typeRef = CastTypeInfo<TypeInfoPointer>(typeRef, TypeInfoKind::Pointer)->pointedType;

        if (typeRef && typeRef->isTuple())
        {
            diag      = new Diagnostic{node, Fmt(Err(Err0093), node->token.ctext())};
            auto note = new Diagnostic{identifierRef->startScope->owner, Nte(Nte0030), DiagnosticLevel::Note};
            notes.push_back(note);
        }
        else
        {
            Utf8           displayName;
            AstIdentifier* prevIdentifier = nullptr;
            if (identifierRef->previousResolvedNode && identifierRef->previousResolvedNode->kind == AstNodeKind::Identifier)
                prevIdentifier = CastAst<AstIdentifier>(identifierRef->previousResolvedNode, AstNodeKind::Identifier);
            if (!(identifierRef->startScope->flags & SCOPE_FILE))
                displayName = identifierRef->startScope->getDisplayFullName();
            if (displayName.empty() && !identifierRef->startScope->name.empty())
                displayName = identifierRef->startScope->name;
            if (displayName.empty() && typeRef)
                displayName = typeRef->name;
            if (!displayName.empty())
            {
                auto varDecl = node->findParent(AstNodeKind::VarDecl);
                if (node->identifierRef && node->identifierRef->flags & AST_TUPLE_UNPACK && varDecl)
                    diag = new Diagnostic{node, Fmt(Err(Err0821), varDecl->token.ctext(), displayName.c_str())};
                else if (prevIdentifier && prevIdentifier->alternateEnum)
                {
                    diag      = new Diagnostic{node, Fmt(Err(Err0492), node->token.ctext(), prevIdentifier->alternateEnum->getDisplayNameC(), Scope::getNakedKindName(identifierRef->startScope->kind), displayName.c_str())};
                    auto note = new Diagnostic{prevIdentifier->alternateEnum->declNode, Fmt(Nte(Nte0029), prevIdentifier->alternateEnum->getDisplayNameC()), DiagnosticLevel::Note};
                    notes.push_back(note);
                }
                else
                    diag = new Diagnostic{node, Fmt(Err(Err0110), node->token.ctext(), Scope::getNakedKindName(identifierRef->startScope->kind), displayName.c_str())};
                switch (identifierRef->startScope->owner->kind)
                {
                case AstNodeKind::StructDecl:
                case AstNodeKind::InterfaceDecl:
                case AstNodeKind::EnumDecl:
                    auto note = new Diagnostic{identifierRef->startScope->owner, Fmt(Nte(Nte0029), displayName.c_str()), DiagnosticLevel::Note};
                    notes.push_back(note);
                    break;
                }
            }
        }
    }

    diag->textMsg += appendMsg;

    VectorNative<OneTryMatch*> v;
    symbolErrorRemarks(context, v, node, diag);
    symbolErrorNotes(context, v, node, diag, notes);
    context->report(*diag, notes);
}
