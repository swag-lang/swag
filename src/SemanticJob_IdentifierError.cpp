#include "pch.h"
#include "SemanticJob.h"
#include "ByteCodeGenJob.h"
#include "Ast.h"
#include "Workspace.h"
#include "Generic.h"
#include "TypeManager.h"
#include "ThreadManager.h"
#include "Module.h"
#include "ErrorIds.h"
#include "LanguageSpec.h"
#include "AstOutput.h"
#include "Naming.h"

Utf8 SemanticJob::getNiceArgumentRank(int idx)
{
    switch (idx)
    {
    case 1:
        return "first argument";
    case 2:
        return "second argument";
    case 3:
        return "third argument";
    }
    return Fmt("argument '%d'", idx);
}

Utf8 SemanticJob::getTheNiceArgumentRank(int idx)
{
    switch (idx)
    {
    case 1:
    case 2:
    case 3:
        return "the " + getNiceArgumentRank(idx);
    }
    return Fmt("the argument '%d'", idx);
}

Utf8 SemanticJob::getNiceParameterRank(int idx)
{
    switch (idx)
    {
    case 1:
        return "first parameter";
    case 2:
        return "second parameter";
    case 3:
        return "third parameter";
    }
    return Fmt("parameter '%d'", idx);
}

Utf8 SemanticJob::getTheNiceParameterRank(int idx)
{
    switch (idx)
    {
    case 1:
    case 2:
    case 3:
        return "the " + getNiceParameterRank(idx);
    }
    return Fmt("the parameter '%d'", idx);
}

static int getBadParamIdx(OneTryMatch& oneTry, AstNode* callParameters)
{
    BadSignatureInfos bi = oneTry.symMatchContext.badSignatureInfos;

    // If the first parameter of the call has been generated by ufcs, then decrease the call parameter index by 1, so
    // that the message is more relevant
    int badParamIdx = bi.badSignatureParameterIdx;
    if (badParamIdx &&
        callParameters &&
        !callParameters->childs.empty() &&
        callParameters->childs.front()->flags & (AST_FROM_UFCS | AST_TO_UFCS) &&
        !(callParameters->childs.front()->flags & AST_UFCS_FCT))
    {
        badParamIdx--;
    }
    else if (badParamIdx && oneTry.ufcs)
        badParamIdx--;
    // This is a closure with a generated first parameter
    if (oneTry.symMatchContext.flags & SymbolMatchContext::MATCH_CLOSURE_PARAM)
        badParamIdx--;

    return badParamIdx;
}

bool SemanticJob::preprocessMatchError(SemanticContext* context, OneTryMatch& oneTry, vector<const Diagnostic*>& result0, vector<const Diagnostic*>& result1)
{
    SymbolOverload*    overload = oneTry.overload;
    auto&              match    = oneTry.symMatchContext;
    BadSignatureInfos& bi       = oneTry.symMatchContext.badSignatureInfos;
    auto               typeFunc = overload->symbol->kind == SymbolKind::Function ? CastTypeInfo<TypeInfoFuncAttr>(overload->typeInfo, TypeInfoKind::FuncAttr) : nullptr;

    // UFCS.toto(a, ...) with in fact toto(a, ...)
    if (match.result == MatchResult::BadSignature &&
        typeFunc &&
        match.parameters.size() == typeFunc->parameters.size() + 1 &&
        oneTry.ufcs &&
        typeFunc->parameters.size() >= 1 &&
        !typeFunc->parameters[0]->typeInfo->isSelf() &&
        bi.badSignatureParameterIdx == 0)
    {
        auto ufcs  = match.parameters[0];
        auto note  = new Diagnostic{ufcs, ufcs->token, Hlp(Hlp0044), DiagnosticLevel::Help};
        note->hint = Hnt(Hnt0094);
        result1.push_back(note);
    }

    return false;
}

void SemanticJob::getDiagnosticForMatch(SemanticContext* context, OneTryMatch& oneTry, vector<const Diagnostic*>& result0, vector<const Diagnostic*>& result1)
{
    // Smart changes for smarter errors (very specific cases)
    if (preprocessMatchError(context, oneTry, result0, result1))
        return;

    auto              node              = context->node;
    BadSignatureInfos bi                = oneTry.symMatchContext.badSignatureInfos;
    auto              symbol            = oneTry.overload->symbol;
    SymbolOverload*   overload          = oneTry.overload;
    auto              genericParameters = oneTry.genericParameters;
    auto              callParameters    = oneTry.callParameters;
    auto&             match             = oneTry.symMatchContext;
    AstFuncCallParam* failedParam       = nullptr;

    // Get the call parameter that failed
    int badParamIdx = getBadParamIdx(oneTry, callParameters);
    if (oneTry.callParameters && badParamIdx >= 0 && badParamIdx < callParameters->childs.size())
        failedParam = static_cast<AstFuncCallParam*>(callParameters->childs[badParamIdx]);
    badParamIdx += 1;

    // Nice name to reference it
    Utf8 refNiceName = "the ";
    refNiceName += Naming::getNakedKindName(overload);

    // Get parameters of destination symbol
    AstFuncDecl* destFuncDecl = nullptr;
    if (overload->node->kind == AstNodeKind::FuncDecl)
        destFuncDecl = CastAst<AstFuncDecl>(overload->node, AstNodeKind::FuncDecl);

    Diagnostic* diag = nullptr;

    // In case it's generic, and we have real types
    bi.badSignatureRequestedType = Generic::doTypeSubstitution(oneTry.symMatchContext.genericReplaceTypes, bi.badSignatureRequestedType);

    // See if it would have worked with an explicit cast, to give a hint in the error message
    Utf8 hintMsg;
    switch (match.result)
    {
    case MatchResult::BadGenericMatch:
    case MatchResult::BadSignature:
    case MatchResult::BadGenericSignature:
        if (bi.badSignatureRequestedType->isPointer() ||
            bi.badSignatureGivenType->isPointer())
            break;

        if (bi.badSignatureRequestedType->isNative())
        {
            if (TypeManager::makeCompatibles(context, bi.badSignatureRequestedType, bi.badSignatureGivenType, nullptr, nullptr, CASTFLAG_TRY_COERCE | CASTFLAG_JUST_CHECK | CASTFLAG_NO_ERROR))
            {
                hintMsg = Fmt(Hnt(Hnt0025), bi.badSignatureRequestedType->name.c_str());
                break;
            }
        }

        if (bi.badSignatureRequestedType->isStruct())
        {
            if (TypeManager::makeCompatibles(context, bi.badSignatureRequestedType, bi.badSignatureGivenType, nullptr, nullptr, CASTFLAG_EXPLICIT | CASTFLAG_JUST_CHECK | CASTFLAG_NO_ERROR))
            {
                hintMsg = Fmt(Hnt(Hnt0025), bi.badSignatureRequestedType->name.c_str());
                break;
            }
        }

        break;
    }

    switch (match.result)
    {
    default:
        SWAG_ASSERT(false);
        return;

    case MatchResult::SelectIfFailed:
    {
        SWAG_ASSERT(destFuncDecl);
        diag = new Diagnostic{node, node->token, Fmt(Err(Err0004), destFuncDecl->token.ctext(), destFuncDecl->selectIf->token.ctext())};
        result0.push_back(diag);
        auto note       = new Diagnostic{destFuncDecl->selectIf, destFuncDecl->selectIf->token, Fmt(Nte(Nte0007), destFuncDecl->selectIf->token.ctext()), DiagnosticLevel::Note};
        note->showRange = false;
        result1.push_back(note);
        return;
    }

    case MatchResult::MissingNamedParameter:
    {
        SWAG_ASSERT(failedParam);
        SWAG_ASSERT(badParamIdx >= 2);
        diag = new Diagnostic{failedParam, Fmt(Err(Err0006), getTheNiceArgumentRank(badParamIdx).c_str()), Hnt(Hnt0031)};
        diag->addRange(callParameters->childs[badParamIdx - 2], Hnt(Hnt0030));
        result0.push_back(diag);
        return;
    }

    case MatchResult::InvalidNamedParameter:
    {
        SWAG_ASSERT(failedParam && failedParam->extension && failedParam->extension->misc && failedParam->extension->misc->isNamed);
        diag = new Diagnostic{failedParam->extension->misc->isNamed, Fmt(Err(Err0008), failedParam->extension->misc->isNamed->token.ctext())};
        result0.push_back(diag);
        if (!(overload->node->flags & AST_GENERATED))
        {
            auto note = Diagnostic::hereIs(overload);
            if (note)
                result1.push_back(note);
        }
        return;
    }

    case MatchResult::DuplicatedNamedParameter:
    {
        SWAG_ASSERT(failedParam && failedParam->extension && failedParam->extension->misc && failedParam->extension->misc->isNamed);
        diag       = new Diagnostic{failedParam->extension->misc->isNamed, Fmt(Err(Err0011), failedParam->extension->misc->isNamed->token.ctext())};
        diag->hint = Hnt(Hnt0009);
        int other  = oneTry.symMatchContext.badSignatureInfos.badSignatureNum1;
        SWAG_ASSERT(other < callParameters->childs.size());
        diag->addRange(callParameters->childs[other], Hnt(Hnt0059));
        result0.push_back(diag);
        return;
    }

    case MatchResult::MissingParameters:
    {
        diag       = new Diagnostic{callParameters ? callParameters : node, Fmt(Err(Err0020), refNiceName.c_str())};
        diag->hint = Hnt(Hnt0044);
        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::MissingSomeParameters:
    {
        if (!callParameters)
        {
            diag       = new Diagnostic{node, Fmt(Err(Err0020), refNiceName.c_str())};
            diag->hint = Hnt(Hnt0044);
        }
        else if (destFuncDecl)
        {
            diag       = new Diagnostic{callParameters, Fmt(Err(Err0016), refNiceName.c_str())};
            auto miss  = destFuncDecl->parameters->childs[match.cptResolved];
            diag->hint = Fmt(Hnt(Hnt0083), miss->token.ctext(), miss->typeInfo->getDisplayNameC());
        }
        else
        {
            diag = new Diagnostic{callParameters, Fmt(Err(Err0016), refNiceName.c_str())};
        }

        result0.push_back(diag);

        if (destFuncDecl && callParameters)
        {
            auto note  = new Diagnostic{destFuncDecl->parameters->childs[match.cptResolved], Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
            note->hint = Hnt(Hnt0071);
            result1.push_back(note);
        }
        else
        {
            auto note = Diagnostic::hereIs(overload);
            if (node)
                result1.push_back(note);
        }

        return;
    }

    case MatchResult::NotEnoughParameters:
    {
        if (!callParameters)
        {
            diag       = new Diagnostic{node, Fmt(Err(Err0020), refNiceName.c_str())};
            diag->hint = Hnt(Hnt0044);
        }
        else
            diag = new Diagnostic{callParameters, Fmt(Err(Err0016), refNiceName.c_str())};
        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::NotEnoughGenericParameters:
    {
        AstNode* errNode = genericParameters;
        if (!errNode)
            errNode = node;
        if (!errNode)
            errNode = context->node;
        if (destFuncDecl && destFuncDecl->isSpecialFunctionName())
            diag = new Diagnostic{errNode, errNode->token, Fmt(Err(Err0352), refNiceName.c_str(), destFuncDecl->token.ctext())};
        else if (genericParameters)
            diag = new Diagnostic{genericParameters, Fmt(Err(Err0035), refNiceName.c_str())};
        else
            diag = new Diagnostic{errNode, Fmt(Err(Err0049), refNiceName.c_str())};
        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::TooManyParameters:
    {
        AstNode* site = failedParam;
        if (!site)
            site = callParameters;
        SWAG_ASSERT(site);
        diag = new Diagnostic{site, Fmt(Err(Err0026), match.badSignatureInfos.badSignatureNum2, match.badSignatureInfos.badSignatureNum1)};
        if (failedParam)
            diag->hint = Hnt(Hnt0026);
        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::TooManyGenericParameters:
    {
        AstNode* errNode = genericParameters;
        if (!errNode)
            errNode = node;
        if (!errNode)
            errNode = context->node;
        if (!match.badSignatureInfos.badSignatureNum2)
        {
            diag = new Diagnostic{errNode, Fmt(Err(Err0135), Naming::getNakedKindName(symbol->kind).c_str(), symbol->name.c_str()).c_str()};
        }
        else
        {
            if (genericParameters)
                errNode = genericParameters->childs[match.badSignatureInfos.badSignatureNum2];
            diag = new Diagnostic{errNode,
                                  Fmt(Err(Err0044),
                                      Naming::getNakedKindName(symbol->kind).c_str(),
                                      symbol->name.c_str(),
                                      match.badSignatureInfos.badSignatureNum2,
                                      match.badSignatureInfos.badSignatureNum1)};
            if (genericParameters)
                diag->hint = Hnt(Hnt0026);
        }

        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::MismatchGenericValue:
    {
        diag = new Diagnostic{bi.badNode,
                              Fmt(Err(Err0123),
                                  bi.badGenMatch.c_str(),
                                  Ast::literalToString(bi.badSignatureGivenType, *bi.badGenValue1).c_str(),
                                  Ast::literalToString(bi.badSignatureGivenType, *bi.badGenValue2).c_str())};
        result0.push_back(diag);
        return;
    }

    case MatchResult::BadSignature:
    {
        auto paramNode = destFuncDecl ? destFuncDecl->parameters->childs[bi.badSignatureParameterIdx] : nullptr;

        // In case of lambda, replace undefined with the corresponding match, if possible
        if (bi.badSignatureRequestedType->isLambdaClosure() && bi.badSignatureGivenType->isLambdaClosure())
        {
            auto type1 = CastTypeInfo<TypeInfoFuncAttr>(bi.badSignatureRequestedType, TypeInfoKind::LambdaClosure);
            auto type2 = CastTypeInfo<TypeInfoFuncAttr>(bi.badSignatureGivenType, TypeInfoKind::LambdaClosure);
            for (int i = 0; i < min(type1->parameters.count, type2->parameters.count); i++)
            {
                if (type2->parameters[i]->typeInfo->isNative(NativeTypeKind::Undefined))
                    type2->parameters[i]->typeInfo = type1->parameters[i]->typeInfo;
            }

            if (type2->returnType && type1->returnType && type2->returnType->isNative(NativeTypeKind::Undefined))
                type2->returnType = type1->returnType;
        }

        SWAG_ASSERT(callParameters);
        auto diagNode = match.parameters[bi.badSignatureParameterIdx];

        if (overload->typeInfo->isStruct())
        {
            auto typeStruct = CastTypeInfo<TypeInfoStruct>(overload->typeInfo, TypeInfoKind::Struct);
            diag            = new Diagnostic{diagNode,
                                  Fmt(Err(Err0050),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      typeStruct->fields[badParamIdx - 1]->namedParam.c_str(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }
        else if (oneTry.ufcs && bi.badSignatureParameterIdx == 0 && oneTry.dependentVar)
        {
            diag    = new Diagnostic{context->node,
                                  context->node->token,
                                  Fmt(Err(Err0095),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
            hintMsg = Fmt(Hnt(Hnt0093), bi.badSignatureGivenType->getDisplayNameC());
            if (oneTry.dependentVar->isGeneratedSelf())
            {
                auto note = new Diagnostic{oneTry.dependentVar->ownerFct, oneTry.dependentVar->ownerFct->token, Nte(Nte0073), DiagnosticLevel::Note};
                result1.push_back(note);
            }
            else
            {
                auto note = new Diagnostic{oneTry.dependentVar, Nte(Nte0074), DiagnosticLevel::Note};
                result1.push_back(note);
            }
        }
        else if (oneTry.ufcs && bi.badSignatureParameterIdx == 0)
        {
            diag          = new Diagnostic{diagNode,
                                  Fmt(Err(Err0095),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
            auto nodeCall = diagNode->parent->childs.back();
            hintMsg       = Diagnostic::isType(bi.badSignatureGivenType);
            diag->addRange(nodeCall->token, Fmt(Hnt(Hnt0093), bi.badSignatureGivenType->getDisplayNameC()));
        }
        else if (paramNode && paramNode->typeInfo->isSelf() && bi.badSignatureParameterIdx == 0)
        {
            if (diagNode->kind == AstNodeKind::FuncDeclParam)
                diagNode = node;
            diag = new Diagnostic{diagNode,
                                  Fmt(Err(Err0106),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }
        else
        {
            diag = new Diagnostic{diagNode,
                                  Fmt(Err(Err0053),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }

        diag->hint = hintMsg;
        result0.push_back(diag);

        // A more specific cast message ?
        Utf8 castMsg, castHint;
        TypeManager::getCastErrorMsg(castMsg, castHint, bi.castErrorToType, bi.castErrorFromType, bi.castErrorFlags, true);
        if (!castMsg.empty())
        {
            if (oneTry.dependentVar)
            {
                auto note  = new Diagnostic{oneTry.dependentVar, castMsg, DiagnosticLevel::Note};
                note->hint = castHint;
                result1.push_back(note);
            }
            else
            {
                auto note  = new Diagnostic{diag->sourceNode, diag->sourceNode->token, castMsg, DiagnosticLevel::Note};
                note->hint = castHint;
                result1.push_back(note);
            }
        }

        // Here is
        Diagnostic* note = nullptr;
        if (paramNode && paramNode->isGeneratedSelf())
        {
            note                        = new Diagnostic{destFuncDecl, destFuncDecl->token, Fmt(Nte(Nte0008), refNiceName.c_str()), DiagnosticLevel::Note};
            note->showRange             = false;
            note->showMultipleCodeLines = false;
            result1.push_back(note);
        }
        else if (destFuncDecl && bi.badSignatureParameterIdx < destFuncDecl->parameters->childs.size())
        {
            auto reqParam = destFuncDecl->parameters->childs[bi.badSignatureParameterIdx];
            note          = new Diagnostic{reqParam, reqParam->token, Fmt(Nte(Nte0066), reqParam->token.ctext(), refNiceName.c_str()), DiagnosticLevel::Note};
            result1.push_back(note);
        }
        else
        {
            note = Diagnostic::hereIs(overload);
            if (note)
                result1.push_back(note);
        }

        // Generic types
        if (note && context->errorContextStack.empty() || context->errorContextStack.front().type != ErrorContextKind::Generic)
        {
            auto remark = Ast::computeGenericParametersReplacement(match.genericReplaceTypes);
            if (!remark.empty())
                note->remarks.insert(note->remarks.end(), remark.begin(), remark.end());
        }

        return;
    }

    case MatchResult::BadGenericType:
    {
        SWAG_ASSERT(callParameters);
        diag       = new Diagnostic{match.parameters[bi.badSignatureParameterIdx],
                              Fmt(Err(Err0777),
                                  getTheNiceArgumentRank(badParamIdx).c_str(),
                                  refNiceName.c_str(),
                                  bi.badSignatureGivenType->getDisplayNameC(),
                                  bi.badSignatureRequestedType->getDisplayNameC())};
        diag->hint = Fmt(Hnt(Hnt0063), bi.badSignatureRequestedType->getDisplayNameC());
        result0.push_back(diag);
        return;
    }

    case MatchResult::BadGenericMatch:
    {
        SWAG_ASSERT(callParameters);
        diag = new Diagnostic{match.parameters[bi.badSignatureParameterIdx],
                              Fmt(Err(Err0047),
                                  bi.badGenMatch.c_str(),
                                  bi.badSignatureRequestedType->getDisplayNameC(),
                                  bi.badSignatureGivenType->getDisplayNameC())};
        if (hintMsg.empty())
            diag->hint = Diagnostic::isType(match.parameters[bi.badSignatureParameterIdx]->typeInfo);
        else
            diag->hint = hintMsg;
        result0.push_back(diag);

        if (bi.genMatchFromNode)
        {
            auto note = new Diagnostic{bi.genMatchFromNode, Fmt(Nte(Nte0075), bi.genMatchFromNode->typeInfo->getDisplayNameC()), DiagnosticLevel::Note};
            result1.push_back(note);
        }

        if (destFuncDecl && bi.badSignatureParameterIdx < destFuncDecl->parameters->childs.size())
        {
            auto reqParam = destFuncDecl->parameters->childs[bi.badSignatureParameterIdx];
            auto note     = new Diagnostic{reqParam, Fmt(Nte(Nte0066), reqParam->token.ctext(), refNiceName.c_str()), DiagnosticLevel::Note};
            result1.push_back(note);
        }
        else
        {
            auto note = Diagnostic::hereIs(overload);
            if (note)
                result1.push_back(note);
        }

        return;
    }

    case MatchResult::BadGenericSignature:
    {
        SWAG_ASSERT(genericParameters);
        if (match.flags & SymbolMatchContext::MATCH_ERROR_VALUE_TYPE)
        {
            diag       = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0054),
                                      getNiceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str())};
            diag->hint = Hnt(Hnt0028);
        }
        else if (match.flags & SymbolMatchContext::MATCH_ERROR_TYPE_VALUE)
        {
            diag       = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0057),
                                      getNiceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str())};
            diag->hint = Hnt(Hnt0027);
        }
        else
        {
            diag = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0070),
                                      getNiceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str(),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};

            diag->hint = hintMsg.empty() ? Diagnostic::isType(bi.badSignatureGivenType) : hintMsg;
        }

        result0.push_back(diag);

        if (destFuncDecl && bi.badSignatureParameterIdx < destFuncDecl->genericParameters->childs.size())
        {
            auto reqParam = destFuncDecl->genericParameters->childs[bi.badSignatureParameterIdx];
            auto note     = new Diagnostic{reqParam, Fmt(Nte(Nte0068), reqParam->token.ctext(), refNiceName.c_str()), DiagnosticLevel::Note};
            result1.push_back(note);
        }
        else
        {
            auto note = Diagnostic::hereIs(overload);
            if (note)
                result1.push_back(note);
        }

        return;
    }
    }
}

void SemanticJob::symbolErrorNotes(SemanticContext* context, VectorNative<OneTryMatch*>& tryMatches, AstNode* node, Diagnostic* diag, vector<const Diagnostic*>& notes)
{
    if (!node)
        return;
    if (node->kind != AstNodeKind::Identifier && node->kind != AstNodeKind::FuncCall)
        return;
    auto identifier = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);

    // Symbol has been found with a using : display it
    if (tryMatches.size() == 1 && tryMatches[0]->dependentVar)
    {
        // Do not generate a note if this is a generated 'using' in case of methods
        if (!tryMatches[0]->dependentVar->isGeneratedSelf())
        {
            auto note = new Diagnostic{tryMatches[0]->dependentVar, Fmt(Nte(Nte0013), tryMatches[0]->overload->symbol->name.c_str()), DiagnosticLevel::Note};
            notes.push_back(note);
        }
    }

    // Additional error if the first parameter does not match, or if nothing matches
    bool badUfcs = tryMatches.empty();
    for (auto over : tryMatches)
    {
        if (over->symMatchContext.result == MatchResult::BadSignature && over->symMatchContext.badSignatureInfos.badSignatureParameterIdx == 0)
        {
            badUfcs = true;
            break;
        }
    }

    if (badUfcs && !identifier->identifierRef->startScope)
    {
        // There's something before (identifier is not the only one in the identifierRef).
        if (identifier->childParentIdx)
        {
            auto prev = identifier->identifierRef->childs[identifier->childParentIdx - 1];
            if (prev->resolvedSymbolName)
            {
                if (prev->extension && prev->extension->misc->resolvedUserOpSymbolOverload)
                {
                    auto typeInfo = TypeManager::concreteType(prev->extension->misc->resolvedUserOpSymbolOverload->typeInfo);
                    auto note     = new Diagnostic{prev, Fmt(Nte(Nte0018), prev->extension->misc->resolvedUserOpSymbolOverload->symbol->name.c_str(), typeInfo->getDisplayNameC()), DiagnosticLevel::Note};
                    note->hint    = Diagnostic::isType(typeInfo);
                    notes.push_back(note);
                    return;
                }

                if (prev->kind == AstNodeKind::ArrayPointerIndex)
                {
                    auto api = CastAst<AstArrayPointerIndex>(prev, AstNodeKind::ArrayPointerIndex);
                    prev     = api->array;
                }

                if (prev->typeInfo)
                {
                    auto note = new Diagnostic{prev, Fmt(Nte(Nte0001), prev->token.ctext(), Naming::getArticleKindName(prev->resolvedSymbolName->kind).c_str(), prev->typeInfo->getDisplayNameC()), DiagnosticLevel::Note};
                    notes.push_back(note);
                }
                else
                {
                    auto note = new Diagnostic{prev, Fmt(Nte(Nte0010), prev->token.ctext(), Naming::getArticleKindName(prev->resolvedSymbolName->kind).c_str()), DiagnosticLevel::Note};
                    notes.push_back(note);
                }

                if (prev->resolvedSymbolOverload)
                {
                    auto note = new Diagnostic{prev->resolvedSymbolOverload->node, Nte(Nte0000), DiagnosticLevel::Note};
                    notes.push_back(note);
                }
            }
        }
    }
}

void SemanticJob::symbolErrorRemarks(SemanticContext* context, VectorNative<OneTryMatch*>& tryMatches, AstNode* node, Diagnostic* diag)
{
    if (!node)
        return;
    if (node->kind != AstNodeKind::Identifier && node->kind != AstNodeKind::FuncCall)
        return;
    if (tryMatches.empty())
        return;

    // If we have an ufcs call, and the match does not come from its symtable, then that means that we have not found the
    // symbol in the original struct also.
    auto identifier = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);
    if (identifier->identifierRef->startScope && !tryMatches.empty())
    {
        int notFound = 0;
        for (auto tryMatch : tryMatches)
        {
            if (tryMatch->ufcs &&
                tryMatch->overload->node->ownerStructScope &&
                identifier->ownerStructScope &&
                tryMatch->overload->node->ownerStructScope->owner != identifier->identifierRef->startScope->owner)
                notFound++;
        }

        if (notFound == tryMatches.size())
        {
            if (identifier->identifierRef->typeInfo)
            {
                auto over = tryMatches.front()->overload;
                auto msg  = Fmt(Nte(Nte0043),
                               Naming::getNakedKindName(over).c_str(),
                               node->token.ctext(),
                               identifier->identifierRef->typeInfo->getDisplayNameC(),
                               over->node->ownerStructScope->owner->token.ctext());
                diag->remarks.push_back(msg);
            }

            for (auto s : identifier->identifierRef->startScope->childScopes)
            {
                if (s->kind == ScopeKind::Impl)
                {
                    if (s->symTable.find(node->token.text))
                    {
                        diag->remarks.push_back(Fmt(Nte(Nte0044), node->token.ctext(), s->getFullName().c_str()));
                    }
                }
            }
        }
    }
}

bool SemanticJob::cannotMatchIdentifierError(SemanticContext* context, VectorNative<OneTryMatch*>& tryMatches, AstNode* node)
{
    AstIdentifier* identifier        = nullptr;
    AstNode*       genericParameters = nullptr;
    AstNode*       callParameters    = nullptr;

    // node can be null when we try to resolve a userOp
    if (node && (node->kind == AstNodeKind::Identifier || node->kind == AstNodeKind::FuncCall))
    {
        identifier        = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);
        genericParameters = identifier->genericParameters;
        callParameters    = identifier->callParameters;
    }
    else
        node = context->node;

    // Take non generic errors in priority
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            switch (one.symMatchContext.result)
            {
            case MatchResult::BadSignature:
            case MatchResult::DuplicatedNamedParameter:
            case MatchResult::InvalidNamedParameter:
            case MatchResult::MissingNamedParameter:
            case MatchResult::MissingParameters:
            case MatchResult::NotEnoughParameters:
            case MatchResult::MissingSomeParameters:
            case MatchResult::TooManyParameters:
            case MatchResult::SelectIfFailed:
            case MatchResult::NotEnoughGenericParameters:
                n.push_back(oneMatch);
                break;
            }
        }
        if (!n.empty())
            tryMatches = n;
    }

    // MatchResult::MissingSomeParameters is a correct match, but not enough parameters
    // We take it in priority
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            switch (one.symMatchContext.result)
            {
            case MatchResult::MissingSomeParameters:
                n.push_back(oneMatch);
                break;
            }
        }
        if (!n.empty())
            tryMatches = n;
    }

    // If we do not have generic parameters, then eliminate generic fail
    if (!genericParameters)
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            if (!(one.overload->flags & OVERLOAD_GENERIC))
                n.push_back(oneMatch);
        }
        if (!n.empty())
            tryMatches = n;
    }

    // If we have generic parameters, then eliminate non generic fail
    if (genericParameters)
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            if (one.overload->flags & OVERLOAD_GENERIC)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            tryMatches = n;
    }

    // Take selectif if failed in priority
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            if (one.symMatchContext.result == MatchResult::SelectIfFailed)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            tryMatches = n;
    }

    // Take bad signature in priority
    {
        vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            if (one.symMatchContext.result == MatchResult::BadGenericSignature || one.symMatchContext.result == MatchResult::BadSignature)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            tryMatches = n;
    }

    // One single overload
    if (tryMatches.size() == 1)
    {
        // Be sure this is not because of an invalid special function signature
        if (tryMatches[0]->overload->node->kind == AstNodeKind::FuncDecl)
            SWAG_CHECK(checkFuncPrototype(context, CastAst<AstFuncDecl>(tryMatches[0]->overload->node, AstNodeKind::FuncDecl)));

        vector<const Diagnostic*> errs0, errs1;
        getDiagnosticForMatch(context, *tryMatches[0], errs0, errs1);
        SWAG_ASSERT(!errs0.empty());
        symbolErrorRemarks(context, tryMatches, node, const_cast<Diagnostic*>(errs0[0]));
        symbolErrorNotes(context, tryMatches, node, const_cast<Diagnostic*>(errs0[0]), errs1);
        return context->report(*errs0[0], errs1);
    }

    // Multiple tryMatches
    Diagnostic diag{node, Fmt(Err(Err0113), tryMatches.size(), tryMatches[0]->overload->symbol->name.c_str())};
    symbolErrorRemarks(context, tryMatches, node, &diag);

    vector<const Diagnostic*> notes;

    int  badParamIdx, bestBadParamIdx;
    int  badGenParamIdx, bestBadGenParamIdx;
    bool sameBadParamIdx, sameBadGenParamIdx;
    bool sameBadResult = true;
    auto badResult     = MatchResult::Ok;

    for (int pass = 0; pass < 2; pass++)
    {
        badParamIdx        = -1;
        bestBadParamIdx    = -1;
        sameBadParamIdx    = true;
        badGenParamIdx     = -1;
        bestBadGenParamIdx = -1;
        sameBadGenParamIdx = true;

        for (auto& one : tryMatches)
        {
            if (badResult != MatchResult::Ok && badResult != one->symMatchContext.result)
                sameBadResult = false;
            badResult = one->symMatchContext.result;

            // If this is the same parameter that fails for every tryMatches, remember it
            if (one->symMatchContext.result == MatchResult::BadSignature)
            {
                sameBadResult      = false;
                sameBadGenParamIdx = false;
                auto ep            = getBadParamIdx(*one, callParameters);
                if (badParamIdx == -1)
                {
                    badParamIdx     = ep;
                    bestBadParamIdx = ep;
                }

                if (ep != badParamIdx)
                    sameBadParamIdx = false;
                if (ep > bestBadParamIdx)
                    bestBadParamIdx = ep;
            }
            else
                sameBadParamIdx = false;

            if (one->symMatchContext.result == MatchResult::BadGenericSignature)
            {
                sameBadResult   = false;
                sameBadParamIdx = false;
                auto ep         = one->symMatchContext.badSignatureInfos.badSignatureParameterIdx;
                if (badGenParamIdx == -1)
                {
                    badGenParamIdx     = ep;
                    bestBadGenParamIdx = ep;
                }
                if (ep != badGenParamIdx)
                    sameBadGenParamIdx = false;
                if (ep > bestBadGenParamIdx)
                    bestBadGenParamIdx = ep;
            }
            else
                sameBadGenParamIdx = false;
        }

        if (pass == 1)
            break;

        // If all fail on the same parameter, we do not display the list of tryMatches
        if (sameBadParamIdx || sameBadGenParamIdx || sameBadResult)
        {
            static const int MAX_OVERLOADS = 5;
            Diagnostic*      diagRemarks   = &diag;

            switch (badResult)
            {
            case MatchResult::SelectIfFailed:
                diagRemarks = new Diagnostic(Fmt("#selectifonce have all failed"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            case MatchResult::TooManyParameters:
                diagRemarks = new Diagnostic(Fmt("too many parameters"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            case MatchResult::TooManyGenericParameters:
                diagRemarks = new Diagnostic(Fmt("too many generic parameters"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            case MatchResult::NotEnoughParameters:
                diagRemarks = new Diagnostic(Fmt("not enough parameters"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            case MatchResult::NotEnoughGenericParameters:
                diagRemarks = new Diagnostic(Fmt("not enough generic parameters"), DiagnosticLevel::Note);
                notes.push_back(diagRemarks);
                break;
            }

            Concat                   concat;
            AstOutput::OutputContext outCxt;
            concat.init(10 * 1024);

            for (int i = 0; i < min(tryMatches.size(), MAX_OVERLOADS); i++)
            {
                auto funcNode = CastAst<AstFuncDecl>(tryMatches[i]->overload->node, AstNodeKind::FuncDecl);
                AstOutput::outputFuncSignature(outCxt, concat, funcNode, funcNode->genericParameters, funcNode->parameters, nullptr);
                Utf8 n = Utf8{(const char*) concat.firstBucket->datas, concat.bucketCount(concat.firstBucket)};
                if (n.back() == '\n')
                    n.count--;
                if (n.back() == ';')
                    n.count--;
                Utf8 fn = Fmt("%d: %s", i + 1, n.c_str());
                diagRemarks->remarks.push_back(fn);
                concat.clear();
            }

            if (tryMatches.size() >= MAX_OVERLOADS)
                diagRemarks->remarks.push_back("...");

            tryMatches.clear();
            break;
        }

        // Remove tryMatches with a less accurate match
        for (int i = 0; i < tryMatches.size(); i++)
        {
            auto one = tryMatches[i];

            if (one->symMatchContext.result == MatchResult::BadSignature)
            {
                auto ep = getBadParamIdx(*one, callParameters);
                if (ep < bestBadParamIdx)
                {
                    tryMatches.erase(i);
                    i--;
                    continue;
                }
            }

            if (one->symMatchContext.result == MatchResult::BadGenericSignature)
            {
                auto ep = one->symMatchContext.badSignatureInfos.badSignatureParameterIdx;
                if (ep < bestBadGenParamIdx)
                {
                    tryMatches.erase(i);
                    i--;
                    continue;
                }
            }
        }
    }

    int overIdx = 1;
    for (auto& one : tryMatches)
    {
        vector<const Diagnostic*> errs0, errs1;
        getDiagnosticForMatch(context, *one, errs0, errs1);

        SWAG_ASSERT(!errs0.empty());
        auto note = const_cast<Diagnostic*>(errs0[0]);
        if (tryMatches.size() > 1)
            note->noteHeader = Fmt("overload %d", overIdx++);
        note->showFileName          = false;
        note->showMultipleCodeLines = false;

        switch (one->symMatchContext.result)
        {
        case MatchResult::MissingSomeParameters:
        case MatchResult::BadSignature:
        case MatchResult::BadGenericSignature:
            // Get location from the note
            if (errs1.size())
            {
                note->startLocation = errs1[0]->startLocation;
                note->endLocation   = errs1[0]->endLocation;
            }

            note->hint = "";
            break;

        default:
            note->showRange = false;
            break;
        }

        // Get the overload site
        if (!errs1.empty())
        {
            note->sourceFile    = errs1[0]->sourceFile;
            note->startLocation = errs1[0]->startLocation;
            note->endLocation   = errs1[0]->startLocation;
        }

        note->errorLevel = DiagnosticLevel::Note;
        notes.push_back(errs0[0]);
    }

    if (sameBadParamIdx && badParamIdx != -1 && callParameters && badParamIdx < (int) callParameters->childs.size())
    {
        diag.startLocation = callParameters->childs[badParamIdx]->token.startLocation;
        diag.endLocation   = callParameters->childs[badParamIdx]->token.endLocation;
        diag.hint          = Fmt(Hnt(Hnt0048), callParameters->childs[badParamIdx]->typeInfo->getDisplayNameC());
    }
    else if (sameBadGenParamIdx && badGenParamIdx != -1 && genericParameters && badGenParamIdx < (int) genericParameters->childs.size())
    {
        diag.startLocation = genericParameters->childs[badGenParamIdx]->token.startLocation;
        diag.endLocation   = genericParameters->childs[badGenParamIdx]->token.endLocation;
        diag.hint          = Fmt(Hnt(Hnt0048), genericParameters->childs[badGenParamIdx]->typeInfo->getDisplayNameC());
    }

    symbolErrorNotes(context, tryMatches, node, &diag, notes);
    return context->report(diag, notes);
}

void SemanticJob::findClosestMatches(SemanticContext* context, const Utf8& searchName, const vector<Utf8>& searchList, vector<Utf8>& result)
{
    uint32_t bestScore = UINT32_MAX;
    result.clear();

    auto searchName1 = searchName;
    searchName1.makeLower();

    for (uint32_t i = 0; i < (uint32_t) searchList.size(); i++)
    {
        auto searchName2 = searchList[i];
        searchName2.makeLower();
        if (searchName1 == searchName2)
            continue;

        auto score = Utf8::fuzzyCompare(searchName1, searchName2);

        // If number of changes is too big considering the size of the text, cancel
        if (searchName.count > 1 && score > (uint32_t) searchName.count / 2)
            continue;
        // If too much changes, cancel
        if (score > 2)
            continue;

        if (score < bestScore)
            result.clear();
        if (score <= bestScore)
        {
            // Be sure it's not already in the best list
            bool here = false;
            for (auto& n : result)
            {
                if (n == searchList[i])
                {
                    here = true;
                    break;
                }
            }

            if (!here)
            {
                result.push_back(searchList[i]);
            }

            bestScore = score;
        }
    }
}

void SemanticJob::findClosestMatches(SemanticContext* context, IdentifierSearchFor searchFor, AstNode* node, VectorNative<AlternativeScope>& scopeHierarchy, vector<Utf8>& best)
{
    // Do not take some time if file is supposed to fail, in test mode
    if (context->sourceFile->numTestErrors && !g_CommandLine.verboseTestErrors)
        return;

    vector<Utf8> searchList;
    for (auto& as : scopeHierarchy)
    {
        auto s = as.scope;
        for (uint32_t i = 0; i < s->symTable.mapNames.allocated; i++)
        {
            auto one = s->symTable.mapNames.buffer[i];
            if (!one.symbolName)
                continue;

            // Filter to try to be as relevant as possible
            if (searchFor == IdentifierSearchFor::Function &&
                one.symbolName->kind != SymbolKind::Function)
                continue;
            if (searchFor != IdentifierSearchFor::Function &&
                one.symbolName->kind == SymbolKind::Function)
                continue;
            if (searchFor == IdentifierSearchFor::Type &&
                one.symbolName->kind != SymbolKind::TypeAlias &&
                one.symbolName->kind != SymbolKind::Enum &&
                one.symbolName->kind != SymbolKind::GenericType &&
                one.symbolName->kind != SymbolKind::Struct &&
                one.symbolName->kind != SymbolKind::Interface)
                continue;
            if (one.symbolName->cptOverloadsInit == 0)
                continue;

            searchList.push_back(one.symbolName->name);
        }
    }

    if (searchFor == IdentifierSearchFor::Type)
    {
        for (int i = 0; i < (int) g_LangSpec->keywords.allocated; i++)
        {
            if (g_LangSpec->keywords.buffer[i].value == TokenId::NativeType)
            {
                searchList.push_back(g_LangSpec->keywords.buffer[i].key);
            }
        }
    }
    else if (searchFor == IdentifierSearchFor::Function && node->token.text[0] == '@')
    {
        for (int i = 0; i < (int) g_LangSpec->keywords.allocated; i++)
        {
            auto& k = g_LangSpec->keywords.buffer[i].key;
            if (k && k[0] == '@')
                searchList.push_back(k);
        }
    }
    else if (searchFor == IdentifierSearchFor::Function && node->token.text[0] == '#')
    {
        for (int i = 0; i < (int) g_LangSpec->keywords.allocated; i++)
        {
            auto& k = g_LangSpec->keywords.buffer[i].key;
            if (k && k[0] == '#')
                searchList.push_back(k);
        }
    }

    findClosestMatches(context, node->token.text, searchList, best);
}

Utf8 SemanticJob::findClosestMatchesMsg(SemanticContext* context, vector<Utf8>& best)
{
    Utf8 appendMsg;
    switch (best.size())
    {
    case 1:
        appendMsg = Fmt("do you mean '%s' ?", best[0].c_str());
        break;
    case 2:
        appendMsg = Fmt("do you mean '%s' or '%s' ?", best[0].c_str(), best[1].c_str());
        break;
    case 3:
        appendMsg = Fmt("do you mean '%s', '%s' or '%s' ?", best[0].c_str(), best[1].c_str(), best[2].c_str());
        break;
    }

    return appendMsg;
}

void SemanticJob::unknownIdentifier(SemanticContext* context, AstIdentifierRef* identifierRef, AstIdentifier* node)
{
    auto  job                = context->job;
    auto& scopeHierarchy     = job->cacheScopeHierarchy;
    auto& scopeHierarchyVars = job->cacheScopeHierarchyVars;

    // What kind of thing to we search for ?
    auto searchFor = IdentifierSearchFor::Whatever;
    if (node->parent->parent && node->parent->parent->kind == AstNodeKind::TypeExpression && node->parent->childs.back() == node)
        searchFor = IdentifierSearchFor::Type;
    else if (node->callParameters)
        searchFor = IdentifierSearchFor::Function;

    // Find best matches
    vector<Utf8> best;
    if (identifierRef->startScope)
    {
        scopeHierarchy.clear();
        addAlternativeScopeOnce(scopeHierarchy, identifierRef->startScope);
    }
    else
    {
        collectScopeHierarchy(context, scopeHierarchy, scopeHierarchyVars, node, COLLECT_ALL);
    }

    findClosestMatches(context, searchFor, node, scopeHierarchy, best);
    Utf8 appendMsg;
    Utf8 bestMatch = findClosestMatchesMsg(context, best);
    if (!bestMatch.empty())
        appendMsg = bestMatch;

    vector<const Diagnostic*> notes;
    Diagnostic*               diag = nullptr;

    // Message
    switch (searchFor)
    {
    case IdentifierSearchFor::Function:
        if (node->token.text[0] == '#')
            diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0140), node->token.ctext())};
        else if (node->token.text[0] == '@')
            diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0129), node->token.ctext())};
        else
            diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0228), node->token.ctext())};
        break;
    case IdentifierSearchFor::Type:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0165), node->token.ctext())};
        break;
    default:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0122), node->token.ctext())};
        break;
    }

    // Error in scope context
    if (identifierRef->startScope)
    {
        auto typeWhere = identifierRef->startScope->owner->typeInfo;
        auto typeRef   = TypeManager::concreteType(identifierRef->typeInfo);
        if (typeRef && typeRef->isPointer())
            typeRef = CastTypeInfo<TypeInfoPointer>(typeRef, TypeInfoKind::Pointer)->pointedType;

        if (typeRef && typeRef->isTuple())
        {
            diag      = new Diagnostic{node, Fmt(Err(Err0093), node->token.ctext())};
            auto note = new Diagnostic{identifierRef->startScope->owner, Nte(Nte0030), DiagnosticLevel::Note};
            notes.push_back(note);
        }
        else
        {
            Utf8           displayName;
            AstIdentifier* prevIdentifier = nullptr;
            if (identifierRef->previousResolvedNode && identifierRef->previousResolvedNode->kind == AstNodeKind::Identifier)
                prevIdentifier = CastAst<AstIdentifier>(identifierRef->previousResolvedNode, AstNodeKind::Identifier);
            if (!(identifierRef->startScope->flags & SCOPE_FILE))
                displayName = identifierRef->startScope->getDisplayFullName();
            if (displayName.empty() && !identifierRef->startScope->name.empty())
                displayName = identifierRef->startScope->name;
            if (displayName.empty() && typeRef)
                displayName = typeRef->name;
            if (!displayName.empty())
            {
                auto varDecl = node->findParent(AstNodeKind::VarDecl);
                if (node->identifierRef && node->identifierRef->flags & AST_TUPLE_UNPACK && varDecl)
                {
                    diag = new Diagnostic{node, Fmt(Err(Err0821), varDecl->token.ctext(), displayName.c_str())};
                }
                else if (prevIdentifier && prevIdentifier->alternateEnum)
                {
                    diag            = new Diagnostic{node, node->token, Fmt(Err(Err0492), node->token.ctext(), prevIdentifier->alternateEnum->getDisplayNameC(), Scope::getNakedKindName(identifierRef->startScope->kind), displayName.c_str())};
                    auto note       = new Diagnostic{prevIdentifier->alternateEnum->declNode, prevIdentifier->alternateEnum->declNode->token, Fmt(Nte(Nte0029), prevIdentifier->alternateEnum->getDisplayNameC()), DiagnosticLevel::Note};
                    note->showRange = false;
                    notes.push_back(note);
                }
                else if (typeWhere)
                {
                    Utf8 what = "identifier";
                    if (node->callParameters)
                        what = "function";
                    diag = new Diagnostic{node, node->token, Fmt(Err(Err0112), what.c_str(), node->token.ctext(), typeWhere->getDisplayNameC())};
                }
                else
                {
                    Utf8 where = Scope::getNakedKindName(identifierRef->startScope->kind);
                    diag       = new Diagnostic{node, node->token, Fmt(Err(Err0110), node->token.ctext(), where.c_str(), displayName.c_str())};
                }

                switch (identifierRef->startScope->owner->kind)
                {
                case AstNodeKind::StructDecl:
                case AstNodeKind::InterfaceDecl:
                case AstNodeKind::EnumDecl:
                    auto note       = new Diagnostic{identifierRef->startScope->owner, identifierRef->startScope->owner->token, Fmt(Nte(Nte0029), displayName.c_str()), DiagnosticLevel::Note};
                    note->showRange = false;
                    notes.push_back(note);
                    break;
                }
            }
        }
    }

    VectorNative<OneTryMatch*> v;
    symbolErrorRemarks(context, v, node, diag);
    symbolErrorNotes(context, v, node, diag, notes);

    if (diag->hint.empty())
        diag->hint = appendMsg;
    else
    {
        diag->textMsg += " (";
        diag->textMsg += appendMsg;
        diag->textMsg += ")";
    }

    context->report(*diag, notes);
}
