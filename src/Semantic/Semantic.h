#pragma once
#include "Semantic/SemanticContext.h"

struct AstAttrUse;
struct AstFuncCallParam;
struct AstFuncDecl;
struct AstIdentifier;
struct AstIdentifierRef;
struct AstNode;
struct AttributeList;
struct DataSegment;
struct Diagnostic;
struct Module;
struct SourceFile;
struct SymbolName;
struct SymbolOverload;
struct TypeInfoFuncAttr;

enum class AstNodeKind : uint8_t;
enum class SymbolKind : uint8_t;
using ToConcreteFlags = Flags<uint32_t>;
using GenExportFlags  = Flags<uint32_t>;
using OverloadFlags   = Flags<uint32_t>;

struct FindUserOp
{
    SymbolName*     symbol;
    TypeInfoStruct* parentStruct;
    TypeInfoParam*  usingField;
};

using CollectFlags                              = Flags<uint32_t>;
constexpr CollectFlags COLLECT_ALL              = 0x00000000;
constexpr CollectFlags COLLECT_NO_STRUCT        = 0x00000001;
constexpr CollectFlags COLLECT_NO_INLINE_PARAMS = 0x00000002;

using MatchIdParamsFlags                            = Flags<uint32_t>;
constexpr MatchIdParamsFlags MIP_JUST_CHECK         = 0x00000001;
constexpr MatchIdParamsFlags MIP_FOR_GHOSTING       = 0x00000002;
constexpr MatchIdParamsFlags MIP_FOR_ZERO_GHOSTING  = 0x00000004;
constexpr MatchIdParamsFlags MIP_SECOND_GENERIC_TRY = 0x00000008;

constexpr uint32_t ROP_SIMPLE_CAST = 0x00000001;

using ResolveIdFlags                          = Flags<uint32_t>;
constexpr ResolveIdFlags RI_ZERO              = 0x00000000;
constexpr ResolveIdFlags RI_FOR_GHOSTING      = 0x00000001;
constexpr ResolveIdFlags RI_FOR_ZERO_GHOSTING = 0x00000002;

namespace Semantic
{
    void start(SemanticContext* context, SourceFile* sourceFile, AstNode* originalNode);

    void waitAllStructInterfaces(Job* job, TypeInfo* typeInfo);
    void waitAllStructInterfacesReg(Job* job, TypeInfo* typeInfo);
    void waitAllStructMethods(Job* job, TypeInfo* typeInfo);
    void waitAllStructSpecialMethods(Job* job, TypeInfo* typeInfo);
    void waitForGenericParameters(const SemanticContext* context, OneMatch& match);
    void waitForOverloads(Job* job, SymbolName* symbol);
    void waitFuncDeclFullResolve(Job* job, AstFuncDecl* funcDecl);
    void waitOverloadCompleted(Job* job, const SymbolOverload* overload);
    void waitStructGenerated(Job* job, TypeInfo* typeInfo);
    void waitStructGeneratedAlloc(Job* job, TypeInfo* typeInfo);
    void waitSymbolNoLock(Job* job, SymbolName* symbol);
    void waitTypeCompleted(Job* job, TypeInfo* typeInfo);

    bool valueEqualsTo(const ComputedValue* value, AstNode* node);
    bool valueEqualsTo(const ComputedValue* value1, const ComputedValue* value2, const TypeInfo* typeInfo, AstNodeFlags flags);

    Utf8 checkLiteralValue(ComputedValue& computedValue, LiteralType& literalType, const Register& literalValue, TypeInfo* typeSuffix, bool negApplied);
    bool checkAttribute(SemanticContext* context, AstNode* oneAttribute, AstNode* checkNode);
    bool checkCanCatch(SemanticContext* context);
    bool checkCanMakeFuncPointer(SemanticContext* context, AstFuncDecl* funcNode, AstNode* node);
    bool checkCanTakeAddress(SemanticContext* context, AstNode* node);
    bool checkCanThrow(SemanticContext* context);
    bool checkFuncPrototype(SemanticContext* context, AstFuncDecl* node);
    bool checkFuncPrototypeOp(SemanticContext* context, AstFuncDecl* node);
    bool checkFuncPrototypeOpNumParams(SemanticContext* context, const AstFuncDecl* node, AstNode* parameters, uint32_t numWanted, bool exact = true);
    bool checkFuncPrototypeOpParam(SemanticContext* context, AstNode* parameters, uint32_t index, TypeInfo* wanted);
    bool checkFuncPrototypeOpReturnType(SemanticContext* context, AstFuncDecl* node, TypeInfo* wanted);
    bool checkImplScopes(SemanticContext* context, AstImpl* node, const Scope* scopeImpl, const Scope* scope);
    bool checkInitDropCount(SemanticContext* context, const AstNode* node, AstNode* expression, AstNode* count);
    bool checkIsConcrete(SemanticContext* context, AstNode* node);
    bool checkIsConcreteOrType(SemanticContext* context, AstNode* node, bool typeOnly = false);
    bool checkIsConstAffect(SemanticContext* context, AstNode* left, const AstNode* right);
    bool checkIsConstExpr(JobContext* context, AstNode* expression, const Utf8& errMsg = "", const Utf8& errParam = "");
    bool checkIsConstExpr(JobContext* context, bool test, AstNode* expression, const Utf8& errMsg = "", const Utf8& errParam = "");
    bool checkTypeIsNative(SemanticContext* context, AstNode* node, TypeInfo* typeInfo);
    bool checkTypeIsNative(SemanticContext* context, TypeInfo* leftTypeInfo, TypeInfo* rightTypeInfo, AstNode* left, AstNode* right);

    bool hasUserOp(SemanticContext* context, const Utf8& name, TypeInfoStruct* leftStruct, TypeInfoParam* parentField, VectorNative<FindUserOp>& result);
    bool hasUserOp(SemanticContext* context, const Utf8& name, TypeInfoStruct* leftStruct, SymbolName** result);
    bool hasUserOp(SemanticContext* context, const Utf8& name, const AstNode* left, SymbolName** result);
    bool waitUserOp(SemanticContext* context, const Utf8& name, const AstNode* left, SymbolName** result);

    bool collectAttributes(SemanticContext* context, AstNode* forNode, AttributeList* result);
    bool collectAttributes(SemanticContext* context, AstNode* forNode, AttributeList* result, AstAttrUse* attrUse);
    bool collectAutoScope(SemanticContext* context, VectorNative<AlternativeScope>& scopeHierarchy, AstIdentifierRef* identifierRef, const AstIdentifier* identifier);
    bool collectScopeHierarchy(Scope* startScope, VectorNative<AlternativeScope>& scopeHierarchy, VectorNative<AlternativeScopeVar>& scopeHierarchyVars, VectorNative<OneSymbolMatch>& symbolsMatch, const AstIdentifierRef* identifierRef, const AstIdentifier* identifier, uint32_t identifierCrc);
    bool collectScopeHierarchy(SemanticContext* context, VectorNative<AlternativeScope>& scopeHierarchy, VectorNative<AlternativeScopeVar>& scopeHierarchyVars, AstIdentifierRef* identifierRef, AstIdentifier* identifier);
    bool collectScopeHierarchy(SemanticContext* context, VectorNative<AlternativeScope>& scopes, VectorNative<AlternativeScopeVar>& scopesVars, AstNode* startNode, CollectFlags flags, IdentifierScopeUpMode scopeUpMode = IdentifierScopeUpMode::None, TokenParse* scopeUpValue = nullptr);
    bool findIdentifierInScopes(SemanticContext* context, AstIdentifierRef* identifierRef, AstIdentifier* identifier);
    bool findIdentifierInScopes(SemanticContext* context, VectorNative<OneSymbolMatch>& symbolsMatch, AstIdentifierRef* identifierRef, AstIdentifier* identifier);
    bool hasAlternativeScope(VectorNative<AlternativeScope>& scopes, const Scope* scope);
    void addAlternativeScope(VectorNative<AlternativeScope>& scopes, Scope* scope, AltScopeFlags flags = 0);
    void addAlternativeScopeOnce(VectorNative<AlternativeScope>& scopes, Scope* scope, AltScopeFlags flags = 0);
    void collectAlternativeScopeHierarchy(SemanticContext* context, VectorNative<AlternativeScope>& scopes, VectorNative<AlternativeScopeVar>& scopesVars, AstNode* startNode, CollectFlags flags, IdentifierScopeUpMode scopeUpMode = IdentifierScopeUpMode::None, TokenParse* scopeUpValue = nullptr);
    void collectAlternativeScopeVars(const AstNode* startNode, VectorNative<AlternativeScope>& scopes, VectorNative<AlternativeScopeVar>& scopesVars);
    void collectAlternativeScopes(const AstNode* startNode, VectorNative<AlternativeScope>& scopes);
    void findSymbolsInHierarchy(VectorNative<AlternativeScope>& scopeHierarchy, VectorNative<OneSymbolMatch>& symbolsMatch, const AstIdentifier* identifier, uint32_t identifierCrc);

    AstSemFlags attributeToAccess(AttributeFlags attribute);
    bool        canHaveAccess(const AstNode* node);
    bool        canHaveGlobalAccess(const AstNode* node);
    bool        canInheritAccess(const AstNode* node);
    bool        checkAccess(JobContext* context, AstNode* node);
    void        computeAccess(AstNode* node);
    void        computeAccessRec(AstNode* node);
    void        doInheritAccess(AstNode* forNode, const AstNode* node);
    void        inheritAccess(const AstNode* node);
    void        setDefaultAccess(AstNode* node);
    void        setNodeAccess(AstNode* node);

    AstFuncDecl*   getFunctionForReturn(AstNode* node);
    AstIdentifier* createTmpId(SemanticContext* context, AstNode* node, const Utf8& name);
    DataSegment*   getConstantSegFromContext(const AstNode* node, bool forceCompiler = false);
    DataSegment*   getSegmentForVar(SemanticContext* context, const AstVarDecl* varNode);
    Diagnostic*    computeNonConstExprNote(AstNode* node);
    TypeInfo*      getConcreteTypeUnRef(AstNode* node, ToConcreteFlags concreteFlags);
    TypeInfo*      getDeducedLambdaType(SemanticContext* context, const AstMakePointer* node);
    TypeInfoEnum*  findEnumTypeInContext(SemanticContext* context, TypeInfo* typeInfo);
    Utf8           getSpecialOpSignature(const AstFuncDecl* node);
    bool           appendLastCodeStatement(SemanticContext* context, AstIdentifier* node, const SymbolOverload* overload);
    bool           boundCheck(SemanticContext* context, const TypeInfo* forType, AstNode* arrayNode, AstNode* arrayAccess, uint64_t maxCount);
    bool           collectAssignment(SemanticContext* context, DataSegment* storageSegment, uint32_t& storageOffset, AstVarDecl* node, TypeInfo* typeInfo = nullptr);
    bool           collectConstantAssignment(SemanticContext* context, DataSegment** storageSegmentResult, uint32_t* storageOffsetResult, OverloadFlags& symbolFlags);
    bool           collectConstantSlice(SemanticContext* context, AstNode* assignNode, TypeInfo* assignType, DataSegment* storageSegment, uint32_t& storageOffset);
    bool           collectLiteralsToSegment(JobContext* context, DataSegment* storageSegment, uint32_t baseOffset, uint32_t& offset, AstNode* node);
    bool           collectStructLiterals(JobContext* context, DataSegment* storageSegment, uint32_t offsetStruct, AstNode* node);
    bool           computeExpressionListTupleType(SemanticContext* context, AstNode* node);
    bool           convertTypeListToArray(SemanticContext* context, AstVarDecl* node, bool isCompilerConstant, OverloadFlags overFlags, CastFlags castFlags = 0);
    bool           deduceLambdaParamTypeFrom(SemanticContext* context, AstVarDecl* nodeParam, bool& lambdaExpr, bool& genericType);
    bool           derefConstant(SemanticContext* context, uint8_t* ptr, const SymbolOverload* overload, DataSegment* storageSegment);
    bool           derefConstantValue(SemanticContext* context, AstNode* node, TypeInfo* typeInfo, DataSegment* storageSegment, uint8_t* ptr);
    bool           doExecuteCompilerNode(SemanticContext* context, AstNode* node, bool onlyConstExpr);
    bool           evaluateConstExpression(SemanticContext* context, AstNode* node);
    bool           evaluateConstExpression(SemanticContext* context, AstNode* node1, AstNode* node2);
    bool           evaluateConstExpression(SemanticContext* context, AstNode* node1, AstNode* node2, AstNode* node3);
    bool           executeCompilerNode(SemanticContext* context, AstNode* node, bool onlyConstExpr);
    bool           fillMatchContextCallParameters(SemanticContext* context, SymbolMatchContext& symMatchContext, AstIdentifier* identifier, const SymbolOverload* overload, AstNode* ufcsFirstParam);
    bool           fillMatchContextGenericParameters(SemanticContext* context, SymbolMatchContext& symMatchContext, AstIdentifier* node, const SymbolOverload* overload);
    bool           findEnumTypeInContext(SemanticContext* context, const AstNode* node, VectorNative<TypeInfoEnum*>& result, VectorNative<std::pair<AstNode*, TypeInfoEnum*>>& has, VectorNative<SymbolOverload*>& testedOver);
    bool           getConstantArrayPtr(SemanticContext* context, uint32_t* storageOffset, DataSegment** storageSegment);
    bool           getDigitHex(SemanticContext* context, const SourceLocation& startLoc, const char* pzs, const char** pzr, int& result, const char* errMsg);
    bool           getUsingVar(SemanticContext* context, AstIdentifierRef* identifierRef, const AstIdentifier* node, const SymbolOverload* overload, AstNode** result, AstNode** resultLeaf);
    bool           isCompilerContext(const AstNode* node);
    bool           isFunctionButNotACall(SemanticContext* context, AstNode* node, const SymbolName* symbol);
    bool           isMethod(const AstFuncDecl* funcNode);
    bool           makeInline(JobContext* context, AstFuncDecl* funcDecl, AstNode* identifier);
    bool           makeInline(SemanticContext* context, AstFuncDecl* funcDecl, AstNode* identifier);
    bool           makeIntrinsicKindof(SemanticContext* context, AstNode* node);
    bool           needToCompleteSymbolNoLock(SemanticContext* context, const AstIdentifier* identifier, SymbolName* symbol, bool testOverloads);
    bool           needToWaitForSymbolNoLock(SemanticContext* context, const AstIdentifier* identifier, const SymbolName* symbol);
    bool           processLiteralString(SemanticContext* context);
    bool           registerFuncSymbol(SemanticContext* context, AstFuncDecl* funcNode, OverloadFlags overFlags = 0);
    bool           reserveAndStoreToSegment(JobContext* context, DataSegment* storageSegment, uint32_t& storageOffset, ComputedValue* value, TypeInfo* typeInfo, AstNode* assignment);
    bool           resolveIdentifier(SemanticContext* context, AstIdentifier* identifier, ResolveIdFlags riFlags);
    bool           resolveMakePointer(SemanticContext* context);
    bool           resolveMakePointerLambda(SemanticContext* context);
    bool           setFullResolve(SemanticContext* context, AstFuncDecl* funcNode);
    bool           setState(SemanticContext* context, AstNode* node, AstNodeResolveState state);
    bool           setUnRef(AstNode* node);
    bool           setupFuncDeclParams(SemanticContext* context, TypeInfoFuncAttr* typeInfo, const AstNode* funcNode, AstNode* parameters, bool forGenerics);
    bool           setupIdentifierRef(SemanticContext* context, AstNode* node);
    bool           solveValidIf(SemanticContext* context, OneMatch* oneMatch, AstFuncDecl* funcDecl);
    bool           solveValidIf(SemanticContext* context, const AstStruct* structDecl);
    bool           storeToSegment(JobContext* context, DataSegment* storageSegment, uint32_t storageOffset, ComputedValue* value, TypeInfo* typeInfo, AstNode* assignment);
    bool           waitForStructUserOps(SemanticContext* context, const AstNode* node);
    bool           waitForSymbols(SemanticContext* context, AstIdentifier* identifier, Job* job);
    uint32_t       alignOf(const AstVarDecl* node);
    uint32_t       getMaxStackSize(AstNode* node);
    void           addSymbolMatch(VectorNative<OneSymbolMatch>& symbolsMatch, SymbolName* symName, Scope* scope, AltScopeFlags altFlags);
    void           allocateOnStack(AstNode* node, const TypeInfo* typeInfo);
    void           decreaseInterfaceCount(TypeInfoStruct* typeInfoStruct);
    void           decreaseInterfaceRegCount(TypeInfoStruct* typeInfoStruct);
    void           decreaseMethodCount(const AstFuncDecl* funcNode, TypeInfoStruct* typeInfoStruct);
    void           disableCompilerIfBlock(SemanticContext* context, AstCompilerIfBlock* block);
    void           flattenStructChildren(SemanticContext* context, AstNode* parent, VectorNative<AstNode*>& result);
    void           forceConstType(SemanticContext* context, AstTypeExpression* node);
    void           inheritAttributesFrom(AstNode* child, AttributeFlags attributeFlags, SafetyFlags safetyOn, SafetyFlags safetyOff);
    void           inheritAttributesFromOwnerFunc(AstNode* child);
    void           inheritAttributesFromParent(AstNode* child);
    void           launchResolveSubDecl(const JobContext* context, AstNode* node);
    void           propagateReturn(AstNode* node);
    void           resolveSubDecls(const JobContext* context, AstFuncDecl* funcNode);
    void           setFuncDeclParamsIndex(const AstFuncDecl* funcNode);
    void           setOwnerMaxStackSize(AstNode* node, uint32_t size);
    void           setVarDeclResolve(AstVarDecl* varNode);

    bool computeMatch(SemanticContext* context, AstIdentifier* identifier, ResolveIdFlags riFlags, VectorNative<OneSymbolMatch>& symbolsMatch, AstIdentifierRef* identifierRef);
    bool dealWithMatchResults(SemanticContext* context, VectorNative<OneTryMatch*>& tryMatches, AstNode*& node, MatchIdParamsFlags flags, VectorNative<OneMatch*>& matches, VectorNative<OneMatch*>& genericMatches, VectorNative<OneMatch*>& genericMatchesSI, bool forStruct, uint32_t prevMatchesCount);
    bool doSimpleMatch(SemanticContext* context, VectorNative<OneMatch*>& matches, OneTryMatch* const& oneMatch, OneTryMatch& oneOverload);
    bool matchIdentifierParameters(SemanticContext* context, VectorNative<OneTryMatch*>& tryMatches, AstNode* node, MatchIdParamsFlags flags = 0);
    bool matchRetval(SemanticContext* context, VectorNative<OneSymbolMatch>& symbolsMatch, const AstIdentifier* identifier);
    bool matchSharpSelf(SemanticContext* context, VectorNative<OneSymbolMatch>& symbolsMatch, AstIdentifierRef* identifierRef, AstIdentifier* identifier);
    bool needToWaitForSymbol(Job* job, SymbolName* symbol);
    bool registerMatch(SemanticContext* context, AstNode* node, VectorNative<OneTryMatch*>& tryMatches, VectorNative<OneMatch*>& matches, VectorNative<OneMatch*>& genericMatches, VectorNative<OneMatch*>& genericMatchesSI, OneTryMatch& oneOverload, TypeInfo* typeWasForced);
    bool setMatchResult(SemanticContext* context, AstIdentifierRef* identifierRef, AstIdentifier* identifier, OneMatch& oneMatch);
    bool checkMatchResult(SemanticContext* context, const AstIdentifierRef* identifierRef, AstIdentifier* identifier, const OneMatch& oneMatch, const SymbolName* symbol, const SymbolOverload* overload, AstNode* prevNode);
    bool setMatchResultAndType(SemanticContext* context, AstIdentifierRef* identifierRef, AstIdentifier* identifier, OneMatch& oneMatch);
    bool setSymbolMatchCallParams(SemanticContext* context, const OneMatch& oneMatch, AstIdentifier* identifier);
    bool setSymbolMatchFunc(SemanticContext* context, const OneMatch& oneMatch, AstIdentifier* identifier, const SymbolOverload* overload);
    bool setSymbolMatchStruct(SemanticContext* context, OneMatch& oneMatch, AstIdentifierRef* identifierRef, AstIdentifier* identifier, const SymbolOverload* overload, TypeInfo* typeAlias);
    bool setSymbolMatchUsingVar(SemanticContext* context, AstIdentifierRef* identifierRef, const AstIdentifier* identifier, AstNode* dependentVar);
    bool setSymbolMatchVar(SemanticContext* context, const OneMatch& oneMatch, AstIdentifierRef* idRef, AstIdentifier* identifier, SymbolOverload* overload);
    bool tryOneMatch(SemanticContext* context, OneTryMatch& oneOverload, const SymbolOverload* overload, TypeInfo* rawTypeInfo, MatchIdParamsFlags flags);
    void dealWithIntrinsic(const SemanticContext* context, AstIdentifier* identifier);
    void resolvePendingLambdaTyping(const SemanticContext* context, AstNode* funcNode, const TypeInfo* resolvedType);
    void sortParameters(AstNode* allParams);

    bool setFirstParamUFCS(SemanticContext* context, AstIdentifierRef* identifierRef, OneMatch& match);
    bool canTryUFCS(SemanticContext* context, TypeInfoFuncAttr* typeFunc, AstNode* nodeUFCS, bool nodeIsExplicit);
    bool getUFCS(SemanticContext* context, const AstIdentifierRef* identifierRef, AstIdentifier* node, const SymbolOverload* overload, AstNode** firstParamUFCS);

    void computeMatchesCoerceCast(VectorNative<OneMatch*>& matches);
    bool filterMatches(SemanticContext* context, VectorNative<OneMatch*>& matches, VectorNative<OneMatch*>& genericMatches, VectorNative<OneMatch*>& genericMatchesSI);
    bool filterMatchesDirect(SemanticContext* context, VectorNative<OneMatch*>& matches);
    bool filterMatchesCompare(const SemanticContext* context, VectorNative<OneMatch*>& matches);
    bool filterMatchesCoerceCast(SemanticContext* context, VectorNative<OneMatch*>& matches);
    bool filterSymbols(SemanticContext* context, AstIdentifier* node);
    bool filterGenericMatches(const SemanticContext* context, VectorNative<OneMatch*>& matches, VectorNative<OneMatch*>& genMatches);
    bool filterMatchesInContext(SemanticContext* context, VectorNative<OneMatch*>& matches);

    Utf8 getCompilerFunctionString(const AstNode* node, TokenId id);
    bool sendCompilerMsgFuncDecl(SemanticContext* context);
    bool sendCompilerMsgTypeDecl(SemanticContext* context);
    bool sendCompilerMsgGlobalVar(SemanticContext* context);

    bool preResolveAttrDecl(SemanticContext* context);
    bool preResolveCompilerInstruction(SemanticContext* context);
    bool preResolveGeneratedStruct(SemanticContext* context);
    bool preResolveIdentifierRef(SemanticContext* context);
    bool preResolveStructContent(SemanticContext* context);
    bool preResolveSubstBreakContinue(SemanticContext* context);

    bool resolveAffect(SemanticContext* context);
    bool resolveAfterKnownType(SemanticContext* context);
    bool resolveAppend(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveArrayPointerDeRef(SemanticContext* context);
    bool resolveArrayPointerIndex(SemanticContext* context);
    bool resolveArrayPointerRef(SemanticContext* context);
    bool resolveArrayPointerSlicing(SemanticContext* context);
    bool resolveArrayPointerSlicingUpperBound(SemanticContext* context);
    bool resolveAssume(SemanticContext* context);
    bool resolveAssumeBlock(SemanticContext* context);
    bool resolveAttrDecl(SemanticContext* context);
    bool resolveAttrUse(SemanticContext* context);
    bool resolveAttrUse(SemanticContext* context, AstAttrUse* node);
    bool resolveBinaryOpDiv(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveBinaryOpMinus(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveBinaryOpModulo(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveBinaryOpMul(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveBinaryOpPlus(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveBitmaskAnd(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveBitmaskOr(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveBoolExpression(SemanticContext* context);
    bool resolveBreak(SemanticContext* context);
    bool resolveCaptureFuncCallParams(SemanticContext* context);
    bool resolveCase(SemanticContext* context);
    bool resolveCatch(SemanticContext* context);
    bool resolveCompOp3Way(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveCompOpEqual(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveCompOpGreater(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveCompOpLower(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveCompareExpression(SemanticContext* context);
    bool resolveCompilerAssert(SemanticContext* context);
    bool resolveCompilerAstExpression(SemanticContext* context);
    bool resolveCompilerError(SemanticContext* context);
    bool resolveCompilerForeignLib(SemanticContext* context);
    bool resolveCompilerIf(SemanticContext* context);
    bool resolveCompilerInclude(SemanticContext* context);
    bool resolveCompilerMacro(SemanticContext* context);
    bool resolveCompilerMixin(SemanticContext* context);
    bool resolveCompilerPrint(SemanticContext* context);
    bool resolveCompilerRun(SemanticContext* context);
    bool resolveCompilerSpecialValue(SemanticContext* context);
    bool resolveCompilerValidIfExpression(SemanticContext* context);
    bool resolveCompilerWarning(SemanticContext* context);
    bool resolveConditionalOp(SemanticContext* context);
    bool resolveContinue(SemanticContext* context);
    bool resolveDefer(SemanticContext* context);
    bool resolveDropCopyMove(SemanticContext* context);
    bool resolveEnum(SemanticContext* context);
    bool resolveEnumType(SemanticContext* context);
    bool resolveEnumValue(SemanticContext* context);
    bool resolveExplicitAutoCast(SemanticContext* context);
    bool resolveExplicitBitCast(SemanticContext* context);
    bool resolveExplicitCast(SemanticContext* context);
    bool resolveExplicitNoInit(SemanticContext* context);
    bool resolveExpressionListArray(SemanticContext* context);
    bool resolveExpressionListTuple(SemanticContext* context);
    bool resolveFactorExpression(SemanticContext* context);
    bool resolveFallThrough(SemanticContext* context);
    bool resolveFor(SemanticContext* context);
    bool resolveForBefore(SemanticContext* context);
    bool resolveFuncCallGenParams(SemanticContext* context);
    bool resolveFuncCallParam(SemanticContext* context);
    bool resolveFuncCallParams(SemanticContext* context);
    bool resolveFuncDecl(SemanticContext* context);
    bool resolveFuncDeclAfterSI(SemanticContext* context);
    bool resolveFuncDeclParams(SemanticContext* context);
    bool resolveFuncDeclType(SemanticContext* context);
    bool resolveIdentifier(SemanticContext* context);
    bool resolveIdentifierRef(SemanticContext* context);
    bool resolveIf(SemanticContext* context);
    bool resolveImpl(SemanticContext* context);
    bool resolveImplFor(SemanticContext* context);
    bool resolveImplForAfterFor(SemanticContext* context);
    bool resolveImplForType(SemanticContext* context);
    bool resolveIndex(SemanticContext* context);
    bool resolveInit(SemanticContext* context);
    bool resolveInlineAfter(SemanticContext* context);
    bool resolveInlineBefore(SemanticContext* context);
    bool resolveInterface(SemanticContext* context);
    bool resolveIntrinsicCountOf(SemanticContext* context, AstNode* node, AstNode* expression);
    bool resolveIntrinsicDataOf(SemanticContext* context, AstNode* node, AstNode* expression);
    bool resolveIntrinsicDeclType(SemanticContext* context);
    bool resolveIntrinsicDefined(SemanticContext* context);
    bool resolveIntrinsicKindOf(SemanticContext* context);
    bool resolveIntrinsicLocation(SemanticContext* context);
    bool resolveIntrinsicMakeAny(SemanticContext* context, AstNode* node);
    bool resolveIntrinsicMakeCallback(SemanticContext* context, AstNode* node);
    bool resolveIntrinsicMakeInterface(SemanticContext* context);
    bool resolveIntrinsicMakeSlice(SemanticContext* context, AstNode* node, const char* name);
    bool resolveIntrinsicNameOf(SemanticContext* context);
    bool resolveIntrinsicProperty(SemanticContext* context);
    bool resolveIntrinsicRunes(SemanticContext* context);
    bool resolveIntrinsicSpread(SemanticContext* context);
    bool resolveIntrinsicStringOf(SemanticContext* context);
    bool resolveIntrinsicTag(SemanticContext* context);
    bool resolveIntrinsicTypeOf(SemanticContext* context);
    bool resolveKeepRef(SemanticContext* context);
    bool resolveLiteral(SemanticContext* context);
    bool resolveLiteralSuffix(SemanticContext* context);
    bool resolveLoop(SemanticContext* context);
    bool resolveLoopBefore(SemanticContext* context);
    bool resolveMove(SemanticContext* context);
    bool resolveMoveRef(SemanticContext* context);
    bool resolveNameAlias(SemanticContext* context);
    bool resolveNullConditionalOp(SemanticContext* context);
    bool resolveRange(SemanticContext* context);
    bool resolveRetVal(SemanticContext* context);
    bool resolveReturn(SemanticContext* context);
    bool resolveScopeBreakable(SemanticContext* context);
    bool resolveScopedStmtAfter(SemanticContext* context);
    bool resolveScopedStmtBefore(SemanticContext* context);
    bool resolveShiftExpression(SemanticContext* context);
    bool resolveShiftLeft(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveShiftRight(SemanticContext* context, AstNode* left, AstNode* right);
    bool resolveStruct(SemanticContext* context);
    bool resolveSubDeclRef(SemanticContext* context);
    bool resolveSubEnumValue(SemanticContext* context);
    bool resolveSwitch(SemanticContext* context);
    bool resolveSwitchAfterExpr(SemanticContext* context);
    bool resolveThrow(SemanticContext* context);
    bool resolveTry(SemanticContext* context);
    bool resolveTryBlock(SemanticContext* context);
    bool resolveTryCatch(SemanticContext* context);
    bool resolveTupleUnpackBefore(SemanticContext* context);
    bool resolveTupleUnpackBeforeVar(SemanticContext* context);
    bool resolveType(SemanticContext* context);
    bool resolveTypeAlias(SemanticContext* context);
    bool resolveTypeAliasBefore(SemanticContext* context);
    bool resolveTypeAsExpression(SemanticContext* context, AstNode* node, TypeInfo* typeInfo, TypeInfo** resultTypeInfo, GenExportFlags genFlags = 0);
    bool resolveTypeAsExpression(SemanticContext* context, AstNode* node, TypeInfo** resultTypeInfo, GenExportFlags genFlags = 0);
    bool resolveTypeLambdaClosure(SemanticContext* context);
    bool resolveTypeList(SemanticContext* context);
    bool resolveUnaryOp(SemanticContext* context);
    bool resolveUnaryOpExclam(SemanticContext* context, AstNode* child);
    bool resolveUnaryOpInvert(SemanticContext* context, AstNode* child);
    bool resolveUnaryOpMinus(SemanticContext* context, AstNode* op, AstNode* child);
    bool resolveUnreachable(SemanticContext* context);
    bool resolveUserOp(SemanticContext* context, const Utf8& name, const char* opConst, TypeInfo* opType, AstNode* left, AstNode* right, uint32_t ropFlags = 0);
    bool resolveUserOp(SemanticContext* context, const Utf8& name, const char* opConst, TypeInfo* opType, AstNode* left, VectorNative<AstNode*>& params, uint32_t ropFlags = 0);
    bool resolveUserOpAffect(SemanticContext* context, TypeInfo* leftTypeInfo, TypeInfo* rightTypeInfo, AstNode* left, AstNode* right);
    bool resolveUserOpCommutative(SemanticContext* context, const Utf8& name, const char* opConst, TypeInfo* opType, AstNode* left, AstNode* right, uint32_t ropFlags = 0);
    bool resolveUsing(SemanticContext* context);
    bool resolveUsingVar(SemanticContext* context, AstNode* varNode, TypeInfo* typeInfoVar);
    bool resolveVarDecl(SemanticContext* context);
    bool resolveVarDeclAfter(SemanticContext* context);
    bool resolveVarDeclAfterAssign(SemanticContext* context);
    bool resolveVarDeclAfterType(SemanticContext* context);
    bool resolveVarDeclBefore(SemanticContext* context);
    bool resolveVisit(SemanticContext* context);
    bool resolveWhile(SemanticContext* context);
    bool resolveWith(SemanticContext* context);
    bool resolveWithAfterKnownType(SemanticContext* context);
    bool resolveWithVarDeclAfter(SemanticContext* context);
    bool resolveXor(SemanticContext* context, AstNode* left, AstNode* right);
}
