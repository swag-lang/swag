#include "pch.h"
#include "CommandLine.h"
#include "CommandLineParser.h"
#include "Log.h"

void CommandLineParser::setup(CommandLine* cmdLine)
{
    addArg("all", "--stats", nullptr, CommandLineType::Bool, &cmdLine->stats, nullptr, "display build statistics at the end");
    addArg("all", "--silent", "-s", CommandLineType::Bool, &cmdLine->silent, nullptr, "do not log messages");

    addArg("all", "--verbose-cmdline", nullptr, CommandLineType::Bool, &cmdLine->verboseCmdLine, nullptr, "log swag command line");
    addArg("bu", "--verbose-path", nullptr, CommandLineType::Bool, &cmdLine->verbosePath, nullptr, "log global paths");
    addArg("bu", "--verbose-link", nullptr, CommandLineType::Bool, &cmdLine->verboseLink, nullptr, "log linker command line");
    addArg("bu", "--verbose-pass", nullptr, CommandLineType::Bool, &cmdLine->verbosePass, nullptr, "log compile passes");
    addArg("bu", "--verbose-ctypes", nullptr, CommandLineType::Bool, &cmdLine->verboseConcreteTypes, nullptr, "log generated concrete types");
    addArg("bu", "--error-out-source", nullptr, CommandLineType::Bool, &cmdLine->errorSourceOut, nullptr, "display source code when an error is raised");
    addArg("bu", "--error-out-note", nullptr, CommandLineType::Bool, &cmdLine->errorNoteOut, nullptr, "display notes when an error is raised");

    addArg("bu ne wa cl", "--workspace", "-w", CommandLineType::String, &cmdLine->workspacePath, nullptr, "the path to the workspace to work with");
    addArg("bu", "--module", "-m", CommandLineType::String, &cmdLine->moduleFilter, nullptr, "the module to work with (all modules if not specified)");

    addArg("bu", "--cache", "-t", CommandLineType::String, &cmdLine->cachePath, nullptr, "specify the cache folder (system specific if empty)");
    addArg("bu", "--num-cores", nullptr, CommandLineType::Int, &cmdLine->numCores, nullptr, "max number of cpu to use (0 = automatic)");

    addArg("bu", "--output", "-o", CommandLineType::Bool, &cmdLine->output, nullptr, "output backend");
    addArg("bu", "--output-legit", "-ol", CommandLineType::Bool, &cmdLine->outputLegit, nullptr, "output legit backend");
    addArg("bu", "--output-test", "-ot", CommandLineType::Bool, &cmdLine->outputTest, nullptr, "output test backend");

    addArg("te", "--test-bytecode", "-tb", CommandLineType::Bool, &cmdLine->runByteCodeTests, nullptr, "run #test functions as bytecode");
    addArg("te", "--test-native", "-tn", CommandLineType::Bool, &cmdLine->runBackendTests, nullptr, "run #test functions as native");

    addArg("bu", "--rebuild", nullptr, CommandLineType::Bool, &cmdLine->rebuild, nullptr, "full rebuild");

    addArg("bu", "--file-filter", nullptr, CommandLineType::String, &cmdLine->fileFilter, nullptr, nullptr);
    addArg("te", "--test-filter", nullptr, CommandLineType::String, &cmdLine->testFilter, nullptr, nullptr);

    addArg("bu", "--devmode", nullptr, CommandLineType::Bool, &cmdLine->devMode, nullptr, "swag compiler developer mode, add some assertions");
    addArg("bu", "--randomize", nullptr, CommandLineType::Bool, &cmdLine->randomize, nullptr, "swag compiler developer mode, randomize behavior");
    addArg("bu", "--seed", nullptr, CommandLineType::Int, &cmdLine->randSeed, nullptr, "swag compiler developer mode, set seed for randomize behavior");

    addArg("bu cl", "--cfg", nullptr, CommandLineType::String, &cmdLine->buildCfg, nullptr, "set the build configuration (debug|fast-debug|release are predefined)");
    addArg("bu cl", "--cfg-debug", nullptr, CommandLineType::EnumString, &cmdLine->buildCfgDebug, "true|false|default", "force the build configuration to (not) have debug informations");
    addArg("bu cl", "--cfg-safety", nullptr, CommandLineType::EnumString, &cmdLine->buildCfgSafety, "true|false|default", "force the build configuration to (not) have safety guards");
    addArg("bu cl", "--cfg-inline-bc", nullptr, CommandLineType::EnumString, &cmdLine->buildCfgInlineBC, "true|false|default", "inline marked functions");
    addArg("bu cl", "--cfg-optim-bc", nullptr, CommandLineType::EnumString, &cmdLine->buildCfgOptimBC, "true|false|default", "optimize the generated bytecode");
    addArg("bu cl", "--cfg-optim-speed", nullptr, CommandLineType::EnumString, &cmdLine->buildCfgOptimSpeed, "true|false|default", "force the build configuration to (not) be optimized for speed");
    addArg("bu cl", "--cfg-optim-size", nullptr, CommandLineType::EnumString, &cmdLine->buildCfgOptimSize, "true|false|default", "force the build configuration to (not) be optimized for size");

    addArg("bu cl", "--arch", nullptr, CommandLineType::EnumInt, &cmdLine->arch, "x86_64", "set the target architecture");
    addArg("bu cl", "--os", nullptr, CommandLineType::EnumInt, &cmdLine->os, "windows", "set the target operating system");
    addArg("bu cl", "--abi", nullptr, CommandLineType::EnumInt, &cmdLine->abi, "msvc", "set the target abi");
    addArg("bu cl", "--vendor", nullptr, CommandLineType::EnumInt, &cmdLine->vendor, "pc", "set the target vendoor");

    addArg("bu", "--tag", nullptr, CommandLineType::StringSet, &cmdLine->tags, nullptr, "add a build tag, with an optional associated type and value");
    addArg("bu", "--user-args", nullptr, CommandLineType::String, &cmdLine->userArguments, nullptr, "pass some specific arguments to the user code");

    addArg("bu", "--max-recurse", nullptr, CommandLineType::Int, &cmdLine->maxRecurse, nullptr, "maximum recursion level in bytecode (0 for no limit)");
    addArg("bu", "--stack-size", nullptr, CommandLineType::Int, &cmdLine->stackSize, nullptr, "set the stack size for bytecode and backend");

    addArg("bu", "--backend", nullptr, CommandLineType::EnumInt, &cmdLine->backendType, "llvm|x64", "the type of backend to use");
    addArg("bu", "--script", nullptr, CommandLineType::Bool, &cmdLine->script, nullptr, "run full bytecode");

    addArg("cl", "--clean-dep", nullptr, CommandLineType::Bool, &cmdLine->cleanDep, nullptr, "removes the content of the dependency folder");
    addArg("cl", "--clean-log", nullptr, CommandLineType::Bool, &cmdLine->cleanLog, nullptr, "display what will be removed, without actually cleaning");
}

void CommandLineParser::logArguments()
{
    string line0, line1;

    static const int COL_SHORT_NAME = 20;
    static const int COL_VALUE      = COL_SHORT_NAME + 7;
    static const int COL_DEFAULT    = COL_VALUE + 25;
    static const int COL_CMD        = COL_DEFAULT + 12;
    static const int COL_HELP       = COL_CMD + 24;

    line0 = "argument";
    line1 = "--------";
    while (line0.length() < COL_SHORT_NAME)
        line0 += " ", line1 += " ";
    line0 += "short";
    line1 += "-----";
    while (line0.length() < COL_VALUE)
        line0 += " ", line1 += " ";
    line0 += "value";
    line1 += "-----";
    while (line0.length() < COL_DEFAULT)
        line0 += " ", line1 += " ";
    line0 += "default";
    line1 += "-------";
    while (line0.length() < COL_CMD)
        line0 += " ", line1 += " ";
    line0 += "command";
    line1 += "-------";
    while (line0.length() < COL_HELP)
        line0 += " ", line1 += " ";
    line0 += "help";
    line1 += "----";

    line0 += "\n";
    line1 += "\n";
    g_Log.message(line0);
    g_Log.message(line1);

    int cpt = 0;
    for (auto arg : longNameArgs)
    {
        auto oneArg = arg.second;

        line0 = arg.first;
        while (line0.length() < COL_SHORT_NAME)
            line0 += " ";
        line0 += oneArg->shortName;
        while (line0.length() < COL_VALUE)
            line0 += " ";

        switch (oneArg->type)
        {
        case CommandLineType::Bool:
            line0 += "true|false";
            while (line0.length() < COL_DEFAULT)
                line0 += " ";
            if (*(bool*) oneArg->buffer)
                line0 += "true";
            else
                line0 += "false";
            break;
        case CommandLineType::Int:
            line0 += "<integer>";
            while (line0.length() < COL_DEFAULT)
                line0 += " ";
            line0 += to_string(*(int*) oneArg->buffer);
            break;
        case CommandLineType::String:
            line0 += "<string>";
            while (line0.length() < COL_DEFAULT)
                line0 += " ";
            line0 += *(string*) oneArg->buffer;
            break;
        case CommandLineType::StringSet:
            line0 += "<string>";
            while (line0.length() < COL_DEFAULT)
                line0 += " ";
            break;
        case CommandLineType::EnumInt:
        {
            line0 += oneArg->param;
            while (line0.length() < COL_DEFAULT)
                line0 += " ";
            vector<Utf8> tokens;
            tokenize(oneArg->param, '|', tokens);
            line0 += tokens[*(int*) oneArg->buffer];
            break;
        }
        case CommandLineType::EnumString:
            line0 += oneArg->param;
            while (line0.length() < COL_DEFAULT)
                line0 += " ";
            line0 += *(string*) oneArg->buffer;
            break;
        }

        while (line0.length() < COL_CMD)
            line0 += " ";
        for (int i = 0; i < oneArg->cmds.size(); i++)
        {
            line0 += oneArg->cmds[i][0];
            line0 += oneArg->cmds[i][1];
            line0 += " ";
        }

        if (oneArg->help)
        {
            while (line0.length() < COL_HELP)
                line0 += " ";
            line0 += oneArg->help;
        }

        g_Log.message(line0);
        cpt++;
    }
}

void CommandLineParser::addArg(const char* commands, const char* longName, const char* shortName, CommandLineType type, void* address, const char* param, const char* help)
{
    auto arg = new CommandLineArgument{commands, type, address, param, help};

    if (longName)
        arg->longName = longName;
    if (shortName)
        arg->shortName = shortName;

    if (longName)
        longNameArgs[longName] = arg;
    if (shortName)
        shortNameArgs[shortName] = arg;
}

bool CommandLineParser::isArgValidFor(const string& swagCmd, CommandLineArgument* arg)
{
    for (int i = 0; i < arg->cmds.size(); i++)
    {
        if (arg->cmds[i] == swagCmd)
            return true;
    }

    return false;
}

bool CommandLineParser::process(const string& swagCmd, int argc, const char* argv[])
{
    bool result = true;
    for (int i = 0; i < argc; i++)
    {
        // Split in half, with the ':' delimiter
        string      command;
        string      argument;
        const char* pz = argv[i];
        while (*pz && *pz != ':')
            command += *pz++;
        if (*pz)
            pz++;
        while (*pz)
            argument += *pz++;

        // Find command
        auto it = longNameArgs.find(command);
        if (it == longNameArgs.end())
        {
            it = shortNameArgs.find(command);
            if (it == shortNameArgs.end())
            {
                g_Log.error(format("command line error: invalid argument '%s'", command.c_str()));
                result = false;
                continue;
            }
        }

        auto arg = it->second;

        // Be sure the argument is valid for the swag command
        if (!isArgValidFor(swagCmd, arg))
        {
            g_Log.error(format("command line error: invalid argument '%s'", command.c_str()));
            result = false;
            continue;
        }

        switch (arg->type)
        {
        case CommandLineType::EnumInt:
        {
            vector<Utf8> tokens;
            tokenize(arg->param, '|', tokens);

            int index = 0;
            for (auto one : tokens)
            {
                if (one == argument)
                {
                    *(int*) arg->buffer = index;
                    break;
                }

                index++;
            }

            if (index == tokens.size())
            {
                g_Log.error(format("command line error: argument '%s' must be followed by '%s'", it->first.c_str(), arg->param));
                result = false;
                continue;
            }
        }
        break;

        case CommandLineType::EnumString:
        {
            vector<Utf8> tokens;
            tokenize(arg->param, '|', tokens);

            int index = 0;
            for (auto one : tokens)
            {
                if (one == argument)
                {
                    *(string*) arg->buffer = one;
                    break;
                }

                index++;
            }

            if (index == tokens.size())
            {
                g_Log.error(format("command line error: argument '%s' must be followed by '%s'", it->first.c_str(), arg->param));
                result = false;
                continue;
            }
        }
        break;

        case CommandLineType::Bool:
            if (argument == "true" || argument.empty())
                *(bool*) arg->buffer = true;
            else if (argument == "false")
                *(bool*) arg->buffer = false;
            else
            {
                g_Log.error(format("command line error: argument '%s' must be followed by 'true' or 'false' ('%s')", it->first.c_str(), argument.c_str()));
                result = false;
                continue;
            }
            break;

        case CommandLineType::String:
        {
            if (argument.empty())
            {
                g_Log.error(format("command line error: argument '%s' must be followed by a string", it->first.c_str(), argument.c_str()));
                result = false;
                continue;
            }

            *((string*) arg->buffer) = argument;
            break;
        }

        case CommandLineType::StringSet:
        {
            if (argument.empty())
            {
                g_Log.error(format("command line error: argument '%s' must be followed by a string", it->first.c_str(), argument.c_str()));
                result = false;
                continue;
            }

            ((set<string>*) arg->buffer)->insert(argument);
            break;
        }

        case CommandLineType::Int:
        {
            pz               = argument.c_str();
            bool thisIsAnInt = argument.empty() ? false : true;

            while (*pz)
            {
                if (!isdigit(*pz))
                {
                    thisIsAnInt = false;
                    break;
                }

                pz++;
            }

            if (!thisIsAnInt)
            {
                if (argument.empty())
                    g_Log.error(format("command line error: argument '%s' must be followed by an integer value", it->first.c_str()));
                else
                    g_Log.error(format("command line error: argument '%s' must be followed by an integer value ('%s')", it->first.c_str(), argument.c_str()));
                result = false;
                continue;
            }

            *(int*) arg->buffer = atoi(argument.c_str());
            break;
        }
        }
    }

    return result;
}

string CommandLineParser::buildString(bool full)
{
    CommandLine       defaultValues;
    CommandLineParser defaultParser;
    defaultParser.setup(&defaultValues);

    string result;
    for (auto arg : longNameArgs)
    {
        auto itDefault  = defaultParser.longNameArgs.find(arg.first);
        auto defaultArg = itDefault->second;
        auto oneArg     = arg.second;

        switch (oneArg->type)
        {
        case CommandLineType::String:
            if (full || *(string*) oneArg->buffer != *(string*) defaultArg->buffer)
            {
                result += oneArg->longName + ":";
                result += *(string*) oneArg->buffer;
                result += " ";
            }
            break;
        case CommandLineType::EnumInt:
            if (full || *(int*) oneArg->buffer != *(int*) defaultArg->buffer)
            {
                result += oneArg->longName + ":";

                vector<Utf8> tokens;
                tokenize(oneArg->param, '|', tokens);
                int idx = *(int*) oneArg->buffer;
                result += tokens[idx];
                result += " ";
            }
            break;
        case CommandLineType::StringSet:
        {
            if (full)
            {
                result += oneArg->longName + ":";
                auto all = (set<string>*) oneArg->buffer;
                for (auto& one : *all)
                {
                    result += one;
                    result += " ";
                }
            }
            break;
        }
        case CommandLineType::EnumString:
            if (full || *(string*) oneArg->buffer != *(string*) defaultArg->buffer)
            {
                result += oneArg->longName + ":";
                result += *(string*) oneArg->buffer;
                result += " ";
            }
            break;
        case CommandLineType::Int:
            if (full || *(int*) oneArg->buffer != *(int*) defaultArg->buffer)
            {
                result += oneArg->longName + ":";
                result += to_string(*(int*) oneArg->buffer);
                result += " ";
            }
            break;
        case CommandLineType::Bool:
            if (full || *(bool*) oneArg->buffer != *(bool*) defaultArg->buffer)
            {
                result += oneArg->longName + ":";
                if (*(bool*) oneArg->buffer == true)
                    result += "true";
                else
                    result += "false";
                result += " ";
            }
            break;
        }
    }

    return result;
}
