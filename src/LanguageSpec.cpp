#include "pch.h"
#include "LanguageSpec.h"
#include "TypeManager.h"

LanguageSpec g_LangSpec;

void LanguageSpec::setup()
{
    keywords.add("#global", TokenId::CompilerGlobal);
    keywords.add("#assert", TokenId::CompilerAssert);
    keywords.add("#semerror", TokenId::CompilerSemError);
    keywords.add("#print", TokenId::CompilerPrint);
    keywords.add("#run", TokenId::CompilerRun);
    keywords.add("#ast", TokenId::CompilerAst);
    keywords.add("#selectif", TokenId::CompilerSelectIf);
    keywords.add("#checkif", TokenId::CompilerCheckIf);
    keywords.add("#cfg", TokenId::CompilerBuildCfg);
    keywords.add("#arch", TokenId::CompilerArch);
    keywords.add("#os", TokenId::CompilerOs);
    keywords.add("#abi", TokenId::CompilerAbi);
    keywords.add("#hastag", TokenId::CompilerHasTag);
    keywords.add("#tagval", TokenId::CompilerTagVal);
    keywords.add("#file", TokenId::CompilerFile);
    keywords.add("#line", TokenId::CompilerLine);
    keywords.add("#function", TokenId::CompilerFunction);
    keywords.add("#callerfunction", TokenId::CompilerCallerFunction);
    keywords.add("#location", TokenId::CompilerLocation);
    keywords.add("#callerlocation", TokenId::CompilerCallerLocation);
    keywords.add("#swagversion", TokenId::CompilerBuildVersion);
    keywords.add("#swagrevision", TokenId::CompilerBuildRevision);
    keywords.add("#swagbuildnum", TokenId::CompilerBuildNum);
    keywords.add("#swagos", TokenId::CompilerSwagOs);
    keywords.add("#import", TokenId::CompilerImport);
    keywords.add("#test", TokenId::CompilerFuncTest);
    keywords.add("#init", TokenId::CompilerFuncInit);
    keywords.add("#drop", TokenId::CompilerFuncDrop);
    keywords.add("#main", TokenId::CompilerFuncMain);
    keywords.add("#compiler", TokenId::CompilerFuncCompiler);
    keywords.add("#placeholder", TokenId::CompilerPlaceHolder);
    keywords.add("#if", TokenId::CompilerIf);
    keywords.add("#else", TokenId::CompilerElse);
    keywords.add("#elif", TokenId::CompilerElseIf);
    keywords.add("#code", TokenId::CompilerCode);
    keywords.add("#mixin", TokenId::CompilerMixin);
    keywords.add("#inline", TokenId::CompilerInline);
    keywords.add("#macro", TokenId::CompilerMacro);
    keywords.add("#defined", TokenId::CompilerDefined);
    keywords.add("#load", TokenId::CompilerLoad);
    keywords.add("#scopefct", TokenId::CompilerScopeFct);

    keywords.add("var", TokenId::KwdVar);
    keywords.add("const", TokenId::KwdConst);
    keywords.add("namespace", TokenId::KwdNamespace);
    keywords.add("public", TokenId::KwdPublic);
    keywords.add("protected", TokenId::KwdProtected);
    keywords.add("private", TokenId::KwdPrivate);
    keywords.add("alias", TokenId::KwdAlias);
    keywords.add("enum", TokenId::KwdEnum);
    keywords.add("impl", TokenId::KwdImpl);
    keywords.add("struct", TokenId::KwdStruct);
    keywords.add("union", TokenId::KwdUnion);
    keywords.add("interface", TokenId::KwdInterface);
    keywords.add("typeset", TokenId::KwdTypeSet);
    keywords.add("func", TokenId::KwdFunc);
    keywords.add("true", TokenId::KwdTrue);
    keywords.add("false", TokenId::KwdFalse);
    keywords.add("null", TokenId::KwdNull);
    keywords.add("attr", TokenId::KwdAttr);
    keywords.add("return", TokenId::KwdReturn);
    keywords.add("retval", TokenId::KwdRetVal);
    keywords.add("using", TokenId::KwdUsing);
    keywords.add("cast", TokenId::KwdCast);
    keywords.add("bitcast", TokenId::KwdBitCast);
    keywords.add("autocast", TokenId::KwdAutoCast);
    keywords.add("if", TokenId::KwdIf);
    keywords.add("else", TokenId::KwdElse);
    keywords.add("while", TokenId::KwdWhile);
    keywords.add("break", TokenId::KwdBreak);
    keywords.add("continue", TokenId::KwdContinue);
    keywords.add("loop", TokenId::KwdLoop);
    keywords.add("visit", TokenId::KwdVisit);
    keywords.add("move", TokenId::KwdMove);
    keywords.add("nodrop", TokenId::KwdNoDrop);
    keywords.add("switch", TokenId::KwdSwitch);
    keywords.add("case", TokenId::KwdCase);
    keywords.add("fallthrough", TokenId::KwdFallThrough);
    keywords.add("default", TokenId::KwdDefault);
    keywords.add("for", TokenId::KwdFor);
    keywords.add("defer", TokenId::KwdDefer);
    keywords.add("errdefer", TokenId::KwdErrDefer);
    keywords.add("code", TokenId::KwdCode);
    keywords.add("label", TokenId::KwdLabel);
    keywords.add("try", TokenId::KwdTry);
    keywords.add("catch", TokenId::KwdCatch);
    keywords.add("assume", TokenId::KwdAssume);
    keywords.add("throw", TokenId::KwdThrow);
    keywords.add("discard", TokenId::KwdDiscard);

    keywords.add("uint", TokenId::NativeType);
    keywords.add("int", TokenId::NativeType);
    keywords.add("u64", TokenId::NativeType);
    keywords.add("u32", TokenId::NativeType);
    keywords.add("u16", TokenId::NativeType);
    keywords.add("u8", TokenId::NativeType);
    keywords.add("s64", TokenId::NativeType);
    keywords.add("s32", TokenId::NativeType);
    keywords.add("s16", TokenId::NativeType);
    keywords.add("s8", TokenId::NativeType);
    keywords.add("f32", TokenId::NativeType);
    keywords.add("f64", TokenId::NativeType);
    keywords.add("bool", TokenId::NativeType);
    keywords.add("char", TokenId::NativeType);
    keywords.add("string", TokenId::NativeType);
    keywords.add("any", TokenId::NativeType);
    keywords.add("void", TokenId::NativeType);
    keywords.add("typeinfo", TokenId::NativeType);

    keywords.add("@spread", TokenId::IntrinsicSpread);
    keywords.add("@init", TokenId::IntrinsicInit);
    keywords.add("@drop", TokenId::IntrinsicDrop);
    keywords.add("@postmove", TokenId::IntrinsicPostMove);
    keywords.add("@postcopy", TokenId::IntrinsicPostCopy);
    keywords.add("@reloc", TokenId::IntrinsicReloc);
    keywords.add("@sizeof", TokenId::IntrinsicSizeOf);
    keywords.add("@alignof", TokenId::IntrinsicAlignOf);
    keywords.add("@offsetof", TokenId::IntrinsicOffsetOf);
    keywords.add("@typeof", TokenId::IntrinsicTypeOf);
    keywords.add("@kindof", TokenId::IntrinsicKindOf);
    keywords.add("@countof", TokenId::IntrinsicCountOf);
    keywords.add("@stringof", TokenId::IntrinsicStringOf);
    keywords.add("@dataof", TokenId::IntrinsicDataOf);
    keywords.add("@mkslice", TokenId::IntrinsicMakeSlice);
    keywords.add("@mkstring", TokenId::IntrinsicMakeString);
    keywords.add("@mkany", TokenId::IntrinsicMakeAny);
    keywords.add("@mkinterface", TokenId::IntrinsicMakeInterface);
    keywords.add("@mkcallback", TokenId::IntrinsicMakeCallback);
    keywords.add("@mkforeign", TokenId::IntrinsicMakeForeign);
    keywords.add("@index", TokenId::IntrinsicIndex);
    keywords.add("@isconstexpr", TokenId::IntrinsicIsConstExpr);
    keywords.add("@err", TokenId::IntrinsicGetErr);
    keywords.add("@seterr", TokenId::IntrinsicSetErr);
    keywords.add("@print", TokenId::IntrinsicPrint);
    keywords.add("@assert", TokenId::IntrinsicAssert);
    keywords.add("@bcdbg", TokenId::IntrinsicBcDbg);
    keywords.add("@panic", TokenId::IntrinsicPanic);
    keywords.add("@errormsg", TokenId::IntrinsicErrorMsg);
    keywords.add("@alloc", TokenId::IntrinsicAlloc);
    keywords.add("@realloc", TokenId::IntrinsicRealloc);
    keywords.add("@free", TokenId::IntrinsicFree);
    keywords.add("@memcpy", TokenId::IntrinsicMemCpy);
    keywords.add("@memmove", TokenId::IntrinsicMemMove);
    keywords.add("@memset", TokenId::IntrinsicMemSet);
    keywords.add("@memcmp", TokenId::IntrinsicMemCmp);
    keywords.add("@cstrlen", TokenId::IntrinsicCStrLen);
    keywords.add("@strcmp", TokenId::IntrinsicStrCmp);
    keywords.add("@typecmp", TokenId::IntrinsicTypeCmp);
    keywords.add("@getcontext", TokenId::IntrinsicGetContext);
    keywords.add("@setcontext", TokenId::IntrinsicSetContext);
    keywords.add("@args", TokenId::IntrinsicArguments);
    keywords.add("@isbytecode", TokenId::IntrinsicIsByteCode);
    keywords.add("@compiler", TokenId::IntrinsicCompiler);
    keywords.add("@atomadd", TokenId::IntrinsicAtomicAdd);
    keywords.add("@atomand", TokenId::IntrinsicAtomicAnd);
    keywords.add("@atomor", TokenId::IntrinsicAtomicOr);
    keywords.add("@atomxor", TokenId::IntrinsicAtomicXor);
    keywords.add("@atomxchg", TokenId::IntrinsicAtomicXchg);
    keywords.add("@atomcmpxchg", TokenId::IntrinsicAtomicCmpXchg);

    keywords.add("@sqrt", TokenId::IntrinsicSqrt);
    keywords.add("@sin", TokenId::IntrinsicSin);
    keywords.add("@cos", TokenId::IntrinsicCos);
    keywords.add("@tan", TokenId::IntrinsicTan);
    keywords.add("@sinh", TokenId::IntrinsicSinh);
    keywords.add("@cosh", TokenId::IntrinsicCosh);
    keywords.add("@tanh", TokenId::IntrinsicTanh);
    keywords.add("@asin", TokenId::IntrinsicASin);
    keywords.add("@acos", TokenId::IntrinsicACos);
    keywords.add("@atan", TokenId::IntrinsicATan);
    keywords.add("@log", TokenId::IntrinsicLog);
    keywords.add("@log2", TokenId::IntrinsicLog2);
    keywords.add("@log10", TokenId::IntrinsicLog10);
    keywords.add("@floor", TokenId::IntrinsicFloor);
    keywords.add("@ceil", TokenId::IntrinsicCeil);
    keywords.add("@trunc", TokenId::IntrinsicTrunc);
    keywords.add("@round", TokenId::IntrinsicRound);
    keywords.add("@abs", TokenId::IntrinsicAbs);
    keywords.add("@exp", TokenId::IntrinsicExp);
    keywords.add("@exp2", TokenId::IntrinsicExp2);
    keywords.add("@pow", TokenId::IntrinsicPow);
    keywords.add("@min", TokenId::IntrinsicMin);
    keywords.add("@max", TokenId::IntrinsicMax);
    keywords.add("@bitcountnz", TokenId::IntrinsicBitCountNz);
    keywords.add("@bitcounttz", TokenId::IntrinsicBitCountTz);
    keywords.add("@bitcountlz", TokenId::IntrinsicBitCountLz);
    keywords.add("@byteswap", TokenId::IntrinsicByteSwap);

    nativeTypes.add("uint", LiteralType::TT_UINT);
    nativeTypes.add("int", LiteralType::TT_INT);
    nativeTypes.add("u64", LiteralType::TT_U64);
    nativeTypes.add("u32", LiteralType::TT_U32);
    nativeTypes.add("u16", LiteralType::TT_U16);
    nativeTypes.add("u8", LiteralType::TT_U8);
    nativeTypes.add("s64", LiteralType::TT_S64);
    nativeTypes.add("s32", LiteralType::TT_S32);
    nativeTypes.add("s16", LiteralType::TT_S16);
    nativeTypes.add("s8", LiteralType::TT_S8);
    nativeTypes.add("f32", LiteralType::TT_F32);
    nativeTypes.add("f64", LiteralType::TT_F64);
    nativeTypes.add("bool", LiteralType::TT_BOOL);
    nativeTypes.add("char", LiteralType::TT_CHAR);
    nativeTypes.add("string", LiteralType::TT_STRING);
    nativeTypes.add("any", LiteralType::TT_ANY);
    nativeTypes.add("void", LiteralType::TT_VOID);
    nativeTypes.add("typeinfo", LiteralType::TT_TYPE);
}

string LanguageSpec::tokenToName(TokenId id)
{
    switch (id)
    {
    case TokenId::SymComma:
        return ",";
    case TokenId::SymColon:
        return ":";
    case TokenId::SymSemiColon:
        return ";";
    case TokenId::SymLeftCurly:
        return "{";
    case TokenId::SymRightCurly:
        return "}";
    case TokenId::SymLeftParen:
        return "(";
    case TokenId::SymRightParen:
        return ")";
    case TokenId::SymLeftSquare:
        return "[";
    case TokenId::SymRightSquare:
        return "]";
    case TokenId::SymDot:
        return ".";
    case TokenId::SymExclam:
        return "!";
    case TokenId::SymMinusGreat:
        return "->";
    case TokenId::SymEqual:
        return "=";
    }

    return "???";
}