#include "pch.h"
#include "Semantic.h"
#include "Ast.h"
#include "Generic.h"
#include "TypeManager.h"
#include "LanguageSpec.h"
#include "AstOutput.h"
#include "Naming.h"
#include "SyntaxColor.h"

static int getBadParamIdx(OneTryMatch& oneTry, AstNode* callParameters)
{
    BadSignatureInfos bi = oneTry.symMatchContext.badSignatureInfos;

    // If the first parameter of the call has been generated by ufcs, then decrease the call parameter index by 1, so
    // that the message is more relevant
    int badParamIdx = bi.badSignatureParameterIdx;
    if (badParamIdx &&
        callParameters &&
        !callParameters->childs.empty() &&
        callParameters->childs.front()->flags & (AST_FROM_UFCS | AST_TO_UFCS) &&
        !(callParameters->childs.front()->flags & AST_UFCS_FCT))
    {
        badParamIdx--;
    }
    else if (badParamIdx && oneTry.ufcs)
        badParamIdx--;
    // This is a closure with a generated first parameter
    if (oneTry.symMatchContext.flags & SymbolMatchContext::MATCH_CLOSURE_PARAM)
        badParamIdx--;

    return badParamIdx;
}

bool Semantic::preprocessMatchError(SemanticContext* context, OneTryMatch& oneTry, Vector<const Diagnostic*>& result0, Vector<const Diagnostic*>& result1)
{
    SymbolOverload*    overload = oneTry.overload;
    auto&              match    = oneTry.symMatchContext;
    BadSignatureInfos& bi       = oneTry.symMatchContext.badSignatureInfos;
    auto               typeFunc = overload->symbol->kind == SymbolKind::Function ? CastTypeInfo<TypeInfoFuncAttr>(overload->typeInfo, TypeInfoKind::FuncAttr) : nullptr;

    // UFCS.toto(a, ...) with in fact toto(a, ...)
    if (match.result == MatchResult::BadSignature &&
        typeFunc &&
        match.parameters.size() == typeFunc->parameters.size() + 1 &&
        oneTry.ufcs &&
        typeFunc->parameters.size() >= 1 &&
        !typeFunc->parameters[0]->typeInfo->isSelf() &&
        bi.badSignatureParameterIdx == 0)
    {
        auto ufcs  = match.parameters[0];
        auto note  = Diagnostic::note(ufcs, ufcs->token, Nte(Nte0144));
        note->hint = Nte(Nte1094);
        result1.push_back(note);
    }

    return false;
}

void Semantic::getDiagnosticForMatch(SemanticContext* context, OneTryMatch& oneTry, Vector<const Diagnostic*>& result0, Vector<const Diagnostic*>& result1, uint32_t getFlags)
{
    // Smart changes for smarter errors (very specific cases)
    if (preprocessMatchError(context, oneTry, result0, result1))
        return;

    auto              node              = context->node;
    BadSignatureInfos bi                = oneTry.symMatchContext.badSignatureInfos;
    auto              symbol            = oneTry.overload->symbol;
    SymbolOverload*   overload          = oneTry.overload;
    auto              genericParameters = oneTry.genericParameters;
    auto              callParameters    = oneTry.callParameters;
    auto&             match             = oneTry.symMatchContext;
    AstFuncCallParam* failedParam       = nullptr;

    // Get the call parameter that failed
    size_t badParamIdx = getBadParamIdx(oneTry, callParameters);
    if (oneTry.callParameters && badParamIdx >= 0 && badParamIdx < callParameters->childs.size())
        failedParam = static_cast<AstFuncCallParam*>(callParameters->childs[badParamIdx]);
    badParamIdx += 1;

    // Nice name to reference it
    Utf8 refNiceName = "the ";
    refNiceName += Naming::kindName(overload);

    if (node->isSilentCall())
    {
        auto arrNode = node->parent->childs[node->childParentIdx() - 1];
        SWAG_ASSERT(arrNode->kind == AstNodeKind::ArrayPointerIndex);
        node = arrNode;
    }

    // Get parameters of destination symbol
    AstFuncDecl*   destFuncDecl   = nullptr;
    AstTypeLambda* destLambdaDecl = nullptr;
    AstAttrDecl*   destAttrDecl   = nullptr;
    if (overload->node->kind == AstNodeKind::FuncDecl)
        destFuncDecl = CastAst<AstFuncDecl>(overload->node, AstNodeKind::FuncDecl);
    else if (overload->node->kind == AstNodeKind::AttrDecl)
        destAttrDecl = CastAst<AstAttrDecl>(overload->node, AstNodeKind::AttrDecl);
    else if (overload->node->kind == AstNodeKind::VarDecl)
        destLambdaDecl = CastAst<AstTypeLambda>(overload->node->typeInfo->declNode, AstNodeKind::TypeLambda, AstNodeKind::TypeClosure);

    // In case it's generic, and we have real types
    bi.badSignatureRequestedType = Generic::doTypeSubstitution(oneTry.symMatchContext.genericReplaceTypes, bi.badSignatureRequestedType);

    // See if it would have worked with an explicit cast, to give a hint in the error message
    Utf8 hintMsg;
    switch (match.result)
    {
    case MatchResult::BadSignature:
    case MatchResult::BadGenericSignature:
        if (bi.badSignatureRequestedType->isPointer() ||
            bi.badSignatureGivenType->isPointer())
            break;

        if (bi.badSignatureRequestedType->isNative())
        {
            if (TypeManager::makeCompatibles(context, bi.badSignatureRequestedType, bi.badSignatureGivenType, nullptr, nullptr, CASTFLAG_TRY_COERCE | CASTFLAG_JUST_CHECK))
            {
                hintMsg = Fmt(Nte(Nte1025), bi.badSignatureRequestedType->name.c_str());
                break;
            }
        }

        if (bi.badSignatureRequestedType->isStruct())
        {
            if (TypeManager::makeCompatibles(context, bi.badSignatureRequestedType, bi.badSignatureGivenType, nullptr, nullptr, CASTFLAG_EXPLICIT | CASTFLAG_JUST_CHECK))
            {
                hintMsg = Fmt(Nte(Nte1025), bi.badSignatureRequestedType->name.c_str());
                break;
            }
        }

        break;
    default:
        break;
    }

    Diagnostic* diag = nullptr;
    switch (match.result)
    {
    default:
        SWAG_ASSERT(false);
        return;

    case MatchResult::ValidIfFailed:
    {
        SWAG_ASSERT(destFuncDecl);
        diag = new Diagnostic{node, node->token, Fmt(Err(Err0004), destFuncDecl->validif->token.ctext(), destFuncDecl->token.ctext(), destFuncDecl->validif->token.ctext())};
        result0.push_back(diag);
        auto note = Diagnostic::hereIs(destFuncDecl->validif);
        result1.push_back(note);
        return;
    }

    case MatchResult::MissingNamedParameter:
    {
        SWAG_ASSERT(failedParam);
        SWAG_ASSERT(badParamIdx >= 2);
        diag = new Diagnostic{failedParam, Fmt(Err(Err0006), Naming::niceArgumentRank(badParamIdx).c_str())};
        diag->addRange(callParameters->childs[badParamIdx - 2], Nte(Nte1030));
        result0.push_back(diag);
        return;
    }

    case MatchResult::InvalidNamedParameter:
    {
        SWAG_ASSERT(failedParam && failedParam->hasExtMisc() && failedParam->extMisc()->isNamed);
        diag = new Diagnostic{failedParam->extMisc()->isNamed, Fmt(Err(Err0008), failedParam->extMisc()->isNamed->token.ctext())};
        result0.push_back(diag);
        if (!(overload->node->flags & AST_GENERATED))
        {
            auto note = Diagnostic::hereIs(overload);
            if (note)
                result1.push_back(note);
        }
        return;
    }

    case MatchResult::DuplicatedNamedParameter:
    {
        SWAG_ASSERT(failedParam && failedParam->hasExtMisc() && failedParam->extMisc()->isNamed);
        diag         = new Diagnostic{failedParam->extMisc()->isNamed, Fmt(Err(Err0011), failedParam->extMisc()->isNamed->token.ctext())};
        size_t other = oneTry.symMatchContext.badSignatureInfos.badSignatureNum1;
        SWAG_ASSERT(other < callParameters->childs.size());
        diag->addRange(callParameters->childs[other], Nte(Nte1059));
        result0.push_back(diag);
        return;
    }

    case MatchResult::MissingParameters:
    {
        diag = new Diagnostic{callParameters ? callParameters : node, Fmt(Err(Err0020), refNiceName.c_str())};
        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::NotEnoughParameters:
    {
        if (!callParameters || callParameters->childs.empty())
            diag = new Diagnostic{node, node->token, Fmt(Err(Err0020), refNiceName.c_str())};
        else if (destAttrDecl)
            diag = new Diagnostic{node, node->token, Fmt(Err(Err0157), refNiceName.c_str())};
        else
            diag = new Diagnostic{node, node->token, Fmt(Err(Err0016), refNiceName.c_str())};

        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);

        for (uint32_t si = 0; si < match.solvedParameters.size(); si++)
        {
            if (si >= match.firstDefault)
                break;
            if (!match.solvedParameters[si])
            {
                AstNode* parameters = nullptr;
                if (destFuncDecl)
                    parameters = destFuncDecl->parameters;
                else if (destLambdaDecl)
                    parameters = destLambdaDecl->parameters;
                else if (destAttrDecl)
                    parameters = destAttrDecl->parameters;

                if (parameters)
                {
                    if (parameters->childs[si]->specFlags & AstVarDecl::SPECFLAG_UNNAMED)
                        diag->remarks.push_back(Fmt(Nte(Nte0089), Naming::niceParameterRank(si + 1).c_str(), parameters->childs[si]->typeInfo->getDisplayNameC()));
                    else
                        diag->remarks.push_back(Fmt(Nte(Nte0088), parameters->childs[si]->token.ctext(), parameters->childs[si]->typeInfo->getDisplayNameC()));
                    if (note && !parameters->childs[si]->isGeneratedSelf())
                        note->addRange(parameters->childs[si], "missing");
                }
            }
        }

        return;
    }

    case MatchResult::NotEnoughGenericParameters:
    {
        AstNode* errNode = genericParameters;
        if (!errNode)
            errNode = node;
        if (!errNode)
            errNode = context->node;
        if (destFuncDecl && destFuncDecl->isSpecialFunctionName())
            diag = new Diagnostic{errNode, errNode->token, Fmt(Err(Err0352), refNiceName.c_str(), destFuncDecl->token.ctext())};
        else if (genericParameters)
            diag = new Diagnostic{genericParameters, Fmt(Err(Err0035), refNiceName.c_str())};
        else
            diag = new Diagnostic{errNode, errNode->token, Fmt(Err(Err0049), refNiceName.c_str())};
        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::TooManyParameters:
    {
        AstNode* site = failedParam;
        if (!site)
            site = callParameters;
        SWAG_ASSERT(site);
        diag = new Diagnostic{site, Fmt(Err(Err0026), match.badSignatureInfos.badSignatureNum2, match.badSignatureInfos.badSignatureNum1)};
        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::TooManyGenericParameters:
    {
        AstNode* errNode = genericParameters;
        if (!errNode)
            errNode = node;
        if (!errNode)
            errNode = context->node;
        if (!match.badSignatureInfos.badSignatureNum2)
        {
            diag = new Diagnostic{errNode, Fmt(Err(Err0135), Naming::kindName(symbol->kind).c_str(), symbol->name.c_str()).c_str()};
        }
        else
        {
            if (genericParameters)
                errNode = genericParameters->childs[match.badSignatureInfos.badSignatureNum2];
            diag = new Diagnostic{errNode,
                                  Fmt(Err(Err0044),
                                      Naming::kindName(symbol->kind).c_str(),
                                      symbol->name.c_str(),
                                      match.badSignatureInfos.badSignatureNum2,
                                      match.badSignatureInfos.badSignatureNum1)};
        }

        result0.push_back(diag);

        auto note = Diagnostic::hereIs(overload);
        if (note)
            result1.push_back(note);
        return;
    }

    case MatchResult::MismatchGenericValue:
    {
        diag = new Diagnostic{bi.badNode,
                              Fmt(Err(Err0123),
                                  bi.badGenMatch.c_str(),
                                  Ast::literalToString(bi.badSignatureGivenType, *bi.badGenValue1).c_str(),
                                  Ast::literalToString(bi.badSignatureGivenType, *bi.badGenValue2).c_str())};
        result0.push_back(diag);
        return;
    }

    case MatchResult::BadSignature:
    {
        AstNode* paramNode = nullptr;

        if (destFuncDecl)
            paramNode = destFuncDecl->parameters->childs[bi.badSignatureParameterIdx];
        else if (destAttrDecl)
            paramNode = destAttrDecl->parameters->childs[bi.badSignatureParameterIdx];

        // In case of lambda, replace undefined with the corresponding match, if possible
        if (bi.badSignatureRequestedType->isLambdaClosure() && bi.badSignatureGivenType->isLambdaClosure())
        {
            auto type1 = CastTypeInfo<TypeInfoFuncAttr>(bi.badSignatureRequestedType, TypeInfoKind::LambdaClosure);
            auto type2 = CastTypeInfo<TypeInfoFuncAttr>(bi.badSignatureGivenType, TypeInfoKind::LambdaClosure);
            for (uint32_t i = 0; i < min(type1->parameters.count, type2->parameters.count); i++)
            {
                if (type2->parameters[i]->typeInfo->isNative(NativeTypeKind::Undefined))
                    type2->parameters[i]->typeInfo = type1->parameters[i]->typeInfo;
            }

            if (type2->returnType && type1->returnType && type2->returnType->isNative(NativeTypeKind::Undefined))
                type2->returnType = type1->returnType;
        }

        SWAG_ASSERT(callParameters);
        auto diagNode = match.parameters[bi.badSignatureParameterIdx];

        if (overload->typeInfo->isStruct())
        {
            auto typeStruct = CastTypeInfo<TypeInfoStruct>(overload->typeInfo, TypeInfoKind::Struct);
            typeStruct->flattenUsingFields();
            diag = new Diagnostic{diagNode,
                                  Fmt(Err(Err0723),
                                      typeStruct->flattenFields[badParamIdx - 1]->name.c_str(),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }
        else if (oneTry.ufcs && bi.badSignatureParameterIdx == 0 && oneTry.dependentVar)
        {
            diag    = new Diagnostic{context->node,
                                  context->node->token,
                                  Fmt(Err(Err0095),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
            hintMsg = Fmt(Nte(Nte1093), bi.badSignatureGivenType->getDisplayNameC());
            if (oneTry.dependentVar->isGeneratedSelf())
            {
                if (bi.badSignatureGivenType->isConst())
                {
                    auto note = Diagnostic::note(oneTry.dependentVar->ownerFct, oneTry.dependentVar->ownerFct->token, Nte(Nte0084));
                    result1.push_back(note);
                }
                else
                {
                    auto note = Diagnostic::note(oneTry.dependentVar->ownerFct, oneTry.dependentVar->ownerFct->token, Nte(Nte0073));
                    result1.push_back(note);
                }
            }
            else
            {
                auto note = Diagnostic::note(oneTry.dependentVar, Nte(Nte0074));
                result1.push_back(note);
            }
        }
        else if (oneTry.ufcs && bi.badSignatureParameterIdx == 0)
        {
            diag          = new Diagnostic{diagNode,
                                  Fmt(Err(Err0095),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
            auto nodeCall = diagNode->parent->childs.back();
            hintMsg       = Diagnostic::isType(bi.badSignatureGivenType);
            if (!oneTry.overload->node->isSpecialFunctionName())
                diag->addRange(nodeCall->token, Fmt(Nte(Nte1093), bi.badSignatureGivenType->getDisplayNameC()));
        }
        else if (paramNode && paramNode->typeInfo->isSelf() && bi.badSignatureParameterIdx == 0)
        {
            if (diagNode->kind == AstNodeKind::FuncDeclParam)
                diagNode = node;
            diag = new Diagnostic{diagNode,
                                  Fmt(Err(Err0106),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }
        else
        {
            diag = new Diagnostic{diagNode,
                                  Fmt(Err(Err0053),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
        }

        diag->hint = hintMsg;
        result0.push_back(diag);

        if (bi.genMatchFromNode)
        {
            auto note = Diagnostic::note(bi.genMatchFromNode, Fmt(Nte(Nte0075), bi.genMatchFromNode->typeInfo->getDisplayNameC()));
            result1.push_back(note);
        }

        // A more specific cast message ?
        Utf8         castMsg, castHint;
        Vector<Utf8> castRemarks;
        TypeManager::getCastErrorMsg(castMsg, castHint, castRemarks, bi.castErrorToType, bi.castErrorFromType, bi.castErrorFlags, bi.castErrorType, true);
        if (!castMsg.empty())
        {
            if (oneTry.dependentVar)
            {
                if (oneTry.dependentVar->isGeneratedSelf())
                {
                    auto note = Diagnostic::note(castMsg);
                    result1.push_back(note);
                }
                else
                {
                    auto note  = Diagnostic::note(oneTry.dependentVar, castMsg);
                    note->hint = castHint;
                    result1.push_back(note);
                }
            }
            else if (castHint.empty())
            {
                auto note = Diagnostic::note(castMsg);
                result1.push_back(note);
            }
            else
            {
                auto note  = Diagnostic::note(diag->sourceNode, diag->sourceNode->token, castMsg);
                note->hint = castHint;
                result1.push_back(note);
            }
        }
        else if (diag->hint.empty())
            diag->hint = castHint;

        // Here is
        if (getFlags & GDFM_HERE_IS)
        {
            if (destFuncDecl && paramNode && paramNode->isGeneratedSelf())
            {
                result1.push_back(Diagnostic::hereIs(destFuncDecl));
            }
            else if (paramNode)
            {
                Diagnostic* note = Diagnostic::note(paramNode, paramNode->token, Fmt(Nte(Nte0066), paramNode->token.ctext(), refNiceName.c_str()));
                result1.push_back(note);
            }
            else
            {
                Diagnostic* note = Diagnostic::hereIs(overload);
                if (note)
                    result1.push_back(note);
            }
        }

        return;
    }

    case MatchResult::CannotDeduceGenericType:
    {
        SWAG_ASSERT(callParameters);
        diag = new Diagnostic{match.parameters[bi.badSignatureParameterIdx],
                              Fmt(Err(Err0618),
                                  bi.badSignatureRequestedType->getDisplayNameC(),
                                  bi.badSignatureGivenType->getDisplayNameC())};
        result0.push_back(diag);
        return;
    }

    case MatchResult::BadGenericSignature:
    {
        SWAG_ASSERT(genericParameters);
        if (match.flags & SymbolMatchContext::MATCH_ERROR_VALUE_TYPE)
        {
            diag = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0054),
                                      Naming::niceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str())};
        }
        else if (match.flags & SymbolMatchContext::MATCH_ERROR_TYPE_VALUE)
        {
            diag = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0057),
                                      Naming::niceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str())};
        }
        else
        {
            diag       = new Diagnostic{match.genericParameters[bi.badSignatureParameterIdx],
                                  Fmt(Err(Err0070),
                                      Naming::niceArgumentRank(badParamIdx).c_str(),
                                      refNiceName.c_str(),
                                      bi.badSignatureRequestedType->getDisplayNameC(),
                                      bi.badSignatureGivenType->getDisplayNameC())};
            diag->hint = hintMsg;
        }

        result0.push_back(diag);

        // Here is
        if (getFlags & GDFM_HERE_IS)
        {
            if (destFuncDecl && bi.badSignatureParameterIdx < (int) destFuncDecl->genericParameters->childs.size())
            {
                auto reqParam = destFuncDecl->genericParameters->childs[bi.badSignatureParameterIdx];
                auto note     = Diagnostic::note(reqParam, Fmt(Nte(Nte0068), reqParam->token.ctext(), refNiceName.c_str()));
                result1.push_back(note);
            }
            else
            {
                auto note = Diagnostic::hereIs(overload);
                if (note)
                    result1.push_back(note);
            }
        }

        return;
    }
    }
}

void Semantic::symbolErrorNotes(SemanticContext* context, VectorNative<OneTryMatch*>& tryMatches, AstNode* node, Diagnostic* diag, Vector<const Diagnostic*>& notes)
{
    if (!node)
        return;
    if (node->kind != AstNodeKind::Identifier && node->kind != AstNodeKind::FuncCall)
        return;
    auto identifier = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);

    // Symbol has been found with a using : display it
    if (tryMatches.size() == 1 && tryMatches[0]->dependentVar)
    {
        // Do not generate a note if this is a generated 'using' in case of methods
        if (!tryMatches[0]->dependentVar->isGeneratedSelf())
        {
            auto note = Diagnostic::note(tryMatches[0]->dependentVar, Fmt(Nte(Nte0013), tryMatches[0]->overload->symbol->name.c_str()));
            notes.push_back(note);
        }
    }

    // Additional error if the first parameter does not match, or if nothing matches
    bool badUfcs = tryMatches.empty();
    for (auto over : tryMatches)
    {
        if (over->symMatchContext.result == MatchResult::BadSignature && over->symMatchContext.badSignatureInfos.badSignatureParameterIdx == 0)
        {
            badUfcs = true;
            break;
        }
    }

    if (badUfcs && !identifier->identifierRef()->startScope)
    {
        // There's something before (identifier is not the only one in the identifierRef).
        if (identifier != identifier->parent->childs.front())
        {
            auto idIdx = identifier->childParentIdx();
            auto prev  = identifier->identifierRef()->childs[idIdx - 1];
            if (prev->resolvedSymbolName)
            {
                if (prev->hasExtMisc() && prev->extMisc()->resolvedUserOpSymbolOverload)
                {
                    auto typeInfo = TypeManager::concreteType(prev->extMisc()->resolvedUserOpSymbolOverload->typeInfo);
                    auto note     = Diagnostic::note(prev, Fmt(Nte(Nte0018), prev->extMisc()->resolvedUserOpSymbolOverload->symbol->name.c_str(), typeInfo->getDisplayNameC()));
                    note->hint    = Diagnostic::isType(typeInfo);
                    notes.push_back(note);
                    return;
                }

                if (prev->kind == AstNodeKind::ArrayPointerIndex)
                {
                    auto api = CastAst<AstArrayPointerIndex>(prev, AstNodeKind::ArrayPointerIndex);
                    if (api->array->typeInfo)
                    {
                        prev           = api->array;
                        auto typeArray = CastTypeInfo<TypeInfoArray>(api->array->typeInfo, TypeInfoKind::Array);
                        auto note      = Diagnostic::note(prev, Fmt(Nte(Nte0000), prev->token.ctext(), typeArray->finalType->getDisplayNameC()));
                        notes.push_back(note);
                    }
                }
                else
                {
                    Diagnostic* note = nullptr;
                    if (prev->typeInfo)
                        note = Diagnostic::note(prev, Fmt(Nte(Nte0001), prev->token.ctext(), Naming::aKindName(prev->resolvedSymbolName->kind).c_str(), prev->typeInfo->getDisplayNameC()));
                    else
                        note = Diagnostic::note(prev, Fmt(Nte(Nte0010), prev->token.ctext(), Naming::aKindName(prev->resolvedSymbolName->kind).c_str()));
                    notes.push_back(note);
                    if (prev->resolvedSymbolOverload)
                        notes.push_back(Diagnostic::hereIs(prev));
                }
            }
        }
    }
}

void Semantic::symbolErrorRemarks(SemanticContext* context, VectorNative<OneTryMatch*>& tryMatches, AstNode* node, Diagnostic* diag)
{
    if (!node)
        return;
    if (node->kind != AstNodeKind::Identifier && node->kind != AstNodeKind::FuncCall)
        return;
    if (tryMatches.empty())
        return;

    // If we have an UFCS call, and the match does not come from its symtable, then that means that we have not found the
    // symbol in the original struct also.
    auto identifier = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);
    if (identifier->identifierRef()->startScope && !tryMatches.empty())
    {
        size_t notFound = 0;
        for (auto tryMatch : tryMatches)
        {
            if (tryMatch->ufcs &&
                tryMatch->overload->node->ownerStructScope &&
                identifier->ownerStructScope &&
                tryMatch->overload->node->ownerStructScope->owner != identifier->identifierRef()->startScope->owner)
                notFound++;
        }

        if (notFound == tryMatches.size())
        {
            if (identifier->identifierRef()->typeInfo)
            {
                auto over = tryMatches.front()->overload;
                auto msg  = Fmt(Nte(Nte0043),
                               Naming::kindName(over).c_str(),
                               node->token.ctext(),
                               identifier->identifierRef()->typeInfo->getDisplayNameC(),
                               over->node->ownerStructScope->owner->token.ctext());
                diag->remarks.push_back(msg);
            }

            for (auto s : identifier->identifierRef()->startScope->childScopes)
            {
                if (s->kind == ScopeKind::Impl)
                {
                    if (s->symTable.find(node->token.text))
                    {
                        diag->remarks.push_back(Fmt(Nte(Nte0044), node->token.ctext(), s->getFullName().c_str()));
                    }
                }
            }
        }
    }
}

bool Semantic::cannotMatchIdentifierError(SemanticContext*            context,
                                          MatchResult                 result,
                                          int                         paramIdx,
                                          VectorNative<OneTryMatch*>& tryMatches,
                                          AstNode*                    node,
                                          Vector<const Diagnostic*>&  notes)
{
    if (tryMatches.empty())
        return false;

    bool                       hasCorrectResult = false;
    VectorNative<OneTryMatch*> tryResult;
    for (size_t i = 0; i < tryMatches.size(); i++)
    {
        auto one = tryMatches[i];
        if (one->symMatchContext.result == result)
        {
            hasCorrectResult = true;
            bool take        = true;
            if (result == MatchResult::BadSignature || result == MatchResult::BadGenericSignature)
                take = one->symMatchContext.badSignatureInfos.badSignatureParameterIdx == paramIdx;
            if (take)
            {
                tryResult.push_back(one);
                tryMatches.erase(i);
                i--;
            }
        }
    }

    if (tryResult.empty())
        return hasCorrectResult;

    static const int MAX_OVERLOADS = 5;
    Diagnostic*      note          = nullptr;

    switch (result)
    {
    case MatchResult::ValidIfFailed:
        note = Diagnostic::note(node, node->token, "all '#validif' have failed");
        break;
    case MatchResult::TooManyParameters:
        note = Diagnostic::note(node, node->token, "too many arguments");
        break;
    case MatchResult::TooManyGenericParameters:
        note = Diagnostic::note(node, node->token, "too many generic arguments");
        break;
    case MatchResult::NotEnoughParameters:
        note = Diagnostic::note(node, node->token, "not enough arguments");
        break;
    case MatchResult::NotEnoughGenericParameters:
        note = Diagnostic::note(node, node->token, "not enough generic arguments");
        break;
    case MatchResult::BadSignature:
        if (tryResult[0]->ufcs && paramIdx == 0)
            note = Diagnostic::note(node, node->token, "the UFCS argument does not match");
        else
            note = Diagnostic::note(node, node->token, Fmt("the %s does not match", Naming::niceArgumentRank(paramIdx + 1).c_str()));
        break;
    case MatchResult::BadGenericSignature:
        note = Diagnostic::note(node, node->token, Fmt("the generic %s does not match", Naming::niceArgumentRank(paramIdx + 1).c_str()));
        break;
        break;
    default:
        SWAG_ASSERT(false);
        break;
    }

    Concat                   concat;
    AstOutput::OutputContext outCxt;
    concat.init(10 * 1024);

    for (size_t i = 0; i < min(tryResult.size(), MAX_OVERLOADS); i++)
    {
        if (tryResult[i]->overload->node->kind == AstNodeKind::FuncDecl)
        {
            auto funcNode = CastAst<AstFuncDecl>(tryResult[i]->overload->node, AstNodeKind::FuncDecl);
            AstOutput::outputFuncSignature(outCxt, concat, funcNode, funcNode->genericParameters, funcNode->parameters, nullptr);
        }
        else if (tryResult[i]->overload->node->kind == AstNodeKind::VarDecl)
        {
            auto varNode = CastAst<AstVarDecl>(tryResult[i]->overload->node, AstNodeKind::VarDecl);
            auto lambda  = CastAst<AstTypeLambda>(varNode->typeInfo->declNode, AstNodeKind::TypeLambda);
            AstOutput::outputFuncSignature(outCxt, concat, varNode, nullptr, lambda->parameters, nullptr);
        }
        else
        {
            SWAG_ASSERT(false);
        }

        Utf8 n = Utf8{(const char*) concat.firstBucket->datas, concat.bucketCount(concat.firstBucket)};
        if (n.back() == '\n')
            n.count--;
        if (n.back() == ';')
            n.count--;

        if (g_CommandLine.logColors)
        {
            SyntaxColorContext cxt;
            n = syntaxColor(n, cxt);
        }

        Utf8 fn = Fmt("%d: %s", i + 1, n.c_str());

        note->remarks.push_back(fn);
        fn.clear();

        if (result == MatchResult::BadSignature || result == MatchResult::BadGenericSignature)
        {
            Vector<const Diagnostic*> errs0, errs1;
            getDiagnosticForMatch(context, *tryResult[i], errs0, errs1);
            fn += "        ";

            if (g_CommandLine.logColors)
                fn += Log::colorToVTS(LogColor::Red);
            Vector<Utf8> parts;
            Diagnostic::tokenizeError(errs0[0]->textMsg, parts);
            if (parts.size() > 1)
                fn += parts[1];
            else
                fn += parts[0];
            if (g_CommandLine.logColors)
                fn += Log::colorToVTS(LogColor::Default);
        }

        note->remarks.push_back(fn);
        concat.clear();
    }

    if (tryResult.size() >= MAX_OVERLOADS)
        note->remarks.push_back("...");

    // Locate to the first error
    Vector<const Diagnostic*> errs0, errs1;
    getDiagnosticForMatch(context, *tryResult[0], errs0, errs1);
    note->sourceFile      = errs0[0]->sourceFile;
    note->startLocation   = errs0[0]->startLocation;
    note->endLocation     = errs0[0]->endLocation;
    note->forceSourceFile = true;

    notes.push_back(note);
    return true;
}

bool Semantic::cannotMatchIdentifierError(SemanticContext* context, VectorNative<OneTryMatch*>& tryMatches, AstNode* node)
{
    AstIdentifier* identifier        = nullptr;
    AstNode*       genericParameters = nullptr;
    AstNode*       callParameters    = nullptr;

    // node can be null when we try to resolve a userOp
    if (node && (node->kind == AstNodeKind::Identifier || node->kind == AstNodeKind::FuncCall))
    {
        identifier        = CastAst<AstIdentifier>(node, AstNodeKind::Identifier, AstNodeKind::FuncCall);
        genericParameters = identifier->genericParameters;
        callParameters    = identifier->callParameters;
    }
    else
        node = context->node;

    // Take non generic errors in priority
    {
        Vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            switch (one.symMatchContext.result)
            {
            case MatchResult::BadSignature:
            case MatchResult::DuplicatedNamedParameter:
            case MatchResult::InvalidNamedParameter:
            case MatchResult::MissingNamedParameter:
            case MatchResult::MissingParameters:
            case MatchResult::NotEnoughParameters:
            case MatchResult::TooManyParameters:
            case MatchResult::ValidIfFailed:
            case MatchResult::NotEnoughGenericParameters:
                n.push_back(oneMatch);
                break;
            default:
                break;
            }
        }
        if (!n.empty())
            tryMatches = n;
    }

    // Remove duplicates overloads, as we can have one with ufcs, and one without, as we
    // could have tried both
    {
        Vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            for (auto oneMatch1 : tryMatches)
            {
                if (oneMatch == oneMatch1)
                    continue;
                if (oneMatch->overload != oneMatch1->overload)
                    continue;

                // If the ufcs version has matched the UFCS parameter, then take that one
                if (oneMatch->ufcs && oneMatch->symMatchContext.badSignatureInfos.badSignatureParameterIdx > 0)
                    oneMatch1->overload = nullptr;

                // If the UFCS has failed because of constness, takes the UFCS error
                else if (oneMatch->ufcs && oneMatch->symMatchContext.badSignatureInfos.badSignatureParameterIdx == 0 && oneMatch->symMatchContext.badSignatureInfos.castErrorType == CastErrorType::Const)
                    oneMatch1->overload = nullptr;

                // If this is a lambda call that comes from a struct, then this is ambiguous. Do we keep the error where the struct
                // has been used to find the lambda and UFCS, or do we consider the struct is just there to find the lambda ?
                // We consider that UFCS of 'struct.lambda.call(struct)' has less priority than other errors
                else if (oneMatch->ufcs && oneMatch->scope && oneMatch->scope->kind == ScopeKind::Struct && oneMatch->overload->symbol->kind == SymbolKind::Variable)
                    oneMatch->overload = nullptr;

                // Otherwise, if with UFCS we do not have enough argument, we use UFCS in priority
                else if (oneMatch->ufcs && oneMatch1->symMatchContext.result == MatchResult::NotEnoughParameters)
                    oneMatch1->overload = nullptr;

                // Otherwise we remove the UFCS error and take the other one
                else if (oneMatch->ufcs)
                    oneMatch->overload = nullptr;

                break;
            }

            if (oneMatch->overload)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            tryMatches = n;
    }

    // If we do not have generic parameters, then eliminate generic fail
    if (!genericParameters)
    {
        Vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            if (!(one.overload->flags & OVERLOAD_GENERIC))
                n.push_back(oneMatch);
        }
        if (!n.empty())
            tryMatches = n;
    }

    // If we have generic parameters, then eliminate non generic fail
    if (genericParameters)
    {
        Vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            if (one.overload->flags & OVERLOAD_GENERIC)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            tryMatches = n;
    }

    // Take validif if failed in priority
    {
        Vector<OneTryMatch*> n;
        for (auto oneMatch : tryMatches)
        {
            auto& one = *oneMatch;
            if (one.symMatchContext.result == MatchResult::ValidIfFailed)
                n.push_back(oneMatch);
        }
        if (!n.empty())
            tryMatches = n;
    }

    uint32_t getFlags = GDFM_ALL;

    // All errors are because of a constness problem on the UFCS argument
    // Then just raise one error
    int badConstUfcs = 0;
    for (auto& tm : tryMatches)
    {
        if (tm->ufcs &&
            tm->symMatchContext.badSignatureInfos.badSignatureParameterIdx == 0 &&
            tm->symMatchContext.badSignatureInfos.castErrorType == CastErrorType::Const)
            badConstUfcs += 1;
    }
    if (badConstUfcs == tryMatches.size())
    {
        while (tryMatches.size() > 1)
            tryMatches.pop_back();
        getFlags &= ~GDFM_HERE_IS;
    }

    // One single overload
    if (tryMatches.size() == 1)
    {
        // Be sure this is not because of an invalid special function signature
        if (tryMatches[0]->overload->node->kind == AstNodeKind::FuncDecl)
            SWAG_CHECK(checkFuncPrototype(context, CastAst<AstFuncDecl>(tryMatches[0]->overload->node, AstNodeKind::FuncDecl)));

        Vector<const Diagnostic*> errs0, errs1;
        getDiagnosticForMatch(context, *tryMatches[0], errs0, errs1, getFlags);
        SWAG_ASSERT(!errs0.empty());
        symbolErrorRemarks(context, tryMatches, node, const_cast<Diagnostic*>(errs0[0]));
        symbolErrorNotes(context, tryMatches, node, const_cast<Diagnostic*>(errs0[0]), errs1);
        return context->report(*errs0[0], errs1);
    }

    // Multiple tryMatches
    Diagnostic diag{node, node->token, Fmt(Err(Err0113), tryMatches.size(), tryMatches[0]->overload->symbol->name.c_str())};
    symbolErrorRemarks(context, tryMatches, node, &diag);

    Vector<const Diagnostic*> notes;
    symbolErrorNotes(context, tryMatches, node, &diag, notes);

    cannotMatchIdentifierError(context, MatchResult::ValidIfFailed, 0, tryMatches, node, notes);
    cannotMatchIdentifierError(context, MatchResult::NotEnoughParameters, 0, tryMatches, node, notes);
    cannotMatchIdentifierError(context, MatchResult::TooManyParameters, 0, tryMatches, node, notes);
    cannotMatchIdentifierError(context, MatchResult::NotEnoughGenericParameters, 0, tryMatches, node, notes);
    cannotMatchIdentifierError(context, MatchResult::TooManyGenericParameters, 0, tryMatches, node, notes);

    // For a bad signature, only show the ones with the greatest match
    int paramIdx;
    for (int what = 0; what < 2; what++)
    {
        Vector<const Diagnostic*> notesSig;
        paramIdx = 0;
        while (true)
        {
            Vector<const Diagnostic*> notesTmp;
            auto                      m = what == 0 ? MatchResult::BadSignature : MatchResult::BadGenericSignature;
            if (!cannotMatchIdentifierError(context, m, paramIdx++, tryMatches, node, notesTmp))
                break;
            notesSig = notesTmp;
        }
        notes.insert(notes.end(), notesSig.begin(), notesSig.end());
    }

    return context->report(diag, notes);
}

Utf8 Semantic::findClosestMatchesMsg(const Utf8& searchName, const Vector<Utf8>& best)
{
    Utf8 appendMsg;
    switch (best.size())
    {
    case 1:
    {
        Utf8 a0 = searchName;
        Utf8 a1 = best[0];
        a0.makeLower();
        a1.makeLower();
        if (a0 == a1)
            appendMsg = Fmt("do you mean '%s'? (notice the capitalization)", best[0].c_str());
        else
            appendMsg = Fmt("do you mean '%s'?", best[0].c_str());
        break;
    }
    case 2:
        appendMsg = Fmt("do you mean '%s' or '%s'?", best[0].c_str(), best[1].c_str());
        break;
    case 3:
        appendMsg = Fmt("do you mean '%s', '%s' or '%s'?", best[0].c_str(), best[1].c_str(), best[2].c_str());
        break;
    }

    return appendMsg;
}

void Semantic::findClosestMatches(const Utf8& searchName, const Vector<Utf8>& searchList, Vector<Utf8>& result)
{
    uint32_t bestScore = UINT32_MAX;
    result.clear();

    auto searchName1 = searchName;
    for (uint32_t i = 0; i < (uint32_t) searchList.size(); i++)
    {
        auto searchName2 = searchList[i];
        auto score       = Utf8::fuzzyCompare(searchName1, searchName2);

        // If number of changes is too big considering the size of the text, cancel
        if (searchName.count > 1 && score > (uint32_t) searchName.count / 2)
            continue;
        // If too much changes, cancel
        if (score > 2)
            continue;

        if (score < bestScore)
            result.clear();
        if (score <= bestScore)
        {
            // Be sure it's not already in the best list
            bool here = false;
            for (auto& n : result)
            {
                if (n == searchList[i])
                {
                    here = true;
                    break;
                }
            }

            if (!here)
            {
                result.push_back(searchList[i]);
            }

            bestScore = score;
        }
    }
}

void Semantic::findClosestMatches(const Utf8& searchName, const VectorNative<AlternativeScope>& scopeHierarchy, Vector<Utf8>& best, IdentifierSearchFor searchFor)
{
    Vector<Utf8> searchList;
    for (auto& as : scopeHierarchy)
    {
        auto s = as.scope;
        for (uint32_t i = 0; i < s->symTable.mapNames.allocated; i++)
        {
            auto one = s->symTable.mapNames.buffer[i];
            if (!one.symbolName)
                continue;

            // Filter to try to be as relevant as possible
            if (searchFor == IdentifierSearchFor::Function &&
                one.symbolName->kind != SymbolKind::Function)
                continue;
            if (searchFor == IdentifierSearchFor::Attribute &&
                one.symbolName->kind != SymbolKind::Attribute)
                continue;
            if (searchFor != IdentifierSearchFor::Function &&
                one.symbolName->kind == SymbolKind::Function)
                continue;
            if (searchFor != IdentifierSearchFor::Function &&
                one.symbolName->kind == SymbolKind::Attribute)
                continue;
            if (searchFor == IdentifierSearchFor::Type &&
                one.symbolName->kind != SymbolKind::TypeAlias &&
                one.symbolName->kind != SymbolKind::Enum &&
                one.symbolName->kind != SymbolKind::GenericType &&
                one.symbolName->kind != SymbolKind::Struct &&
                one.symbolName->kind != SymbolKind::Interface)
                continue;
            if (searchFor == IdentifierSearchFor::Struct &&
                one.symbolName->kind != SymbolKind::Struct)
                continue;
            if (one.symbolName->cptOverloadsInit == 0)
                continue;

            searchList.push_back(one.symbolName->name);
        }
    }

    for (int i = 0; i < (int) g_LangSpec->keywords.allocated; i++)
    {
        switch (searchFor)
        {
        case IdentifierSearchFor::TopLevelInstruction:
            if (Tokenizer::isTopLevelInst(g_LangSpec->keywords.buffer[i].value))
                searchList.push_back(g_LangSpec->keywords.buffer[i].key);
            break;

        case IdentifierSearchFor::Keyword:
            if (Tokenizer::isKeyword(g_LangSpec->keywords.buffer[i].value))
                searchList.push_back(g_LangSpec->keywords.buffer[i].key);
            break;

        case IdentifierSearchFor::Type:
            if (g_LangSpec->keywords.buffer[i].value == TokenId::NativeType)
                searchList.push_back(g_LangSpec->keywords.buffer[i].key);
            break;

        case IdentifierSearchFor::Function:
            if (searchName[0] == '@' || searchName[0] == '#')
            {
                auto& k = g_LangSpec->keywords.buffer[i].key;
                if (k && k[0] == searchName[0])
                    searchList.push_back(k);
            }
            break;

        default:
            if (g_LangSpec->keywords.buffer[i].key)
                searchList.push_back(g_LangSpec->keywords.buffer[i].key);
            break;
        }
    }

    findClosestMatches(searchName, searchList, best);
}

Utf8 Semantic::findClosestMatchesMsg(const Utf8& searchName, const VectorNative<AlternativeScope>& scopeHierarchy, IdentifierSearchFor searchFor)
{
    Vector<Utf8> best;
    findClosestMatches(searchName, scopeHierarchy, best, searchFor);
    return findClosestMatchesMsg(searchName, best);
}

void Semantic::unknownIdentifier(SemanticContext* context, AstIdentifierRef* identifierRef, AstIdentifier* node)
{
    auto& scopeHierarchy     = context->cacheScopeHierarchy;
    auto& scopeHierarchyVars = context->cacheScopeHierarchyVars;

    // What kind of thing to we search for ?
    auto searchFor = IdentifierSearchFor::Whatever;
    if (node->parent->parent && node->parent->parent->kind == AstNodeKind::TypeExpression && node->parent->childs.back() == node)
        searchFor = IdentifierSearchFor::Type;
    else if (node->parent->parent && node->parent->parent->kind == AstNodeKind::AttrUse && node->parent->childs.back() == node)
        searchFor = IdentifierSearchFor::Attribute;
    else if (node->callParameters && (node->callParameters->specFlags & AstFuncCallParams::SPECFLAG_CALL_FOR_STRUCT))
        searchFor = IdentifierSearchFor::Struct;
    else if (node->callParameters)
        searchFor = IdentifierSearchFor::Function;

    // Find best matches
    if (identifierRef->startScope)
    {
        scopeHierarchy.clear();
        addAlternativeScopeOnce(scopeHierarchy, identifierRef->startScope);
    }
    else
    {
        collectScopeHierarchy(context, scopeHierarchy, scopeHierarchyVars, node, COLLECT_ALL);
    }

    Vector<const Diagnostic*> notes;
    Diagnostic*               diag = nullptr;

    // Message
    switch (searchFor)
    {
    case IdentifierSearchFor::Function:
        if (node->token.text[0] == '#')
            diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0140), node->token.ctext())};
        else if (node->token.text[0] == '@')
            diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0129), node->token.ctext())};
        else
            diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0228), node->token.ctext())};
        break;
    case IdentifierSearchFor::Attribute:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0251), node->token.ctext())};
        break;
    case IdentifierSearchFor::Type:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0165), node->token.ctext())};
        break;
    case IdentifierSearchFor::Struct:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0393), node->token.ctext())};
        break;
    default:
        diag = new Diagnostic{node->sourceFile, node->token, Fmt(Err(Err0122), node->token.ctext())};
        break;
    }

    // Error in scope context
    if (identifierRef->startScope)
    {
        auto typeWhere = identifierRef->startScope->owner->typeInfo;
        auto typeRef   = TypeManager::concreteType(identifierRef->typeInfo);
        if (typeRef && typeRef->isPointer())
            typeRef = CastTypeInfo<TypeInfoPointer>(typeRef, TypeInfoKind::Pointer)->pointedType;

        if (typeRef && typeRef->isTuple())
        {
            diag            = new Diagnostic{node, Fmt(Err(Err0093), node->token.ctext())};
            auto structNode = CastAst<AstStruct>(identifierRef->startScope->owner, AstNodeKind::StructDecl);
            auto note       = Diagnostic::note(structNode->originalParent ? structNode->originalParent : identifierRef->startScope->owner, Nte(Nte0030));
            notes.push_back(note);
        }
        else
        {
            Utf8           displayName;
            AstIdentifier* prevIdentifier = nullptr;
            if (identifierRef->previousResolvedNode && identifierRef->previousResolvedNode->kind == AstNodeKind::Identifier)
                prevIdentifier = CastAst<AstIdentifier>(identifierRef->previousResolvedNode, AstNodeKind::Identifier);
            if (!(identifierRef->startScope->flags & SCOPE_FILE))
                displayName = identifierRef->startScope->getDisplayFullName();
            if (displayName.empty() && !identifierRef->startScope->name.empty())
                displayName = identifierRef->startScope->name;
            if (displayName.empty() && typeRef)
                displayName = typeRef->name;
            if (!displayName.empty())
            {
                auto varDecl = node->findParent(AstNodeKind::VarDecl);
                auto idRef   = node->identifierRef();
                if (idRef && idRef->flags & AST_TUPLE_UNPACK && varDecl)
                {
                    diag = new Diagnostic{node, Fmt(Err(Err0821), varDecl->token.ctext(), displayName.c_str())};
                }
                else if (prevIdentifier && prevIdentifier->identifierExtension && prevIdentifier->identifierExtension->alternateEnum)
                {
                    auto altEnum    = prevIdentifier->identifierExtension->alternateEnum;
                    diag            = new Diagnostic{node, node->token, Fmt(Err(Err0492), node->token.ctext(), altEnum->getDisplayNameC(), Naming::kindName(identifierRef->startScope->kind).c_str(), displayName.c_str())};
                    auto note       = Diagnostic::hereIs(altEnum->declNode, false, true);
                    note->showRange = false;
                    notes.push_back(note);
                }
                else if (typeWhere)
                {
                    if (typeWhere->kind == TypeInfoKind::Struct && node->callParameters)
                    {
                        if (node->token.text.startsWith(g_LangSpec->name_opVisit) && node->token.text != g_LangSpec->name_opVisit)
                        {
                            Utf8 variant{node->token.text.buffer + g_LangSpec->name_opVisit.length()};
                            diag = new Diagnostic{node, node->token, Fmt(Err(Err1139), variant.c_str(), typeWhere->getDisplayNameC())};
                        }
                        else if (node->token.text == g_LangSpec->name_opVisit)
                        {
                            diag = new Diagnostic{node, node->token, Fmt(Err(Err0557), typeWhere->getDisplayNameC())};
                        }
                        else
                            diag = new Diagnostic{node, node->token, Fmt(Err(Err1107), node->token.ctext(), typeWhere->getDisplayNameC())};
                    }
                    else if (typeWhere->kind == TypeInfoKind::Enum)
                    {
                        diag = new Diagnostic{node, node->token, Fmt(Err(Err0144), node->token.ctext(), typeWhere->getDisplayNameC())};
                    }
                    else
                    {
                        diag = new Diagnostic{node, node->token, Fmt(Err(Err0112), node->token.ctext(), typeWhere->getDisplayNameC())};
                    }

                    if (prevIdentifier && prevIdentifier->resolvedSymbolName && prevIdentifier->resolvedSymbolName->kind == SymbolKind::Variable)
                        diag->addRange(prevIdentifier, Diagnostic::isType(prevIdentifier));
                }
                else
                {
                    Utf8 where = Naming::kindName(identifierRef->startScope->kind).c_str();
                    diag       = new Diagnostic{node, node->token, Fmt(Err(Err0110), node->token.ctext(), where.c_str(), displayName.c_str())};
                }

                switch (identifierRef->startScope->owner->kind)
                {
                case AstNodeKind::StructDecl:
                case AstNodeKind::InterfaceDecl:
                case AstNodeKind::EnumDecl:
                {
                    auto note = Diagnostic::hereIs(identifierRef->startScope->owner, false, true);
                    notes.push_back(note);
                    break;
                }
                default:
                    break;
                }
            }
        }
    }

    VectorNative<OneTryMatch*> v;
    symbolErrorRemarks(context, v, node, diag);
    symbolErrorNotes(context, v, node, diag, notes);

    Utf8 appendMsg = findClosestMatchesMsg(node->token.text, scopeHierarchy, searchFor);
    if (!appendMsg.empty())
        notes.push_back(Diagnostic::note(appendMsg));

    context->report(*diag, notes);
}

bool Semantic::notAllowedError(ErrorContext* context, AstNode* node, TypeInfo* typeInfo, const char* msg, AstNode* hintType)
{
    Utf8 text = Fmt(Err(Err0005), node->token.ctext(), typeInfo->getDisplayNameC());
    if (msg)
    {
        text += " ";
        text += msg;
    }

    Diagnostic diag{node, node->token, text};
    if (hintType)
        diag.addRange(hintType, Diagnostic::isType(typeInfo));
    return context->report(diag);
}

bool Semantic::duplicatedSymbolError(ErrorContext* context,
                                     SourceFile*   sourceFile,
                                     Token&        token,
                                     SymbolKind    thisKind,
                                     const Utf8&   thisName,
                                     SymbolKind    otherKind,
                                     AstNode*      otherSymbolDecl)
{
    Utf8 as;
    if (thisKind != otherKind)
        as = Fmt("as %s", Naming::aKindName(otherKind).c_str());

    Diagnostic diag{sourceFile, token, Fmt(Err(Err0305), Naming::kindName(thisKind).c_str(), thisName.c_str(), as.c_str())};

    auto note = Diagnostic::note(otherSymbolDecl, otherSymbolDecl->token, Nte(Nte0036));
    return context->report(diag, note);
}

bool Semantic::error(SemanticContext* context, const Utf8& msg)
{
    return context->report({context->node, msg});
}
