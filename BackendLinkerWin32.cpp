#include "pch.h"
#include "Utf8.h"
#include "BackendSetupWin32.h"
#include "Global.h"
#include "CommandLine.h"
#include "Workspace.h"
#include "Module.h"

#ifdef _WIN32

namespace BackendLinkerWin32
{
    string getCacheFolder(const BuildParameters& buildParameters)
    {
        auto targetPath = g_Workspace.cachePath.string();
        if (buildParameters.flags & BUILDPARAM_FOR_TEST)
            targetPath += "/test/";
        return targetPath;
    }

    void getLibPaths(vector<Utf8>& libPath)
    {
        // For vcruntime & msvcrt (mandatory under windows, even with clang...)
        libPath.push_back(format(R"(%s\lib\x64)", BackendSetupWin32::visualStudioPath.c_str()));

        // Windows sdk library paths
        libPath.push_back(format(R"(%s\lib\%s\um\x64)", BackendSetupWin32::winSdkPath.c_str(), BackendSetupWin32::winSdkVersion.c_str()));
        libPath.push_back(format(R"(%s\lib\%s\ucrt\x64)", BackendSetupWin32::winSdkPath.c_str(), BackendSetupWin32::winSdkVersion.c_str()));

        // Modules
        libPath.push_back(g_Workspace.targetPath.string());

        // Runtime
        libPath.push_back(g_CommandLine.exePath.parent_path().string());
    }

    string getResultFile(const BuildParameters& buildParameters)
    {
        SWAG_ASSERT(!buildParameters.destFile.empty());
        string destFile = g_Workspace.targetPath.string() + buildParameters.destFile;
        string resultFile;
        switch (buildParameters.type)
        {
        case BackendOutputType::StaticLib:
            resultFile = destFile + buildParameters.postFix + ".lib";
            break;

        case BackendOutputType::DynamicLib:
            resultFile = destFile + buildParameters.postFix + ".dll";
            break;

        case BackendOutputType::Binary:
            resultFile = destFile + buildParameters.postFix + ".exe";
            break;
        }

        return resultFile;
    }

    void getArguments(const BuildParameters& buildParameters, Module* module, Utf8& arguments)
    {
        vector<Utf8> libPath;
        getLibPaths(libPath);

        // Registered #foreignlib
        // As this is defined by the user, the consider the library must exists
        for (auto fl : buildParameters.foreignLibs)
        {
            arguments += fl;
            arguments += ".lib ";
        }

        // Registered #import dependencies
        // As this is generated by #import, it's possible that the .lib does not exists, because it
        // has another name
        for (const auto& dep : module->moduleDependencies)
        {
            auto libName = dep.first + ".lib ";
            for (const auto& oneLibPath : libPath)
            {
                auto fullName = oneLibPath;
                fullName += "/";
                fullName += libName;

                if (fs::exists(fs::path(fullName.c_str())))
                {
                    arguments += libName;
                    break;
                }
            }
        }

        // This is mandatory under windows
        arguments += "kernel32.lib ";
        arguments += "user32.lib ";

        // Add swag.runtime
        arguments += "swag.runtime.lib ";

        // Default libraries
        arguments += "/NODEFAULTLIB ";
        arguments += "ucrt.lib ";
        arguments += "vcruntime.lib ";
        arguments += "msvcrt.lib ";

        for (const auto& oneLibPath : libPath)
            arguments += "/LIBPATH:\"" + oneLibPath + "\" ";

        arguments += "/INCREMENTAL:NO /NOLOGO /SUBSYSTEM:CONSOLE /MACHINE:X64 ";

        bool debugMode = buildParameters.target.backendDebugInformations || g_CommandLine.debug;
        if (debugMode)
            arguments += "/DEBUG ";

        auto resultFile = getResultFile(buildParameters);
        if (buildParameters.type == BackendOutputType::DynamicLib)
        {
            arguments += "/DLL ";
            arguments += "/OUT:\"" + resultFile + "\" ";
        }
        else
        {
            arguments += "/OUT:\"" + resultFile + "\" ";
        }
    }

} // namespace BackendLinkerWin32

#endif