{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "swag",
  "patterns": [
    { "include": "#one-line-comment" },
    { "include": "#multi-line-comment" },
    { "include": "#attributes" },
    { "include": "#keywords" },
    { "include": "#keywords-control" },
    { "include": "#keywords-decl" },
    { "include": "#op" },
    { "include": "#op-invalid" },
    { "include": "#function-call" },
    { "include": "#function-call1" },
    { "include": "#raw-strings" },
    { "include": "#intrinsics" },
    { "include": "#intrinsics-buildin" },
    { "include": "#intrinsics-alias" },
    { "include": "#intrinsics-invalid" },
    { "include": "#intrinsics-literal" },
    { "include": "#compiler-function" },
    { "include": "#compiler-global" },
    { "include": "#compiler-statement" },
    { "include": "#compiler" },
    { "include": "#compiler-invalid" },
    { "include": "#types" },
    { "include": "#strings" },
    { "include": "#var-decl" },
    { "include": "#storage-modifier" },
    { "include": "#constant" },
    { "include": "#struct-name" },
    { "include": "#literal-binary" },
    { "include": "#literal-hexa" },
    { "include": "#literal-float" },
    { "include": "#literal-integer" },
    { "include": "#characters" },
    { "include": "#operator-character" },
    { "include": "#code" }
  ],
  "repository": {
    "one-line-comment": {
      "patterns": [
        {
          "name": "comment.line",
          "match": "///?(.*)"
        }
      ]
    },
    "multi-line-comment": {
      "name": "comment.line",
      "begin": "/\\*",
      "end": "\\*/",
      "patterns": [
        {
          "name": "comment.line",
          "begin": "/\\*",
          "end": "\\*/"
        }
      ]
    },
    "attributes": {
      "patterns": [
        {
          "name": "entity.name.function.preprocessor",
          "match": "(#\\[)(\\w+)(.*)(\\])"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword",
          "match": "\\b(using|deref|cast|autocast|bitcast|move|nodrop|retval)\\b"
        }
      ]
    },
    "keywords-control": {
      "patterns": [
        {
          "name": "keyword.control",
          "match": "\\b(if|else|for|while|switch|defer|loop|visit|break|fallthrough|return|case|continue|default|label)\\b"
        }
      ]
    },
    "keywords-decl": {
      "patterns": [
        {
          "name": "keyword.declaration",
          "match": "\\b(enum|struct|union|impl|interface|typeset|func|namespace|alias|attr)\\b"
        }
      ]
    },
    "var-decl": {
      "patterns": [
        {
          "name": "keyword.declaration",
          "match": "\\b(var|const)\\b"
        }
      ]
    },
    "intrinsics": {
      "patterns": [
        {
          "name": "entity.name.function.intrinsic",
          "match": "(@)\\b(init|drop|index|mkany|mkslice|mkforeign|mkcallback|mkinterface|sizeof|alignof|offsetof|typeof|kindof|countof|dataof|postcopy|postmove|spread|isconstexpr)\\b"
        }
      ]
    },
    "intrinsics-buildin": {
      "patterns": [
        {
          "name": "entity.name.tag",
          "match": "(@)\\b(sqrt|sin|cos|tan|sinh|cosh|tanh|asin|acos|atan|log|log2|log10|floor|ceil|trunc|round|abs|exp|exp2|pow|print|error|assert|assertmsg|alloc|realloc|free|memcpy|memmove|memset|strcmp|memcmp|typecmp|interfaceof|getcontext|setcontext|args|compiler|isbytecode|cstrlen|atomadd|atomand|atomor|atomxor|atomxchg|atomcmpxchg)\\b"
        }
      ]
    },
    "intrinsics-alias": {
      "patterns": [
        {
          "name": "entity.name.function.intrinsic",
          "match": "(@)(alias)([0-9]*)"
        }
      ]
    },
    "intrinsics-literal": {
      "patterns": [
        {
          "name": "keyword.declaration",
          "match": "@"
        }
      ]
    },
    "intrinsics-invalid": {
      "patterns": [
        {
          "name": "invalid",
          "match": "@\\w+"
        }
      ]
    },
    "compiler-function": {
      "patterns": [
        {
          "name": "entity.name.function",
          "match": "(#)\\b(run|test|init|drop|main|compiler|ast)\\b"
        }
      ]
    },
    "compiler-global": {
      "patterns": [
        {
          "name": "constant.character.escape",
          "match": "(#)(global)\\s+(export|foreignlib|generated|if|namespace|public|protected|private|testpass|testerror)\\b",
          "captures": {
            "3": {
              "name": "meta.preprocessor"
            }
          }
        }
      ]
    },
    "compiler-statement": {
      "patterns": [
        {
          "name": "meta.preprocessor",
          "match": "(#)\\b(assert|print|import|mixin|macro|inline|placeholder|if|else|elif|selectif)\\b"
        }
      ]
    },
    "compiler": {
      "patterns": [
        {
          "name": "entity.name.function.intrinsic",
          "match": "(#)\\b(load|defined|scopefct|file|line|hastag|tagval|cfg|arch|os|function|location|callerlocation|callerfunction|swagversion|swagrevision|swagbuildnum|swagos|code)"
        }
      ]
    },
    "compiler-invalid": {
      "patterns": [
        {
          "name": "invalid",
          "match": "(#)\\w+"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type",
          "match": "\\b(code|Self|self|any|void|char|f32|f64|s8|s16|s32|s64|u8|u16|u32|u64|bool|string|typeinfo|uint|int)\\b"
        }
      ]
    },
    "storage-modifier": {
      "patterns": [
        {
          "name": "storage.modifier",
          "match": "\\b(public|private|protected)\\b"
        }
      ]
    },
    "op": {
      "patterns": [
        {
          "name": "entity.name.function.intrinsic",
          "match": "\\b(opSlice|opBinary|opUnary|opAssign|opIndexAssign|opIndexAffect|opCast|opCount|opData|opVisit|opInit|opEquals|opCmp|opPostCopy|opPostMove|opDrop|opCount|opAffect|opIndex|opIndexAssign)\\b"
        },
        {
          "name": "entity.name.function.intrinsic",
          "match": "\\b(opVisit\\w+)\\b"
        }
      ]
    },
    "op-invalid": {
      "patterns": [
        {
          "name": "invalid",
          "match": "\\b(op)[A-Z]\\w*\\b"
        }
      ]
    },
    "constant": {
      "patterns": [
        {
          "name": "constant.language",
          "match": "\\b(true|false|null)\\b"
        }
      ]
    },
    "function-call": {
      "patterns": [
        {
          "match": "([A-Za-z_][A-Za-z_0-9]*)\\s*\\(",
          "captures": {
            "1": {
              "name": "entity.name.function"
            }
          }
        }
      ]
    },
    "function-call1": {
      "patterns": [
        {
          "match": "([A-Za-z_][A-Za-z_0-9]*)\\s*\\b(')\\s*([A-Za-z_][A-Za-z_0-9]*)\\s*\\(",
          "captures": {
            "1": {
              "name": "entity.name.function"
            },
            "3": {
              "name": "entity.name.class"
            }
          }
        }
      ]
    },
    "struct-name": {
      "patterns": [
        {
          "name": "entity.name.class",
          "match": "(\\b[A-Z]\\w*)"
        }
      ]
    },
    "code": {
      "patterns": [
        {
          "name": "source.code",
          "match": "\\b\\w+"
        }
      ]
    },
    "literal-binary": {
      "patterns": [
        {
          "name": "constant.numeric.binary",
          "match": "0b[01][01_]*"
        }
      ]
    },
    "literal-hexa": {
      "patterns": [
        {
          "name": "constant.numeric.hex",
          "match": "0x([[:xdigit:]][[:xdigit:]_]*)((\\.\\g<1>)?[pP][-+]?\\d[\\d_]*)?"
        }
      ]
    },
    "literal-float": {
      "patterns": [
        {
          "name": "constant.numeric.float",
          "match": "(\\d[\\d_]*)(\\.\\g<1>)([eE][-+]?\\g<1>)?"
        },
        {
          "name": "constant.numeric.float",
          "match": "(\\d[\\d_]*)([eE][-+]?\\g<1>)"
        }
      ]
    },
    "literal-integer": {
      "patterns": [
        {
          "name": "constant.numeric.integer",
          "match": "(\\d[\\d_]*)"
        }
      ]
    },
    "raw-strings": {
      "name": "string.quoted.double",
      "begin": "@\"",
      "end": "\"@",
      "patterns": [
        {
          "name": "constant.character.escape",
          "match": ""
        }
      ]
    },
    "strings": {
      "name": "string.quoted.double",
      "begin": "\"",
      "end": "\"",
      "patterns": [
        {
          "name": "constant.character.escape",
          "match": "\\\\."
        }
      ]
    },
    "characters": {
      "patterns": [
        {
          "name": "string.quoted.single",
          "match": "\\'\\w+\\'"
        }
      ]
    },
    "operator-character": {
      "patterns": [
        {
          "name": "keyword.operator",
          "match": "[\\/=\\-+!*%<>&|^~.`'!:]"
        }
      ]
    }
  },
  "scopeName": "source"
}