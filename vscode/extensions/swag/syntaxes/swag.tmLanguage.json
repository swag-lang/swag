{
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json",
  "name": "swag",
  "patterns": [
    { "include": "#one-line-comment" },
    { "include": "#multi-line-comment" },
    { "include": "#attributes" },
    { "include": "#keywords" },
    { "include": "#keywords-control" },
    { "include": "#keywords-decl" },
    { "include": "#intrinsics" },
    { "include": "#intrinsics-buildin" },
    { "include": "#intrinsics-alias" },
    { "include": "#intrinsics-invalid" },
    { "include": "#intrinsics-literal" },
    { "include": "#compiler-function" },
    { "include": "#compiler" },
    { "include": "#compiler-invalid" },
    { "include": "#types" },
    { "include": "#strings" },
    { "include": "#var-decl" },
    { "include": "#storage-modifier" },
    { "include": "#op" },
    { "include": "#op-invalid" },
    { "include": "#constant" },
    { "include": "#function-call" },
    { "include": "#struct-name" },
    { "include": "#literal-binary" },
    { "include": "#literal-hexa" },
    { "include": "#literal-float" },
    { "include": "#literal-integer" },
    { "include": "#characters" },
    { "include": "#operator-character" },
    { "include": "#code" }
  ],
  "repository": {
    "one-line-comment": {
      "patterns": [
        {
          "name": "comment.line",
          "match": "///?(.*)"
        }
      ]
    },
    "multi-line-comment": {
      "name": "comment.line",
      "begin": "/\\*",
      "end": "\\*/",
      "patterns": [
        {
          "name": "comment.line",
          "begin": "/\\*",
          "end": "\\*/"
        }
      ]
    },
    "attributes": {
      "patterns": [
        {
          "name": "entity.name.tag",
          "match": "(#\\[)(\\w+)(.*)(\\])"
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword",
          "match": "\\b(using|is|deref|cast|acast|move|nodrop)\\b"
        }
      ]
    },
    "keywords-control": {
      "patterns": [
        {
          "name": "keyword.control",
          "match": "\\b(if|else|for|while|switch|defer|loop|visit|break|fallthrough|return|case|continue|default|label)\\b"
        }
      ]
    },
    "keywords-decl": {
      "patterns": [
        {
          "name": "keyword.declaration",
          "match": "\\b(enum|struct|impl|interface|func|namespace|alias|attr)\\b"
        }
      ]
    },
    "var-decl": {
      "patterns": [
        {
          "name": "keyword.declaration",
          "match": "\\b(var|let|const)\\b"
        }
      ]
    },
    "intrinsics": {
      "patterns": [
        {
          "name": "entity.name.function.intrinsic",
          "match": "(@)\\b(index|mkslice|mkinterface|sizeof|typeof|kindof|countof|dataof|print|assert|alloc|realloc|free|memcpy|memset|memcmp|getcontext|setcontext|args|target|isbytecode)\\b"
        }
      ]
    },
    "intrinsics-buildin": {
      "patterns": [
        {
          "name": "entity.name.tag",
          "match": "(@)\\b(sqrt|sin|cos|log|log2|log10|floor|ceil|trunc|round|abs)\\b"
        }
      ]
    },
    "intrinsics-alias": {
      "patterns": [
        {
          "name": "entity.name.function.intrinsic",
          "match": "(@)(alias)([0-9]*)"
        }
      ]
    },
    "intrinsics-literal": {
      "patterns": [
        {
          "name": "keyword.declaration",
          "match": "@"
        }
      ]
    },
    "intrinsics-invalid": {
      "patterns": [
        {
          "name": "invalid",
          "match": "@\\w+"
        }
      ]
    },
    "compiler-function": {
      "patterns": [
        {
          "name": "entity.name.function.preprocessor",
          "match": "(#)\\b(run|test|init|drop|main)\\b"
        }
      ]
    },
    "compiler": {
      "patterns": [
        {
          "name": "meta.preprocessor",
          "match": "(#)\\b(ast|skip|module|unittest|assert|print|run|file|line|cfg|target|function|callerfile|callerline|callerfunction|swagversion|swagrevision|swagbuildnum|import|test|init|drop|main|if|else|elif|code|mixin|macro|foreignlib)"
        }
      ]
    },
    "compiler-invalid": {
      "patterns": [
        {
          "name": "invalid",
          "match": "(#)\\w+"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type",
          "match": "\\b(code|Self|self|any|void|char|f32|f64|s8|s16|s32|s64|u8|u16|u32|u64|bool|string)\\b"
        }
      ]
    },
    "storage-modifier": {
      "patterns": [
        {
          "name": "storage.modifier",
          "match": "\\b(public|private|readwrite|readonly|internal)\\b"
        }
      ]
    },
    "op": {
      "patterns": [
        {
          "name": "entity.name.function.op",
          "match": "\\b(opBinary|opUnary|opAssign|opIndexAssign|opIndexAffect|opCast|opCount|opData|opVisit|opInit|opEquals|opCmp|opPostCopy|opPostMove|opDrop|opCount|opAffect|opIndex|opIndexAssign)\\b"
        },
        {
          "name": "entity.name.function.op",
          "match": "\\b(opVisit\\w+)\\b"
        }
      ]
    },
    "op-invalid": {
      "patterns": [
        {
          "name": "invalid",
          "match": "\\b(op\\w+)\\b"
        }
      ]
    },
    "constant": {
      "patterns": [
        {
          "name": "constant.language",
          "match": "\\b(true|false|null)\\b"
        }
      ]
    },
    "function-call": {
      "patterns": [
        {
          "match": "([A-Za-z_][A-Za-z_0-9]*)\\s*\\(",
          "captures": {
            "1": {
              "name": "entity.name.function"
            }
          }
        }
      ]
    },
    "struct-name": {
      "patterns": [
        {
          "name": "entity.name.class",
          "match": "(\\b[A-Z]\\w*)"
        }
      ]
    },
    "code": {
      "patterns": [
        {
          "name": "source.code",
          "match": "\\b\\w+"
        }
      ]
    },
    "literal-binary": {
      "patterns": [
        {
          "name": "constant.numeric.binary",
          "match": "0b[01][01_]*"
        }
      ]
    },
    "literal-hexa": {
      "patterns": [
        {
          "name": "constant.numeric.hex",
          "match": "0x([[:xdigit:]][[:xdigit:]_]*)((\\.\\g<1>)?[pP][-+]?\\d[\\d_]*)?"
        }
      ]
    },
    "literal-float": {
      "patterns": [
        {
          "name": "constant.numeric.float",
          "match": "(\\d[\\d_]*)(\\.\\g<1>)([eE][-+]?\\g<1>)?"
        },
        {
          "name": "constant.numeric.float",
          "match": "(\\d[\\d_]*)([eE][-+]?\\g<1>)"
        }
      ]
    },
    "literal-integer": {
      "patterns": [
        {
          "name": "constant.numeric.integer",
          "match": "(\\d[\\d_]*)"
        }
      ]
    },
    "strings": {
      "name": "string.quoted.double",
      "begin": "\"",
      "end": "\"",
      "patterns": [
        {
          "name": "constant.character.escape",
          "match": "\\\\."
        }
      ]
    },
    "characters": {
      "patterns": [
        {
          "name": "string.quoted.single",
          "match": "\\'\\w+\\'"
        }
      ]
    },
    "operator-character": {
      "patterns": [
        {
          "name": "keyword.operator",
          "match": "[\\/=\\-+!*%<>&|^~.`'!:]"
        }
      ]
    }
  },
  "scopeName": "source"
}