<html lang="en">
<body>

    <style>
    .code {
        background-color: LightYellow;
        border: 1px solid LightGrey;
        margin: 20px;
        padding: 20px;
    }

    .incode {
        background-color: #eeeeee;
        padding: 2px;
        border: 1px dotted #cccc00;
    }

    .linecomment {
        color: Grey;
    }

    .container {
        display:        flex;
        flex-wrap:      nowrap;
        flex-direction: row;
        height:         100%;
        font-family:    arial;
        line-height:    1.3em;
    }

    .left {
        display:    block;
        overflow-y: scroll;
        width:      450;
        height:     100%;
    }

    .right {
        display:     block;
        overflow-y:  scroll;
        width:       100%;
        font-family: arial;
        line-height: 1.3em;
        height:      100%;
    }

    .page {
        width:       1000;
        margin:      0 auto;
    }

    </style>
<div class="container">
<div class="left">
<h1>Table of content</h1>
<ul>
<li><a href="#000_introduction">Introduction</a></li>
<ul>
</ul>
<li><a href="#001_source">Source</a></li>
<ul>
</ul>
<li><a href="#002_comments">Comments</a></li>
<ul>
</ul>
<li><a href="#003_identifiers">Identifiers</a></li>
<ul>
</ul>
<li><a href="#004_keywords">Keywords</a></li>
<ul>
<li><a href="#Basic types">Basic types</a></li>
<li><a href="#Language keywords">Language keywords</a></li>
<li><a href="#Compiler keywords">Compiler keywords</a></li>
<li><a href="#Intrinsics libc">Intrinsics libc</a></li>
<li><a href="#Other intrinsics">Other intrinsics</a></li>
<li><a href="#Modifiers">Modifiers</a></li>
</ul>
<li><a href="#005_semicolon">Semicolon</a></li>
<ul>
</ul>
<li><a href="#006_declaration_order">Declaration order</a></li>
<ul>
</ul>
<li><a href="#010_basic_types">Basic types</a></li>
<ul>
<li><a href="#Type reflection">Type reflection</a></li>
</ul>
<li><a href="#011_number_literals">Number literals</a></li>
<ul>
<li><a href="#Postfix">Postfix</a></li>
</ul>
<li><a href="#012_string">String</a></li>
<ul>
<li><a href="#Escape sequence">Escape sequence</a></li>
<li><a href="#Raw string">Raw string</a></li>
<li><a href="#Multiline string">Multiline string</a></li>
<li><a href="#Character">Character</a></li>
<li><a href="#@stringof and @nameof">@stringof and @nameof</a></li>
</ul>
<li><a href="#013_variables">Variables</a></li>
<ul>
</ul>
<li><a href="#014_const">Const</a></li>
<ul>
</ul>
<li><a href="#015_operators">Operators</a></li>
<ul>
<li><a href="#Binary operators">Binary operators</a></li>
<li><a href="#Affect operators">Affect operators</a></li>
<li><a href="#Unary operators">Unary operators</a></li>
<li><a href="#Comparison operators">Comparison operators</a></li>
<li><a href="#Logical operators">Logical operators</a></li>
<li><a href="#Ternary operator">Ternary operator</a></li>
<li><a href="#Spaceshift operator">Spaceshift operator</a></li>
<li><a href="#Null-coalescing operator">Null-coalescing operator</a></li>
<li><a href="#Type promotion">Type promotion</a></li>
</ul>
<li><a href="#016_cast">Cast</a></li>
<ul>
</ul>
<li><a href="#020_array">Array</a></li>
<ul>
</ul>
<li><a href="#021_slice">Slice</a></li>
<ul>
<li><a href="#The slicing operator">The slicing operator</a></li>
</ul>
<li><a href="#022_pointers">Pointers</a></li>
<ul>
<li><a href="#Single value pointers">Single value pointers</a></li>
<li><a href="#Multiple values pointers">Multiple values pointers</a></li>
</ul>
<li><a href="#023_references">References</a></li>
<ul>
</ul>
<li><a href="#024_any">Any</a></li>
<ul>
</ul>
<li><a href="#025_tuple">Tuple</a></li>
<ul>
<li><a href="#Tuple unpacking">Tuple unpacking</a></li>
</ul>
<li><a href="#030_enum">Enum</a></li>
<ul>
<li><a href="#Enum as flags">Enum as flags</a></li>
<li><a href="#Enum of arrays">Enum of arrays</a></li>
<li><a href="#Enum of slices">Enum of slices</a></li>
<li><a href="#Enum type inference">Enum type inference</a></li>
</ul>
<li><a href="#031_impl">Impl</a></li>
<ul>
</ul>
<li><a href="#035_namespace">Namespace</a></li>
<ul>
</ul>
<li><a href="#050_if">If</a></li>
<ul>
</ul>
<li><a href="#051_loop">Loop</a></li>
<ul>
</ul>
<li><a href="#052_visit">Visit</a></li>
<ul>
</ul>
<li><a href="#053_for">For</a></li>
<ul>
</ul>
<li><a href="#054_while">While</a></li>
<ul>
</ul>
<li><a href="#055_switch">Switch</a></li>
<ul>
</ul>
<li><a href="#056_break">Break</a></li>
<ul>
</ul>
<li><a href="#060_struct">Struct</a></li>
<ul>
</ul>
<ul>
<li><a href="#061__declaration">Declaration</a></li>
<ul>
</ul>
<li><a href="#062__impl">Impl</a></li>
<ul>
</ul>
<li><a href="#063__special_functions">Special functions</a></li>
<ul>
</ul>
<li><a href="#064__affectation">Affectation</a></li>
<ul>
</ul>
<li><a href="#064__count">Count</a></li>
<ul>
</ul>
<li><a href="#064__post_copy_and_post_move">Post copy and post move</a></li>
<ul>
</ul>
<li><a href="#064__visit">Visit</a></li>
<ul>
</ul>
<li><a href="#067__offset">Offset</a></li>
<ul>
</ul>
<li><a href="#068__packing">Packing</a></li>
<ul>
</ul>
</ul>
<li><a href="#070_union">Union</a></li>
<ul>
</ul>
<li><a href="#075_interface">Interface</a></li>
<ul>
</ul>
<li><a href="#080_safety">Safety</a></li>
<ul>
<li><a href="##[Swag.Safety("overflow", true)]">#[Swag.Safety("overflow", true)]</a></li>
<li><a href="##[Swag.Safety("any", true)]">#[Swag.Safety("any", true)]</a></li>
<li><a href="##[Swag.Safety("boundcheck", true)]">#[Swag.Safety("boundcheck", true)]</a></li>
<li><a href="##[Swag.Safety("math", true)]">#[Swag.Safety("math", true)]</a></li>
<li><a href="##[Swag.Safety("switch", true)]">#[Swag.Safety("switch", true)]</a></li>
<li><a href="##[Swag.Safety("bool", true)]">#[Swag.Safety("bool", true)]</a></li>
<li><a href="##[Swag.Safety("nan", true)]">#[Swag.Safety("nan", true)]</a></li>
</ul>
<li><a href="#100_function">Function</a></li>
<ul>
</ul>
<ul>
<li><a href="#101__declaration">Declaration</a></li>
<ul>
<li><a href="#Multiple return values">Multiple return values</a></li>
</ul>
<li><a href="#102__lambda">Lambda</a></li>
<ul>
<li><a href="#Anonymous functions">Anonymous functions</a></li>
</ul>
<li><a href="#103__closure">Closure</a></li>
<ul>
</ul>
<li><a href="#104__mixin">Mixin</a></li>
<ul>
</ul>
<li><a href="#105__macro">Macro</a></li>
<ul>
</ul>
<li><a href="#105__variadic_parameters">Variadic parameters</a></li>
<ul>
</ul>
<li><a href="#106__ufcs">Ufcs</a></li>
<ul>
</ul>
<li><a href="#107__constexpr">Constexpr</a></li>
<ul>
</ul>
<li><a href="#108__function_overloading">Function overloading</a></li>
<ul>
</ul>
<li><a href="#109__discard">Discard</a></li>
<ul>
</ul>
<li><a href="#110__retval">Retval</a></li>
<ul>
</ul>
<li><a href="#111__foreign">Foreign</a></li>
<ul>
</ul>
</ul>
<li><a href="#120_compiler_intrinsics">Compiler intrinsics</a></li>
<ul>
<li><a href="#Base">Base</a></li>
<li><a href="#Buildin">Buildin</a></li>
<li><a href="#Memory related">Memory related</a></li>
<li><a href="#Atomic operations">Atomic operations</a></li>
<li><a href="#Math">Math</a></li>
</ul>
<li><a href="#121_init">Init</a></li>
<ul>
<li><a href="#@init">@init</a></li>
<li><a href="#@drop">@drop</a></li>
</ul>
<li><a href="#130_generic">Generic</a></li>
<ul>
</ul>
<ul>
<li><a href="#131__declaration">Declaration</a></li>
<ul>
</ul>
<li><a href="#132__validif">Validif</a></li>
<ul>
<li><a href="#One time evaluation">One time evaluation</a></li>
<li><a href="#Multiple evaluations">Multiple evaluations</a></li>
</ul>
<li><a href="#133__constraint">Constraint</a></li>
<ul>
</ul>
</ul>
<li><a href="#160_defer">Defer</a></li>
<ul>
</ul>
<li><a href="#161_using">Using</a></li>
<ul>
<li><a href="#For a function parameter">For a function parameter</a></li>
<li><a href="#For a field">For a field</a></li>
</ul>
<li><a href="#162_with">With</a></li>
<ul>
</ul>
<li><a href="#163_alias">Alias</a></li>
<ul>
</ul>
<li><a href="#170_error">Error</a></li>
<ul>
</ul>
<li><a href="#180_compiler_declarations">Compiler declarations</a></li>
<ul>
</ul>
<ul>
<li><a href="#181__compile_time_evaluation">Compile time evaluation</a></li>
<ul>
</ul>
<li><a href="#182__special_functions">Special functions</a></li>
<ul>
<li><a href="##test">#test</a></li>
<li><a href="##main">#main</a></li>
<li><a href="##init">#init</a></li>
<li><a href="##drop">#drop</a></li>
<li><a href="##premain">#premain</a></li>
</ul>
<li><a href="#183__run">Run</a></li>
<ul>
</ul>
<li><a href="#184__global">Global</a></li>
<ul>
</ul>
<li><a href="#185__var">Var</a></li>
<ul>
</ul>
</ul>
<li><a href="#190_attributes">Attributes</a></li>
<ul>
</ul>
<ul>
<li><a href="#191__user_attributes">User attributes</a></li>
<ul>
</ul>
<li><a href="#192__predefined_attributes">Predefined attributes</a></li>
<ul>
</ul>
</ul>
<li><a href="#200_type_reflection">Type reflection</a></li>
<ul>
<li><a href="#@decltype">@decltype</a></li>
</ul>
<li><a href="#210_code_inspection">Code inspection</a></li>
<ul>
</ul>
<li><a href="#220_meta_programmation">Meta programmation</a></li>
<ul>
</ul>
<ul>
<li><a href="#221__ast">Ast</a></li>
<ul>
<li><a href="#Struct and enums">Struct and enums</a></li>
<li><a href="#For example">For example</a></li>
<li><a href="#At global scope">At global scope</a></li>
</ul>
<li><a href="#222__compiler_interface">Compiler interface</a></li>
<ul>
</ul>
</ul>
</div>
<div class="right">
<div class="page">
<h1>Swag language reference</h1>

<h2 id="000_introduction">Introduction</h2>
<div>This <code class="incode">swag-lang/swag/bin/reference/language</code> module provides a brief explanation of the language basic syntax and usage without the need of the <b>Swag standard libraries</b> (<code class="incode">Std</code>).</br>
</br>
More advanced features such as dynamic arrays, dynamic strings or hash maps can be found in the <code class="incode">Std.Core</code> module and will not be covered in the examples to come. For now we will focus on the language itself.</br>
</br>
As <code class="incode">reference/language</code> is written as a test module, you can run it with :</br>
</div>
<div class="code"><code style="white-space: break-spaces">swag test --workspace:c:/swag-lang/swag/bin/reference
swag test -w:c:/swag-lang/swag/bin/reference
</code></div><div>This will run all the test modules of the specified workspace (including this one). You can also omit the <code class="incode">--workspace</code> parameter (or <code class="incode">-w</code> in its short form) if you run Swag directly from the workspace folder.</br>
</br>
If you want to compile and run a single module in the workspace, you can specify it with the <code class="incode">--module</code> (<code class="incode">-m</code>) parameter.</br>
</div>
<div class="code"><code style="white-space: break-spaces">swag test -w:c:/swag-lang/swag/bin/reference -m:test_language
</code></div><div>Note that as this is a test module, its name is prefixed with <code class="incode">test_</code>.</br>
</div>

<h2 id="001_source">Source</h2>
<div>All source files in Swag have the <code class="incode">.swg</code> extension, except if you write a simple script with the <code class="incode">.swgs</code> extension.</br>
They must be encoded in <b>UTF8</b>.</br>
</br>
In Swag you cannot compile a single file (with the exception of <code class="incode">.swgs</code> script files). The source code is organized in a <b>workspace</b> which contains one or multiple <b>modules</b>.</br>
</br>
For example, the Swag standard library is a collection of modules in the <code class="incode">Std</code> workspace.</br>
</br>
A module is a <code class="incode">dll</code> (under windows) or an executable, and a workspace can include many of them. So a workspace will contain the modules you write (like your main executable) but also all your dependencies (some external modules you use).Typically, the entire workspace is compiled.</br>
</div>

<h2 id="002_comments">Comments</h2>
<div>Let's start with the basics. Swag support classical single-line and multi-line comments.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Single-line comment</span>

/*
    Multi-line comment on...
    ... multiple lines
*/

const A = 0 // This is a constant with the value '0' assigned to it
const B = /* false */ true
</code></div><div>Nested comments are supported.</br>
</div>
<div class="code"><code style="white-space: break-spaces">/*
    /* You can also nest multi-line comments */
*/
</code></div>
<h2 id="003_identifiers">Identifiers</h2>
<div>User identifiers (like variables, constants, function names...) must start with an underscore or an ascii letter. Those identifiers can then contain underscores, ascii letters and digit numbers.</br>
</div>
<div class="code"><code style="white-space: break-spaces">const thisIsAValidIdentifier0   = 0
const this_is_also_valid        = 0
const this_1_is_2_also__3_valid = 0
</code></div><div>But your identifiers cannot start with two underscores. This is reserved by the compiler.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// const __this_is_invalid = 0</span>
</code></div><div>Note that some identifiers may start with <code class="incode">#</code>. This indicates a <b>compiler special keyword</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#assert
#run
#main
</code></div><div></br>
Some identifiers can also start with <code class="incode">@</code>. This indicates an <b>intrinsic</b> function.</br>
</div>
<div class="code"><code style="white-space: break-spaces">@min()
@max()
@sqrt()
</code></div>
<h2 id="004_keywords">Keywords</h2>
<div>This is the list of all keywords in the language.</br>
</br>
<h3 id="Basic types">Basic types</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">s8
s16
s32
s64
u8
u16
u32
u64
f32
f64
bool
string
rune
any
typeinfo
void
code
cstring
cvarargs
</code></div><div><h3 id="Language keywords">Language keywords</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">if
else
elif
and
or
switch
case
default
break
continue
fallthrough
unreachable
for
loop
while
visit
return
defer

false
true
null
undefined
retval

const
var
ref
acast
cast
assume
try
catch
throw
closure
func
attr
enum
struct
union
namespace
impl
private
public
interface
using
alias
discard
dref
</code></div><div><h3 id="Compiler keywords">Compiler keywords</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">#arch
#backend
#callerfunction
#callerlocation
#cfg
#code
#file
#line
#location
#module
#os
#self
#swagbuildnum
#swagos
#swagrevision
#swagversion
#type
#up

#assert
#elif
#else
#error
#global
#if
#import
#include
#load
#macro
#mixin
#placeholder
#print
#validifx
#validif
#warning
#scope
#scopefile

#ast
#drop
#init
#main
#message
#premain
#run
</code></div><div><h3 id="Intrinsics libc">Intrinsics libc</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">@abs
@acos
@alloc
@asin
@atan
@atomadd
@atomand
@atomcmpxchg
@atomor
@atomxchg
@atomxor
@bitcountlz
@bitcountnz
@bitcounttz
@byteswap
@ceil
@cos
@cosh
@cvaarg
@cvaend
@cvastart
@exp
@exp2
@floor
@free
@log
@log10
@log2
@max
@memcmp
@memcpy
@memmove
@memset
@muladd
@min
@pow
@realloc
@round
@sin
@sinh
@sqrt
@strcmp
@strlen
@tan
@tanh
@trunc
</code></div><div><h3 id="Other intrinsics">Other intrinsics</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">@index
@err
@alias0
@alias1
@alias2 and more generally @alias<N>
@alignof
@args
@assert
@breakpoint
@compiler
@countof
@dataof
@dbgalloc
@defined
@drop
@compilererror
@compilerwarning
@getcontext
@getpinfos
@gettag
@hastag
@init
@interfaceof
@isbytecode
@isconstexpr
@itftableof
@kindof
@location
@mixin0
@mixin1
@mixin2 and more generally @mixinN
@mkany
@mkcallback
@mkinterface
@mkslice
@mkstring
@decltype
@modules
@nameof
@offsetof
@panic
@postcopy
@postmove
@print
@rtflags
@safety
@setcontext
@sizeof
@spread
@stringcmp
@stringof
@sysalloc
@typecmp
@typeof
</code></div><div><h3 id="Modifiers">Modifiers</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">,over
,nodrop
,bit
,move
,moveraw
</code></div>
<h2 id="005_semicolon">Semicolon</h2>
<div>In Swag, there's no need to end a statement with <code class="incode">;</code> like in C/C++. Most of the time a <code class="incode">end of line</code> is enough.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Declare two variables x and y of type s32 (signed 32 bits), and initialize them to 1.</span>
var x, y: s32 = 1

<span class="linecomment">// Increment x and y by 1.</span>
x += 1
y += 1

<span class="linecomment">// When running the tests, @assert will verify that those values are correct.</span>
@assert(x == 2)     // Verify that x is equal to 2, and raise an error if not.
@assert(y == x)     // Verify that y is equal to x.
</code></div><div>The semicolons are not mandatory, but it's possible to use them if you want.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// You can notice that the type of x and y is not specified here. This is due to type inference (we will see that later).</span>
var x, y = 0;

<span class="linecomment">// You can also notice the short syntax to do the same operation on multiple variables at once.</span>
x, y += 1;
</code></div><div>Semicolons can be usefull if you want to do multiple things on the same line.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var x = 0; var y = 0
x += 1; y += 1

<span class="linecomment">// Two instructions on the same line separated with ';'</span>
@assert(x == 1); @assert(y == 1)
</code></div>
<h2 id="006_declaration_order">Declaration order</h2>
<div>The order of all <b>top level</b> declarations does not matter.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Here we declare a constant 'A' and initialize it with 'B', which is not yet known (neither its value or its type).</span>
const A = B
<span class="linecomment">// Declare a constant 'B' equals to 'C', still unknown at this point.</span>
const B = C
<span class="linecomment">// Declare a constant C of type 'u64' (unsigned 64 bits integer) and assigned it to 1.</span>
<span class="linecomment">// At this point A and B are then also defined.</span>
const C: u64 = 1
</code></div><div>In this test, we call the function <code class="incode">functionDeclaredLater</code> before it is known. This is fine.</br>
</div>
<div class="code"><code style="white-space: break-spaces">functionDeclaredLater()
</code></div><div class="code"><code style="white-space: break-spaces">func functionDeclaredLater()
{
}
</code></div><div>Note that the order is not relevant in the same file, but it is also irrelevant across multiple files. You can for example call a function in one file and declare it in another one. Ordrer does not matter !</br>
</div>

<h2 id="010_basic_types">Basic types</h2>
<div>
</br>
 These are all signed integers types <code class="incode">s8</code>, <code class="incode">s16</code>, <code class="incode">s32</code> and <code class="incode">s64</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: s8 = -1      // 8 bits signed integer
    var b: s16 = -2     // 16 bits signed integer
    var c: s32 = -3     // 32 bits signed integer
    var d: s64 = -4     // 64 bits signed integer

<span class="linecomment">    // Remember that the instrinsic '@assert' will raise an error at runtime if the enclosed expression is false.</span>
    @assert(a == -1)
    @assert(b == -2)
    @assert(c == -3)
    @assert(d == -4)

<span class="linecomment">    // The instrinsic '@sizeof' gives the size, in bytes, of a variable.</span>
    @assert(@sizeof(a) == 1)    // 'a' has type 's8', so this should be 1 byte.
    @assert(@sizeof(b) == 2)    // 'b' has type 's16', so this should be 2 bytes.
    @assert(@sizeof(c) == 4)
    @assert(@sizeof(d) == 8)
}
</code></div><div>
</br>
 These are all unsigned integers types <code class="incode">u8</code>, <code class="incode">u16</code>, <code class="incode">u32</code> and <code class="incode">u64</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: u8 = 1       // 8 bits unsigned integer
    var b: u16 = 2      // 16 bits unsigned integer
    var c: u32 = 3      // 32 bits unsigned integer
    var d: u64 = 4      // 64 bits unsigned integer

    @assert(a == 1)
    @assert(b == 2)
    @assert(c == 3)
    @assert(d == 4)

    @assert(@sizeof(a) == 1)
    @assert(@sizeof(b) == 2)
    @assert(@sizeof(c) == 4)
    @assert(@sizeof(d) == 8)
}
</code></div><div>
</br>
 These are all floating point types <code class="incode">f32</code> and <code class="incode">f64</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: f32 = 3.14       // 32 bits floating point value
    var b: f64 = 3.14159    // 64 bits floating point value

    @assert(a == 3.14)
    @assert(b == 3.14159)

    @assert(@sizeof(a) == 4)
    @assert(@sizeof(b) == 8)
}
</code></div><div>
</br>
 The boolean type <code class="incode">bool</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: bool = true      // Stored in 1 byte
    var b: bool = false     // Stored in 1 byte

    @assert(a == true)
    @assert(b == false)

    @assert(@sizeof(a) == 1)
    @assert(@sizeof(b) == 1)
}
</code></div><div>
</br>
 The <code class="incode">string</code> type. Strings are <b>UTF8</b>, and are stored as two 64 bits (the pointer to the value and the string length in bytes). Note that a string literal ends with a null character like in C.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: string = "string 是"
    @assert(a == "string 是")
    @assert(@sizeof(a) == 2 * @sizeof(*void))
}
</code></div><div>
</br>
 The <code class="incode">rune</code> type uses the string syntax, postfix with the type <code class="incode">rune</code>. It's a 32 bits unicode code point.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: rune = "是"'rune
    @assert(a == "是"'rune)
    @assert(@sizeof(a) == 4)
}
</code></div><div><h3 id="Type reflection">Type reflection</br>
</h3>Swag has <b>type reflection</b> at <b>compile time</b> and at <b>runtime</b>. We will see that later in more details.</br>
</div>
<div>
</br>
 You can use <code class="incode">@decltype</code> to create a type based on an expression.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a = 0                   // 'a' is inferred to have the 's32' type
    var b: @decltype(a) = 1     // 'b' will have the same type as 'a'

<span class="linecomment">    // We can verify with '@typeof' that 'a' and 'b' have the same type.</span>
    @assert(@typeof(a) == @typeof(b))
    @assert(@typeof(a) == s32)

<span class="linecomment">    // As the types of 'a' and 'b' are known by the compiler, we can use '#assert' instead of '@assert'.</span>
<span class="linecomment">    // The '#assert' will be done at compile time, and will not generate code (unlike '@assert').</span>
    #assert @typeof(a) == @typeof(b)
    #assert @typeof(a) == s32
}
</code></div><div>
</br>
 Short notice that types are also values, at compile time and at runtime.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := @typeof(s32)   // 'x' is now a variable that contains a type
    @assert(x == s32)   // So it can be compared to a type

<span class="linecomment">    // A type is a predefined struct, which contains some fields to inspect it.</span>
<span class="linecomment">    // You can for example get the name.</span>
    @assert(x.name == "s32")

<span class="linecomment">    // @typeof is not really necessary when there's no ambiguity about the expression.</span>
    y := bool
    @assert(y == bool)
}
</code></div>
<h2 id="011_number_literals">Number literals</h2>
<div>
</br>
 Integers in <i>decimal</i>, <i>hexadecimal</i> or <i>binary</i> forms.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a: u32 = 123456           // Decimal
    const b: u32 = 0xFFFF           // Hexadecimal, with '0x'
    const c: u32 = 0b00001111       // Binary, with '0b'
    @assert(a == 123456)
    @assert(b == 65535)
    @assert(c == 15)
}
</code></div><div>
</br>
 You can separate the digits with the <code class="incode">_</code> character.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a: u32 = 123_456
    const b: u32 = 0xF_F_F_F
    const c: u32 = 0b0000_1111
    @assert(a == 123456)
    @assert(b == 65_535)
    @assert(c == 15)
}
</code></div><div>
</br>
 The default type of an hexadecimal number or a binary number is <code class="incode">u32</code> or <code class="incode">u64</code> depending on its value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
<span class="linecomment">    // The compiler will deduce that the type of 'a' is 'u32'.</span>
    const a = 0xFF
    #assert @typeof(a) == u32

<span class="linecomment">    // The compiler will deduce that the type of 'b' is 'u64' because the constant is too big for 32 bits.</span>
    const b = 0xF_FFFFF_FFFFFF
    #assert @typeof(b) == u64

    const c = 0b00000001
    #assert @typeof(c) == u32
    const d = 0b00000001_00000001_00000001_00000001_00000001
    #assert @typeof(d) == u64
}
</code></div><div>
</br>
 A boolean is <code class="incode">true</code> or <code class="incode">false</code>. Note again that as constants are known at compile time, we can  use <code class="incode">#assert</code> to check the values.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = true
    #assert a == true

    const b, c = false
    #assert b == false
    #assert c == false
}
</code></div><div>
</br>
 A floating point value has the usual C/C++ form.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a = 1.5
    @assert(a == 1.5)
    #assert @typeof(a) == f32

    var b = 0.11
    @assert(b == 0.11)

    var c = 15e2
    @assert(c == 15e2)

    var d = 15e+2
    @assert(d == 15e2)

    var e = -1E-1
    @assert(e == -0.1)
}
</code></div><div>
</br>
 By default, a floating point value is <code class="incode">f32</code>, not <code class="incode">f64</code> (aka <code class="incode">double</code>) like in C/C++.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a = 1.5
    @assert(a == 1.5)
    #assert @typeof(a) == f32
    #assert @typeof(a) != f64
}
</code></div><div><h3 id="Postfix">Postfix</br>
</h3>You can also <b>postfix</b> a literal number by a type.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Declare 'a' to be a 'f64' variable assigned to '1.5'</span>
var a = 1.5'f64
@assert(a == 1.5)
@assert(a == 1.5'f64)
#assert @typeof(a) == f64

<span class="linecomment">// Here we have the first usage of the 'short declaration form' with ':='.</span>
<span class="linecomment">// 'b' is a new variable of type 'u8' initialized with '10'.</span>
b := 10'u8
@assert(b == 10)
#assert @typeof(b) == u8

c := 1'u32
#assert @typeof(c) == u32
</code></div>
<h2 id="012_string">String</h2>
<div>In Swag, strings are encoded in UTF8.</br>
</div>
<div>
</br>
 They also can be compared.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = "this is a chinese character: 是"
    #assert a == "this is a chinese character: 是"

    const b = "this are some cyrillic characters: ӜИ"
    #assert b == "this are some cyrillic characters: ӜИ"
}
</code></div><div>
</br>
 A rune is an unicode codepoint, and is 32 bits.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = "是"'rune
    #assert a == "是"'rune
    #assert @sizeof(a) == @sizeof(u32)
}
</code></div><div>You cannot index a string to get a rune, except in ascii strings. This is because we didn't want the runtime to come with the cost of UTF8 encoding/decoding. But note that the <code class="incode">Std.Core</code> module will have all you need to manipulate UTF8 strings.</br>
</div>
<div>
</br>
 So in that case you will retrieve a byte.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = "this is a chinese character: 是"

<span class="linecomment">    // Get the first byte of the string</span>
    const b = a[0]
    #assert b == "t"'u8
    #assert @typeof(b) == @typeof(u8)

<span class="linecomment">    // Here, the 'X' character in the middle does not have the index '1', because the chinese character before is</span>
<span class="linecomment">    // encoded in UTF8 with more than 1 byte.</span>
    const c = "是X是"
    #assert c[1] != "X"'u8 // False because the byte number 1 is not the character 'X'
}
</code></div><div>Multiple adjacent strings are compiled as one.</br>
</div>
<div class="code"><code style="white-space: break-spaces">const a = "this is "   "a"   " string"
#assert a == "this is a string"
</code></div><div>You can concatenate some values if the values are known at compile time. Use the <code class="incode">++</code> operator for that.</br>
</div>
<div class="code"><code style="white-space: break-spaces">const a = "the devil number is " ++ 666
#assert a == "the devil number is 666"

const b = 666
var c = "the devil number is not " ++ (b + 1) ++ "!"
@assert(c == "the devil number is not 667!")

var d = "they are " ++ 4 ++ " apples in " ++ (2*2) ++ " baskets"
@assert(d == "they are 4 apples in 4 baskets")
</code></div><div>A string can be <code class="incode">null</code> if not defined.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var a: string
@assert(a == null)
a = "null"
@assert(a != null)
a = null
@assert(a == null)
</code></div><div><h3 id="Escape sequence">Escape sequence</br>
</h3>A string and a rune can contain some <i>escape sequences</i> to specify special characters.</br>
</div>
<div>
</br>
 An escape sequence starts with <code class="incode">\</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = "this is code ascii 0x00:   \0"
    const b = "this is code ascii 0x07:   \a"
    const c = "this is code ascii 0x08:   \b"
    const d = "this is code ascii 0x09:   \t"
    const e = "this is code ascii 0x0A:   \n"
    const f = "this is code ascii 0x0B:   \v"
    const g = "this is code ascii 0x0C:   \f"
    const h = "this is code ascii 0x0D:   \r"
    const i = "this is code ascii 0x22:   \""
    const j = "this is code ascii 0x27:   \'"
    const k = "this is code ascii 0x5C:   \\"
}
</code></div><div>
</br>
 An escape sequence can also be used to specify an ascii or a unicode value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = "\x26"        // 1 byte, hexadecimal, extended ascii
    const b = "\u2626"      // 2 bytes, hexadecimal, unicode 16 bits
    const c = "\U26262626"  // 4 bytes, hexadecimal, unicode 32 bits

    const d = "\u2F46"
    #assert d == "⽆"
}
</code></div><div><h3 id="Raw string">Raw string</br>
</h3>A <i>raw string</i> does not transform the escape sequences inside it.</br>
</div>
<div>
</br>
 A raw string starts and ends with the character <code class="incode">@</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = @"\u2F46"@
    #assert a != "⽆"
    #assert a == @"\u2F46"@
}
</code></div><div>
</br>
 A raw string can be declared on several lines because <code class="incode">eol</code> is now part of the string.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = @"this is
                a
                string
                "@

<span class="linecomment">    // Every blanks before the ending mark `"@` will be removed from every other lines, so the string before is equivalent to :</span>
<span class="linecomment">    //</span>
<span class="linecomment">    // this is</span>
<span class="linecomment">    // a</span>
<span class="linecomment">    // string</span>
}
</code></div><div><h3 id="Multiline string">Multiline string</br>
</h3>A multiline string starts and ends with <code class="incode">"""</code>. Unlike raw strings, they still evaluate escape sequences.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = """this is
                 a
                 string
                 """

<span class="linecomment">    // Equivalent to :</span>
<span class="linecomment">    // this is</span>
<span class="linecomment">    // a</span>
<span class="linecomment">    // string</span>
}
</code></div><div>
</br>
 In a multiline or a raw string, if you end a line with <code class="incode">\</code>, the following <eol> will <b>not</b> be part of the string.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a = """\
                 this is
                 a
                 string
                 """
<span class="linecomment">    // Is equivalent to :</span>
<span class="linecomment">    // this is</span>
<span class="linecomment">    // a</span>
<span class="linecomment">    // string</span>
}
</code></div><div><h3 id="Character">Character</br>
</h3>A single <i>character</i> can be casted to every unsigned integer type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a = "0"'u8
    @assert(a == 48)
    @assert(@typeof(a)== @typeof(u8))

    var b = "1"'u16
    @assert(b == 49)
    @assert(@typeof(b)== @typeof(u16))

    var c = "2"'u32
    @assert(c == 50)
    @assert(@typeof(c)== @typeof(u32))

    var d = "3"'u64
    @assert(d == 51)
    @assert(@typeof(d)== @typeof(u64))

    var e = "4"'rune
    @assert(e == 52)
    @assert(@typeof(e)== @typeof(rune))
}
</code></div><div><h3 id="@stringof and @nameof">@stringof and @nameof</br>
</h3>You can use the instrinsic <code class="incode">@stringof</code> to return at compile time the result of a constant expression as a string.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const X = 1
    #assert @stringof(X) == "1"
    #assert @stringof(X + 10) == "11"
}
</code></div><div>
</br>
 You can also use <code class="incode">@nameof</code> to return the name of a variable, function etc.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const X = 1
    #assert @nameof(X) == "X"
}
</code></div>
<h2 id="013_variables">Variables</h2>
<div>To declare a variable, use the <code class="incode">var</code> keyword, followed by <code class="incode">:</code> and then the type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
<span class="linecomment">    // Variable 'a' is of type 'u32' and its value is '1'.</span>
    var a: u32 = 1
    @assert(a == 1)

    var b: string = "string"
    @assert(b == "string")
}
</code></div><div>
</br>
 We have already seen that we can declare multiple variables on the same line.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a, b: u32 = 123
    @assert(a == 123)
    @assert(b == 123)
}
</code></div><div>
</br>
 Or</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: u32 = 12, b: f32 = 1.5
    @assert(a == 12)
    @assert(b == 1.5)
}
</code></div><div>If you don't assign a value, then the variable will be initialized with its default value (0). So a variable is <b>always</b> initialized.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var a: bool
@assert(a == false)

var b: string
@assert(b == null)

var c: f64
@assert(c == 0)
</code></div><div>But if you really do not want the variable to be initialized, you can assign it with <code class="incode">undefined</code>. To use with care, of course, but this is sometimes necessary to avoid the initialization cost.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var a: bool = undefined
var b: string = undefined
</code></div><div>We have seen that the type is optional in the declaration if it can be deduced from the assignment.</br>
</div>
<div>
</br>
 These are a bunch of <b>type inferences</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a = 1.5
    @assert(a == 1.5)
    #assert @typeof(a) == f32

    var b = "string"
    @assert(b == "string")
    #assert @typeof(b) == string

    var c = 1.5'f64
    @assert(c == 1.5)
    #assert @typeof(c) == f64
}
</code></div><div>
</br>
 The same goes for multiple variables.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a, b = true
    @assert(a == true)
    @assert(b == true)
    #assert @typeof(a) == @typeof(true)
    #assert @typeof(b) == @typeof(a)

    var c = 1.5, d = "string"
    @assert(c == 1.5)
    @assert(d == "string")
    #assert @typeof(c) == f32
    #assert @typeof(d) == string
}
</code></div><div>And in fact even <code class="incode">var</code> is optional if you use the short form with <code class="incode">:=</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">a := 1.5
@assert(a == 1.5)
#assert @typeof(a) == f32

b := "string"
@assert(b == "string")
#assert @typeof(b) == string

c := 1.5'f64
@assert(c == 1.5)
#assert @typeof(c) == f64
</code></div>
<h2 id="014_const">Const</h2>
<div>If you use <code class="incode">const</code> instead of <code class="incode">var</code>, the value must be known by the compiler. There's no memory footprint if the type is a value or a string.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// This are constants and not variables. So they cannot be changed after the declaration.</span>
const a = 666
#assert a == 666

const b: string = "string"
#assert b == "string"
</code></div><div>Constants can have more than just simple types. In that case, there's a memory footprint, because those constants are stored in the data segment. But that means also you could take the address of such constants at runtime.</br>
</div>
<div>
</br>
 This is our first static array. It contains '3' elements, and the type of the elements is <code class="incode">s32</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const a: [3] s32 = [0, 1, 2]

    ptr := &a[0] // Take the address of the first element
    @assert(ptr[0] == 0)
    @assert(ptr[2] == 2)

<span class="linecomment">    // But as this is a constant, we can also test the values at compile time.</span>
    #assert a[0] == 0
    #assert a[1] == 1
    #assert a[2] == 2
}
</code></div><div>
</br>
 An example of a multidimensional array as a constant. We will detail arrays later.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const M4x4: [4, 4] f32 = [
        [1, 0, 0, 0],
        [0, 1, 0, 0],
        [0, 0, 1, 0],
        [0, 0, 0, 1]
    ]
}
</code></div>
<h2 id="015_operators">Operators</h2>
<div>These are the basic operators that can be used to manipulate values.</br>
</div>
<div>
</br>
<h3 id="Binary operators">Binary operators</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">{
    var x: s32 = 10

    x = x + 1
    x = x - 1
    x = x * 2
    x = x / 2
    x = x % 2 // Modulo
    x = x ^ 2 // Xor
    x = x & 0b0000_0001's32 // Bitmask and
    x = x | cast(s32) 0b0000_0001 // Bitmask or
    x = x << 1 // Shift bits left
    x = x >> 1 // Shift bits right
}
</code></div><div>
</br>
<h3 id="Affect operators">Affect operators</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">{
    var x: s32 = 10

    x += 1
    x -= 1
    x *= 2
    x /= 2
    x %= 2
    x ^= 2
    x |= 0b0000_0001's32
    x &= cast(s32) 0b0000_0001
    x <<= 1
    x >>= 1
}
</code></div><div>
</br>
<h3 id="Unary operators">Unary operators</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">{
    x := true
    x = !x      // Invert boolean
    @assert(x == false)

    y := 0b0000_0001'u8
    y = ~y      // Invert bits
    @assert(y == 0b1111_1110)

    z := 1
    z = -z      // Negative
    @assert(z == -1)
}
</code></div><div>
</br>
<h3 id="Comparison operators">Comparison operators</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">{
    a := false

    a = 1 == 1 ? true : false
    a = 1 != 1 ? true : false
    a = 1 <= 1 ? true : false
    a = 1 >= 1 ? true : false
    a = 1 < 1 ? true : false
    a = 1 > 1 ? true : false
}

{
    x := 5
    y := 10
    @assert(x == 5)
    @assert(x != 10)
    @assert(x <= 5)
    @assert(x < 10)
    @assert(x >= 5)
    @assert(x > 0)
}
</code></div><div><h3 id="Logical operators">Logical operators</br>
</h3>This is <b>not</b> <code class="incode">&&</code> and <code class="incode">||</code> like in C/C++, but <code class="incode">and</code> and <code class="incode">or</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">a := false
a = (1 > 10) and (10 < 1)
a = (1 > 10) or (10 < 1)
</code></div><div><h3 id="Ternary operator">Ternary operator</br>
</h3>The ternary operator will test an expression, and will return a value depending on the result of the test.</br>
<code class="incode">A = Expression ? B : C</code> will return <code class="incode">B</code> if the expression is true, and will return <code class="incode">C</code> if the expression is false.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Returns 1 because the expression 'true' is... true.</span>
var x = true ? 1 : 666
@assert(x == 1)

<span class="linecomment">// Returns 666 because the expression 'x == 52' is false.</span>
var y = (x == 52) ? 1 : 666
@assert(y == 666)
</code></div><div><h3 id="Spaceshift operator">Spaceshift operator</br>
</h3>Operator <code class="incode"><=></code> will return -1, 0 or 1 if the expression on the left is lower, equal or greater than the expression on the right. The returned type is <code class="incode">s32</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">A <=> B == -1 if A < B
A <=> B == 0  if A == B
A <=> B == 1  if A > B
</code></div><div class="code"><code style="white-space: break-spaces">{
    a := -1.5 <=> 2.31
    #assert @typeof(a) == s32
    @assert(a == -1)

    @assert(-10 <=>  10 == -1)
    @assert( 10 <=> -10 == 1)
    @assert( 10 <=>  10 == 0)
}

{
    x1 := 10 <=> 20
    @assert(x1 == -1)
    x2 := 20 <=> 10
    @assert(x2 == 1)
    x3 := 20 <=> 20
    @assert(x3 == 0)
}
</code></div><div><h3 id="Null-coalescing operator">Null-coalescing operator</br>
</h3>The operator <code class="incode">orelse</code> will return the left expression if it is not zero, otherwise it will return the right expression.</br>
</div>
<div>
</br>
 Works with strings, pointers and structures with the <code class="incode">opData</code> special function (we'll see that later).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    a := "string1"
    b := "string2"

<span class="linecomment">    // c = a if a is not null, else c = b.</span>
    c := a orelse b
    @assert(c == "string1")

    a = null
    c = a orelse b
    @assert(c == "string2")
}
</code></div><div>
</br>
 Works also for basic types like integers.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    a := 0
    b := 1
    c := a orelse b
    @assert(c == b)
}
</code></div><div><h3 id="Type promotion">Type promotion</br>
</h3>Unlike C, types are not promoted to 32 bits when dealing with 8 or 16 bits types. But types will be promoted if the two sides of an operation do not have the same type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#assert @typeof(0'u8 + 1'u8)  == u8
#assert @typeof(0'u8 + 1'u16) == u16    // Priority to bigger type
#assert @typeof(0'u8 + 1'u32) == u32
#assert @typeof(0'u8 + 1'u64) == u64
#assert @typeof(0'u8 + 1's8)  == s8     // Priority to signed type
#assert @typeof(0'u8 + 1's16) == s16
#assert @typeof(0'u8 + 1's32) == s32
#assert @typeof(0'u8 + 1's64) == s64
#assert @typeof(0'u8 + 1'f32) == f32
#assert @typeof(0'u8 + 1'f64) == f64

#assert @typeof(0's8 + 1'u16) == u16   // Priority to bigger type also

<span class="linecomment">// This means that a 8/16 bits operation (like an addition) can more easily overflow if you do not take care.</span>
<span class="linecomment">// In that case, you can use the ',up' modifier on the operation, which will promote the type to at least 32 bits. The operation will be done accordingly.</span>
#assert @typeof(255'u8 +,up 1'u8) == u32
#assert 255'u8 +,up 1'u8 == 256 // No overflow, because the operation is done in 32 bits.
</code></div>
<h2 id="016_cast">Cast</h2>
<div>Sometimes it's necessary to change the type of a value.</br>
</div>
<div>
</br>
 Use <code class="incode">cast(type)</code> to cast from one type to another.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := 1.0
    #assert @typeof(x) == f32

    y := cast(s32) x
    #assert @typeof(y) == s32
    @assert(y == 1)
}
</code></div><div>
</br>
 Use <code class="incode">acast</code> to automatically cast to the expression on the left.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var x: f32 = 1.0
    var y: s32 = acast x    // cast 'x' to 's32'
    #assert @typeof(y) == s32
    @assert(y == 1)
}
</code></div><div>Use <code class="incode">cast,bit</code> to convert a native type to another without converting the value. Works only if the two types are of the same size.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var x: f32 = 1.0
var y: u32 = cast,bit(u32) x
@assert(y == 0x3f800000)
#assert cast,bit(u32) 1.0 == 0x3f800000
#assert cast,bit(f32) 0x3f800000 == 1.0
</code></div><div>Swag can sometimes cast from one type to another for you. This is an <i>implicit</i> cast.</br>
</div>
<div>
</br>
 An implicit cast is done if there's no loss of precision. In that case, you can affect different types.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var x: s16 = 1's8   // 8 bits to 16 bits, fine
    var y: s32 = 1's16  // 16 bits to 32 bits, fine

<span class="linecomment">    // But the following would generate an error as you cannot affect 's16' to 's8' without an explicit cast(s16).</span>

    /*
    var z0: s16 = 1
    var z1: s8 = z0
    */
}
</code></div>
<h2 id="020_array">Array</h2>
<div>Remember that dynamic arrays are part of the <code class="incode">Std.Core</code> module. Here we are only talking about native static arrays.</br>
</div>
<div>
</br>
 A static array is declared with <code class="incode">[N]</code> followed by the type, where <code class="incode">N</code> is the dimension.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [2] s32  // Static array of two s32
    array[0] = 1
    array[1] = 2
}
</code></div><div>
</br>
 You can get the number of elements of an array with <code class="incode">@countof</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [2] s32
    #assert @countof(array) == 2
    #assert @sizeof(array) == 2 * @sizeof(s32)
}
</code></div><div>
</br>
 You can get the address of the array with <code class="incode">@dataof</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [2] s32
    ptr0 := @dataof(array)
    ptr0[0] = 1

<span class="linecomment">    // This is equivalent of taking the address of the first element</span>
    ptr1 := &array[0]
    ptr1[1] = 2

    @assert(array[0] == 1)
    @assert(array[1] == 2)
}
</code></div><div>
</br>
 An array literal has the form <code class="incode">[A, B, ...]</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    arr := [1, 2, 3, 4] // An array of four s32
    #assert @countof(arr) == 4
    #assert @typeof(arr) == #type [4] s32
}
</code></div><div>
</br>
 The size of the array can be deduced from the initialisation expression.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [] s32 = [1, 2]
    @assert(array[0] == 1)
    @assert(array[1] == 2)
    #assert @countof(array) == 2

    array1 := ["10", "20", "30"]
    @assert(array1[0] == "10")
    @assert(array1[1] == "20")
    @assert(array1[2] == "30")
    #assert @countof(array1) == 3
}
</code></div><div>
</br>
 Like every other types, an array is initialized by default to 0</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [2] s32
    @assert(array[0] == 0)
    @assert(array[1] == 0)
}
</code></div><div>
</br>
 But for speed, you can force the array to be not initialized with <code class="incode">undefined</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [100] s32 = undefined
}
</code></div><div>Of course an array can have multiple dimensions.</br>
</div>
<div>
</br>
 Syntax is <b>not</b> <code class="incode">[X][Y]</code> like in C/C++, but is <code class="incode">[X, Y]</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [2, 2] s32
    array[0, 0] = 1
    array[0, 1] = 2
    array[1, 0] = 3
    array[1, 1] = 4
}
</code></div><div>
</br>
 The sizes can be deduced from the initialization expression too.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    array  := [1, 2, 3, 4]
    array1 := [[1, 2], [3, 4]]

    #assert @countof(array) == 4
    #assert @countof(array) == 4
}
</code></div><div>
</br>
 A static array (with compile time values) can be stored as a constant.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    const array = [1, 2, 3, 4]
    #assert array[0] == 1   // Dereference is done at compile time
    #assert array[3] == 4
}
</code></div><div>
</br>
 If the type of the array is not specified, the type of the first literal value will be used for all other members.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    arr := [1'f64, 2, 3, 4]    // Every values are forced to be 'f64'

    #assert @countof(arr) == 4
    #assert @typeof(arr) == #type [4] f64
    @assert(arr[3] == 4.0)
}
</code></div><div>You can initialize a whole array variable (but not a constant) with one single value. Only basic types are accepted (integers, float, string, bool, rune).</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// The whole array is initialized with 'true'</span>
var arr: [2, 2] bool = true
@assert(arr[0, 0] == true)
@assert(arr[1, 1] == true)

<span class="linecomment">// The whole array is initialized with 'string'</span>
var arr1: [5, 10] string = "string"
@assert(arr1[0, 0] == "string")
@assert(arr1[4, 9] == "string")
</code></div>
<h2 id="021_slice">Slice</h2>
<div>A slice is a pointer on a buffer of datas, and a <code class="incode">u64</code> to count the number of elements. Unlike a static array, its value can be changed at runtime.</br>
</div>
<div>
</br>
 It is declared with <code class="incode">[..]</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: [..] bool
    #assert @sizeof(a) == @sizeof(*void) + @sizeof(u64)
}
</code></div><div>
</br>
 You can initialize a slice like an array.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: const [..] u32 = [10, 20, 30, 40, 50]
    @assert(@countof(a) == 5)
    @assert(a[0] == 10)
    @assert(a[4] == 50)

<span class="linecomment">    // But as this is a slice and not a static array, you can change the value at runtime.</span>
<span class="linecomment">    // So now 'a' is a slice of two s32 values.</span>
    a = [1, 2]
    @assert(@countof(a) == 2)
    @assert(a[0] == 1)
    @assert(a[1] == 2)
}
</code></div><div>
</br>
 At runtime, <code class="incode">@dataof</code> will return the address of the values, <code class="incode">@countof</code> the number of elements.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: const [..] u32 = [10, 20, 30, 40, 50]
    count := @countof(a)
    addr  := @dataof(a)
    @assert(count == 5)
    @assert(addr[0] == 10)
    @assert(addr[4] == 50)

    a = [1, 2]
    @assert(@countof(a) == 2)
}
</code></div><div>
</br>
 You can create a slice with your own <code class="incode">pointer</code> and <code class="incode">count</code> using <code class="incode">@mkslice</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [4]  u32 = [10, 20, 30, 40]

<span class="linecomment">    // Creates a slice of 'array' (a view, or subpart) starting at index 2, with 2 elements.</span>
    var slice: [..] u32 = @mkslice(&array[0] + 2, 2)

    @assert(@countof(slice) == 2)
    @assert(slice[0] == 30)
    @assert(slice[1] == 40)

    @assert(array[2] == 30)
    slice[0] = 314
    @assert(array[2] == 314)
}
</code></div><div>
</br>
 For a string, the slice must be <code class="incode">const</code> because a string is immutable.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var str = "string"
    var strSlice: const [..] u8 = @mkslice(@dataof(str), 2)
    @assert(strSlice[0] == "s"'u8)
    @assert(strSlice[1] == "t"'u8)
}
</code></div><div><h3 id="The slicing operator">The slicing operator</br>
</h3></div>
<div>
</br>
 Instead of <code class="incode">@mkslice</code>, you can slice something with the <code class="incode">..</code> operator. For example you can slice a string.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var str = "string"
    var slice = str[1..3]
    @assert(slice == "tri")
}
</code></div><div>
</br>
 The upper limit is <b>included</b> by default. If you want to exclude it, use <code class="incode">..<</code> insteand of <code class="incode">..</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var str = "string"
    var slice = str[1..<3]
    @assert(slice == "tr")
}
</code></div><div>
</br>
 You can omit the upper bound if you want to slice to the end.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var str = "string"
    var slice = str[2..]
    @assert(slice == "ring")
}
</code></div><div>
</br>
 You can omit the lower bound if you want to slice from the start (0).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var str = "string"
    var slice = str[..2]        // Index 2 is included
    @assert(slice == "str")
    var slice1 = str[..<2]      // Index 2 is excluded
    @assert(slice1 == "st")
}
</code></div><div>
</br>
 You can also slice an array.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    arr := [10, 20, 30, 40]
    slice := arr[2..3]
    @assert(slice[0] == 30)
    @assert(slice[1] == 40)
    @assert(@countof(slice) == 2)

    slice1 := arr[..]
    @assert(@countof(slice1) == @countof(arr))
}
</code></div><div>
</br>
 You can slice another slice.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    arr := [10, 20, 30, 40]
    slice1 := arr[1..3]
    @assert(slice1[0] == 20)
    @assert(slice1[1] == 30)
    @assert(slice1[2] == 40)

    slice2 := slice1[1..2]
    @assert(slice2[0] == 30)
    @assert(slice2[1] == 40)
}
</code></div><div>
</br>
 You can transform a pointer to a slice.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    arr := [10, 20, 30, 40]
    ptr := &arr[2]
    slice := ptr[0..1]
    @assert(slice[0] == 30)
    @assert(slice[1] == 40)
    @assert(@countof(slice) == 2)
}
</code></div>
<h2 id="022_pointers">Pointers</h2>
<div><h3 id="Single value pointers">Single value pointers</br>
</h3></div>
<div>
</br>
 A pointer to a <b>single element</b> is declared with <code class="incode">*</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var ptr1: *u8   // This is a pointer to one single 'u8'
    var ptr2: **u8  // This is a pointer to one other pointer to one single 'u8'
}
</code></div><div>
</br>
 A pointer can be <code class="incode">null</code> (i know some of you will collapse here).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var ptr1: *u8
    @assert(ptr1 == null)
}
</code></div><div>
</br>
 You can take the address of something with <code class="incode">&</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    arr := 1
    ptr := &arr // Take the address of the variable 'arr'
    @assert(@typeof(ptr) == *s32)
}
</code></div><div>
</br>
 You can get the pointed value with <code class="incode">dref</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    arr := 42
    ptr := &arr
    @assert(dref ptr == 42)
}
</code></div><div>
</br>
 Pointers can be <code class="incode">const</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    str := "string"
    var ptr: const *u8 = @dataof(str)
    @assert(dref ptr == "s"'u8)
}
</code></div><div>
</br>
 You can be weird, but is this necessary ?</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var ptr:  *const *u8        // Normal pointer to a const pointer
    var ptr1: const *const *u8  // Const pointer to a const pointer
    var ptr2: const **u8        // Const pointer to a normal pointer
}
</code></div><div><h3 id="Multiple values pointers">Multiple values pointers</br>
</h3>If you want to enable <b>pointer arithmetic</b>, and make a pointer to <b>multiple values</b>, declare your pointer with <code class="incode">^</code> instead of <code class="incode">*</code>.</br>
</div>
<div>
</br>
 <code class="incode">ptr</code> is a pointer to a memory block of <code class="incode">u8</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var ptr: ^u8
    ptr = ptr - 1 // Pointer arithmetic is now possible
}
</code></div><div>
</br>
 Taking the address of an array element enables pointer arithmetic.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var x: [4] s32
    ptr := &x[1]
    ptr = ptr - 1
    #assert @typeof(ptr) == ^s32
}
</code></div><div>
</br>
 As pointer arithmetic is enabled, you can dereference that kind of pointer by index.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    arr := [1, 2, 3, 4]
    ptr := &arr[0]
    @assert(@typeof(ptr) == ^s32)

<span class="linecomment">    // The type of 'ptr' is ^s32, so it can be dereferenced by index</span>
    value1 := ptr[0]
    @assert(value1 == 1)
    #assert @typeof(value1) == s32

    value2 := ptr[1]
    @assert(value2 == 2)
    #assert @typeof(value2) == s32

<span class="linecomment">    // But 'dref' still works for the first element</span>
    value := dref ptr
    @assert(value == 1)
    #assert @typeof(value) == s32
}
</code></div>
<h2 id="023_references">References</h2>
<div>Swag has also <b>references</b>, which are pointers that behave like values.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x := 42

<span class="linecomment">// Use 'ref' to declare a reference.</span>
<span class="linecomment">// Here we declare a reference to the variable 'x'.</span>
<span class="linecomment">// Note that unlike C++, you have to take the address of 'x' to convert it to a reference.</span>
var myRef: const ref s32 = &x

<span class="linecomment">// This is a pointer that behaves like a value, so no explicit dereferencing is necessary.</span>
<span class="linecomment">// You can see this as a kind of an alias.</span>
@assert(myRef == 42)
</code></div><div>When an affectation is done outside of an initialization, you will change the pointed value, and not the reference itself.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x := 42
var myRef: ref s32 = &x // Note here that the reference is no more 'const'
@assert(myRef == 42)

<span class="linecomment">// Here we will change the pointed value 'x'</span>
myRef = 66
@assert(myRef == 66)

<span class="linecomment">// Remember that 'myRef' is an alias for 'x', so 'x' has also been changed.</span>
@assert(x == 66)
</code></div><div>If you want to change the reference and not the pointed value, you can use <code class="incode">ref</code> in the affectation.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x := 1
y := 1000

var myRef: const ref s32 = &x
@assert(myRef == 1)

<span class="linecomment">// Here we force 'myRef' to point to 'y' and not to 'x' anymore.</span>
<span class="linecomment">// We do *NOT* change the value of 'x'.</span>
myRef = ref &y
@assert(myRef == 1000)
</code></div><div>Most of the time, you have to take the address of a variable to make a reference to it. The only exception are function parameters, if the reference is <code class="incode">const</code>. In that case, taking the address is not necessary</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// We can pass a literal because the parameter 'x' of 'toto' is 'const ref' and not just 'ref'.</span>
toto(4)
</code></div><div class="code"><code style="white-space: break-spaces">func toto(x: const ref s32)
{
    @assert(x == 4)

<span class="linecomment">    // Under the hood, you will get a const address to an 's32'</span>
    ptr := &x
    @assert(dref ptr == 4)
}
</code></div><div>This is usefull for structs for examples, as you can directly pass a literal to a function.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct MyStruct {x: s32; y: s32; }  // Our first little struct !
</code></div><div class="code"><code style="white-space: break-spaces">titi0({1, 2})
titi1({3, 4})
titi2({5, 6})
</code></div><div class="code"><code style="white-space: break-spaces">func titi0(param: const ref {s32, s32})
{
<span class="linecomment">    // We'll see later about tuples and naming of fields.</span>
    @assert(param.item0 == 1)
    @assert(param.item1 == 2)
}
</code></div><div>Note that declaring a tuple type or a struct type is equivalent to a constant reference.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func titi1(param: {x: s32, y: s32})
{
    @assert(param.x == 3)
    @assert(param.y == 4)
}

func titi2(param: MyStruct)
{
    @assert(param.x == 5)
    @assert(param.y == 6)
}
</code></div>
<h2 id="024_any">Any</h2>
<div><code class="incode">any</code> is a specific type that can store every other types. <code class="incode">any</code> is <b>not a variant</b>. It's a dynamic typed reference to an existing value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: any

<span class="linecomment">    // Store a s32</span>
    a = 6
    @assert(a == 6)

<span class="linecomment">    // Then store a string instead</span>
    a = "string"
    @assert(a == "string")

<span class="linecomment">    // Then store a bool instead</span>
    a = true
    @assert(a == true)
}
</code></div><div>
</br>
 <code class="incode">any</code> is in fact a pointer to the value, and a <code class="incode">typeinfo</code>. <code class="incode">@dataof</code> can be used to retrieve the pointer to the value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: any = 6
    ptr := cast(const *s32) @dataof(a)
    @assert(dref ptr == 6)
}
</code></div><div>
</br>
 <code class="incode">@typeof</code> will give you the type <code class="incode">any</code>, but <code class="incode">@kindof</code> will give you the real underlying type. In that case, <code class="incode">@kindof</code> is evaluted at runtime.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var a: any = "string"
    #assert @typeof(a) == any
    @assert(@kindof(a) == string)

    a = true
    @assert(@kindof(a) == bool)
}
</code></div><div>
</br>
 You can declare an array with multiple types, with <code class="incode">any</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [] any = [true, 2, 3.0, "4"]
    @assert(@kindof(array[0]) == bool)
    @assert(@kindof(array[1]) == s32)
    @assert(@kindof(array[2]) == f32)
    @assert(@kindof(array[3]) == string)

    @assert(array[0] == true)
    @assert(array[1] == 2)
    @assert(array[2] == 3.0)
    @assert(array[3] == "4")
}
</code></div><div>
</br>
 An <code class="incode">any</code> can be set to null, and tested against null.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var x: any
    @assert(x == null)
    x = 6
    @assert(x != null)
    @assert(x == 6)
    x = "string"
    @assert(x != null)
    @assert(x == "string")
    x = null
    @assert(x == null)
}
</code></div>
<h2 id="025_tuple">Tuple</h2>
<div>
</br>
 A tuple is an anonymous structure, aka a struct literal. Syntax is <code class="incode">{}</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    tuple1 := {2, 2}
    tuple2 := {"string", 2, true}
}
</code></div><div>
</br>
 Tuple values have default names to access them, in the form of <code class="incode">itemX</code> where <code class="incode">X</code> is the field rank.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    tuple := {"string", 2, true}
    @assert(tuple.item0 == "string")
    @assert(tuple.item1 == 2)
    @assert(tuple.item2 == true)
}
</code></div><div>
</br>
 But you can specify your own names.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    tuple := {x: 1.0, y: 2.0}
    @assert(tuple.x == 1.0)
    @assert(tuple.item0 == 1.0)
    @assert(tuple.y == 2.0)
    @assert(tuple.item1 == 2.0)
}
</code></div><div>
</br>
 A tuple is an expression, where names of fields can be omitted. But the automatic name <code class="incode">itemX</code> is always valid.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var tuple: {x: f32, f32}
    tuple.x = 1.0
    @assert(tuple.x == 1.0)
    @assert(tuple.item0 == 1.0)
    @assert(tuple.item1 == 0.0)
}
</code></div><div>
</br>
 When creating a tuple literal with variables, the tuple fields will take the name of the variables (except if specified).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := 555
    y := 666
    t := {x, y}
    @assert(t.x == 555)
    @assert(t.item0 == t.x)
    @assert(t.y == 666)
    @assert(t.item1 == t.y)
}
</code></div><div>
</br>
 Even if two tuples do not have the same field names, they can be assigned to each other if the field types are the same.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var x: {a: s32, b: s32}
    var y: {c: s32, d: s32}

    y = {1, 2}
    x = y
    @assert(x.a == 1)
    @assert(x.b == 2)

<span class="linecomment">    // But note that 'x' and 'y' to not have the same type</span>
    #assert @typeof(x) != @typeof(y)
}
</code></div><div><h3 id="Tuple unpacking">Tuple unpacking</br>
</h3></div>
<div>
</br>
 You can unpack a tuple field by field.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    tuple1 := {x: 1.0, y: 2.0}

<span class="linecomment">    // 'value0' will be assigned with 'x', and 'value1' will be assigned with 'y'.</span>
    var (value0, value1) = tuple1
    @assert(value0 == 1.0)
    @assert(value1 == 2.0)

    tuple2 := {"name", true}
    (name, value) := tuple2
    @assert(name == "name")
    @assert(value == true)
}
</code></div><div>
</br>
 You can ignore a tuple field by naming the variable <code class="incode">?</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    tuple1 := {x: 1.0, y: 2.0}
    (x, ?) := tuple1
    @assert(x == 1.0)
    (?, y) := tuple1
    @assert(y == 2.0)
}
</code></div>
<h2 id="030_enum">Enum</h2>
<div>
</br>
 Enums values, unlike C/C++, must end with <code class="incode">;</code> or an <code class="incode">eol</code> (like a normal Swag declaration).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Values
    {
        A
        B
    }
}
</code></div><div>
</br>
 By default, an enum is of type <code class="incode">s32</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Values { A; B; }
    type := @typeof(Values)

<span class="linecomment">    // 'type' here is a 'typeinfo' dedicated to the enum type.</span>
<span class="linecomment">    // In that case, 'type.rawType' is the enum underlying type.</span>
    @assert(type.rawType == s32)
    #assert @typeof(Values) == Values
}
</code></div><div>
</br>
 <code class="incode">@kindof</code> will return the underlying type of the enum.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum RGB { R; G; B; }
    #assert @typeof(RGB) == RGB
    #assert @kindof(RGB) != RGB
    #assert @kindof(RGB) == s32
}
</code></div><div>
</br>
 You can specify your own type after the enum name.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Values1: s64 // Forced to be 's64' instead of 's32'
    {
        A
        B
        C
    }

    #assert @kindof(Values1) == s64
    #assert @typeof(Values1.A) == Values1
}
</code></div><div>
</br>
 Enum values, if not specified, start at 0 and are increased by 1 at each new value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Value: s64
    {
        A
        B
        C
    }

    #assert Value.A == 0
    #assert Value.B == 1
    #assert Value.C == 2
}
</code></div><div>
</br>
 You can specify your own values.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Value: s64
    {
        A = 10
        B = 20
        C = 30
    }

    #assert Value.A == 10
    #assert Value.B == 20
    #assert Value.C == 30
}
</code></div><div>
</br>
 If you omit one value, it will be assigned to the previous value + 1.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Value: u32
    {
        A = 10
        B // 11
        C // 12
    }

    #assert Value.A == 10
    #assert Value.B == 11
    #assert Value.C == 12
}
</code></div><div>
</br>
 For non integer types, you <b>must</b> specify the values as they cannot be deduced.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Value1: string
    {
        A = "string 1"
        B = "string 2"
        C = "string 3"
    }

    #assert Value1.A == "string 1"
    #assert Value1.B == "string 2"
    #assert Value1.C == "string 3"

    enum Value2: f32
    {
        A = 1.0
        B = 3.14
        C = 6
    }

    #assert Value2.A == 1.0
    #assert Value2.B == 3.14
    #assert Value2.C == 6
}
</code></div><div>
</br>
 <code class="incode">@countof</code> returns the number of values of an enum.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Value: string
    {
        A = "string 1"
        B = "string 2"
        C = "string 3"
    }

    @assert(@countof(Value) == 3)
    #assert @countof(Value) == 3
}
</code></div><div>
</br>
 You can use the keyword <code class="incode">using</code> for an enum.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Value
    {
        A
        B
        C
    }

    using Value

<span class="linecomment">    // No need to say 'Value.A' thanks to the 'using' above</span>
    @assert(A == 0)
    @assert(B == 1)
    @assert(C == 2)

<span class="linecomment">    // But the normal form is still possible</span>
    @assert(Value.A == 0)
    @assert(Value.B == 1)
    @assert(Value.C == 2)
}
</code></div><div><h3 id="Enum as flags">Enum as flags</br>
</h3>An enum can be a set of flags if you declare it with the <code class="incode">#[Swag.EnumFlags]</code> <b>attribute</b>. Its type should be <code class="incode">u8</code>, <code class="incode">u16</code>, <code class="incode">u32</code> or <code class="incode">u64</code>.</br>
</br>
That kind of enum starts by default at 1, and not 0, and each value should be a power of 2.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.EnumFlags]
enum MyFlags: u8
{
    A   // First value is 1 and *not* 0
    B   // Value is 2
    C   // Value is 4
    D   // Value is 8
}

#assert MyFlags.A == 0b00000001
#assert MyFlags.B == 0b00000010
#assert MyFlags.C == 0b00000100
#assert MyFlags.D == 0b00001000

value := MyFlags.B | MyFlags.C
@assert(value == 0b00000110)
@assert(value & MyFlags.B == MyFlags.B)
@assert(value & MyFlags.C == MyFlags.C)
</code></div><div><h3 id="Enum of arrays">Enum of arrays</br>
</h3>You can have an enum of const static arrays.</br>
</div>
<div class="code"><code style="white-space: break-spaces">enum Value: const [2] s32
{
    A = [1, 2]
    B = [10, 20]
}

#assert Value.A[0] == 1
#assert Value.A[1] == 2
#assert Value.B[0] == 10
#assert Value.B[1] == 20
</code></div><div><h3 id="Enum of slices">Enum of slices</br>
</h3>You can have an enum of const slices.</br>
</div>
<div class="code"><code style="white-space: break-spaces">enum Value: const [..] s32
{
    A = [1, 2]
    B = [10, 20, 30, 40]
}

#assert @countof(Value.A) == 2
#assert @countof(Value.B) == 4

x := Value.A
@assert(x[0] == 1)
@assert(x[1] == 2)
y := Value.B
@assert(y[0] == 10)
@assert(y[1] == 20)
</code></div><div><h3 id="Enum type inference">Enum type inference</br>
</h3></div>
<div>
</br>
 The type of the enum is not necessary in the assignement expression when declaring a variable.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Values { A; B; }

<span class="linecomment">    // The normal form</span>
    var x: Values = Values.A

<span class="linecomment">    // But in fact 'Values' is not necessary because it can be deduced</span>
    var y: Values = A

    @assert(x == y)
}
</code></div><div>
</br>
 The enum type is not necessary in a <code class="incode">case</code> expression of a <code class="incode">switch</code> block (it is deduced from the switch expression).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Values { A; B; }
    x := Values.A

<span class="linecomment">    // The 'normal' form</span>
    switch x
    {
    case Values.A: break
    case Values.B: break
    }

<span class="linecomment">    // The 'simplified' form</span>
    switch x
    {
    case A: break
    case B: break
    }
}
</code></div><div>
</br>
 In an expression, and if the enum name can be deduced, you can omit it and use the <code class="incode">.Value</code> syntax.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Values { A; B; }

<span class="linecomment">    // The normal form</span>
    x := Values.A

<span class="linecomment">    // The simplified form, because 'Values' can be deduced from type of x</span>
    @assert(x == .A)
    @assert(x != .B)
}
</code></div><div>
</br>
 Works also for flags.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.EnumFlags]
    enum Values { A; B; }

    x := Values.A | Values.B
    @assert((x & .A) and (x & .B))
}
</code></div><div>
</br>
 Works also (most of the time), for functions.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Values { A; B; }
    func toto(v1, v2: Values) {}
    toto(.A, .B)
}
</code></div><div>By type reflection, you can loop/visit all values of an enum.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum RGB { R; G; B; }

    cpt := 0
    loop idx: RGB
        cpt += 1
    @assert(cpt == 3)

    visit val: RGB
    {
        switch val
        {
        case R:     break
        case G:     break
        case B:     break
        default:    @assert(false)
        }
    }
}
</code></div>
<h2 id="031_impl">Impl</h2>
<div><code class="incode">impl</code> can be used to declare some stuff in the scope of an enum. The keyword <code class="incode">self</code> represents the enum value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">enum RGB { R; G; B; }
</code></div><div>Note the <code class="incode">impl enum</code> syntax. We'll see later that <code class="incode">impl</code> is also used for structs.</br>
</div>
<div class="code"><code style="white-space: break-spaces">impl enum RGB
{
    func isRed(self)       => self == R
    func isRedOrBlue(self) => self == R or self == B
}
</code></div><div class="code"><code style="white-space: break-spaces">@assert(RGB.isRed(RGB.R))
@assert(RGB.isRedOrBlue(RGB.B))

using RGB
@assert(isRedOrBlue(R))
@assert(isRedOrBlue(B))

<span class="linecomment">// A first look at 'ufcs' (uniform function call syntax)</span>
@assert(R.isRedOrBlue())
@assert(!RGB.G.isRedOrBlue())
</code></div>
<h2 id="035_namespace">Namespace</h2>
<div>You can create a global scope with a namespace. All symbols inside the namespace will be in the corresponding global scope.</br>
</div>
<div class="code"><code style="white-space: break-spaces">namespace A
{
    func a() => 1
}
</code></div><div>You can also specify more than one name. Here <code class="incode">C</code> will be a namespace inside <code class="incode">B</code> which is itself inside <code class="incode">A</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">namespace A.B.C
{
    func a() => 2
}
</code></div><div class="code"><code style="white-space: break-spaces">@assert(A.a() == 1)
@assert(A.B.C.a() == 2)
</code></div><div>You can also put <code class="incode">using</code> in front of the namespace to be able to access the content without scoping in the <b>current</b> file.</br>
</div>
<div class="code"><code style="white-space: break-spaces">using namespace Private
{
    const FileSymbol = 0
}

const B = Private.FileSymbol
const C = FileSymbol // No need to specify 'Private' because of the 'using'
</code></div><div>This is equivalent to <code class="incode">#scopefile</code>, but you don't have to specify a name, the compiler will generate it for you.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#scopefile {
    const OtherSymbol = 0
}

const D = OtherSymbol
</code></div><div>All symbols from a Swag source file are exported to other files of the same module. So using <code class="incode">#scopefile</code> can protect from name conflicts.</br>
</div>

<h2 id="050_if">If</h2>
<div>A basic test with <code class="incode">if</code>. Curlies are optional. The expression doesn't need to be enclosed with <code class="incode">()</code> unlike C/C++.</br>
</div>
<div class="code"><code style="white-space: break-spaces">a := 0
if a == 1
    @assert(false)
if (a == 1)
    @assert(false)

if a == 0 {
    @assert(true)
</code></div><div class="code"><code style="white-space: break-spaces"><span class="linecomment">    // 'else' is of course also a thing</span>
    if a == 0
        a += 1
    else
        a += 2
    @assert(a == 1)

<span class="linecomment">    // 'elif' is equivalent to 'else if'</span>
    if a == 1
        a += 1
    else if a == 2
        @assert(false)
    elif a == 3
        @assert(false)
    elif a == 4
        @assert(false)

<span class="linecomment">    // Boolean expression with 'and' and 'or'</span>
    if a == 0 and a == 1
        @assert(false)
    if a == 0 or a == 1
        @assert(true)
}
</code></div><div>You can also at the same time declare and test one variable in an <code class="incode">if</code> expression. <code class="incode">var</code> or <code class="incode">const</code> is mandatory in that case.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// This will declare a variable 'a', and test if against 0.</span>
<span class="linecomment">// 'a' is then only visible in the 'if' block, and not outside.</span>
if var a = 0
{
    @assert(false)
}

if const a = 1
{
    @assert(a == 1)
}
else
    @assert(false)
</code></div>
<h2 id="051_loop">Loop</h2>
<div><code class="incode">loop</code> are used to iterate a given amount of time.</br>
</div>
<div>
</br>
 The loop expression value is evaluated <b>once</b>, and must be a positive value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0
    loop 10 // Loops 10 times
        cpt += 1
    @assert(cpt == 10)
}
</code></div><div>
</br>
 The intrinsic <code class="incode">@index</code> returns the current index of the loop (starting at 0).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0'u64
    loop 5
    {
        cpt += @index
    }

    @assert(cpt == 0+1+2+3+4)
}
</code></div><div>
</br>
 You can name that index if you want.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt  := 0
    cpt1 := 0

    loop i: 5   // index is named 'i'
    {
        cpt  += i
        cpt1 += @index  // @index is always available, even when named
    }

    @assert(cpt  == 0+1+2+3+4)
    @assert(cpt1 == cpt)
}
</code></div><div><code class="incode">loop</code> can be used on every types that accept the <code class="incode">@countof</code> intrinsic. So you can loop on a slice, an array, a string... and we'll see later, even on a struct.</br>
</div>
<div class="code"><code style="white-space: break-spaces">arr := [10, 20, 30, 40]
#assert @countof(arr) == 4

cpt := 0
loop arr    // The array contains 4 elements, so the loop count is 4
    cpt += arr[@index]
@assert(cpt == 10+20+30+40)
</code></div><div><b>Warning !</b></br>
On a string, it will loop for each byte, <b>not</b> runes (if a rune is encoded in more than one byte). If you want to iterate on all runes, you will have to use the <code class="incode">Std.Core</code> module.</br>
</div>
<div class="code"><code style="white-space: break-spaces">cpt := 0
loop "⻘"
    cpt += 1

<span class="linecomment">// cpt is equal to 3 because '⻘' is endoded with 3 bytes</span>
@assert(cpt == 3)
</code></div><div><code class="incode">break</code> and <code class="incode">continue</code> can be used inside a loop.</br>
</div>
<div>
</br>
 You can exit a loop with <code class="incode">break</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0
    loop x: 10
    {
        if x == 5
            break
        cpt += 1
    }

    @assert(cpt == 5)
}
</code></div><div>
</br>
 You can force to return to the loop evaluation with <code class="incode">continue</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0
    loop x: 10
    {
        if x == 5
            continue // Do not count 5
        cpt += 1
    }

    @assert(cpt == 9)
}
</code></div><div>Loop can also be used to iterate on a range of signed values.</br>
</div>
<div>
</br>
 Syntax is <code class="incode">lower bound..upper bound</code></br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    count := 0
    sum   := 0
    loop i: -1..1   // loop from -1 to 1, all included
    {
        count += 1
        sum += i
    }

    @assert(sum == 0)
    @assert(count == 3)
}
</code></div><div>
</br>
 With a range, you can loop in reverse order.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
<span class="linecomment">    // Loop from 5 to 0</span>
    loop 5..0
    {
    }

<span class="linecomment">    // Loop from 1 to -1</span>
    loop 1..-1
    {
    }
}
</code></div><div>
</br>
 You can exclude the last value with the <code class="incode">..<</code> syntax.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
<span class="linecomment">    // Will loop from 1 to 2 and **not** 1 to 3</span>
    cpt := 0
    loop i: 1..<3
    {
        cpt += i
    }

    @assert(cpt == 1+2)
}
</code></div><div>A loop without an expression but with a block is infinite. This is equivalent to <code class="incode">while true {}</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">loop
{
    if @index == 4 // @index is still valid in that case (but cannot be renamed)
        break
}
</code></div>
<h2 id="052_visit">Visit</h2>
<div>
</br>
 <code class="incode">visit</code> is used to visit all the elements of a collection.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    visit value: "ABC"
    {
        a := @index
        switch a
        {
        case 0: @assert(value == "A"'u8)
        case 1: @assert(value == "B"'u8)
        case 2: @assert(value == "C"'u8)
        }
    }
}
</code></div><div>
</br>
 You can name both the value and the loop index, in that order.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    visit value, index: "ABC"
    {
        a := index
        switch a
        {
        case 0: @assert(value == "A"'u8)
        case 1: @assert(value == "B"'u8)
        case 2: @assert(value == "C"'u8)
        }
    }
}
</code></div><div>
</br>
 Both names are optional. In that case, you can use <code class="incode">@alias0</code> and <code class="incode">@alias1</code>. <code class="incode">@alias0</code> for the value, and <code class="incode">@alias1</code> for the index</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    visit "ABC"
    {
        a := @alias1    // This is the index
        @assert(a == @index)
        switch a
        {
        case 0: @assert(@alias0 == "A"'u8)
        case 1: @assert(@alias0 == "B"'u8)
        case 2: @assert(@alias0 == "C"'u8)
        }
    }
}
</code></div><div>
</br>
 You can visit arrays or slices.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    array := [10, 20, 30]

    result := 0
    visit it: array
        result += it

    @assert(result == 10+20+30)
}
</code></div><div>
</br>
 Works also for multi dimensional arrays.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [2, 2] s32 = [[10, 20], [30, 40]]

    result := 0
    visit it: array
        result += it

    @assert(result == 10+20+30+40)
}
</code></div><div>
</br>
 You can visit with a pointer to the value, and not the value itself, by adding <code class="incode">&</code> before the value name.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var array: [2, 2] s32 = [[1, 2], [3, 4]]

    result := 0
    visit &it: array
    {
        result += dref it
        dref it = 555
    }

    @assert(result == 1+2+3+4)

    @assert(array[0, 0] == 555)
    @assert(array[0, 1] == 555)
    @assert(array[1, 0] == 555)
    @assert(array[1, 1] == 555)
}
</code></div>
<h2 id="053_for">For</h2>
<div>
</br>
 <code class="incode">for</code> accepts a <i>start statement</i>, an <i>expression to test</i>, and an <i>ending statement</i>. This is in fact the same as the C/C++ <code class="incode">for</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0
    for i := 0; i < 10; i += 1
        cpt += 1
    @assert(cpt == 10)

<span class="linecomment">    // ';' can be replaced by a newline (like always)</span>
    for i := 0
        i < 10
        i += 1
    {
        cpt += 1
    }
    @assert(cpt == 20)

<span class="linecomment">    // Instead of one single expression, you can use a statement</span>
    for { i := 0; cpt = 0; }
        i < 10
        i += 1
    {
        cpt += 1
    }
    @assert(cpt == 10)

    for { i := 0; cpt = 0; }
        i < 10
        { i += 2; i -= 1; }
    {
        cpt += 1
    }
    @assert(cpt == 10)
}
</code></div><div>
</br>
 Like <code class="incode">loop</code> and <code class="incode">while</code>, you have access to <code class="incode">@index</code>, the <b>current loop index</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0'u64
    for var i: u32 = 10; i < 15; i += 1
        cpt += @index
    @assert(cpt == 0+1+2+3+4)

    cpt1 := 0'u64
    for i := 10; i < 15; i += 1
        cpt1 += @index
    @assert(cpt1 == 0+1+2+3+4)
}
</code></div>
<h2 id="054_while">While</h2>
<div>
</br>
 <code class="incode">while</code> is a loop that runs <b>until the expression is false</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    i := 0
    while i < 10
        i += 1
    @assert(i == 10)
}
</code></div><div>
</br>
 You can also <code class="incode">break</code> and <code class="incode">continue</code> inside a <code class="incode">while</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    i := 0
    while i < 10
    {
        if i == 5
            break
        i += 1
    }

    @assert(i == 5)
}
</code></div>
<h2 id="055_switch">Switch</h2>
<div>
</br>
 <code class="incode">switch</code> works like in C/C++, except that no <code class="incode">break</code> is necessary (except if the <code class="incode">case</code> is empty). That means that there's no automatic <code class="incode">fallthrough</code> from one case to another.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    value := 6
    switch value
    {
    case 0:  @assert(false)
    case 5:  @assert(false)
    case 6:  @assert(true)
    default: @assert(false)
    }

    ch := "A"'rune
    switch ch
    {
    case "B"'rune: @assert(false)
    case "A"'rune: break
    }
}
</code></div><div>
</br>
 You can put multiple values on the same <code class="incode">case</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    value := 6
    switch value
    {
    case 2, 4, 6:   @assert(true)
    default:        @assert(false)
    }

    switch value
    {
    case 2,
         4,
         6:
        @assert(true)
    default:
        @assert(false)
    }
}

<span class="linecomment">// `switch` works with every types that accept the `==` operator.</span>
</code></div><div>
</br>
 So you can switch on strings for example.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    value := "myString"
    switch value
    {
    case "myString":    @assert(true)
    case "otherString": @assert(false)
    default:            @assert(false)
    }
}
</code></div><div>
</br>
 If you want to pass from one case to another like in C/C++, use <code class="incode">fallthrough</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    value := 6
    switch value
    {
    case 6:
        fallthrough
    case 7:
        @assert(value == 6)
    default:
        @assert(true)
    }
}
</code></div><div>
</br>
 <code class="incode">break</code> can be used to exit the current <code class="incode">case</code> statement.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    value := 6
    switch value
    {
    case 6:
        if value == 6
            break
        @assert(false)
    default:
        @assert(false)
    }
}
</code></div><div>
</br>
 A <code class="incode">case</code> statement cannot be empty. Use <code class="incode">break</code> if you want to do nothing.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    value := 6
    switch value
    {
    case 5:     @assert(false)
    case 6:     break
    default:    @assert(false)
    }
}

<span class="linecomment">// `switch` can be marked with `Swag.Complete` to force all the cases to be covered.</span>
</code></div><div>
</br>
 If one or more values are missing, an error will be raised by the compiler.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum Color { Red; Green; Blue; }
    color := Color.Red

    #[Swag.Complete]
    switch color
    {
    case Color.Red:     break
    case Color.Green:   @assert(false)
    case Color.Blue:    @assert(false)
    }
}
</code></div><div>
</br>
 If the switch expression is omitted, then it will behave like a serie of if/else, resolved in order.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    value  := 6
    value1 := "true"

    switch
    {
    case value == 6 or value == 7:
        @assert(true)
        fallthrough
    case value1 == "true":
        @assert(true)
    default:
        @assert(false)
    }
}
</code></div><div>
</br>
 When used on an <code class="incode">any</code> variable, switch is done on the underlying variable type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var x: any = "value"

    switch x
    {
    case string: break
    default:     @assert(false)
    }
}
</code></div><div>
</br>
 A <code class="incode">switch</code> can also be used with a (constant) range of values.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    success := false
    x := 6
    switch x
    {
    case 0..5:  @assert(false)
    case 6..15: success = true
    }

    @assert(success)
}
</code></div><div>
</br>
 If they overlap, the first valid range will be used.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    success := false
    x := 6
    switch x
    {
    case 0..10:  success = true
    case 5..<15: @assert(false)
    }

    @assert(success)
}
</code></div><div>
</br>
 A <code class="incode">case</code> expression doesn't need to be constant, except if the switch is marked with <code class="incode">Swag.Complete</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    test := 2
    a := 0
    b := 1
    switch test
    {
    case a:     // Test with a variable
        @assert(false)
    case b:     // Test with a variable
        @assert(false)
    case b + 1: // Test with an expression
        @assert(true)
    }
}
</code></div>
<h2 id="056_break">Break</h2>
<div>
</br>
 <code class="incode">break</code> is used to exit a loop, while, for, switch.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    loop 10
        break
    for i := 0; i < 10; i += 1
        break
    while false
        break
}
</code></div><div>
</br>
 By default, <code class="incode">break</code> will exit the parent scope only.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0
    loop 10
    {
        loop 10
        {
            break   // Exit the inner loop...
        }

<span class="linecomment">        // ...and continue execution here</span>
        cpt += 1
    }

    @assert(cpt == 10)
}
</code></div><div>
</br>
 But you can name a scope with the <code class="incode">scope</code> keyword, and exit to the end of it with a <code class="incode">break</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0
    #scope BigScope
    {
        loop 10
        {
            cpt += 1
            break BigScope  // Break to the outer scope...
        }

        @assert(false)
    }

<span class="linecomment">    // ...and continue execution here</span>
    @assert(cpt == 1)
}
</code></div><div>
</br>
 When used with a scope, a continue is a way to go back to the start of the scope.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0
    #scope Loop
    {
        cpt += 1
        if cpt == 5
            break
        continue    // Loop
    }

    @assert(cpt == 5)
}
</code></div><div>
</br>
 You are not obliged to name the scope, so this can also be used (for example) as an alternative of a bunch of if/else.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 0
    #scope
    {
        if cpt == 1
        {
            @assert(cpt == 1)
            break
        }

        if cpt == 2
        {
            @assert(cpt == 2)
            break
        }

        if cpt == 3
        {
            @assert(cpt == 3)
            break
        }
    }
}
</code></div><div>
</br>
 Note that a scope can be followed by a simple statement, not always a block.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #scope Up loop 10
    {
        loop 10
        {
            if @index == 5
                break Up
        }

        @assert(false)
    }
}
</code></div>
<h2 id="060_struct">Struct</h2>

<h3 id="061__declaration">Declaration</h3>
<div>
</br>
 This is a <code class="incode">struct</code> declaration. <code class="incode">var</code> is not necessary for the fields.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct
    {
        name: string
    }

    struct MyStruct1
    {
        x:      s32
        y, z:   s32
        val:    bool
        myS:    MyStruct
    }
}
</code></div><div>
</br>
 A struct can be anonymous when declared as a variable type. Unlike tuples, syntax should be the same as for named structs.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var tuple: struct
    {
        x: f32
        y: f32
    }
    var tuple1: struct{x, y: f32; }

    tuple.x = 1.0
    tuple.y = 2.0
    @assert(tuple.x == 1.0)
    @assert(tuple.y == 2.0)
}

{
    struct MyStruct
    {
        rgb: struct {x, y, z: f32; }
        hsl: struct {h, s, l: f32; }
    }
}
</code></div><div>
</br>
 You can initialize a struct variable in different ways.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct
    {
        x, y: s32 = 1
    }

<span class="linecomment">    // Default values</span>
    var v0: MyStruct
    @assert(v0.x == 1)
    @assert(v0.y == 1)

<span class="linecomment">    // Init in the order of the fields</span>
    var v1: MyStruct{10, 20}
    @assert(v1.x == 10)
    @assert(v1.y == 20)

<span class="linecomment">    // Named field</span>
    v2 := MyStruct{y: 20}
    @assert(v2.x == 1)
    @assert(v2.y == 20)

<span class="linecomment">    // With a tuple</span>
    var v3: MyStruct = {10, 20}
    @assert(v3.x == 10)
    @assert(v3.y == 20)
}
</code></div><div>
</br>
 The fields of a struct can be initialized at the declaration.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct
    {
        x: s32    = 666
        y: string = "454"
    }

    v := MyStruct{}
    @assert(v.x == 666)
    @assert(v.y == "454")
}
</code></div><div>
</br>
 A struct can be affected to a constant, as long as it can be evaluated at compile time.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct
    {
        x: s32    = 666
        y: string = "454"
    }

    const X: MyStruct{50, "value"}
    #assert X.x == 50
    #assert X.y == "value"
}
</code></div><div>A function can take an argument of type <code class="incode">struct</code>. No copy is done (this is equivalent to a const reference in C++).</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Struct3
{
    x, y, z: s32 = 666
}

func toto(v: Struct3)
{
    @assert(v.x == 5)
    @assert(v.y == 5)
    @assert(v.z == 666)
}

func titi(v: Struct3)
{
    @assert(v.y == 666)
}
</code></div><div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Call with a struct literal</span>
toto(Struct3{5, 5, 666})

<span class="linecomment">// Type can be deduced from the argument</span>
toto({5, 5, 666})

<span class="linecomment">// You can also just specify some parts of the struct, in the declaration order of the fields</span>
titi({5})      // Initialize x, which is the first field
titi({5, 666}) // Initialize x and y

<span class="linecomment">// You can also name the fields, and omit some of them</span>
titi({x: 5, z: 5}) // Here y will stay to the default value, which is 666
</code></div>
<h3 id="062__impl">Impl</h3>
<div>Like for an enum, <code class="incode">impl</code> is used to declare some stuff in the scope of a struct.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.ExportType("methods")]   // See later, used to export 'methods' in type reflection
struct MyStruct
{
    x: s32 = 5
    y: s32 = 10
    z: s32 = 20
}

impl MyStruct
{
    const MyConst = true
    func returnTrue() => true
}
</code></div><div class="code"><code style="white-space: break-spaces">@assert(MyStruct.returnTrue())
@assert(MyStruct.MyConst)
</code></div><div>You can have multiple <code class="incode">impl</code> blocks. The difference with a namespace is that <code class="incode">self</code> and <code class="incode">Self</code> are defined inside an impl block. They refere to the corresponding type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">impl MyStruct
{
<span class="linecomment">    // 'self' is an alias for 'var self: Self'</span>
    func returnX(using self) => x
    func returnY(self)       => self.y
<span class="linecomment">    // 'Self' is the corresponding type, in that case 'MyStruct'</span>
    func returnZ(me: Self)   => me.z
}
</code></div><div>If you declare your function with <code class="incode">mtd</code> (method) instead of <code class="incode">func</code>, then the first parameter is forced to be <code class="incode">using self</code>.</br>
If you declare your function with <code class="incode">mtdc</code> (method const) instead of <code class="incode">func</code>, then the first parameter is forced to be <code class="incode">const using self</code>.</br>
Other than that, it's exactly the same. So this is just <b>syntaxic sugar</b> to avoid repeating the <code class="incode">using self</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">impl MyStruct
{
    mtd  methodReturnX()          => x
    func funcReturnX(using self)  => x
}
</code></div><div class="code"><code style="white-space: break-spaces">var c: MyStruct
@assert(c.returnX() == 5)
@assert(c.methodReturnX() == 5)
@assert(c.funcReturnX() == 5)
@assert(c.returnY() == 10)
@assert(c.returnZ() == 20)
</code></div><div>All functions in an impl block can be retrieved by reflection, as long as the struct is declared with <code class="incode">#[Swag.ExportType("methods")]</code> (by default, methods are not exported).</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Creates a type alias named 'Lambda'</span>
alias Lambda = func(MyStruct)->s32

var fnX: Lambda
var fnY: Lambda
var fnZ: Lambda

<span class="linecomment">// The 'typeinfo' of a struct contains a field 'methods' which is a slice</span>
t := @typeof(MyStruct)
visit p: t.methods
{
<span class="linecomment">    // When visiting 'methods', the 'value' field contains the function pointer,</span>
<span class="linecomment">    // which can be casted to the correct type</span>
    switch p.name
    {
    case "returnX": fnX = cast(Lambda) p.value
    case "returnY": fnY = cast(Lambda) p.value
    case "returnZ": fnZ = cast(Lambda) p.value
    }
}

<span class="linecomment">// This are now valid functions, which can be called</span>
var v: MyStruct
@assert(fnX(v) == 5)
@assert(fnY(v) == 10)
@assert(fnZ(v) == 20)
</code></div>
<h3 id="063__special_functions">Special functions</h3>
<div>A struct can have special operations in the <code class="incode">impl</code> block. This operations are predefined, and known by the compiler.This is the way to go to <b>overload operators</b> for example.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Struct
{
    x, y: s32
}

alias OneType      = bool
alias AnotherType  = s32
alias WhateverType = bool

impl Struct
{
<span class="linecomment">    // Called each time a variable needs to be dropped</span>
<span class="linecomment">    // This is the destructor in C++</span>
    func opDrop(using self) {}

<span class="linecomment">    // Called after a raw copy operation from one value to another</span>
    func opPostCopy(using self) {}

<span class="linecomment">    // Called after a move semantic operation from one value to another. We'll see that later.</span>
    func opPostMove(using self) {}

<span class="linecomment">    // Get value by slice [low..up]</span>
<span class="linecomment">    // Must return a string or a slice</span>
    func opSlice(using self, low, up: u64)->string { return "true"; }

<span class="linecomment">    // Get value by index</span>
    func opIndex(using self, index: u64)->WhateverType { return true; }

<span class="linecomment">    // Called by @countof</span>
<span class="linecomment">    // Use in a 'loop' block for example</span>
    func opCount(using self)->u64          { return 0; }
<span class="linecomment">    // Called by @dataof</span>
    func opData(using self)->*WhateverType  { return null; }

<span class="linecomment">    // Called for explicit/implicit casting between struct value and return type</span>
<span class="linecomment">    // Can be overloaded by a different return type</span>
<span class="linecomment">    // Example: x := cast(OneType) v</span>
    func opCast(using self)->OneType      { return true; }
    func opCast(using self)->AnotherType  { return 0; }

<span class="linecomment">    // Called to compare the struct value with something else</span>
<span class="linecomment">    // Can be overloaded</span>
<span class="linecomment">    // Returns true if they are equal, otherwise returns false</span>
<span class="linecomment">    // Called by '==', '!='</span>
    func opEquals(using self, other: OneType)->bool      { return false; }
    func opEquals(using self, other: AnotherType)->bool  { return false; }

<span class="linecomment">    // Called to compare the struct value with something else</span>
<span class="linecomment">    // Can be overloaded</span>
<span class="linecomment">    // Returns -1, 0 or 1</span>
<span class="linecomment">    // Called by '<', '>', '<=', '>=', '<=>'</span>
    func opCmp(using self, other: OneType)->s32      { return 0; }
    func opCmp(using self, other: AnotherType)->s32  { return 0; }

<span class="linecomment">    // Affect struct with another value</span>
<span class="linecomment">    // Can be overloaded</span>
<span class="linecomment">    // Called by '='</span>
    func opAffect(using self, other: OneType) {}
    func opAffect(using self, other: AnotherType) {}

<span class="linecomment">    // Affect struct with a literal value with a specified suffix</span>
<span class="linecomment">    // Generic function, can be overloaded</span>
<span class="linecomment">    // Called by '='</span>
    func(suffix: string) opAffectSuffix(using self, value: OneType) {}
    func(suffix: string) opAffectSuffix(using self, value: AnotherType) {}

<span class="linecomment">    // Affect struct with another value at a given index</span>
<span class="linecomment">    // Can be overloaded</span>
<span class="linecomment">    // Called by '[] ='</span>
    func opIndexAffect(using self, index: u64, value: OneType) {}
    func opIndexAffect(using self, index: u64, value: AnotherType) {}

<span class="linecomment">    // Binary operator. 'op' generic argument contains the operator string</span>
<span class="linecomment">    // Generic function, can be overloaded</span>
<span class="linecomment">    // Called by '+', '-', '*', '/', '%', '|', '&', '^', '<<', '>>'</span>
    func(op: string) opBinary(using self, other: OneType)->Self     { return {1, 2}; }
    func(op: string) opBinary(using self, other: AnotherType)->Self { return {1, 2}; }

<span class="linecomment">    // Unary operator. 'op' generic argument contains the operator string (see below)</span>
<span class="linecomment">    // Generic function</span>
<span class="linecomment">    // Called by '!', '-', '~'</span>
    func(op: string) opUnary(using self)->Self { return {1, 2}; }

<span class="linecomment">    // Affect operator. 'op' generic argument contains the operator string (see below)</span>
<span class="linecomment">    // Generic function, can be overloaded</span>
<span class="linecomment">    // Called by '+=', '-=', '*=', '/=', '%=', '|=', '&=', '^=', '<<=', '>>='</span>
    func(op: string) opAssign(using self, other: OneType) {}
    func(op: string) opAssign(using self, other: AnotherType)  {}

<span class="linecomment">    // Affect operator. 'op' generic argument contains the operator string (see below)</span>
<span class="linecomment">    // Generic function, can be overloaded</span>
<span class="linecomment">    // Called by '+=', '-=', '*=', '/=', '%=', '|=', '&=', '^=', '<<=', '>>='</span>
    func(op: string) opIndexAssign(using self, index: u64, value: OneType) {}
    func(op: string) opIndexAssign(using self, index: u64, value: AnotherType) {}

<span class="linecomment">    // Called by a 'visit' block</span>
<span class="linecomment">    // Can have multiple versions, by adding a name after 'opVisit'</span>
<span class="linecomment">    // This is the way to go for iterators</span>
    #[Swag.Macro]
    {
        func(ptr: bool) opVisit(using self, stmt: code) {}
        func(ptr: bool) opVisitWhatever(using self, stmt: code) {}
        func(ptr: bool) opVisitAnother(using self, stmt: code) {}
    }
}
</code></div>
<h3 id="064__affectation">Affectation</h3>
<div><code class="incode">opAffect</code> is a way of assigning to a struct with <code class="incode">=</code>.</br>
You can have more the one opAffect with different types.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Struct
{
    x, y, z: s32 = 666
}

impl Struct
{
    mtd opAffect(value: s32)  { x, y = value; }
    mtd opAffect(value: bool) { x, y = value ? 1 : 0; }
}
</code></div><div class="code"><code style="white-space: break-spaces"><span class="linecomment">// This will initialize v and then call opAffect(s32) with '4'</span>
var v: Struct = 4's32
@assert(v.x == 4)
@assert(v.y == 4)
<span class="linecomment">// Note that variable 'v' is also initiliazed with the default values.</span>
<span class="linecomment">// So here 'z' is still 666.</span>
@assert(v.z == 666)

<span class="linecomment">// This will call opAffect(bool) with 'true'</span>
var v1: Struct = true
@assert(v1.x == 1)
@assert(v1.y == 1)

<span class="linecomment">// This will call opAffect(bool) with 'false'</span>
v1 = false
@assert(v1.x == 0)
@assert(v1.y == 0)
</code></div><div>If <code class="incode">opAffect</code> is supposed to initialize the full content of the struct, you can add <code class="incode">#[Swag.Complete]</code>. This will avoid every variables to be initialized to the default values, then changed later with the <code class="incode">opAffect</code> call.</br>
</div>
<div class="code"><code style="white-space: break-spaces">impl Struct
{
    #[Swag.Complete]
    mtd opAffect(value: u64)  { x, y, z = cast(s32) value; }

<span class="linecomment">    // For later</span>
    #[Swag.Implicit]
    mtd opAffect(value: u16)  { x, y = cast(s32) value; }
}
</code></div><div>Here the variable <code class="incode">v</code> will not be initialized prior to the affectation. This is more optimal, as there's only one initialization.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var v: Struct = 2'u64
@assert(v.x == 2)
@assert(v.y == 2)
@assert(v.z == 2)
</code></div><div class="code"><code style="white-space: break-spaces">func toto(v: Struct)
{
    @assert(v.x == 5)
    @assert(v.y == 5)
    @assert(v.z == 666)
}

func titi(v: Struct)
{
    @assert(v.y == 666)
}

<span class="linecomment">// By default, there's no automatic conversion for a function argument, so you must cast.</span>
<span class="linecomment">// Here, this will create a 'Struct' on the stack, initialized with a call to 'opAffect(s32)'</span>
toto(cast(Struct) 5's32)

<span class="linecomment">// But if opAffect is marked with #[Swag.Implicit], automatic conversion can occur.</span>
<span class="linecomment">// No need for an explicit cast.</span>
toto(5'u16)
</code></div><div>A structure can be converted to a constant by a call to opAffect if the function is marked with <code class="incode">Swag.ConstExpr</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Vector2
{
    x, y: f32
}

impl Vector2
{
    #[Swag.ConstExpr]
    mtd opAffect(one: f32)
    {
        x, y = one
    }
}

const One: Vector2 = 1.0    // This will call opAffect(1.0) at compile time
#assert One.x == 1.0
#assert One.y == 1.0
</code></div>
<h3 id="064__count">Count</h3>
<div class="code"><code style="white-space: break-spaces">struct MyStruct
{
}

impl MyStruct
{
    mtd opCount() => 4'u64
}
</code></div><div class="code"><code style="white-space: break-spaces">v := MyStruct{}

<span class="linecomment">// '@countof' will call 'opCount'</span>
@assert(@countof(v) == 4)

<span class="linecomment">// You can then loop on a struct value if 'opCount' has been defined</span>
cpt := 0
loop v
    cpt += 1

@assert(cpt == 4)
</code></div>
<h3 id="064__post_copy_and_post_move">Post copy and post move</h3>
<div>Swag accepts copy and move semantics for structures. In this examples, we use a <code class="incode">Vector3</code> to illustrate, even if of course that kind of struct does not need a move semantic, as there's no heap involved.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Vector3
{
    x, y, z: s32 = 666
}

impl Vector3
{
<span class="linecomment">    // This is used for 'copy semantic'.</span>
    mtd opPostCopy()
    {
        x, y, z += 1
    }

<span class="linecomment">    // This is used for 'move semantic'.</span>
    mtd opPostMove()
    {
        x, y, z += 2
    }

<span class="linecomment">    // Just imagine that we have something to drop. Like a memory allocated buffer.</span>
    mtd opDrop()
    {
    }
}
</code></div><div class="code"><code style="white-space: break-spaces">a := Vector3{}
b := Vector3{100, 200, 300}

<span class="linecomment">// "copy semantic". The default behaviour.</span>
<span class="linecomment">// 1. This will call 'opDrop' on 'a' if the function exists because 'a' could be already assigned.</span>
<span class="linecomment">// 2. This will raw copy 'b' to 'a'.</span>
<span class="linecomment">// 3. This will call 'opPostCopy' on 'a' if it exists.</span>
a = b
@assert(a.x == 101)     // +1 because of the call to opPostCopy
@assert(a.y == 201)
@assert(a.z == 301)

<span class="linecomment">// "move semantic"</span>
<span class="linecomment">// 1. This will call 'opDrop' on 'a' if it exists</span>
<span class="linecomment">// 2. This will raw copy 'b' to 'a'</span>
<span class="linecomment">// 3. This will call 'opPostMove' on 'a' if it exists</span>
<span class="linecomment">// 4. This will reinitialize 'b' to its default values if 'opDrop' exists</span>
a =,move b
@assert(a.x == 102)     // +2 because of the call to opPostMove
@assert(a.y == 202)
@assert(a.z == 302)

<span class="linecomment">// 'Vector3' contains an 'opDrop' special function, so 'b' will be reinitialized to</span>
<span class="linecomment">// the default values after the 'move'. Default values are 666.</span>
@assert(b.x == 666)

<span class="linecomment">// If you know what you're doing, you can avoid the first call to 'opDrop' with '=,nodrop'</span>
<span class="linecomment">// Do it when you know the state of 'a' and do not want an extra unnecessary call</span>
<span class="linecomment">// (for example if 'a' is in an undetermined state).</span>

a =,nodrop b            // Copy b to a without dropping 'a' first
a =,nodrop,move b       // Move b to a without dropping 'a' first

<span class="linecomment">// For the 'move semantic', you can avoid the last reinitialization by using '=,moveraw'. Of source, do this at your own risk, if you know that 'b' will never by dropped by the compiler or if you reinitialize its state yourself.</span>

<span class="linecomment">// instead of '=,move'</span>
a =,moveraw b
a =,nodrop,moveraw b
</code></div><div><code class="incode">moveref</code> can be used instead of <code class="incode">ref</code> in a function parameter to declare a move semantic intention.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// This is the 'move' version of 'assign'. With 'moveref', we tell the compiler that this version will take the owership on 'from'.</span>
func assign(to: ref Vector3, from: moveref Vector3)
{
    to =,move from
}

<span class="linecomment">// This is the normal 'copy' version. In this version, 'from' will not be changed, that's why it's constant (not a ref).</span>
func assign(to: ref Vector3, from: Vector3)
{
    to = from
}

a := Vector3{1, 2, 3}
var b: Vector3

<span class="linecomment">// Call the 'copy' version of 'assign'.</span>
assign(&b, a)
<span class="linecomment">// As this will call 'opPostCopy', we have +1 on each field.</span>
@assert(b.x == 2 and b.y == 3 and b.z == 4)
<span class="linecomment">// 'a' remains unchanged</span>
@assert(a.x == 1 and a.y == 2 and a.z == 3)

<span class="linecomment">// Now we tell the compiler to use the 'moveref' version of 'assign'.</span>
assign(&b, moveref &a)
<span class="linecomment">// As 'opPostMove' has been called, we have +2 on each field.</span>
@assert(b.x == 3 and b.y == 4 and b.z == 5)
<span class="linecomment">// And as this is a move, then 'a' is now reinitialized to its default values.</span>
@assert(a.x == 666 and a.y == 666 and a.z == 666)
</code></div>
<h3 id="064__visit">Visit</h3>
<div>You can visit a struct value if a macro <code class="incode">opVisit</code> has been defined. This is the equivalent of an <b>iterator</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct MyStruct
{
    x: s32 = 10
    y: s32 = 20
    z: s32 = 30
}

impl MyStruct
{
    #[Swag.Macro]
    func(ptr: bool) opVisit(self, stmt: code)
    {
<span class="linecomment">        // 'ptr' is a generic parameter that tells if we want to visit by pointer.</span>
<span class="linecomment">        // We do not use it in this example.</span>
        #if ptr #error "visiting myStruct by pointer is not supported"

<span class="linecomment">        // Loop on the 3 fields</span>
        loop idx: 3
        {
<span class="linecomment">            // The '#macro' force its body to be in the scope of the caller</span>
            #macro
            {
<span class="linecomment">                // @alias0 will be the value</span>
                var @alias0: s32 = undefined

<span class="linecomment">                // As this code is in the caller scope, with need to add a #up before 'idx' to reference the</span>
<span class="linecomment">                // variable of this function (and not a potential variable in the caller scope)</span>
                switch #up idx
                {
                case 0: @alias0 = #up self.x   // Same for function parameter 'self'
                case 1: @alias0 = #up self.y
                case 2: @alias0 = #up self.z
                }

<span class="linecomment">                // @alias1 will be the index</span>
                @alias1 := @index

<span class="linecomment">                // include user code</span>
                #mixin #up stmt
            }
        }
    }
}
</code></div><div class="code"><code style="white-space: break-spaces">myStruct := MyStruct{}
cpt := 0

<span class="linecomment">// Visiting each field in declaration order</span>
<span class="linecomment">// 'v' is an alias for @alias0 (value)</span>
<span class="linecomment">// 'i' is an alias for @alias1 (index)</span>
visit v, i: myStruct
{
    switch i
    {
    case 0: @assert(v == 10)
    case 1: @assert(v == 20)
    case 2: @assert(v == 30)
    }

    cpt += 1
}

@assert(cpt == 3)
</code></div><div>You can have variants of <code class="incode">opVisit</code> by specifying an <b>additional name</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">impl MyStruct
{
    #[Swag.Macro]
    mtd(ptr: bool) opVisitReverse(stmt: code)   // We add 'Reverse' in the name
    {
<span class="linecomment">        // Visit fields in reverse order (z, y then x)</span>
        loop idx: 3
        {
            #macro
            {
                var @alias0: s32 = undefined
                switch #up idx
                {
                case 0: @alias0 = #up self.z
                case 1: @alias0 = #up self.y
                case 2: @alias0 = #up self.x
                }

                @alias1 := @index
                #mixin #up stmt
            }
        }
    }
}
</code></div><div class="code"><code style="white-space: break-spaces">myStruct := MyStruct{}
cpt := 0

<span class="linecomment">// To call a variant, add the extra name between parenthesis.</span>
visit(Reverse) v, i: myStruct
{
    switch i
    {
    case 0: @assert(v == 30)
    case 1: @assert(v == 20)
    case 2: @assert(v == 10)
    }

    cpt += 1
}

@assert(cpt == 3)
</code></div>
<h3 id="067__offset">Offset</h3>
<div>
</br>
 You can force the layout of a field with the <code class="incode">Swag.Offset</code> attribute.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct
    {
        x: s32

<span class="linecomment">        // 'y' is located at the same offset as 'x', so they share the same space</span>
        #[Swag.Offset("x")]
        y: s32
    }

    #assert @sizeof(MyStruct) == 4
    v := MyStruct{}
    v.x = 666

<span class="linecomment">    // As 'y' and 'x' are sharing the same space, affecting to 'x' also affects to 'y'.</span>
    @assert(v.y == 666)
}
</code></div><div>
</br>
 An example to reference a field by index.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct
    {
        x, y, z:    f32

        #[Swag.Offset("x")]
        idx:        [3] f32
    }

    var v: MyStruct
    v.x = 10; v.y = 20; v.z = 30
    @assert(v.idx[0] == v.x)
    @assert(v.idx[1] == v.y)
    @assert(v.idx[2] == v.z)
}
</code></div>
<h3 id="068__packing">Packing</h3>
<div>You can also control the struct layout with two attributes: <code class="incode">#[Swag.Pack]</code> and <code class="incode">#[Swag.Align]</code>.</br>
</div>
<div>
</br>
 The default struct packing is the same as in C: each field is aligned to the size of the type. This is the equivalent of <code class="incode">#[Swag.Pack(0)]</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct
    {
        x: bool     // offset 0: aligned to 1 byte
        y: s32      // offset 4: s32 is aligned to 4 bytes (so here there's 3 bytes of padding before)
        z: s64      // offset 8: aligned to 8 bytes
    }

<span class="linecomment">    // '@offsetof' can be used to retrieve the offset of a field</span>
    #assert @offsetof(MyStruct.x) == 0
    #assert @offsetof(MyStruct.y) == 4
    #assert @offsetof(MyStruct.z) == 8
    #assert @sizeof(MyStruct)     == 16
}
</code></div><div>
</br>
 You can <i>reduce</i> the packing of the fields with <code class="incode">#[Swag.Pack]</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Pack(1)]
    struct MyStruct1
    {
        x: bool // offset 0: 1 byte
        y: s32  // offset 1: 4 bytes (no padding)
    }

    #assert @offsetof(MyStruct1.x) == 0
    #assert @offsetof(MyStruct1.y) == 1
    #assert @sizeof(MyStruct1)     == 5

    #[Swag.Pack(2)]
    struct MyStruct2
    {
        x: bool // offset 0: 1 byte
        y: s32  // offset 2: 4 bytes (1 byte of padding before)
    }

    #assert @offsetof(MyStruct2.x) == 0
    #assert @offsetof(MyStruct2.y) == 2
    #assert @sizeof(MyStruct2)     == 6

    #[Swag.Pack(4)]
    struct MyStruct3
    {
        x: bool // offset 0: 1 byte
        y: s64  // offset 4: 8 bytes (3 bytes of padding before)
    }

    #assert @offsetof(MyStruct3.x) == 0
    #assert @offsetof(MyStruct3.y) == 4
    #assert @sizeof(MyStruct3)     == 12
}
</code></div><div>
</br>
 The total struct size is always a multiple of the biggest alignement of the fields.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct1
    {
        x: s32  // 4 bytes
        y: bool // 1 byte
<span class="linecomment">        // 3 bytes of padding because of 'x', to aligned on 's32'</span>
    }

    #assert @sizeof(MyStruct1) == 8
}
</code></div><div>
</br>
 You can force the struct alignement with <code class="incode">#[Swag.Align]</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct1
    {
        x: bool     // 1 byte
        y: bool     // 1 byte
    }

    #assert @offsetof(MyStruct1.x) == 0
    #assert @offsetof(MyStruct1.y) == 1
    #assert @sizeof(MyStruct1)     == 2

    #[Swag.Align(8)]
    struct MyStruct2
    {
        x: bool     // 1 byte
        y: bool     // 1 byte
<span class="linecomment">        // 6 bytes of padding to be a multiple of '8'</span>
    }

    #assert @offsetof(MyStruct2.x) == 0
    #assert @offsetof(MyStruct2.y) == 1
    #assert @sizeof(MyStruct2)     == 8
}
</code></div><div>
</br>
 You can also force each field to be aligned on a specific value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct MyStruct1
    {
        x: bool // offset 0: 1 byte
        #[Swag.Align(8)]
        y: bool // offset 8: aligned to 8 (7 bytes of padding before)
    }

    #assert @sizeof(MyStruct1) == 9

    #[Swag.Align(8)]
    struct MyStruct2
    {
        x: bool // offset 0: 1 byte
        #[Swag.Align(4)]
        y: bool // offset 4: aligned to 4 (3 bytes of padding before)
<span class="linecomment">        // 3 bytes of padding to be a multiple of 8</span>
    }

    #assert @sizeof(MyStruct2) == 8
}
</code></div>
<h2 id="070_union">Union</h2>
<div>An union is just a struct where all fields are located at offset 0.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    union MyUnion
    {
        x, y, z: f32
    }

    v := MyUnion{x: 666}
    @assert(v.y == 666)
    @assert(v.z == 666)
}
</code></div>
<h2 id="075_interface">Interface</h2>
<div>Interfaces are <b>virtual tables</b> (a list of function pointers) that can be associated to a struct.</br>
</br>
Unlike c++, the virtual table is not embedded with the struct. It is a separate object.</br>
You can then <i>implement</i> an interface for a given struct without changing the struct definition.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Point2
{
    x, y: f32
}

struct Point3
{
    x, y, z: f32
}
</code></div><div>Here we declare an interface, with two functions <code class="incode">set</code> and <code class="incode">reset</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">interface IReset
{
<span class="linecomment">    // You must declare a lambda variable for each "virtual" function.</span>
<span class="linecomment">    // As the first parameter is always 'self', you can either declare it</span>
<span class="linecomment">    // yourself or use 'mtd/mtdc'</span>
    set: mtd(f32)

<span class="linecomment">    // You can also use the normal "func/mtd/mtdc" declaration.</span>
<span class="linecomment">    // The compiler will then create the table entry for you.</span>
    mtd reset()
}
</code></div><div>You can implement an interface for any given struct with <code class="incode">impl</code> and <code class="incode">for</code>.</br>
For example here, we implement interface <code class="incode">IReset</code> for struct <code class="incode">Point2</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">impl IReset for Point2
{
    mtd set(val: f32)
    {
        x = val
        y = val+1
    }

    mtd reset()
    {
        x, y = 0
    }
}
</code></div><div>And we implement interface <code class="incode">IReset</code> also for struct <code class="incode">Point3</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">impl IReset for Point3
{
    mtd set(val: f32)
    {
        x = val
        y = val+1
        z = val+2
    }

    mtd reset()
    {
        x, y, z = 0
    }
}
</code></div><div class="code"><code style="white-space: break-spaces">var pt2: Point2
var pt3: Point3

<span class="linecomment">// To get the interface associated to a given struct, use the 'cast' operator.</span>
<span class="linecomment">// If the compiler does not find the corresponding implementation, it will raise an error.</span>
itf := cast(IReset) pt2
itf.set(10)
@assert(pt2.x == 10)
@assert(pt2.y == 10+1)

itf = cast(IReset) pt3
itf.set(10)
@assert(pt3.x == 10)
@assert(pt3.y == 10+1)
@assert(pt3.z == 10+2)
itf.reset()
@assert(pt3.x == 0 and pt3.y == 0)

<span class="linecomment">// You can also access, with a normal call, all functions declared in an interface</span>
<span class="linecomment">// implementation block for a given struct.</span>
<span class="linecomment">// They are located in a dedicated scope.</span>
pt2.IReset.set(10)
pt2.IReset.reset()
pt3.IReset.set(10)
pt3.IReset.reset()

<span class="linecomment">// An interface is a real type, with a size equivalent to 2 pointers</span>
#assert @sizeof(itf) == 2 * @sizeof(*void)

<span class="linecomment">// You can retrieve the concrete type associated with an interface instance with '@kindof'</span>
itf = cast(IReset) pt2
@assert(@kindof(itf) == Point2)
itf = cast(IReset) pt3
@assert(@kindof(itf) == Point3)

<span class="linecomment">// You can retrieve the concrete data associated with an interface instance with '@dataof'</span>
itf = cast(IReset) pt2
@assert(@dataof(itf) == &pt2)
itf = cast(IReset) pt3
@assert(@dataof(itf) == &pt3)
</code></div>
<h2 id="080_safety">Safety</h2>
<div>Swag comes with a bunch of safety checks which can be activated by module/function/instruction with the <code class="incode">#[Swag.Safety]</code> attribute.</br>
</br>
Safety checks can also be changed for a specific build configuration (<code class="incode">--cfg:<config></code>) with <code class="incode">buildCfg.safetyGuards</code>.</br>
</br>
Swag comes with four predefined configurations : <code class="incode">debug</code>, <code class="incode">fast-debug</code>, <code class="incode">fast-compile</code> and <code class="incode">release</code>. Safety checks are disabled in <code class="incode">fast-compile</code> and <code class="incode">release</code>.</br>
</div>
<div><h3 id="#[Swag.Safety("overflow", true)]">#[Swag.Safety("overflow", true)]</br>
</h3>Swag will panic if some operators overflow and if we lose some bits during an integer conversion.</br>
</br>
Operators that can overflow are : <code class="incode">+ - * << >></code> and their equivalent <code class="incode">+= -= *= <<= >>=</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x := 255'u8
<span class="linecomment">// x += 1      // This would overflow, and panic, because we lose informations</span>
</code></div><div>But if you know what your are doing, you can use a special version of those operators, which will not panic. Add the <code class="incode">,over</code> modifier after the operation. This will disable safety checks.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x := 255'u8
x +=,over 1     // Overflow is expected, so this will wrap around
@assert(x == 0)
</code></div><div>You can also use <code class="incode">#[Swag.Overflow(true)]</code> to authorize overflow on a more global scale.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.Overflow(true)]
</code></div><div class="code"><code style="white-space: break-spaces">x := 255'u8
x += 1     // No need for operator modifier ',over'
@assert(x == 0)
</code></div><div>For 8 or 16 bits, you can promote an operation to 32 bits by using ',up'.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x := 255'u8 +,up 1
@assert(x == 256)
@assert(@typeof(x) == u32)
</code></div><div>Swag will also check that a cast does not lose information.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x1 := 255'u8

<span class="linecomment">//y0 := cast(s8) x1     // This would lose information and panic, as 255 cannot be encoded in 's8'</span>
<span class="linecomment">//@print(y0)</span>

y1 := cast,over(s8) x1  // But ',over' can be used on the cast operation too
@assert(y1 == -1)

x2 := -1's8
<span class="linecomment">//y2 := cast(u8) x2     // This cast also is not possible, because 'x2' is negative and 'y' is 'u8'</span>
<span class="linecomment">//@print(y)</span>
y2 := cast,over(u8) x2
@assert(y2 == 255)
</code></div><div>Rember that you can disable these safety checks with the corresponding attribute.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.Overflow(true)]
</code></div><div class="code"><code style="white-space: break-spaces">x := 255'u8
x += 255    // 254
x += 1      // 255
x >>= 1     // 127
@assert(x == 127)
</code></div><div><h3 id="#[Swag.Safety("any", true)]">#[Swag.Safety("any", true)]</br>
</h3>Swag will panic if a bad cast from 'any' is performed.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var x: any = "1"
y := cast(string) x     // This is valid, because this is the correct underlying type
<span class="linecomment">//z := cast(s32) x      // This is not valid, and will panic</span>
<span class="linecomment">//@assert(z == 0)</span>
</code></div><div><h3 id="#[Swag.Safety("boundcheck", true)]">#[Swag.Safety("boundcheck", true)]</br>
</h3>Swag will panic if an index is out of range when dereferencing a sized value like an array, a slice, a string...</br>
</div>
<div>Safety for fixed size arrays.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x := [0, 1, 2]
idx := 10
<span class="linecomment">//@assert(x[idx] == 1)     // '10' is out of range, will panic</span>
</code></div><div>Safety when indexing a slice.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var x: const [..] s32 = [0, 1, 2]
idx := 1
@assert(x[idx] == 1)        // '1' is in range, ok
idx += 9
<span class="linecomment">//@assert(x[idx] == 1)      // '10' is out of range, will panic</span>
</code></div><div>Safety when slicing a sized value.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var x: const [..] s32 = [0, 1, 2]
<span class="linecomment">//slice := x[1..4]              // '4' is out of range, will panic</span>
<span class="linecomment">//@assert(slice[0] == 1)</span>
</code></div><div class="code"><code style="white-space: break-spaces">x := "string"
idx := 10
<span class="linecomment">//slice := x[0..idx]            // '10' is out of range, will panic</span>
<span class="linecomment">//@assert(slice[0] == "s"'u8)</span>
</code></div><div><h3 id="#[Swag.Safety("math", true)]">#[Swag.Safety("math", true)]</br>
</h3>Swag will panic if some math operations are invalid.</br>
</div>
<div>Division by zero.</br>
</div>
<div class="code"><code style="white-space: break-spaces">x := 1'f32
y := 0'f32
<span class="linecomment">//z := x / y        // Division by zero, panic</span>
<span class="linecomment">//@print(z)</span>
</code></div><div>Swag will also check for invalid arguments on some math intrinsics.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// All of this will panic, because arguments are incorrect.</span>

<span class="linecomment">//@abs(-128)</span>
<span class="linecomment">//@log(-2'f32)</span>
<span class="linecomment">//@log2(-2'f32)</span>
<span class="linecomment">//@log10(2'f64)</span>
<span class="linecomment">//@sqrt(-2'f32)</span>
<span class="linecomment">//@asin(-2'f32)</span>
<span class="linecomment">//@acos(2'f32)</span>
</code></div><div><h3 id="#[Swag.Safety("switch", true)]">#[Swag.Safety("switch", true)]</br>
</h3>Swag will panic if a switch is marked with #[Swag.Complete], but the value is not covered by a 'case'.</br>
</div>
<div><h3 id="#[Swag.Safety("bool", true)]">#[Swag.Safety("bool", true)]</br>
</h3>Swag will panic if a boolean value is not 'true' (1) or 'false' (0).</br>
</div>
<div><h3 id="#[Swag.Safety("nan", true)]">#[Swag.Safety("nan", true)]</br>
</h3>Swag will panic if a floating point 'NaN' is used.</br>
</div>

<h2 id="100_function">Function</h2>

<h3 id="101__declaration">Declaration</h3>
<div>A function declaration usually starts with the <code class="incode">func</code> keyword followed by the function name.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func toto()
{
}
</code></div><div>If the function needs to return a value, you must add <code class="incode">-></code> followed by the type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func toto1()->s32
{
    return 0
}
</code></div><div>The return type can be deduced in case of a simple expression, by using <code class="incode">=></code> instead of <code class="incode">-></code>.</br>
Here the return type will be deduced to be <code class="incode">s32</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func sum(x, y: s32) => x + y
</code></div><div>A short version exists, in case of a function returning nothing.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func print(val: string) = @print(val)
</code></div><div>Parameters are specified after the function name, between parenthesis.</br>
Here we declare two parameters <code class="incode">x</code> and <code class="incode">y</code> of type <code class="incode">s32</code>, and one last parameter of type <code class="incode">f32</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func sum1(x, y: s32, unused: f32)->s32
{
    return x + y
}
</code></div><div>Parameters can have default values.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func sum2(x, y: s32, unused: f32 = 666)->s32
{
    return x + y
}
</code></div><div>The type of the parameters can be deduced if you specify a default value.</br>
Here <code class="incode">x</code> and <code class="incode">y</code> have the type <code class="incode">f32</code> because <code class="incode">0.0</code> is a 32 bits floating point literal.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func sum3(x, y = 0.0)
{
    #assert @typeof(x) == f32
    #assert @typeof(y) == f32
}

enum Values { A; B; }
func toto(x: s32, y = Values.A)
{
    #assert @typeof(y) == Values
}
</code></div><div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Functions can be nested inside other functions. This are not closure but just functions in a sub scope.</span>
func sub(x, y: s32) => x - y
</code></div><div>
</br>
 Simple call.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := sub(5, 2)
    @assert(x == 3)
}
</code></div><div>You can name parameters, and don't have to respect parameters order in that case.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func sub(x, y: s32) => x - y

{
    x1 := sub(x: 5, y: 2)
    @assert(x1 == 3)
    x2 := sub(y: 5, x: 2)
    @assert(x2 == -3)
}

{
    func returnMe(x, y: s32 = 0) => x + y * 2
    @assert(returnMe(x: 10) == 10)
    @assert(returnMe(y: 10) == 20)
}
</code></div><div><h4 id="Multiple return values">Multiple return values</br>
</h4></div>
<div>
</br>
 A <b>tuple</b> can be used to return multiple values in a function.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func myFunction() -> {f32, f32}
    {
        return {1.0, 2.0}
    }

    result := myFunction()
    @assert(result.item0 == 1.0)
    @assert(result.item1 == 2.0)

    var (x, y) = myFunction()
    @assert(x == 1.0)
    @assert(y == 2.0)

    (z, w) := myFunction()
    @assert(z == 1.0)
    @assert(w == 2.0)
}

<span class="linecomment">// You can name the fields of the function result too</span>
func returns2() -> {x: s32, y: s32}
{
<span class="linecomment">    // You can return a tuple literal as long as the types match</span>
    if false
        return {1, 2}

<span class="linecomment">    // Or use the specifal type 'retval' which is an alias to the</span>
<span class="linecomment">    // function return type (but not only, we'll see later)</span>
    using var result: retval
    x = 1
    y = 2
    return result
}

<span class="linecomment">// You can access the tuple fields with the names (if specified), or with 'item?'</span>
result := returns2()
@assert(result.x == 1)
@assert(result.item0 == 1)
@assert(result.y == 2)
@assert(result.item1 == 2)

<span class="linecomment">// You can deconstruct the returned tuple</span>
(x, y) := returns2()
@assert(x == 1)
@assert(y == 2)
</code></div>
<h3 id="102__lambda">Lambda</h3>
<div>A lambda is just a <b>pointer to a function</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func myFunction0() {}
func myFunction1(x: s32) => x * x

<span class="linecomment">// 'ptr0' is declared as a pointer to a function that takes no parameter, and returns nothing</span>
var ptr0: func() = &myFunction0
ptr0()

<span class="linecomment">// Here type of 'ptr1' is deduced from 'myFunction1'</span>
ptr1 := &myFunction1
@assert(myFunction1(2) == 4)
@assert(ptr1(2) == 4)
</code></div><div>A lambda can be null.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var lambda: func()->bool
@assert(lambda == null)
</code></div><div>You can use a lambda as a function parameter type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">alias callback = func(s32)->s32
func toDo(value: s32, ptr: callback)->s32 => ptr(value)

func square(x: s32) => x * x
@assert(toDo(4, &square) == 16)
</code></div><div><h4 id="Anonymous functions">Anonymous functions</br>
</h4>You can also create <i>anonymous functions</i> (aka functions as literals).</br>
</div>
<div class="code"><code style="white-space: break-spaces">cb := func(x: s32)->s32 => x * x
@assert(cb(4) == 16)
cb = func(x: s32)->s32 => x * x * x
@assert(cb(4) == 64)
</code></div><div>Anonymous functions can be passed as parameters to another function.</br>
</div>
<div class="code"><code style="white-space: break-spaces">alias callback = func(s32)->s32
func toDo(value: s32, ptr: callback)->s32 => ptr(value)

@assert(toDo(4, func(x: s32) => x * x) == 16)
@assert(toDo(4, func(x: s32) => x + x) == 8)
@assert(toDo(4, func(x: s32)->s32 { return x - x; }) == 0)
</code></div><div>The types of the parameters can be deduced.</br>
</div>
<div class="code"><code style="white-space: break-spaces">alias callback = func(s32)->s32
func toDo(value: s32, ptr: callback)->s32 => ptr(value)

@assert(toDo(4, func(x) => x * x) == 16)
@assert(toDo(4, func(x) => x + x) == 8)
@assert(toDo(4, func(x) { return x - x; }) == 0)
</code></div><div>When you affect a lambda to a variable, the type of parameters and the return type can also be omitted, as they will be deduced from the variable type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var fct: func(s32, s32)->bool

fct = func(x, y) => x == y
@assert(fct(10, 10))

fct = func(x, y) { return x != y; }
@assert(fct(20, 120))
</code></div><div>Lambdas can have default parameters values.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := func(val = true) {
        @assert(val == true)
    }

    x()
</code></div><div class="code"><code style="white-space: break-spaces">    {
        var x: func(val: bool = true)

        x = func(val) {
            @assert(val == true)
        }

        x()
        x(true)
    }
}
</code></div>
<h3 id="103__closure">Closure</h3>
<div>Swag supports a limited set of the <code class="incode">closure</code> concept.</br>
</br>
Only a given amount of bytes of capture are possible (for now 48 bytes). That way there's never an hidden allocation.</br>
Another limitation is that you can only capture 'simple' variables (no struct with <code class="incode">opDrop</code>, <code class="incode">opPostCopy</code>, <code class="incode">opPostMove</code> for example).</br>
</div>
<div>
</br>
 A closure is declared like a lambda, with the captured variables between <code class="incode">|...|</code> before the function parameters.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    a := 125
    b := 521

<span class="linecomment">    // Capture 'a' and 'b'</span>
    var fct: closure() = closure|a, b|()
    {
        @assert(a == 125)
        @assert(b == 521)
    }

    fct()
}
</code></div><div>
</br>
 You can also capture by pointer with <code class="incode">&</code> (otherwise it's a copy).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    a := 125

<span class="linecomment">    // Capture 'a' by pointer</span>
    var fct: closure() = closure|&a|()
    {
<span class="linecomment">        // We can change the value of the local variable 'a'</span>
        dref a += 1
    }

    fct()
    @assert(a == 126)
    fct()
    @assert(a == 127)
}
</code></div><div>
</br>
 You can also capture by reference with <code class="incode">ref</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    a := 125

<span class="linecomment">    // Capture 'a' by reference</span>
    fct := closure|ref a|()
    {
<span class="linecomment">        // We can change the value of the local variable 'a'</span>
        a += 1
    }

    fct()
    @assert(a == 126)
    fct()
    @assert(a == 127)
}
</code></div><div>
</br>
 You can assign a normal lambda (no capture) to a closure variable.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var fct: closure(s32, s32)->s32

    fct = func(x, y) => x + y
    @assert(fct(1, 2) == 3)
}
</code></div><div>
</br>
 You can capture arrays, structs, slices etc... as long as it fits in the maximum storage of 'n' bytes (and as long as the struct is a pod).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := [1, 2, 3]

    var fct: closure(s32)->s32

<span class="linecomment">    // Capture the array 'x' by making a copy</span>
    fct = closure|x|(toAdd)
    {
        res := 0
        visit v: x
            res += v
        res += toAdd
        return res
    }

    result := fct(4)
    @assert(result == 1 + 2 + 3 + 4)
}
</code></div><div>
</br>
 Captured variables are mutable, and part of the closure. So you can modify them.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func getInc()->closure()->s32
    {
        x := 10

        return closure|x|()->s32 {
            x += 1
            return x
        }
    }

    fct := getInc()
    @assert(fct() == 11)
    @assert(fct() == 12)
    @assert(fct() == 13)
</code></div><div class="code"><code style="white-space: break-spaces">}
</code></div>
<h3 id="104__mixin">Mixin</h3>
<div>
</br>
 A mixin is declared like a function, with the attribute <code class="incode">#[Swag.Mixin]</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Mixin]
    func myMixin()
    {
    }
}
</code></div><div>
</br>
 A mixin function is inserted in the scope of the caller.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Mixin]
    func myMixin()
    {
        a += 1
    }

    a := 0
    myMixin()   // Equivalent to 'a += 1'
    myMixin()   // Equivalent to 'a += 1'
    @assert(a == 2)
}
</code></div><div>
</br>
 This behaves like a function, so you can add parameters.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Mixin]
    func myMixin(increment: s32 = 1)
    {
        a += increment
    }

    a := 0
    myMixin()   // Equivalent to 'a += 1'
    myMixin(2)  // Equivalent to 'a += 2'
    @assert(a == 3)
}
</code></div><div>
</br>
 A mixin accepts parameters of type <code class="incode">code</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Mixin]
    func doItTwice(what: code)
    {
<span class="linecomment">        // You can then insert the code with '#mixin'</span>
        #mixin what
        #mixin what
    }

    a := 0
    doItTwice(#code {a += 1;})
    @assert(a == 2)
}
</code></div><div>
</br>
 When the last parameter of a mixin is of type <code class="incode">code</code>, the caller can declare that code in a statement just after the call.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Mixin]
    func doItTwice(value: s32, what: code)
    {
        #mixin what
        #mixin what
    }

    a := 0
    doItTwice(4)
    {
        a += value
    }

    doItTwice(2)
    {
        a += value
    }

    @assert(a == 12)
}
</code></div><div>
</br>
 You can use the special name <code class="incode">@alias</code> to create a named alias for an identifier.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Mixin]
    func inc10()
    {
        @alias0 += 10
    }

    a, b := 0
    inc10(|a|)  // Passing alias name 'a'
    inc10(|b|)  // Passing alias name 'b'
    @assert(a == b and b == 10)
}

{
    #[Swag.Mixin]
    func setVar(value: s32)
    {
        var @alias0 = value
    }

    setVar(|a| 10)  // Passing alias name 'a'
    setVar(|b| 20)  // Passing alias name 'b'
    @assert(a == 10)
    @assert(b == 20)
    setVar(30)      // No alias, so name is @alias0
    @assert(@alias0 == 30)
}
</code></div><div>
</br>
 You can declare special variables named <code class="incode">@mixin?</code>. Those variables will have a unique name each time the mixin is used. So the same mixin, even if it declares local variables, can be used multiple time in the same scope.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var total: s32

    #[Swag.Mixin]
    func toScope()
    {
        var @mixin0: s32 = 1
        total += @mixin0
    }

    toScope()
    toScope()
    toScope()

    @assert(total == 3)
}
</code></div>
<h3 id="105__macro">Macro</h3>
<div>
</br>
 A macro, like a mixin, is declared like a function, but with the attribute <code class="incode">Swag.Macro</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Macro]
    func myMacro()
    {
    }
}
</code></div><div>
</br>
 Unlike a mixin, a macro has its own scope, and cannot conflict with the function it is inserted inside.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Macro]
    func myMacro()
    {
        a := 666    // 'a' is declared in the scope of 'myMacro'
    }

    a := 0
    myMacro()   // no conflict with the 'a' declared above
    @assert(a == 0)
}
</code></div><div>
</br>
 But you can force an identifier to be found outside of the scope of the macro with <code class="incode">#up</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Macro]
    func myMacro()
    {
        #up a += 1 // Add '#up' before the identifier to reference the 'a' of the caller
    }

    a := 0
    myMacro()
    myMacro()
    @assert(a == 2)
}
</code></div><div>
</br>
 Like a mixin, macro accepts <code class="incode">code</code> parameters.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Macro]
    func myMacro(what: code)
    {
        #mixin what
    }

    a := 0

    myMacro(#code { #up a += 1; } )

    myMacro()
    {
        #up a += 1
    }

    @assert(a == 2)
}
</code></div><div>
</br>
 You can use <code class="incode">#macro</code> inside a macro to force the code after to be in the same scope of the caller. That is, no <code class="incode">#up</code> is necessary to reference variables of the caller.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Macro]
    func myMacro(what: code)
    {
<span class="linecomment">        // No conflict, in its own scope</span>
        a := 666

        #macro
        {
<span class="linecomment">            // In the scope of the caller</span>
            #mixin #up what
        }
    }

    a := 1
    myMacro()
    {
        a += 2  // will reference the 'a' above because this code has been inserted inside '#macro'
    }

    @assert(a == 3)
}
</code></div><div>
</br>
 You can extend the language with macros, without using pointers to functions (no lambda call cost).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Macro]
    func repeat(count: s32, what: code)
    {
        a := 0
        while a < count
        {
            #macro
            {
                index := #up a
                #mixin #up what
            }

            a += 1
        }
    }

    a := 0
    repeat(5) { a += index; }
    @assert(a == 0+1+2+3+4)
    repeat(3) { a += index; }
    @assert(a == 10+3)
}
</code></div><div>
</br>
 When you need <code class="incode">break</code> in the user code to break outside of a multi loop.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Macro]
    func repeatSquare(count: u32, what: code)
    {
        #scope Up loop count
        {
            loop count
            {
                #macro
                {
<span class="linecomment">                    // 'break' in the user code will be replaced by 'break Up'</span>
<span class="linecomment">                    // So it will break outside the outer loop</span>
                    #mixin #up what { break = break Up; }
                }
            }
        }
    }

    a := 0
    repeatSquare(5)
    {
        a += 1
        if a == 10
            break
    }

    @assert(a == 10)
}
</code></div><div>
</br>
 In a macro, you can use special variables named <code class="incode">@alias<num></code>. Note that this is also valid for mixins.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Macro]
    func call(v: s32, stmt: code)
    {
        @alias0 := v
        @alias1 := v * 2
        #mixin stmt
    }

    call(20)
    {
        @assert(@alias0 == 20)
        @assert(@alias1 == 40)
    }

<span class="linecomment">    // The caller can then name those special variables</span>
<span class="linecomment">    // Use |name0, name1, ...| before the function call parameters</span>
    call(|x| 20)
    {
        @assert(x == 20)        // x is @alias0
        @assert(@alias1 == 40)  // @alias1 is not renamed
    }

    call(|x, y| 20)
    {
        @assert(x == 20)   // x is @alias0
        @assert(y == 40)   // y is @alias1
    }
}
</code></div>
<h3 id="105__variadic_parameters">Variadic parameters</h3>
<div>
</br>
 A function can take a variable number of arguments with <code class="incode">...</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func myFunction(value: bool, parameters: ...)
    {
    }

    myFunction(true, 4, "true", 5.6)
}
</code></div><div>
</br>
 In that case, <code class="incode">parameters</code> is a slice of <code class="incode">any</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func myFunction(parameters: ...)
    {
<span class="linecomment">        // We can know the number of parameters at runtime with '@countof'</span>
        @assert(@countof(parameters) == 3)

<span class="linecomment">        // Each parameter is a type 'any'</span>
        #assert @typeof(parameters[0]) == any
        #assert @typeof(parameters[1]) == any
        #assert @typeof(parameters[2]) == any

<span class="linecomment">        // But you can use '@kindof' to get the real type (at runtime) of the parameter</span>
        @assert(@kindof(parameters[0]) == s32)
        @assert(@kindof(parameters[1]) == string)
        @assert(@kindof(parameters[2]) == f32)
    }

    myFunction(4, "true", 5.6)
}
</code></div><div>
</br>
 If all variadic parameters are of the same type, you can force it. Parameters then won't be of type <code class="incode">any</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func myFunction(value: bool, parameters: s32...)
    {
        #assert @typeof(parameters[0]).name == "s32"
        #assert @typeof(parameters[1]).name == "s32"
        #assert @typeof(parameters[2]) == s32
        #assert @typeof(parameters[3]) == s32

        @assert(parameters[0] == 10)
        @assert(parameters[1] == 20)
        @assert(parameters[2] == 30)
        @assert(parameters[3] == 40)
    }

    myFunction(true, 10, 20, 30, 40)
}
</code></div><div>
</br>
 Variadic parameters can be passed from function to function.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func A(params: ...)
    {
        @assert(@countof(params) == 2)
        @assert(@kindof(params[0]) == string)
        @assert(@kindof(params[1]) == bool)
        @assert(cast(string) params[0] == "value")
        @assert(cast(bool) params[1] == true)
    }

    func B(params: ...)
    {
        A(params)
    }

    B("value", true)
}
</code></div><div>You can spread the content of an array or a slice to variadic parameters with <code class="incode">@spread</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func sum(params: s32...)->s32
    {
<span class="linecomment">        // Note that variadic parameters can be visited, as this is a slice</span>
        total := 0
        visit v: params
            total += v
        return total
    }

    arr := [1, 2, 3, 4]
    res := sum(@spread(arr)) // is equivalent to sum(1, 2, 3, 4)
    @assert(res == 1+2+3+4)

    res1 := sum(@spread(arr[1..2])) // is equivalent to sum(2, 3)
    @assert(res1 == 2+3)
}
</code></div>
<h3 id="106__ufcs">Ufcs</h3>
<div><i>ufcs</i> stands for <i>uniform function call syntax</i>. It allows every functions to be called with a <code class="incode">param.func()</code> form when the first parameter of <code class="incode">func()</code> is of the same type as <code class="incode">param</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func myFunc(param: bool) => param

    b := false
    @assert(myFunc(b) == b.myFunc())
}
</code></div><div>
</br>
 This means that in Swag, there are only <i>static</i> functions, but which can be called like <i>methods</i>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct Point { x, y: s32; }
    func set(using pt: *Point, value: s32) { x, y = value; }

    var pt: Point

<span class="linecomment">    // Ufcs call</span>
    pt.set(10)
    @assert(pt.x == 10 and pt.y == 10)

<span class="linecomment">    // Normal call</span>
    set(&pt, 20)
    @assert(pt.x == 20 and pt.y == 20)
}
</code></div>
<h3 id="107__constexpr">Constexpr</h3>
<div>A function marked with <code class="incode">Swag.ConstExpr</code> can be executed by the compiler if it can.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.ConstExpr]
func sum(x, y: f32) => x + y
</code></div><div>Here <code class="incode">G</code> will be baked to 3 by the compiler.</br>
</div>
<div class="code"><code style="white-space: break-spaces">const G = sum(1, 2)
#assert G == 3
</code></div><div>If a function is not <code class="incode">ConstExpr</code>, you can force the compile time call with <code class="incode">#run</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func mul(x, y: f32) => x * y
const G1 = #run mul(3, 6)
#assert G1 == 18
</code></div>
<h3 id="108__function_overloading">Function overloading</h3>
<div>Functions can have the same names as long as their parameters are different.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.ConstExpr]
{
    func sum(x, y: s32) => x + y
    func sum(x, y, z: s32) => x + y + z
}

#assert sum(1, 2) == 3
#assert sum(1, 2, 3) == 6
</code></div><div>Note that in Swag, there is no implicit cast for function parameters. So you must always specify the right type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func over(x, y: s32) => x + y
func over(x, y: s64) => x * y

<span class="linecomment">// This would generate an error because it's ambiguous, as 1 and 2 are not strong types</span>
<span class="linecomment">// res0 := over(1, 2)</span>

res0 := over(1's32, 2's32)
@assert(res0 == 3)
res1 := over(1's64, 2's64)
@assert(res1 == 2)
</code></div>
<h3 id="109__discard">Discard</h3>
<div>By default, you must always use the returned value of a function, otherwise the compiler will generate an error.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func sum(x, y: s32) => x + y

<span class="linecomment">// This would generated an error, because the return value of 'sum' is not used</span>
<span class="linecomment">// sum(2, 3)</span>

<span class="linecomment">// To force the return value to be ignored, you can use 'discard' at the call site</span>
discard sum(2, 3)
</code></div><div>If a function authorizes the caller to not use its return value, because it's not that important, it can be marked with <code class="incode">Swag.Discardable</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.Discardable]
func mul(x, y: s32)->s32 => x * y

<span class="linecomment">// This is fine to ignore the return value of 'mul' (even if strange)</span>
mul(2, 4)
</code></div>
<h3 id="110__retval">Retval</h3>
<div>Inside a function, you can use the <code class="incode">retval</code> type which is an alias to the function return type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func toto()->s32
    {
        var result: retval
        result = 10
        return result
    }

    @assert(toto() == 10)
}
</code></div><div>But <code class="incode">retval</code> will also make a direct reference to the caller storage, to avoid an unnecessary copy (if possible). So this is mostly a hint for the compiler, and usefull when the function returns a complexe type like a struct, a tuple or an array.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct RGB { x, y, z: f64; }

    func getWhite()->RGB
    {
<span class="linecomment">        // To avoid the clear of the returned struct, we use = undefined</span>
        var result: retval = undefined
        result.x = 0.5
        result.y = 0.1
        result.z = 1.0
        return result
    }

<span class="linecomment">    // Here the 'getWhite' function can directly modify r, g and b without storing</span>
<span class="linecomment">    // a temporary value on the stack.</span>
    (r, g, b) := getWhite()
    @assert(r == 0.5)
    @assert(g == 0.1)
    @assert(b == 1.0)
}
</code></div><div>
</br>
 This is the preferred way (because optimal) to return a struct, a tuple or an array.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func toto()->[255] s32
    {
<span class="linecomment">        // To avoid the clear of the array, we use = undefined</span>
        var result: retval = undefined
        loop i: 255
            result[i] = i
        return result
    }

    arr := toto()
    @assert(arr[0] == 0)
    @assert(arr[100] == 100)
    @assert(arr[254] == 254)
}
</code></div>
<h3 id="111__foreign">Foreign</h3>
<div>Swag can interop with external "modules" (dlls under windows), which contain exported C functions.</br>
</br>
Put a special attribute <code class="incode">Swag.Foreign</code> before the function prototype, and specify the module name where the function is located.</br>
</br>
The module name can be a swag compiled module, or an external system module (where the location depends on the OS).</br>
</div>
<div>In the case below, the function is located in <code class="incode">kernel32.dll</code> (under windows)</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.Foreign("kernel32")]
func ExitProcess(uExitCode: u32);

<span class="linecomment">// Like for other attributes, you can use a block.</span>
#[Swag.Foreign("kernel32")]
{
    func ExitProcess(uExitCode: u32);
    func Sleep(dwMilliseconds: u32);
}
</code></div><div>Note that in the case of a system module, you will have to declare somewhere the imported library too.</br>
</br>
<code class="incode">#foreignlib</code> is here to force a link to the given library (when generating executables).</br>
</div>
<div class="code"><code style="white-space: break-spaces">#foreignlib "kernel32"
</code></div>
<h2 id="120_compiler_intrinsics">Compiler intrinsics</h2>
<div>This is the list of all compiler intrinsics.</br>
All intrinsics start with <code class="incode">@</code>, which is reserved for them.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#global skip
</code></div><div><h3 id="Base">Base</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">func @assert(value: bool);
func @breakpoint();
func @getcontext()->*Swag.Context;
func @setcontext(context: const *Swag.Context);
func @isbytecode()->bool;
func @compiler()->Swag.ICompiler;

func @args()->const [..] string;
@panic()
@compilererror()
@compilerwarning()
</code></div><div><h3 id="Buildin">Buildin</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">@spread()
@init()
@drop()
@postmove()
@postcopy()
@sizeof()
@alignof()
@offsetof()
@typeof()
@kindof()
@countof()
@stringof()
@dataof()
@mkslice()
@mkstring()
@mkany()
@mkinterface()
@mkcallback()
@getpinfos()
@isconstexpr()
@itftableof()

@index
@err
</code></div><div><h3 id="Memory related">Memory related</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">func @alloc(size: u64)->*void;
func @realloc(ptr: *void, size: u64)->*void;
func @free(ptr: *void);
func @memset(dst: *void, value: u8, size: u64);
func @memcpy(dst: *void, src: const *void, size: u64);
func @memmove(dst: *void, src: const *void, size: u64);
func @memcmp(dst, src: const *void, size: u64)->s32;
func @strlen(value: const *u8)->u64;
</code></div><div><h3 id="Atomic operations">Atomic operations</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">func @atomadd(addr: *s8, value: s8)->s8;
func @atomadd(addr: *s16, value: s16)->s16;
func @atomadd(addr: *s32, value: s32)->s32;
func @atomadd(addr: *s64, value: s64)->s64;
func @atomadd(addr: *u8, value: u8)->u8;
func @atomadd(addr: *u16, value: u16)->u16;
func @atomadd(addr: *u32, value: u32)->u32;
func @atomadd(addr: *u64, value: u64)->u64;

func @atomand(addr: *s8, value: s8)->s8;
func @atomand(addr: *s16, value: s16)->s16;
func @atomand(addr: *s32, value: s32)->s32;
func @atomand(addr: *s64, value: s64)->s64;
func @atomand(addr: *u8, value: u8)->u8;
func @atomand(addr: *u16, value: u16)->u16;
func @atomand(addr: *u32, value: u32)->u32;
func @atomand(addr: *u64, value: u64)->u64;

func @atomor(addr: *s8, value: s8)->s8;
func @atomor(addr: *s16, value: s16)->s16;
func @atomor(addr: *s32, value: s32)->s32;
func @atomor(addr: *s64, value: s64)->s64;
func @atomor(addr: *u8, value: u8)->u8;
func @atomor(addr: *u16, value: u16)->u16;
func @atomor(addr: *u32, value: u32)->u32;
func @atomor(addr: *u64, value: u64)->u64;

func @atomxor(addr: *s8, value: s8)->s8;
func @atomxor(addr: *s16, value: s16)->s16;
func @atomxor(addr: *s32, value: s32)->s32;
func @atomxor(addr: *s64, value: s64)->s64;
func @atomxor(addr: *u8, value: u8)->u8;
func @atomxor(addr: *u16, value: u16)->u16;
func @atomxor(addr: *u32, value: u32)->u32;
func @atomxor(addr: *u64, value: u64)->u64;

func @atomxchg(addr: *s8,  exchangeWith: s8)->s8;
func @atomxchg(addr: *s16, exchangeWith: s16)->s16;
func @atomxchg(addr: *s32, exchangeWith: s32)->s32;
func @atomxchg(addr: *s64, exchangeWith: s64)->s64;
func @atomxchg(addr: *u8,  exchangeWith: u8)->u8;
func @atomxchg(addr: *u16, exchangeWith: u16)->u16;
func @atomxchg(addr: *u32, exchangeWith: u32)->u32;
func @atomxchg(addr: *u64, exchangeWith: u64)->u64;

func @atomcmpxchg(addr: *s8,  compareTo, exchangeWith: s8)->s8;
func @atomcmpxchg(addr: *s16, compareTo, exchangeWith: s16)->s16;
func @atomcmpxchg(addr: *s32, compareTo, exchangeWith: s32)->s32;
func @atomcmpxchg(addr: *s64, compareTo, exchangeWith: s64)->s64;
func @atomcmpxchg(addr: *u8,  compareTo, exchangeWith: u8)->u8;
func @atomcmpxchg(addr: *u16, compareTo, exchangeWith: u16)->u16;
func @atomcmpxchg(addr: *u32, compareTo, exchangeWith: u32)->u32;
func @atomcmpxchg(addr: *u64, compareTo, exchangeWith: u64)->u64;
</code></div><div><h3 id="Math">Math</br>
</h3></div>
<div class="code"><code style="white-space: break-spaces">func @sqrt(value: f32)->f32;
func @sqrt(value: f64)->f64;

func @sin(value: f32)->f32;
func @sin(value: f64)->f64;
func @cos(value: f32)->f32;
func @cos(value: f64)->f64;
func @tan(value: f32)->f32;
func @tan(value: f64)->f64;

func @sinh(value: f32)->f32;
func @sinh(value: f64)->f64;
func @cosh(value: f32)->f32;
func @cosh(value: f64)->f64;
func @tanh(value: f32)->f32;
func @tanh(value: f64)->f64;

func @asin(value: f32)->f32;
func @asin(value: f64)->f64;
func @acos(value: f32)->f32;
func @acos(value: f64)->f64;
func @atan(value: f32)->f32;
func @atan(value: f64)->f64;

func @log(value: f32)->f32;
func @log(value: f64)->f64;
func @log2(value: f32)->f32;
func @log2(value: f64)->f64;
func @log10(value: f32)->f32;
func @log10(value: f64)->f64;

func @floor(value: f32)->f32;
func @floor(value: f64)->f64;
func @ceil(value: f32)->f32;
func @ceil(value: f64)->f64;
func @trunc(value: f32)->f32;
func @trunc(value: f64)->f64;
func @round(value: f32)->f32;
func @round(value: f64)->f64;

func @abs(value: s8)->s8;
func @abs(value: s16)->s16;
func @abs(value: s32)->s32;
func @abs(value: s64)->s64;
func @abs(value: f32)->f32;
func @abs(value: f64)->f64;

func @exp(value: f32)->f32;
func @exp(value: f64)->f64;
func @exp2(value: f32)->f32;
func @exp2(value: f64)->f64;
func @pow(value1, value2: f32)->f32;
func @pow(value1, value2: f64)->f64;

func @min(value1, value2: s8)->s8;
func @min(value1, value2: s16)->s16;
func @min(value1, value2: s32)->s32;
func @min(value1, value2: s64)->s64;
func @min(value1, value2: u8)->u8;
func @min(value1, value2: u16)->u16;
func @min(value1, value2: u32)->u32;
func @min(value1, value2: u64)->u64;
func @min(value1, value2: f32)->f32;
func @min(value1, value2: f64)->f64;

func @max(value1, value2: s8)->s8;
func @max(value1, value2: s16)->s16;
func @max(value1, value2: s32)->s32;
func @max(value1, value2: s64)->s64;
func @max(value1, value2: u8)->u8;
func @max(value1, value2: u16)->u16;
func @max(value1, value2: u32)->u32;
func @max(value1, value2: u64)->u64;
func @max(value1, value2: f32)->f32;
func @max(value1, value2: f64)->f64;

func @bitcountnz(value: u8)->u8;
func @bitcountnz(value: u16)->u16;
func @bitcountnz(value: u32)->u32;
func @bitcountnz(value: u64)->u64;
func @bitcounttz(value: u8)->u8;
func @bitcounttz(value: u16)->u16;
func @bitcounttz(value: u32)->u32;
func @bitcounttz(value: u64)->u64;
func @bitcountlz(value: u8)->u8;
func @bitcountlz(value: u16)->u16;
func @bitcountlz(value: u32)->u32;
func @bitcountlz(value: u64)->u64;

func @byteswap(value: u16)->u16;
func @byteswap(value: u32)->u32;
func @byteswap(value: u64)->u64;

func @muladd(val1, val2, val3: f32)->f32;
func @muladd(val1, val2, val3: f64)->f64;
</code></div>
<h2 id="121_init">Init</h2>
<div><h3 id="@init">@init</br>
</h3><code class="incode">@init</code> can be used to reinitialize a variable/array to the default value.</br>
</div>
<div>
</br>
 For a simple variable, default value is 0.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := 666
    @init(&x)
    @assert(x == 0)
}
</code></div><div>
</br>
 Work also for an array, as you can specify the number of elements you want to initialize.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := [1, 2]
    @init(&x, 2)    // Initialize 2 elements
    @assert(x[0] == 0)
    @assert(x[1] == 0)
}
</code></div><div>
</br>
 You can also specify a <i>value</i> to initialize, instead of the default one.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := 666'f32
    @init(&x)(3.14)  // Initialize to 3.14 instead of zero
    @assert(x == 3.14)
}
</code></div><div>
</br>
 Same for an array.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := [1, 2]
    @init(&x, 2)(555)
    @assert(x[0] == 555)
    @assert(x[1] == 555)
}
</code></div><div>When called on a struct, the struct will be restored to the values defined in it.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct RGB
{
    r = 1
    g = 2
    b = 3
}

{
    var rgb: RGB{10, 20, 30}
    @init(&rgb)
    @assert(rgb.r == 1)
    @assert(rgb.g == 2)
    @assert(rgb.b == 3)
}
</code></div><div>
</br>
 But you can also specified the values.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var rgb: RGB{10, 20, 30}
    @init(&rgb)(5, 6, 7)
    @assert(rgb.r == 5)
    @assert(rgb.g == 6)
    @assert(rgb.b == 7)
}
</code></div><div>
</br>
 And this works also for array.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var rgb: [4] RGB
    @init(&rgb, 4)(5, 6, 7)
    @assert(rgb[3].r == 5)
    @assert(rgb[3].g == 6)
    @assert(rgb[3].b == 7)
}
</code></div><div><h3 id="@drop">@drop</br>
</h3>Note that for a struct, this will <b>not</b> call <code class="incode">opDrop</code>, so this is mostly useful to initialize a plain old data.</br>
</br>
But there is also <code class="incode">@drop</code>, which works the same, except that it will <code class="incode">drop</code> all the content by calling <code class="incode">opDrop</code> if it is defined.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct RGB
{
    r = 1
    g = 2
    b = 3
}

{
    var rgb: [4] RGB

<span class="linecomment">    // In fact this is a no op, as struct RGB is plain old data, without a defined 'opDrop'</span>
    @drop(&rgb, 4)

    @init(&rgb, 4)(5, 6, 7)
    @assert(rgb[3].r == 5)
    @assert(rgb[3].g == 6)
    @assert(rgb[3].b == 7)
}
</code></div>
<h2 id="130_generic">Generic</h2>

<h3 id="131__declaration">Declaration</h3>
<div>A function can be generic by specifying some parameters after <code class="incode">func</code>.</br>
At the call site, you specify the generic parameters with <code class="incode">funcCall'(type1, type2, ...)(parameters)</code>.</br>
Note that parenthesis can be ommited if there's only one generic parameter.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
<span class="linecomment">    // Here 'T' is a generic type.</span>
    func(var T) myFunc(val: T) => 2 * val

    @assert(myFunc's32(2) == 4)
    @assert(myFunc'f32(2.0) == 4.0)
}

{
<span class="linecomment">    // You can omit 'var' to declare the generic type, because a single identifier is considered to be a type.</span>
    func(T) myFunc(val: T) => 2 * val

    @assert(myFunc's32(2) == 4)
    @assert(myFunc'f32(2.0) == 4.0)
}

{
<span class="linecomment">    // You can set a default value to the type.</span>
    func(T = s32) myFunc(val: T) => 2 * val

    @assert(myFunc(2's32) == 4)
    @assert(myFunc'f32(2.0) == 4.0)
}

{
<span class="linecomment">    // Of course you can specify more than one generic parameter</span>
    func(K, V) myFunc(key: K, value: V) => value

    @assert(myFunc(2's32, "value") == "value")              // K and V are deduced
    @assert(myFunc'(s32, string)(2, "value") == "value")    // K and V are explicit

    @assert(myFunc(2's32, true) == true)
    @assert(myFunc'(s32, bool)(2, true) == true)
}
</code></div><div>Generic types can be deduced from parameters, so <code class="incode">func'type()</code> is not always necessary.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func(T) myFunc(val: T) => 2 * val

@assert(myFunc(2's32) == 4)         // T is deduced to be s32
@assert(myFunc(2.0'f32) == 4.0)     // T is deduced to be f32
</code></div><div>You can also specify constants as generic parameters.</br>
</div>
<div>
</br>
 <code class="incode">N</code> is a constant a type <code class="incode">s32</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func(const N: s32) myFunc() = @assert(N == 10)
    myFunc'10()
}
</code></div><div>
</br>
 <code class="incode">const</code> can also be omitted, as an identifier followed by a type definition is considered to be a constant and not a type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func(N: s32) myFunc() = @assert(N == 10)
    myFunc'10()
}
</code></div><div>
</br>
 You can also assign a default value to the constant.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func(N: s32 = 10) myFunc() = @assert(N == 10)
    myFunc()
}
</code></div><div>
</br>
 You can ommit the type if you declare the constant with <code class="incode">const</code>. It will be deduced from the assignment expression.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func(const N = 10) myFunc() = @assert(N == 10)
    myFunc()
}
</code></div><div>You can mix types and constants.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
<span class="linecomment">    // `T` is a type, `N` is a constant of type `s32`, because remember that an identifier alone is considered to be a generic type.</span>
    func(T, N: s32) myFunc(x: T) => x * N

    alias call = myFunc'(s32, 10)
    @assert(call(2) == 20)
    @assert(call(100) == 1000)
}

{
<span class="linecomment">    // So if you want to declare multiple constants, specify the type (or 'const') for each.</span>
    func(T: s32, N: s32) myFunc() => T * N

    @assert(myFunc'(5, 10)() == 50)
}

{
<span class="linecomment">    // And if you want to declare multiple types with default values, specify the value for each.</span>
    func(T = s32, V = s32) myFunc(x: T, y: V) => x * y

    @assert(myFunc(1's32, 2'f32) == 2.0)
    @assert(myFunc(1's32, 2's32) == 2)
}
</code></div><div>Like functions, a struct can also be generic.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct(T) Struct
    {
        val: T
    }

    var x: Struct's32
    @assert(@typeof(x.val) == s32)
    var x1: Struct'f32
    @assert(@typeof(x1.val) == f32)
}

{
    struct(T, N: s32) Struct
    {
        val: [N] T
    }

    var x: Struct'(bool, 10)
    @assert(@typeof(x.val) == #type [10] bool)
}
</code></div>
<h3 id="132__validif">Validif</h3>
<div><h4 id="One time evaluation">One time evaluation</br>
</h4>On a function, you can use <code class="incode">#validif</code> to check if the usage of the function is correct.</br>
</br>
If the <code class="incode">#validif</code> expression returns false, then the function will not be considered for the call. If there's no other overload to match, then the compiler will raise an error.</br>
</br>
The <code class="incode">#validif</code> expression is evaluated <b>only once</b>, whatever the call, so it is typically used to check generic parameters.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Here we validate the function only if the generic type is `s32` or `s64`.</span>
func(T) sum(x: T...)->T
    #validif @typeof(T) == s32 or @typeof(T) == s64
{
    total := 0'T
    visit it: x
        total += it
    return total
}

<span class="linecomment">// This is ok.</span>
res1 := sum's32(1, 2)
@assert(res1 == 3)
res2 := sum's64(10, 20)
@assert(res2 == 30)

<span class="linecomment">// But the following would generate an error because the type is `f32`. So there's no match possible for that type.</span>

<span class="linecomment">// res1 := sum'f32(1, 2)</span>
</code></div><div>You can use <code class="incode">#validif</code> to make a kind of a generic specialisation.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// s32 version</span>
func(T) isNull(x: T)->bool
    #validif @typeof(T) == s32
{
    return x == 0
}

<span class="linecomment">// f32/f64 version</span>
func(T) isNull(x: T)->bool
    #validif @typeof(T) == f32 or @typeof(T) == f64
{
    return @abs(x) < 0.01
}

@assert(isNull(0's32))
@assert(isNull(0.001'f32))
</code></div><div>Instead of a single expression, <code class="incode">#validif</code> can be followed by a block that returns a <code class="incode">bool</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func(T) sum(x: T...)->T
    #validif
    {
        if @typeof(T) == s32 or @typeof(T) == s64
            return true
        return false
    }
{
    total := 0'T
    visit it: x
        total += it
    return total
}
</code></div><div>By using <code class="incode">@compilererror</code>, you can then trigger your own errors at compile time if the type is incorrect.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func(T) sum(x, y: T)->T
    #validif
    {
        if @typeof(T) == s32 or @typeof(T) == s64
            return true
        @compilererror("invalid type " ++ @stringof(T), @location(T))
        return false
    }
{
    return x + y
}

<span class="linecomment">// This will trigger an error</span>

<span class="linecomment">// x := sum'f32(1, 2)</span>
</code></div><div><code class="incode">#validif</code> can also be used on a generic struct. Unlike functions, if the expression failed, then you will have an error right away because there's no overload in the case of structures.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct(T) Point
    #validif T == f32 or T == f64
{
    x, y: T
}

<span class="linecomment">// Fine.</span>
var v: Point'f32

<span class="linecomment">// Error.</span>
<span class="linecomment">//var v: Point's32</span>
</code></div><div><h4 id="Multiple evaluations">Multiple evaluations</br>
</h4>Instead of <code class="incode">#validif</code>, you can use <code class="incode">#validifx</code>. <code class="incode">#validifx</code> is evaluated for <b>each</b> call, so it can be used to check parameters, as long as they can be <b>evaluated at compile time</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func div(x, y: s32)->s32
        #validifx
        {
<span class="linecomment">            // Here we use '@isconstexpr'.</span>
<span class="linecomment">            // If 'y' cannot be evaluated at compile time, then we can do nothing about it.</span>
            if !@isconstexpr(y)
                return true
            if y == 0
                @compilererror("division by zero", @location(y))
            return true
        }
    {
        return x / y
    }

<span class="linecomment">    // Fine</span>
    x1 := div(1, 1)

<span class="linecomment">    // Error at compile time, division by zero.</span>

<span class="linecomment">    // x2 := div(1, 0)</span>
}

{
<span class="linecomment">    // A version of 'first' where 'x' is known at compile time.</span>
    func first(x: s32)->s32
        #validifx @isconstexpr(x)
    {
        return 555
    }

<span class="linecomment">    // A version of 'first' where 'x' is **not** known at compile time.</span>
    func first(x: s32)->s32
        #validifx !@isconstexpr(x)
    {
        return 666
    }

<span class="linecomment">    // Will call version 1 because parameter is a literal.</span>
    @assert(first(0) == 555)

<span class="linecomment">    // Will call version 2 because parameter is a variable.</span>
    var a: s32
    @assert(first(a) == 666)
}
</code></div>
<h3 id="133__constraint">Constraint</h3>
<div>Swag provides also a simple way of checking generic parameters, without the need of <code class="incode">#validif</code>.</br>
A type constraint can be added when declaring a generic type. If a function or a struct is instantiated with a type that does not conform to the constraint, then an error will be raised.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// The type constraint is a compile time function (with #[Swag.ConstExpr]) that should return a bool.</span>
#[Swag.ConstExpr]
func isS32(t: typeinfo) => t == s32

<span class="linecomment">// Here we check that the function generic type is 's32' by calling 'isS32'.</span>
func(var T: isS32(T)) sum(x: T...)->T
{
    total := 0'T
    visit it: x
        total += it
    return total
}

<span class="linecomment">// This is ok.</span>
res1 := sum's32(1, 2)
@assert(res1 == 3)

<span class="linecomment">// But the following would generate an error because the type is 'f32'.</span>
<span class="linecomment">// res1 := sum'f32(1, 2)</span>
</code></div><div>The type constraint can be any compile time expression, as long as the resulting type is <code class="incode">bool</code>.</br>
So you could do something like this.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.ConstExpr]
func isS32(t: typeinfo)  => t == s32
#[Swag.ConstExpr]
func isBool(t: typeinfo) => t == bool

<span class="linecomment">// Here we check that the function generic type is 's32' or 'bool'.</span>
func(var T: isS32(T) or isBool(T)) myFunc(x: T) => x

<span class="linecomment">// This is ok.</span>
@assert(myFunc(5's32) == 5)
@assert(myFunc(true)  == true)
@assert(myFunc(false) == false)
</code></div><div>Works also for structs.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.ConstExpr]
func isFloat(t: typeinfo) => t == f32 or t == f64

struct(var T: isFloat(T)) Point
{
    x, y: T
}

var pt:  Point'f32
var pt1: Point'f64

<span class="linecomment">// This will generate a type constraint error.</span>
<span class="linecomment">//var pt: Point's32</span>
</code></div>
<h2 id="160_defer">Defer</h2>
<div><code class="incode">defer</code> is used to call an expression when the current scope is left. It's purely compile time, so it does not evaluate until the block is left.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    v := 0
    defer @assert(v == 1)
    v += 1
<span class="linecomment">    // defer expression will be executed here</span>
}
</code></div><div>
</br>
 <code class="incode">defer</code> can also be used with a block.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    v := 0
    defer
    {
        v += 10
        @assert(v == 15)
    }

    v += 5
<span class="linecomment">    // defer block will be executed here</span>
}
</code></div><div>
</br>
 <code class="incode">defer</code> expressions are called when leaving the corresponding scope, even with <code class="incode">return</code>, <code class="incode">break</code>, <code class="incode">continue</code> etc., and even inside a <code class="incode">loop/while/for</code> etc.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var G = 0
    loop 10
    {
        defer G += 1
        if G == 2
            break   // will be called here, before breaking the loop
<span class="linecomment">        // will be called here also</span>
    }

    @assert(G == 3)
}
</code></div><div>
</br>
 <code class="incode">defer</code> are executed in reverse order of their declaration.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    x := 1
    defer @assert(x == 2)   // Will be executed second
    defer x *= 2            // Will be executed first
}
</code></div><div>
</br>
 It's typically used to unregister/destroy a resource, by putting the release code just after the creation one.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func createResource() => true
    func releaseResource(resource: *bool) = dref resource = false
    func isResourceCreated(b: bool) => b

    resource := false
    loop 10
    {
        resource = createResource()
        defer
        {
            @assert(resource.isResourceCreated())
            releaseResource(&resource)
        }

        if @index == 2
            break
    }

    @assert(!resource.isResourceCreated())
}
</code></div>
<h2 id="161_using">Using</h2>
<div>
</br>
 <code class="incode">using</code> brings the scope of a namespace, a struct or an enum in the current one.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum RGB { R; G; B; }
    @assert(RGB.R == 0)

    using RGB
    @assert(G == 1)
}
</code></div><div>
</br>
 <code class="incode">using</code> can also be used with a variable</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct Point { x: s32; y: s32; }

    var pt: Point

    using pt
    x = 1 // no need to specify 'pt'
    y = 2 // no need to specify 'pt'

    @assert(pt.x == 1)
    @assert(pt.y == 2)
}
</code></div><div>
</br>
 You can declare a variable with <code class="incode">using</code> just before.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    struct Point { x: s32; y: s32; }

    using var pt: Point
    x = 1 // no need to specify 'pt'
    y = 2 // no need to specify 'pt'

    @assert(pt.x == 1)
    @assert(pt.y == 2)
}
</code></div><div><h3 id="For a function parameter">For a function parameter</br>
</h3><code class="incode">using</code> applied to a function parameter can be seen as the equivalent of the hidden <code class="incode">this</code> in C++.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Point { x: s32; y: s32; }

func setOne(using point: *Point)
{
<span class="linecomment">    // Here there's no need to specify 'point'</span>
    x, y = 1
}

var pt: Point
setOne(&pt)
@assert(pt.x == 1)
@assert(pt.y == 1)

<span class="linecomment">// ufcs</span>
pt.setOne()
@assert(pt.x == 1)
@assert(pt.y == 1)
</code></div><div><h3 id="For a field">For a field</br>
</h3><code class="incode">using</code> can also be used with a field inside a struct.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Point2
{
    x, y: s32
}

struct Point3
{
    using base: Point2
    z: s32
}

<span class="linecomment">// That way the content of the field can be referenced directly</span>
var value: Point3
value.x = 0 // Equivalent to value.base.x = 0
value.y = 0 // Equivalent to value.base.y = 0
value.z = 0
@assert(&value.x == &value.base.x)
@assert(&value.y == &value.base.y)

<span class="linecomment">// The compiler can then cast automatically 'Point3' to 'Point2'</span>
func set1(using ptr: *Point2)
{
    x, y = 1
}

set1(&value) // Here the cast is automatic thanks to the using
@assert(value.x == 1)
@assert(value.y == 1)
@assert(value.base.x == 1)
@assert(value.base.y == 1)
</code></div>
<h2 id="162_with">With</h2>
<div>You can use <code class="incode">with</code> to avoid repeating the same variable again and again. You can then access fields with a simple <code class="incode">.</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct Point { x, y: s32; }

impl Point
{
    mtd setOne()
    {
        x, y = 1
    }
}
</code></div><div>
</br>
 <code class="incode">with</code> on a variable.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var pt: Point
    with pt
    {
        .x = 1   // equivalent to pt.x
        .y = 2   // equivalent to pt.y
    }

    @assert(pt.x == 1)
    @assert(pt.y == 2)
}
</code></div><div>
</br>
 Works for function calls to.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var pt: Point
    with pt
    {
        .setOne()           // equivalent to pt.setOne() or setOne(pt)
        .y = 2              // equivalent to pt.y
        @assert(.x == 1)    // equivalent to pt.x
        @assert(.y == 2)    // equivalent to pt.y
        @assert(pt.x == 1)
        @assert(pt.y == 2)
    }
}
</code></div><div>
</br>
 Works also with a namespace.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    with NameSpace
    {
        .inside0()
        .inside1()
    }
}
</code></div><div>
</br>
 Instead of an identifier name, <code class="incode">with</code> also accepts a variable declaration.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    with pt := Point{1, 2}
    {
        .x = 10
        .y = 20
    }

    @assert(pt.x == 10 and pt.y == 20)
}

{
    with var pt: Point
    {
        .x = 10
        .y = 20
    }

    @assert(pt.x == 10 and pt.y == 20)
}
</code></div><div>
</br>
 Or an affectation statement.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var pt: Point
    with pt = Point{1, 2}
    {
        .x = 10
        .y = 20
    }

    @assert(pt.x == 10 and pt.y == 20)
}
</code></div><div class="code"><code style="white-space: break-spaces">namespace NameSpace
{
    func inside0() {}
    func inside1() {}
}
</code></div>
<h2 id="163_alias">Alias</h2>
<div>
</br>
 <code class="incode">alias</code> is used to make a shortcut to another name or type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    enum RGB { R; G; B; }
    @assert(RGB.R == 0)

    alias Color = RGB
    @assert(Color.G == 1)
}
</code></div><div>
</br>
 Types alias</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    alias Float32 = f32
    alias Float64 = f64
    var x: Float32 = 1.0
    var y: Float64 = 1.0
    #assert @typeof(Float32) == f32
    #assert @typeof(Float64) == f64
}
</code></div><div>
</br>
 A type alias can be marked with the <code class="incode">Swag.Strict</code> attribute. In that case, implicit cast is not done, but explicit cast is still possible.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.Strict]
    alias MyType = s32
    #assert @typeof(MyType) != s32
    var x: MyType = cast(MyType) 0
}
</code></div><div>
</br>
 You can also alias a function.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func thisIsABigFunctionName(x: s32) => x * x
    alias myFunc = thisIsABigFunctionName
    @assert(myFunc(4) == 16)
}
</code></div><div>
</br>
 You can also alias a variable.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var myLongVariableName: s32 = 0
    alias short = myLongVariableName
    short += 2
    @assert(myLongVariableName == 2)
}
</code></div>
<h2 id="170_error">Error</h2>
<div>Swag contains a <i>very</i> simple error system used to deal with function returning errors.</br>
Will probably be changed/improved at some point.</br>
</br>
These are <b>not</b> exceptions !</br>
</br>
A function that can return an error must be marked with <code class="incode">throw</code>. It can then raise an error with the <code class="incode">throw</code> keyword, passing an error message.</br>
</br>
When an error is raised by a function, the return value is always equal to the default value, depending on the return type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func count(name: string)->u64 throw
{
    if name == null
    {
<span class="linecomment">        // This function will return 0 in case of an error, because this is the default</span>
<span class="linecomment">        // value for 'u64'.</span>
        throw "null pointer"
    }

    return @countof(name)
}
</code></div><div>The caller will then have to deal with the error in some way.</br>
It can <code class="incode">catch</code> it, and test (or not) its value with the <code class="incode">@err</code> intrinsic.</br>
Execution will continue at the call site.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func myFunc()
{
<span class="linecomment">    // Dismiss the eventual error with 'catch' and continue execution</span>
    cpt := catch count("fileName")

<span class="linecomment">    // And test it with @err, which returns the 'throw' corresponding string</span>
    if @err
    {
        @assert(cpt == 0)
        @print(@err)
        return
    }

<span class="linecomment">    // You can also use 'trycatch', which will return the current function in case</span>
<span class="linecomment">    // an error has been raised (returning the default value if necessary)</span>
    cpt1 := trycatch count("fileName")
}
</code></div><div>The caller can stop the execution with <code class="incode">try</code>, and return to its own caller with the same error raised.</br>
The function must then also be marked with <code class="incode">throw</code>.</br>
Here, the caller of <code class="incode">myFunc1</code> will have to deal with the error at its turn.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func myFunc1() throw
{
<span class="linecomment">    // If 'count()' raises an error, 'myFunc1' will return with the same error</span>
    cpt := try count("filename")
}
</code></div><div>The caller can also panic if an error is raised, with <code class="incode">assume</code>.</br>
This can be disabled in release builds (in that case the behaviour is undefined).</br>
</div>
<div class="code"><code style="white-space: break-spaces">func myFunc2()
{
<span class="linecomment">    // Here the program will stop with a panic message if 'count()' throws an error</span>
    cpt := assume count("filename")
}
</code></div><div>Note that you can use a block instead of one single statement (this does not create a scope).</br>
</div>
<div class="code"><code style="white-space: break-spaces">func myFunc3() throw
{
<span class="linecomment">    // This is not really necessary, see below, but this is just to show 'try' with a block</span>
<span class="linecomment">    // instead of one single call</span>
    try
    {
        cpt0 := count("filename")
        cpt1 := count("other filename")
    }

    assume
    {
        cpt2 := count("filename")
        cpt3 := count("other filename")
    }

<span class="linecomment">    // Works also for 'catch' if you do not want to deal with the error message.</span>
<span class="linecomment">    // '@err' in that case is not really relevant.</span>
    catch
    {
        cpt4 := count("filename")
        cpt5 := count("other filename")
    }

<span class="linecomment">    // Works also for 'trycatch' if you do not want to deal with the error message</span>
<span class="linecomment">    // and you want to return as soon as an error is raised.</span>
    trycatch
    {
        cpt6 := count("filename")
        cpt7 := count("other filename")
    }
}
</code></div><div>When a function is marked with <code class="incode">throw</code>, the <code class="incode">try</code> for a function call is automatic if not specified.</br>
That means that most of the time it's not necessary to specify it.</br>
</div>
<div class="code"><code style="white-space: break-spaces">func mySubFunc2() throw
{
    throw "error"
}

func mySubFunc1() throw
{
<span class="linecomment">    // In fact there's no need to add a 'try' before the call because 'mySubFunc1' is</span>
<span class="linecomment">    // marked with 'throw'</span>
<span class="linecomment">    // This is less verbose when you do not want to do something special in case</span>
<span class="linecomment">    // of errors (with 'assume', 'catch' or 'trycatch')</span>
    mySubFunc2()
}

catch mySubFunc1()
@assert(@err == "error")
</code></div><div><code class="incode">defer</code> can have parameters like <code class="incode">defer(err)</code> or <code class="incode">defer(noerr)</code> to control if it should be executed depending on the error status.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var g_Defer = 0

func raiseError() throw
{
    throw "error"
}

func testDefer(err: bool) throw
{
    defer(err)      g_Defer += 1    // This will be called in case an error is raised, before exiting
    defer(noerr)    g_Defer += 2    // This will only be called in case an error is not raised
    defer           g_Defer += 3    // This will be called in both cases
    if err
        raiseError()
}
</code></div><div class="code"><code style="white-space: break-spaces">g_Defer = 0
catch testDefer(true)
@assert(g_Defer == 4)   // Will call only defer(err) and the normal defer

g_Defer = 0
catch testDefer(false)
@assert(g_Defer == 5)   // Will call only defer(noerr) and the normal defer
</code></div>
<h2 id="180_compiler_declarations">Compiler declarations</h2>

<h3 id="181__compile_time_evaluation">Compile time evaluation</h3>
<div><code class="incode">#assert</code> is a static assert (at compile time).</br>
</div>
<div class="code"><code style="white-space: break-spaces">#assert true
</code></div><div><code class="incode">@defined(SYMBOL)</code> returns true, at compile time, if the given symbol exists in the current context.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#assert !@defined(DOES_NOT_EXISTS)
#assert @defined(Global)
var Global = 0
</code></div><div>A static <code class="incode">#if/#elif/#else</code>, with an expression that can be evaluated at compile time.</br>
</div>
<div class="code"><code style="white-space: break-spaces">const DEBUG = 1
const RELEASE = 0
#if DEBUG
{
}
#elif RELEASE
{
}
#else
{
}
</code></div><div><code class="incode">#error</code> to raise a compile time error, and <code class="incode">#warning</code> to raise a compile time warning.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#if false
{
    #error   "this is an error"
    #warning "this is a warning"
}

<span class="linecomment">// 'isThisDebug' is marked with 'Swag.ConstExpr', so it can be automatically evaluated</span>
<span class="linecomment">// at compile time</span>
#[Swag.ConstExpr]
func isThisDebug() => true

<span class="linecomment">// This call is valid</span>
#if isThisDebug() == false
{
    #error "this should not be called !"
}

<span class="linecomment">// This time 'isThisRelease' is not marked with 'Swag.ConstExpr'</span>
func isThisRelease() => true

<span class="linecomment">// But this call is still valid because we force the compile time execution with '#run'</span>
#if #run isThisRelease() == false
{
    #error "this should not be called !"
}
</code></div><div>A more complicated <code class="incode">#assert</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.ConstExpr]
func factorial(x: s32)->s32
{
    if x == 1 return 1
    return x * factorial(x - 1)
}

#assert factorial(4) == 24 // Evaluated at compile time
</code></div>
<h3 id="182__special_functions">Special functions</h3>
<div><h4 id="#test">#test</br>
</h4><code class="incode">#test</code> is a special function than can be used in the 'tests/' folder of the workspace.</br>
They will be executed only if swag is running in test mode.</br>
</div>
<div><h4 id="#main">#main</br>
</h4><code class="incode">#main</code> is the program entry point.</br>
Can only be defined once per module.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#main
{
}
</code></div><div><h4 id="#init">#init</br>
</h4><code class="incode">#init</code> will be called at runtime, during the module initialization.</br>
You can have as many #init as you want.</br>
Order of #init in the same module is undefined.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#init
{
}
</code></div><div><h4 id="#drop">#drop</br>
</h4><code class="incode">#drop</code> will be called at runtime, when module is unloaded.</br>
You can have as many #drop as you want.</br>
Order of #drop in the same module is undefined (but is always the inverse order of #init).</br>
</div>
<div class="code"><code style="white-space: break-spaces">#drop
{
}
</code></div><div><h4 id="#premain">#premain</br>
</h4><code class="incode">#premain</code> will be called after all modules have done their #init code, but before the #main function is called.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#premain
{
}
</code></div>
<h3 id="183__run">Run</h3>
<div><code class="incode">#run</code> is a special function that will be called at compile time.</br>
It can be used to precompute some global values for example.</br>
</div>
<div class="code"><code style="white-space: break-spaces">var G: [5] f32 = undefined
</code></div><div>Initialize <code class="incode">G</code> with <code class="incode">[1,2,4,8,16]</code> at compile time.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#run
{
    value := 1'f32
    loop i: @countof(G)
    {
        G[i] = value
        value *= 2
    }
}
</code></div><div><code class="incode">#test</code> are executed after #run, even at compile time (during testing).</br>
So we can test the values of G here.</br>
</div>
<div class="code"><code style="white-space: break-spaces">@assert(G[0] == 1)
@assert(G[1] == 2)
@assert(G[2] == 4)
@assert(G[3] == 8)
@assert(G[4] == 16)
</code></div><div><code class="incode">#run</code> can also be used as an expression, to call for example a function not marked with <code class="incode">#[Swag.ConstExpr]</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">const SumValue = #run sum(1, 2, 3, 4) + 10
#assert SumValue == 20

func sum(values: s32...)->s32
{
    result := 0's32
    visit v: values
        result += v
    return result
}
</code></div><div><code class="incode">#run</code> can also be used as an expression block.</br>
The return type is deduced from the <code class="incode">return</code> statement.</br>
</div>
<div class="code"><code style="white-space: break-spaces">const Value = #run {
    var result: f32
    loop 10
        result += 1
    return result   // 'Value' will be of type 'f32'
}
#assert Value == 10.0
</code></div>
<h3 id="184__global">Global</h3>
<div>A bunch of <code class="incode">#global</code> can start a source file.</br>
</div>
<div class="code"><code style="white-space: break-spaces"><span class="linecomment">// Skip the content of the file, like this one (but must be a valid swag file)</span>
#global skip

<span class="linecomment">// All symbols in the file will be public/private</span>
#global public
#global private

<span class="linecomment">// All symbols in the file will go in the namespace 'Toto'</span>
#global namespace Toto

<span class="linecomment">// A #if for the whole file</span>
#global if DEBUG == true

<span class="linecomment">// Some attributes can be assigned to the full file</span>
#global #[Swag.Safety("", true)]

<span class="linecomment">// The file will be exported for external usage</span>
<span class="linecomment">// It's like putting everything in public, except that the file will</span>
<span class="linecomment">// be copied in its totality in the public folder</span>
#global export

<span class="linecomment">// Link with a given external library</span>
#foreignlib "windows.lib"
</code></div>
<h3 id="185__var">Var</h3>
<div>A global variable can be tagged with <code class="incode">#[Swag.Tls]</code> to store it in the thread local storage (one copy per thread).</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.Tls]
var G = 0
</code></div><div>
</br>
 A local variable can be tagged with <code class="incode">#[Swag.Global]</code> to make it global (aka <code class="incode">static</code> in C/C++).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    func toto()->s32
    {
        #[Swag.Global]
        var G1 = 0

        G1 += 1
        return G1
    }

    @assert(toto() == 1)
    @assert(toto() == 2)
    @assert(toto() == 3)
}
</code></div><div>A global variable can also be marked as <code class="incode">#[Swag.Compiler]</code>. That kind of variable will not be exported to the runtime and can only be used in compile time code.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.Compiler]
var G2 = 0

#run
{
    G2 += 5
}
</code></div>
<h2 id="190_attributes">Attributes</h2>
<div>Attributes are tags associated with functions, structures etc...</br>
</div>

<h3 id="191__user_attributes">User attributes</h3>
<div>User attributes are declared like functions, but with the <code class="incode">attr</code> keyword before instead of <code class="incode">func</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">using Swag
attr AttributeA()
</code></div><div>Like functions, attributes can have parameters.</br>
</div>
<div class="code"><code style="white-space: break-spaces">attr AttributeB(x, y: s32, z: string)
</code></div><div>So attributes can also have default values.</br>
</div>
<div class="code"><code style="white-space: break-spaces">attr AttributeBA(x: s32, y: string = "string")
</code></div><div>You can define a usage before the attribute definition to restrict its usage.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[AttrUsage(AttributeUsage.Function)]
attr AttributeC()
</code></div><div>To use an attribute, the syntax is <code class="incode">#[attribute, attribute...]</code>. It should be placed <b>before</b> the thing you want to tag.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[AttributeA, AttributeB(0, 0, "string")]
func function1()
{
}
</code></div><div>You can declare multiple usages.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct)]
attr AttributeD(x: s32);

#[AttributeD(6)]
func function2()
{
}

#[AttributeD(150)]
struct struct1
{
}
</code></div><div>Finaly, attributes can be retrieved at runtime thanks to <b>type reflection</b>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">type := @typeof(function2)                  // Get the type of the function
@assert(@countof(type.attributes) == 1)     // Check the function has exactly one attribute associated with it
</code></div>
<h3 id="192__predefined_attributes">Predefined attributes</h3>
<div>This is the list of predefined attributes.</br>
All are located in the reserved <code class="incode">Swag</code> namespace.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#global skip

#[AttrUsage(AttributeUsage.Function)]
attr ConstExpr()

#[AttrUsage(AttributeUsage.Function|AttributeUsage.Struct|AttributeUsage.File)]
attr PrintBc()

#[AttrUsage(AttributeUsage.Function|AttributeUsage.GlobalVariable)]
attr Compiler()

#[AttrUsage(AttributeUsage.Function)]
attr Inline()

#[AttrUsage(AttributeUsage.Function)]
attr Macro()

#[AttrUsage(AttributeUsage.Function)]
attr Mixin()

#[AttrUsage(AttributeUsage.Function)]
attr Test()

#[AttrUsage(AttributeUsage.Function)]
attr Implicit()

<span class="linecomment">// Hardcoded also for switch</span>
#[AttrUsage(AttributeUsage.Function)]
attr Complete()

#[AttrUsage(AttributeUsage.Function)]
attr NoReturn()

#[AttrUsage(AttributeUsage.Function)]
attr Foreign(module: string, function: string = "");

#[AttrUsage(AttributeUsage.Function)]
attr Callback()

#[AttrUsage(AttributeUsage.Function|AttributeUsage.Variable)]
attr Discardable()

#[AttrUsage(AttributeUsage.Function|AttributeUsage.Struct|AttributeUsage.Enum|AttributeUsage.EnumValue)]
attr Deprecated(msg: string = null)

<span class="linecomment">// Hardcoded for type alias</span>
attr Strict()

<span class="linecomment">// Hardcoded for local variables</span>
attr Global()

<span class="linecomment">// Hardcoded for struct and variables</span>
attr Align(value: u8)

#[AttrUsage(AttributeUsage.Struct)]
attr Pack(value: u8)

#[AttrUsage(AttributeUsage.Struct)]
attr NoCopy()

#[AttrUsage(AttributeUsage.StructVariable)]
attr Offset(name: string)

#[AttrUsage(AttributeUsage.Enum)]
attr EnumFlags()

#[AttrUsage(AttributeUsage.Enum)]
attr EnumIndex()

#[AttrUsage(AttributeUsage.All|AttributeUsage.File)]
attr Safety(what: string, value: bool)

#[AttrUsage(AttributeUsage.All)]
attr SelectIf(value: bool)

#[AttrUsage(AttributeUsage.Function|AttributeUsage.File)]
attr Optim(what: string, value: bool)
</code></div>
<h2 id="200_type_reflection">Type reflection</h2>
<div>In Swag, types are also values that can be inspected at compile time or at runtime. The two main intrinsics for this are <code class="incode">@typeof</code> and <code class="incode">@kindof</code>.</br>
</div>
<div>
</br>
 You can get the type of an expression with <code class="incode">@typeof</code>, or just with the type itself (<b>types are also values</b>).</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    ptr1 := @typeof(s8)
    @assert(ptr1.name == "s8")
    @assert(ptr1 == s8)

    ptr2 := @typeof(s16)
    @assert(ptr2.name == "s16")
    @assert(ptr2 == s16)

    ptr3 := s32
    @assert(ptr3.name == "s32")
    @assert(ptr3 == @typeof(s32))

    ptr4 := s64
    @assert(ptr4.name == "s64")
    @assert(ptr4 == s64)
}
</code></div><div>
</br>
 The return result of <code class="incode">@typeof</code> is a const pointer to a <code class="incode">Swag.TypeInfo</code> kind of structure. This is an alias for the <code class="incode">typeinfo</code> type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    ptr := bool
    @assert(@typeof(ptr) == @typeof(const *Swag.TypeInfoNative))

    ptr1 := #type [2] s32
    @assert(@typeof(ptr1) == @typeof(const *Swag.TypeInfoArray))
    @assert(ptr1.name == "[2] s32")
}
</code></div><div>
</br>
 The <code class="incode">TypeInfo</code> structure contains a different enum value for each type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    ptr := f64
    @assert(@typeof(ptr.kind).fullname == "Swag.TypeInfoKind")
    @assert(ptr.sizeof == @sizeof(f64))
}
</code></div><div><h3 id="@decltype">@decltype</br>
</h3></div>
<div>
</br>
 <code class="incode">@decltype</code> can be used to transform a <code class="incode">typeinfo</code> to a real compiler type. This is the opposite of <code class="incode">@typeof</code> or <code class="incode">@kindof</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    var x: @decltype(@typeof(s32))
    #assert @typeof(x) == s32
}
</code></div><div>
</br>
 <code class="incode">@decltype</code> can evaluate a constexpr expression that returns a <code class="incode">typeinfo</code> to determine the real type.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #[Swag.ConstExpr]
    func getType(needAString: bool)->typeinfo
    {
        if needAString
            return string
        else
            return s32
    }

    var x: @decltype(getType(needAString: false))
    #assert @typeof(x) == s32
    x = 0

    var x1: @decltype(getType(needAString: true))
    #assert @typeof(x1) == string
    x1 = "0"
}
</code></div>
<h2 id="210_code_inspection">Code inspection</h2>
<div><code class="incode">#message</code> is a special function that will be called by the compiler when something specific occurs during the build. The parameter of <code class="incode">#message</code> is a mask that tells the compiler when to call the function.</br>
</div>
<div>With the <code class="incode">Swag.CompilerMsgMask.SemFunctions</code> flag, for example, <code class="incode">#message</code> will be called each time a function of the module <b>has been typed</b>. You can then use <code class="incode">getMessage()</code> in the <code class="incode">@compiler()</code> interface to retrieve some informations about the reason of the call.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#message(Swag.CompilerMsgMask.SemFunctions)
{
<span class="linecomment">    // Get the interface to communicate with the compiler</span>
    itf := @compiler()

<span class="linecomment">    // Get the current message</span>
    msg := itf.getMessage()

<span class="linecomment">    // We know that the type in the message is a function because of the '#message' mask.</span>
<span class="linecomment">    // So we can safely cast.</span>
    typeFunc := cast(const *Swag.TypeInfoFunc) msg.type

<span class="linecomment">    // The message name, for `Swag.CompilerMsgMask.SemFunctions`, is the name of the function being compiled.</span>
    nameFunc := msg.name

<span class="linecomment">    // As an example, we count that name if it starts with "XX".</span>
<span class="linecomment">    // But we could use custom function attributes instead...</span>
    if @countof(nameFunc) > 2 and nameFunc[0] == "X"'u8 and nameFunc[1] == "X"'u8
        G += 1
}

var G = 0

func XXTestFunc1() {}
func XXTestFunc2() {}
func XXTestFunc3() {}
</code></div><div>The compiler will call the following function after the semantic pass. So after <b>all the functions</b> of the module have been parsed.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#message(Swag.CompilerMsgMask.PassAfterSemantic)
{
<span class="linecomment">    // We should have found 3 functions starting with "XX"</span>
    @assert(G == 3)
}
</code></div><div>This will be called for every global variables of the module.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#message(Swag.CompilerMsgMask.SemGlobals)
{
    itf := @compiler()
    msg := itf.getMessage()
}
</code></div><div>This will be called for every global types of the module (structs, enums, interfaces...).</br>
</div>
<div class="code"><code style="white-space: break-spaces">#message(Swag.CompilerMsgMask.SemTypes)
{
    itf := @compiler()
    msg := itf.getMessage()
}
</code></div>
<h2 id="220_meta_programmation">Meta programmation</h2>
<div>In Swag you can construct some source code at compile time, which will then be compiled. The source code you provide in the form of a <b>string</b> must be a valid Swag program.</br>
</div>

<h3 id="221__ast">Ast</h3>
<div>The most simple way to produce a string which contains the Swag code to compile is with an <code class="incode">#ast</code> block. An <code class="incode">#ast</code> block is executed at compile time and the string it returns will be compiled <b>inplace</b>.</br>
</div>
<div>
</br>
 The <code class="incode">#ast</code> can be a simple expression with the string to compile.</br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    #ast "x := 666"
    @assert(x == 666)
}
</code></div><div>
</br>
 Or it can be a block, with an explicit <code class="incode">return</code></br>
</div>
<div class="code"><code style="white-space: break-spaces">{
    cpt := 2
    #ast
    {
        const INC = 5
        return "cpt += " ++ INC   // Equivalent to 'cpt += 5'
    }

    @assert(cpt == 7)
}
</code></div><div><h4 id="Struct and enums">Struct and enums</br>
</h4><code class="incode">#ast</code> can for example be used to generate the content of a <code class="incode">struct</code> or <code class="incode">enum</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct MyStruct
{
    #ast
    {
        return "x, y: s32 = 666"
    }
}

var v: MyStruct
@assert(v.x == 666)
@assert(v.y == 666)
</code></div><div>It works with generics too, and can be mixed with static declarations.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct(T) MyStruct
{
    #ast
    {
        return "x, y: " ++ @typeof(T).name
    }

    z: string
}

var v: MyStruct'bool
#assert @typeof(v.x) == bool
#assert @typeof(v.y) == bool
#assert @typeof(v.z) == string

var v1: MyStruct'f64
#assert @typeof(v1.x) == f64
#assert @typeof(v1.y) == f64
#assert @typeof(v1.z) == string
</code></div><div><code class="incode">#ast</code> needs to return a <i>string like</i> value, which can of source be dynamically constructed.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[Swag.Compiler]
func append(buf: ^u8, val: string)
{
    len := 0
    while buf[len] len += 1
    @memcpy(buf + len, @dataof(val), cast(u64) @countof(val) + 1)
}

struct Vector3
{
    #ast
    {
<span class="linecomment">        // We construct the code to compile in this local array</span>
        var buf: [256] u8
        append(buf, "x: f32 = 1\n")
        append(buf, "y: f32 = 2\n")
        append(buf, "z: f32 = 3\n")

<span class="linecomment">        // And returns to the compiler the corresponding *code*</span>
        return cast(string) buf
    }
}

var v: Vector3
@assert(v.x == 1)
@assert(v.y == 2)
@assert(v.z == 3)
</code></div><div><h4 id="For example">For example</br>
</h4>This is a real life example of an <code class="incode">#ast</code> usage from the <code class="incode">Std.Core</code> module. Here we generate a structure which contains all the fields of an original other structure, but where the types are forced to be <code class="incode">bool</code>.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct(T) IsSet
{
    #ast
    {
<span class="linecomment">        // A `StringBuilder` is used to manipulate dynamic strings.</span>
        str := StrConv.StringBuilder{}

<span class="linecomment">        // We get the type of the generic parameter `T`</span>
        typeof := @typeof(T)

<span class="linecomment">        // Then we visit all the fields, assuming the type is a struct (or this will not compile).</span>
<span class="linecomment">        // For each original field, we create one with the same name, but with a `bool` type.</span>
        visit f: typeof.fields
            str.appendFormat("%: bool\n", f.name)

<span class="linecomment">        // Then we return the constructed source code.</span>
<span class="linecomment">        // It will be used by the compiler to generate the content of the `IsSet` struct.</span>
        return str.toString()
    }
}
</code></div><div><h4 id="At global scope">At global scope</br>
</h4><code class="incode">#ast</code> can also be called at the global scope.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#ast
{
    const value = 666
    return "const myGeneratedConst = " ++ value
}
</code></div><div>But be aware that you must use <code class="incode">#placeholder</code> in case you are generating global symbols that can be used by something else in the code. This will tell Swag that <i>this symbol</i> will exist at some point, so please wait for it to <i>exist</i> before complaining.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#placeholder myGeneratedConst   // Symbol `myGeneratedConst` will be generated
</code></div><div>Here for example, thanks to the <code class="incode">#placeholder</code>, the <code class="incode">#assert</code> will wait for the symbol <code class="incode">myGeneratedConst</code> to be replaced with its real content.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#assert myGeneratedConst == 666
</code></div>
<h3 id="222__compiler_interface">Compiler interface</h3>
<div>The other method to compile generated code is to use the function <code class="incode">compileString()</code> in the <code class="incode">@compiler()</code> interface. Of course this should be called at compile time, and mostly during a <code class="incode">#message</code> call.</br>
</br>
Here is a real life example from the <code class="incode">Std.Ogl</code> module (opengl wrapper), which uses <code class="incode">#message</code> to track functions marked with a specific <b>user attribute</b> <code class="incode">Ogl.Extension</code>, and generates some code for each function that has been found.</br>
</div>
<div>First we declare a new specific attribute, which can then be associated with a function.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#[AttrUsage(AttributeUsage.Function)]
attr Extension()

<span class="linecomment">// Here is an example of usage of that attribute.</span>
#[Extension]
{
    func glUniformMatrix2x3fv(location: GLint, count: GLsizei, transpose: GLboolean, value: const *GLfloat);
    func glUniformMatrix2x4fv(location: GLint, count: GLsizei, transpose: GLboolean, value: const *GLfloat);
    func glUniformMatrix3x2fv(location: GLint, count: GLsizei, transpose: GLboolean, value: const *GLfloat);
    func glUniformMatrix3x4fv(location: GLint, count: GLsizei, transpose: GLboolean, value: const *GLfloat);
    func glUniformMatrix4x2fv(location: GLint, count: GLsizei, transpose: GLboolean, value: const *GLfloat);
    func glUniformMatrix4x3fv(location: GLint, count: GLsizei, transpose: GLboolean, value: const *GLfloat);
}
</code></div><div>The following will be used to track the functions with that specific attribute.</br>
</div>
<div class="code"><code style="white-space: break-spaces">struct OneFunc
{
    type: typeinfo
    name: string
}

#[Compiler]
var g_Functions: Array'OneFunc
</code></div><div>This <code class="incode">#message</code> will be called for each function of the <code class="incode">Ogl</code> module.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#message(CompilerMsgMask.SemFunctions)
{
    itf := @compiler()
    msg := itf.getMessage()

<span class="linecomment">    // If the function does not have our attribute, forget it</span>
    if !Reflection.hasAttribute(msg.type, Extension)
        return

<span class="linecomment">    // We just track all the functions with the given attribute</span>
    g_Functions.add({msg.type, msg.name})
}
</code></div><div>We will generate a <code class="incode">glInitExtensions</code> global function, so we register it as a place holder.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#placeholder glInitExtensions
</code></div><div>This is called once all functions of the module have been typed, and this is the main code generation.</br>
</div>
<div class="code"><code style="white-space: break-spaces">#message(CompilerMsgMask.PassAfterSemantic)
{
    var builderVars: StringBuilder
    var builderInit: StringBuilder

<span class="linecomment">    // Generate the `glInitExtensions` function</span>
    builderInit.appendString("public func glInitExtensions()\n{\n");

<span class="linecomment">    // Visit all functions we have registered, i.e. all functions with the `Ogl.Extension` attribute.</span>
    visit e: g_Functions
    {
        typeFunc := cast(const *TypeInfoFunc) e.type

<span class="linecomment">        // Declare a lambda variable for that extension</span>
        builderVars.appendFormat("var ext_%: %\n", e.name, typeFunc.name)

<span class="linecomment">        // Make a wrapper function</span>
        builderVars.appendFormat("public func %(", e.name)
        visit p, i: typeFunc.parameters
        {
            if i != 0 builderVars.appendString(", ")
            builderVars.appendFormat("p%: %", i, p.pointedType.name)
        }

        if typeFunc.returnType == void
            builderVars.appendFormat(")\n{\n")
        else
            builderVars.appendFormat(")->%\n{\n", typeFunc.returnType.name)
        builderVars.appendFormat("\treturn ext_%(", e.name)
        visit p, i: typeFunc.parameters
        {
            if i != 0 builderVars.appendString(", ")
            builderVars.appendFormat("p%", i)
        }

        builderVars.appendString(");\n}\n\n")

<span class="linecomment">        // Initialize the variable with the getExtensionAddress</span>
        builderInit.appendFormat("\text_% = cast(%) getExtensionAddress(@dataof(\"%\"))\n", e.name, typeFunc.name, e.name);
    }

<span class="linecomment">    // Compile !!</span>
    itf := @compiler()
    str := builderVars.toString()
    itf.compileString(str.toString())

    builderInit.appendString("}\n");
    str = builderInit.toString()
    itf.compileString(str.toString())
}
</code></div>
</div>
</div>
</div>
</body>
</html>
