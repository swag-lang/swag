<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<?php include('common/start-head.php'); ?><title>Swag Language Reference</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script src="https://kit.fontawesome.com/f76be2b3ee.js" crossorigin="anonymous"></script>
<style>

    .container  { display: flex; flex-wrap: nowrap; flex-direction: row; margin: 0px auto; padding: 0px; }
    .left       { display: block; overflow-y: scroll; width: 500px; }
    .left-page  { margin: 10px; }
    .right      { display: block; width: 100%; }
    .right-page { max-width: 1024px; margin: 10px auto; }
    
    @media(min-width: 640px)  { .container { max-width: 640px; }}
    @media(min-width: 768px)  { .container { max-width: 768px; }}
    @media(min-width: 1024px) { .container { max-width: 1024px; }}
    @media(min-width: 1280px) { .container { max-width: 1280px; }}
    @media(min-width: 1536px) { .container { max-width: 1536px; }}
    
    @media screen and (max-width: 600px) {
        .left       { display: none; }
        .right-page { margin:  10px; }
    }

            .container { height: 100vh; }
            .right     { overflow-y: scroll; }
        
    html { font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
    body { margin: 0px; line-height: 1.3em; }     

    .container a        { color: DoggerBlue; }
    .container a:hover  { text-decoration: underline; }
    .container img      { margin: 0 auto; }
   
    .left a     { text-decoration: none; }
    .left ul    { list-style-type: none; margin-left: -20px; }
    .left h3    { background-color: Black; color: White; padding: 6px; }
    .right h1   { margin-top: 50px; margin-bottom: 50px; }
    .right h2   { margin-top: 35px; }

    .right ol li { margin-bottom: 10px; }

    .strikethrough-text { text-decoration: line-through; }
    .swag-watermark     { text-align:right; font-size: 80%; margin-top: 30px; }
    .swag-watermark a   { text-decoration: none; color: inherit; }

    .blockquote               { border-radius: 5px; border: 1px solid; margin: 20px; padding: 10px; }
    .blockquote-default       { border-color: Orange; border-left: 6px solid Orange; background-color: LightYellow; }
    .blockquote-note          { border-color: #ADCEDD; background-color: #CDEEFD; }
    .blockquote-tip           { border-color: #BCCFBC; background-color: #DCEFDC; }
    .blockquote-warning       { border-color: #DFBDB3; background-color: #FFDDD3; }
    .blockquote-attention     { border-color: #DDBAB8; background-color: #FDDAD8; }
    .blockquote-example       { border: 2px solid LightGrey; }
    .blockquote-title-block   { margin-bottom: 10px; }
    .blockquote-title         { font-weight: bold; }
    .blockquote-default       p:first-child { margin-top: 0px; }
    .blockquote-default       p:last-child  { margin-bottom: 0px; }
    .blockquote               p:last-child  { margin-bottom: 0px; }

    .description-list-title   { font-weight: bold; font-style: italic; }
    .description-list-block   { margin-left: 30px; }

    .container table          { border: 1px solid LightGrey; border-collapse: collapse; font-size: 90%; margin-left: 20px; margin-right: 20px; }
    .container td             { border: 1px solid LightGrey; border-collapse: collapse; padding: 6px; min-width: 100px; }
    .container th             { border: 1px solid LightGrey; border-collapse: collapse; padding: 6px; min-width: 100px; background-color: #eeeeee; }

    table.api-item            { border-collapse: separate; background-color: Black; color: White; width: 100%; margin-top: 70px; margin-right: 0px; font-size: 110%; }
    .api-item td              { font-size: revert; border: 0; }
    .api-item td:first-child  { width: 33%; white-space: nowrap; }
    .api-item-title-src-ref   { text-align:  right; }
    .api-item-title-src-ref a { color:       inherit; }
    .api-item-title-kind      { font-weight: normal; font-size: 80%; }
    .api-item-title-light     { font-weight: normal; }
    .api-item-title-strong    { font-weight: bold; font-size: 100%; }
    .api-additional-infos     { font-size: 90%; white-space: break-spaces; overflow-wrap: break-word; }

    table.table-enumeration           { width: calc(100% - 40px); }
    .table-enumeration td:first-child { background-color: #f8f8f8; white-space: nowrap; }
    .table-enumeration td:last-child  { width: 100%; }
    .table-enumeration td.code-type   { background-color: #eeeeee; }
    .table-enumeration a              { text-decoration: none; color: inherit; }

    .code-inline  { background-color: #eeeeee; border-radius: 5px; border: 1px dotted #cccccc; padding: 0px 8px; font-size: 110%; font-family: monospace; display: inline-block; }
    .code-block   { background-color: #eeeeee; border-radius: 5px; border: 1px solid LightGrey; padding: 10px; margin: 20px; white-space: pre; overflow-x: auto; }
    .code-block   { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .code-block a { color: inherit; }

    .blockquote-default     .code-inline    { background-color: #FFE89C; }
    .blockquote-note        .code-inline    { border-color: #9DBECD; background-color: #BDDEED; }
    .blockquote-tip         .code-inline    { border-color: #ACBFAC; background-color: #CCDFCC; }
    .blockquote-warning     .code-inline    { border-color: #CFADA3; background-color: #EFCDC3; }
    .blockquote-attention   .code-inline    { border-color: #CDAAA8; background-color: #EDCAC8; }
    .SCde { color: #222222; }
    .SCmt { color: #71a35b; }
    .SCmp { color: #7f7f7f; }
    .SFct { color: #ff6a00; }
    .SCst { color: #3bc3a7; }
    .SItr { color: #b4b44a; }
    .STpe { color: #ed9a11; }
    .SKwd { color: #3186cd; }
    .SLgc { color: #b040be; }
    .SNum { color: #74a35b; }
    .SStr { color: #bb6643; }
    .SAtr { color: #7f7f7f; }
    .SBcR { color: #b5af49; }
    .SInv { color: #ff0000; }
</style>
<?php include('common/end-head.php'); ?>
</head>
<body>
<?php include('common/start-body.php'); ?>
<div class="container">
<div class="left">
<div class="left-page">
<h2>Table of Contents</h2>
<ul>
<li><a href="#_001_000_introduction_swg">Introduction</a></li>
<ul>
<li><a href="#_001_000_introduction_swg__001_001_hello_mad_world_swg">Hello mad world</a></li>
</ul>
<li><a href="#_002_000_code_structure_swg">Code structure</a></li>
<ul>
<li><a href="#_002_000_code_structure_swg__002_002_source_code_organization_swg">Source code organization</a></li>
<li><a href="#_002_000_code_structure_swg__002_003_global_declaration_order_swg">Global declaration order</a></li>
<li><a href="#_002_000_code_structure_swg__002_004_comments_swg">Comments</a></li>
<li><a href="#_002_000_code_structure_swg__002_005_semicolons_swg">Semicolons</a></li>
<li><a href="#_002_000_code_structure_swg__002_006_identifiers_swg">Identifiers</a></li>
<li><a href="#_002_000_code_structure_swg__002_007_keywords_swg">Keywords</a></li>
</ul>
<li><a href="#_003_000_fundamentals_swg">Fundamentals</a></li>
<ul>
<li><a href="#_003_000_fundamentals_swg__003_001_basic_types_swg">Basic types</a></li>
<li><a href="#_003_000_fundamentals_swg__003_002_number_literals_swg">Number literals</a></li>
<li><a href="#_003_000_fundamentals_swg__003_003_string_swg">String</a></li>
<li><a href="#_003_000_fundamentals_swg__003_004_constants_swg">Constants</a></li>
<li><a href="#_003_000_fundamentals_swg__003_005_variables_swg">Variables</a></li>
<li><a href="#_003_000_fundamentals_swg__003_006_operators_swg">Operators</a></li>
<li><a href="#_003_000_fundamentals_swg__003_007_cast_swg">Cast</a></li>
<li><a href="#_003_000_fundamentals_swg__003_008_alias_swg">Alias</a></li>
</ul>
<li><a href="#_004_000_data_structures_swg">Data structures</a></li>
<ul>
<li><a href="#_004_000_data_structures_swg__004_001_array_swg">Array</a></li>
<li><a href="#_004_000_data_structures_swg__004_002_slice_swg">Slice</a></li>
<li><a href="#_004_000_data_structures_swg__004_003_tuple_swg">Tuple</a></li>
<li><a href="#_004_000_data_structures_swg__004_004_enum_swg">Enum</a></li>
<li><a href="#_004_000_data_structures_swg__004_005_impl_swg">Impl</a></li>
<li><a href="#_004_000_data_structures_swg__004_006_union_swg">Union</a></li>
<li><a href="#_004_000_data_structures_swg__004_007_pointers_swg">Pointers</a></li>
<li><a href="#_004_000_data_structures_swg__004_008_references_swg">References</a></li>
<li><a href="#_004_000_data_structures_swg__004_009_any_swg">Any</a></li>
</ul>
<li><a href="#_005_000_control_flow_swg">Control flow</a></li>
<ul>
<li><a href="#_005_000_control_flow_swg__005_001_if_swg">If</a></li>
<li><a href="#_005_000_control_flow_swg__005_002_loop_swg">Loop</a></li>
<li><a href="#_005_000_control_flow_swg__005_003_for_swg">For</a></li>
<li><a href="#_005_000_control_flow_swg__005_004_while_swg">While</a></li>
<li><a href="#_005_000_control_flow_swg__005_005_switch_swg">Switch</a></li>
<li><a href="#_005_000_control_flow_swg__005_006_break_swg">Break</a></li>
<li><a href="#_005_000_control_flow_swg__005_007_visit_swg">Visit</a></li>
</ul>
<li><a href="#_006_000_structs_swg">Structs</a></li>
<ul>
<li><a href="#_006_000_structs_swg__006_001_declaration_swg">Declaration</a></li>
<li><a href="#_006_000_structs_swg__006_002_impl_swg">Impl</a></li>
<li><a href="#_006_000_structs_swg__006_003_offset_swg">Offset</a></li>
<li><a href="#_006_000_structs_swg__006_004_packing_swg">Packing</a></li>
<li><a href="#_006_000_structs_swg__006_005_special_functions_swg">Special functions</a></li>
<li><a href="#_006_000_structs_swg__006_006_custom_assignment_swg">Custom assignment</a></li>
<li><a href="#_006_000_structs_swg__006_007_custom_loop_swg">Custom loop</a></li>
<li><a href="#_006_000_structs_swg__006_008_custom_iteration_swg">Custom iteration</a></li>
<li><a href="#_006_000_structs_swg__006_009_custom_copy_and_move_swg">Custom copy and move</a></li>
<li><a href="#_006_000_structs_swg__006_010_custom_literals_swg">Custom literals</a></li>
<li><a href="#_006_000_structs_swg__006_011_interface_swg">Interface</a></li>
</ul>
<li><a href="#_007_000_functions_swg">Functions</a></li>
<ul>
<li><a href="#_007_000_functions_swg__007_001_declaration_swg">Declaration</a></li>
<li><a href="#_007_000_functions_swg__007_002_lambda_swg">Lambda</a></li>
<li><a href="#_007_000_functions_swg__007_003_closure_swg">Closure</a></li>
<li><a href="#_007_000_functions_swg__007_004_mixin_swg">Mixin</a></li>
<li><a href="#_007_000_functions_swg__007_005_macro_swg">Macro</a></li>
<li><a href="#_007_000_functions_swg__007_006_variadic_parameters_swg">Variadic parameters</a></li>
<li><a href="#_007_000_functions_swg__007_007_ufcs_swg">Ufcs</a></li>
<li><a href="#_007_000_functions_swg__007_008_constexpr_swg">Constexpr</a></li>
<li><a href="#_007_000_functions_swg__007_009_function_overloading_swg">Function overloading</a></li>
<li><a href="#_007_000_functions_swg__007_010_discard_swg">Discard</a></li>
<li><a href="#_007_000_functions_swg__007_011_retval_swg">Retval</a></li>
<li><a href="#_007_000_functions_swg__007_012_foreign_swg">Foreign</a></li>
<li><a href="#_007_000_functions_swg__007_013_special_functions_swg">Special functions</a></li>
</ul>
<li><a href="#_008_000_intrinsics_swg">Intrinsics</a></li>
<ul>
<li><a href="#_008_000_intrinsics_swg__008_001_init_swg">Init</a></li>
<li><a href="#_008_000_intrinsics_swg__008_002_drop_swg">Drop</a></li>
</ul>
<li><a href="#_009_000_generics_swg">Generics</a></li>
<ul>
<li><a href="#_009_000_generics_swg__009_001_functions_swg">Functions</a></li>
<li><a href="#_009_000_generics_swg__009_002_structs_swg">Structs</a></li>
<li><a href="#_009_000_generics_swg__009_003_where_constraints_swg">Where constraints</a></li>
</ul>
<li><a href="#_010_000_attributes_swg">Attributes</a></li>
<ul>
<li><a href="#_010_000_attributes_swg__010_001_user_attributes_swg">User attributes</a></li>
<li><a href="#_010_000_attributes_swg__010_002_predefined_attributes_swg">Predefined attributes</a></li>
</ul>
<li><a href="#_011_000_scoping_swg">Scoping</a></li>
<ul>
<li><a href="#_011_000_scoping_swg__011_001_namespace_swg">Namespace</a></li>
<li><a href="#_011_000_scoping_swg__011_002_defer_swg">Defer</a></li>
<li><a href="#_011_000_scoping_swg__011_003_using_swg">Using</a></li>
<li><a href="#_011_000_scoping_swg__011_004_with_swg">With</a></li>
</ul>
<li><a href="#_012_000_type_reflection_swg">Type reflection</a></li>
<li><a href="#_013_000_error_management_and_safety_swg">Error management and safety</a></li>
<ul>
<li><a href="#_013_000_error_management_and_safety_swg__013_001_error_management_swg">Error management</a></li>
<li><a href="#_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety</a></li>
</ul>
<li><a href="#_014_000_compile-time_evaluation_swg">Compile-time evaluation</a></li>
<ul>
<li><a href="#_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Constexpr</a></li>
<li><a href="#_014_000_compile-time_evaluation_swg__014_002_run_swg">Run</a></li>
<li><a href="#_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg">Compiler instructions</a></li>
<li><a href="#_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Code inspection</a></li>
</ul>
<li><a href="#_017_000_meta_programming_swg">Meta programming</a></li>
<ul>
<li><a href="#_017_000_meta_programming_swg__017_001_ast_swg">Ast</a></li>
<li><a href="#_017_000_meta_programming_swg__017_002_compiler_interface_swg">Compiler interface</a></li>
</ul>
<li><a href="#_018_000_documentation_md">Documentation</a></li>
<ul>
<li><a href="#_018_000_documentation_md__018_001_api_swg">Api</a></li>
<li><a href="#_018_000_documentation_md__018_002_examples_md">Examples</a></li>
<li><a href="#_018_000_documentation_md__018_003_pages_md">Pages</a></li>
</ul>
</div>
</div>
<div class="right">
<div class="right-page">
<h1>Swag Language Reference</h1>

<h2 id="_001_000_introduction_swg">Introduction</h2><p>The <span class="code-inline">swag-lang/swag/bin/reference/language</span> module offers a foundational introduction to the syntax and usage of the Swag programming language, separate from the <a href="std.php">Swag standard modules</a> (<span class="code-inline">Std</span>). This documentation is auto-generated from the module's source code. </p>
<p>For more advanced features, such as dynamic arrays, dynamic strings, or hash maps, please consult the <a href="std.core.php">Std.Core</a> module documentation, as these topics are beyond the scope of the examples covered here. This guide focuses exclusively on the core elements of the Swag language. </p>
<p>Since <span class="code-inline">reference/language</span> is implemented as a test module, you can run it using the following commands: </p>
<div class="code-block"><span class="SCde">swag test --workspace:c:/swag-lang/swag/bin/reference
swag test -w:c:/swag-lang/swag/bin/reference</span></div>
<p>These commands will execute all test modules within the specified workspace, including this one. If you are running Swag from the workspace directory, the <span class="code-inline">--workspace</span> flag (or shorthand <span class="code-inline">-w</span>) can be omitted. </p>
<p>To compile and execute a specific module within the workspace, use the <span class="code-inline">--module</span> (or <span class="code-inline">-m</span>) flag: </p>
<div class="code-block"><span class="SCde">swag test -w:c:/swag-lang/swag/bin/reference -m:test_language</span></div>

<h3 id="_001_000_introduction_swg__001_001_hello_mad_world_swg">Hello mad world</h3><p>Let's start with the most simple version of the "hello world" example. This is a version that does not require external dependencies like the <a href="std.php">Swag standard modules</a>. </p>
<p><span class="code-inline">#main</span> is the <b>program entry point</b>, a special compiler function (that's why the name starts with <span class="code-inline">#</span>). It must be defined only once for a native executable. <span class="code-inline">@print</span> is an <b>intrinsic</b>, a special built-in function (that's why the name starts with <span class="code-inline">@</span>). </p>
<p>All intrinsics are part of the <a href="std/swag.runtime.php">compiler runtime</a> which comes with the compiler. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SItr">@print</span>(<span class="SStr">"Hello mad world !\n"</span>)
}</span></div>
<p>Next, a version that this time uses the <span class="code-inline">Core.Console.print</span> function in the <a href="std.core.html">Std.Core</a> module. The <span class="code-inline">Std.Core</span> module would have to be imported in order to be used, but let's keep it simple. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world !"</span>, <span class="SStr">"\n"</span>)
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">printf</span>(<span class="SStr">"%\n"</span>, <span class="SStr">"Hello mad world again !"</span>)
}</span></div>
<p>A <span class="code-inline">#run</span> block is executed at <b>compile time</b>, and can make Swag behaves like a kind of a <b>scripting language</b>. So in the following example, the famous message will be printed by the compiler during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
{
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SStr">"Hello mad world !\n"</span>   <span class="SCmt">// Creates a compiler constant of type 'string'</span>
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)             <span class="SCmt">// And call 'Console.print' at compile time</span>
}</span></div>
<p>A version that calls a <b>nested function</b> at compile time (only) to initialize the string constant to print. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Brings the 'Core' namespace into scope, to avoid repeating it again and again</span>
<span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">nestedFunc</span>() =&gt; <span class="SStr">"Hello mad world !\n"</span>   <span class="SCmt">// Function short syntax</span>

    <span class="SCmt">// nestedFunc() can be called at compile time because it is marked with</span>
    <span class="SCmt">// the 'Swag.ConstExpr' attribute.</span>
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SFct">nestedFunc</span>()
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)
}</span></div>
<p>Now a stupid version that generates the code to: the print thanks to <b>meta programming</b>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SStr">"Hello mad world !\n"</span>

    <span class="SCmt">// The result of an '#ast' block is a string that will be compiled in place.</span>
    <span class="SCmt">// So this whole thing is equivalent to a simple 'Console.print(Msg)'.</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">var</span> sb = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}
        sb.<span class="SFct">appendString</span>(<span class="SStr">"Console.print(Msg)"</span>)
        <span class="SLgc">return</span> sb.<span class="SFct">toString</span>()
    }
}</span></div>
<p>And finally let's be more and more crazy. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SCmt">// #run will force the call of mySillyFunction() at compile time even if it's not marked</span>
    <span class="SCmt">// with #[Swag.ConstExpr]</span>
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SFct">#run</span> <span class="SFct">mySillyFunction</span>()
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)
}

<span class="SCmt">// The attribute #[Swag.Compiler] tells Swag that this is a compile time function only.</span>
<span class="SCmt">// So this function will not be exported to the final executable or module.</span>
<span class="SAtr">#[Swag.Compiler]</span>
<span class="SKwd">func</span> <span class="SFct">mySillyFunction</span>()-&gt;<span class="STpe">string</span>
{
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world at compile time !\n"</span>)

    <span class="SCmt">// This creates a constant named 'MyConst'</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">var</span> sb = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}
        sb.<span class="SFct">appendString</span>(<span class="SStr">"const MyConst = \"Hello "</span>)
        sb.<span class="SFct">appendString</span>(<span class="SStr">"mad world "</span>)
        sb.<span class="SFct">appendString</span>(<span class="SStr">"at runtime !\""</span>)
        <span class="SLgc">return</span> sb.<span class="SFct">toString</span>()
    }

    <span class="SLgc">return</span> <span class="SCst">MyConst</span>
}</span></div>
<p>This whole piece of code is equivalent to... </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world at runtime !"</span>)
}</span></div>

<h2 id="_002_000_code_structure_swg">Code structure</h2><p>In Swag, all source files are required to use the <span class="code-inline">.swg</span> extension, with the exception of simple script files, which use the <span class="code-inline">.swgs</span> extension. All files must be encoded in <b>UTF-8</b> to ensure proper handling of text and symbols. </p>
<p>Swag does not support the compilation of individual source files (except for <span class="code-inline">.swgs</span> script files). Instead, source code is structured within a <b>workspace</b> that comprises one or more <b>modules</b>. This approach promotes organized and modular development, allowing for efficient management of complex projects. </p>
<p>For example, <span class="code-inline">Std</span> is a workspace that includes all the standard modules provided by Swag. </p>
<p>A module can either be a <span class="code-inline">dll</span> (on Windows) or an executable. A single workspace may contain multiple modules, meaning that a workspace usually includes the modules you develop (such as your main executable) as well as all your dependencies, including any external modules. </p>
<p>Typically, the entire workspace is compiled together, ensuring that all modules and their dependencies are up to date and correctly integrated. </p>

<h3 id="_002_000_code_structure_swg__002_002_source_code_organization_swg">Source code organization</h3><p>In Swag, all source files use the <span class="code-inline">.swg</span> extension, except for simple scripts, which use the <span class="code-inline">.swgs</span> extension. All files must be encoded in <b>UTF-8</b>. </p>
<p>Swag does not support compiling individual source files (with the exception of <span class="code-inline">.swgs</span> script files). Instead, source code is organized within a <b>workspace</b> that contains one or more <b>modules</b>. </p>
<p>For instance, <span class="code-inline">Std</span> is a workspace that includes all the Swag standard modules. </p>
<p>A module can be either a <span class="code-inline">dll</span> (on Windows) or an executable, and a workspace may encompass multiple modules. Therefore, a workspace typically contains both the modules you develop (such as your main executable) and all your dependencies (including any external modules you use). </p>
<p>In most cases, the entire workspace is compiled together. </p>

<h3 id="_002_000_code_structure_swg__002_003_global_declaration_order_swg">Global declaration order</h3><p>The order of all <b>top-level</b> declarations in Swag does not matter. This feature allows you to reference constants, variables, or functions before they are defined, either within the same file or even across multiple files. This flexibility can be particularly useful in large codebases, where the natural flow of logic or readability may benefit from organizing code independently of its declaration order. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// In this example, we declare a constant 'A' and initialize it with 'B', </span>
<span class="SCmt">// even though 'B' has not yet been declared or defined.</span>
<span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SCst">B</span>

<span class="SCmt">// Next, we declare a constant 'B' and initialize it with 'C',</span>
<span class="SCmt">// which is also not declared or defined at this point.</span>
<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCst">C</span>

<span class="SCmt">// Finally, we declare and define 'C' as a constant of type 'u64' </span>
<span class="SCmt">// (an unsigned 64-bit integer) with a value of 1.</span>
<span class="SCmt">// This retroactively assigns values to both 'A' and 'B', </span>
<span class="SCmt">// based on the earlier assignments.</span>
<span class="SKwd">const</span> <span class="SCst">C</span>: <span class="STpe">u64</span> = <span class="SNum">1</span></span></div>
<p>In this test, we demonstrate Swag's flexibility by calling the function <span class="code-inline">functionDeclaredLater</span> before it is defined. Swag's allowance for this behavior highlights the language's flexibility in handling the order of top-level declarations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
{
    <span class="SCmt">// We call the function 'functionDeclaredLater' before it is declared.</span>
    <span class="SCmt">// Swag permits this because the order of function declarations and calls is flexible.</span>
    <span class="SFct">functionDeclaredLater</span>()
}

<span class="SCmt">// The function is declared here, after it has already been called.</span>
<span class="SKwd">func</span> <span class="SFct">functionDeclaredLater</span>() {}</span></div>
<p>It is important to note that this flexibility applies not only within the same file but also across multiple files. For instance, you can call a function in one file and define it in another. The global order of declarations in Swag is designed to be non-restrictive, allowing for a more intuitive organization of your code. </p>

<h3 id="_002_000_code_structure_swg__002_004_comments_swg">Comments</h3><p>Swag supports both single-line and multi-line comments, allowing for flexible documentation  and inline explanations within your code. This capability is essential for maintaining clarity  and readability, especially in complex codebases. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Example of a single-line comment</span>
<span class="SCmt">// Single-line comments are typically used for brief explanations or notes.</span>

<span class="SCmt">/*
    Example of a multi-line comment
    that spans several lines.
    
    Multi-line comments are useful when more detailed explanations are required. 
    These comments can describe the overall purpose of a function, document complex 
    logic, or provide additional context to developers.
*/</span>

<span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SNum">0</span>                 <span class="SCmt">// A constant named 'A' is declared and assigned the value '0'.</span>
<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCmt">/* false */</span> <span class="SKwd">true</span>  <span class="SCmt">// A constant named 'B' is assigned the value 'true', with an inline </span>
                            <span class="SCmt">// comment indicating that 'false' was an alternative considered value.</span></span></div>
<p>Swag also supports nested comments within multi-line comments. This feature can be particularly useful when temporarily disabling a block of code  or when adding additional notes inside an existing comment block. </p>
<div class="code-block"><span class="SCmt">/*
    */ Example of a nested multi-line comment */
    The nested comment above is encapsulated within another multi-line comment.
    This demonstrates Swag's ability to handle complex comment structures without 
    causing errors or ambiguity.
*/</span></div>

<h3 id="_002_000_code_structure_swg__002_005_semicolons_swg">Semicolons</h3><h4 id="_002_000_code_structure_swg__002_005_semicolons_swg">Statement Termination in Swag </h4>
<p>In Swag, unlike languages such as C/C++, there is no strict requirement to end statements with a semicolon (<span class="code-inline">;</span>). The default method of terminating a statement in Swag is simply reaching the end of a line (<span class="code-inline">end of line</span>). This feature allows for cleaner and more concise syntax, reducing visual clutter and making the code easier to read. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Declare two variables, x and y, both of type s32 (signed 32-bit integer), </span>
    <span class="SCmt">// and initialize them with the value 1.</span>
    <span class="SKwd">var</span> x, y: <span class="STpe">s32</span> = <span class="SNum">1</span>

    <span class="SCmt">// Increment the value of both x and y by 1.</span>
    x += <span class="SNum">1</span>
    y += <span class="SNum">1</span>

    <span class="SCmt">// Use the '@assert' intrinsic to verify the correctness of the program logic.</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">2</span>)     <span class="SCmt">// Confirms that x equals 2. An error is raised if this assertion fails.</span>
    <span class="SItr">@assert</span>(y == x)     <span class="SCmt">// Confirms that y equals x, which should also be 2 at this point.</span>
}</span></div>
<h4 id="_002_000_code_structure_swg__002_005_semicolons_swg">Optional Semicolons </h4>
<p>While semicolons are optional in Swag, they can still be used if desired. In some cases, using semicolons might enhance the clarity of the code or improve readability, particularly when dealing with more complex statements or when writing multiple statements on a single line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Here, type inference is used, so the types of x and y are not explicitly defined.</span>
    <span class="SKwd">var</span> x, y = <span class="SNum">0</span>;  <span class="SCmt">// Both x and y are initialized to 0, with their types inferred automatically.</span>

    <span class="SCmt">// The following statement increments both x and y by 1 simultaneously.</span>
    x, y += <span class="SNum">1</span>;     <span class="SCmt">// Both x and y now have the value 1.</span>
}</span></div>
<h4 id="_002_000_code_structure_swg__002_005_semicolons_swg">Multiple Statements on a Single Line </h4>
<p>Semicolons become particularly useful when you need to write multiple statements on a single line.  Although this can make the code more compact, it is advisable to use this approach sparingly,  as excessive use may negatively impact code readability. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Two variable declarations and initializations on a single line.</span>
    <span class="SKwd">var</span> x = <span class="SNum">0</span>; <span class="SKwd">var</span> y = <span class="SNum">0</span>

    <span class="SCmt">// Increment both x and y by 1, all on the same line.</span>
    x += <span class="SNum">1</span>; y += <span class="SNum">1</span>

    <span class="SCmt">// Assert the correctness of both x and y values on the same line.</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>); <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)
}</span></div>

<h3 id="_002_000_code_structure_swg__002_006_identifiers_swg">Identifiers</h3><h4 id="_002_000_code_structure_swg__002_006_identifiers_swg">Naming </h4>
<p>User-defined identifiers, such as variables, constants, and function names, must begin with either an underscore or an ASCII letter. These identifiers can then include underscores, ASCII letters, and digits. </p>
<p>Examples: </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> thisIsAValidIdentifier0   = <span class="SNum">0</span>
<span class="SKwd">const</span> this_is_also_valid        = <span class="SNum">0</span>
<span class="SKwd">const</span> this_1_is_2_also__3_valid = <span class="SNum">0</span></span></div>
<p>However, identifiers cannot start with two underscores, as this prefix is reserved by the compiler. </p>
<div class="code-block"><span class="SCmt">// const __this_is_invalid = 0</span></div>
<h4 id="_002_000_code_structure_swg__002_006_identifiers_swg">Compiler Instructions </h4>
<p>Additionally, some identifiers may begin with <span class="code-inline">#</span>, indicating a compiler instruction. These instructions have specific roles within the Swag programming environment. </p>
<p>Examples of compiler instructions: </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span>
<span class="SFct">#run</span>
<span class="SFct">#main</span></span></div>
<h4 id="_002_000_code_structure_swg__002_006_identifiers_swg">Intrinsics </h4>
<p>Identifiers that start with <span class="code-inline">@</span> represent intrinsic functions. These functions may be available only at compile time or at both compile time and runtime, depending on the specific intrinsic. </p>
<p>Examples of intrinsic functions: </p>
<div class="code-block"><span class="SCde"><span class="SItr">@min</span>()
<span class="SItr">@max</span>()
<span class="SItr">@sqrt</span>()
<span class="SItr">@print</span>()</span></div>

<h3 id="_002_000_code_structure_swg__002_007_keywords_swg">Keywords</h3><h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Special Keywords </h4>
<p>Special keywords are predefined, reserved identifiers that have specific meanings within the Swag compiler. These cannot be used as identifiers in your code as they are integral to the language's structure. </p>
<div class="code-block"><span class="SCde"><span class="SLgc">if</span>
<span class="SLgc">else</span>
<span class="SLgc">elif</span>
<span class="SLgc">while</span>
<span class="SLgc">switch</span>
<span class="SLgc">defer</span>
<span class="SLgc">for</span>
<span class="SLgc">foreach</span>
<span class="SLgc">break</span>
<span class="SLgc">fallthrough</span>
<span class="SLgc">return</span>
<span class="SLgc">case</span>
<span class="SLgc">continue</span>
<span class="SLgc">default</span>
<span class="SLgc">and</span>
<span class="SLgc">or</span>
<span class="SLgc">orelse</span>
<span class="SLgc">unreachable</span>
<span class="SLgc">to</span>
<span class="SLgc">until</span>
<span class="SLgc">where</span>
<span class="SLgc">in</span>
<span class="SLgc">as</span>

<span class="SKwd">true</span>
<span class="SKwd">false</span>
<span class="SKwd">null</span>
<span class="SKwd">undefined</span>

<span class="SKwd">using</span>
<span class="SKwd">with</span>
<span class="SKwd">cast</span>
<span class="SKwd">dref</span>
<span class="SKwd">retval</span>
<span class="SKwd">try</span>
<span class="SKwd">trycatch</span>
<span class="SKwd">catch</span>
<span class="SKwd">assume</span>
<span class="SKwd">throw</span>
<span class="SKwd">discard</span>

<span class="SKwd">public</span>
<span class="SKwd">internal</span>
<span class="SKwd">private</span>

<span class="SKwd">enum</span>
<span class="SKwd">struct</span>
<span class="SKwd">union</span>
<span class="SKwd">impl</span>
<span class="SKwd">interface</span>
<span class="SKwd">func</span>
<span class="SKwd">mtd</span>
<span class="SKwd">namespace</span>
<span class="SKwd">alias</span>
<span class="SKwd">attr</span>
<span class="SKwd">var</span>
<span class="SKwd">let</span>
<span class="SKwd">const</span>
<span class="SKwd">moveref</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Reserved Keywords </h4>
<p>These keywords are reserved by the language and cannot be used by developers, even though they may not currently serve an active role in the syntax. They are reserved for potential future use or to avoid conflicts with language features. </p>
<div class="code-block"><span class="SCde"><span class="SInv">is</span>
<span class="SInv">not</span>
<span class="SInv">do</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Basic Types </h4>
<p>These are the fundamental data types provided by the language. They are reserved keywords and form the core types that can be used to define variables, constants, and function return types. </p>
<div class="code-block"><span class="SCde"><span class="STpe">s8</span>
<span class="STpe">s16</span>
<span class="STpe">s32</span>
<span class="STpe">s64</span>
<span class="STpe">u8</span>
<span class="STpe">u16</span>
<span class="STpe">u32</span>
<span class="STpe">u64</span>
<span class="STpe">f32</span>
<span class="STpe">f64</span>
<span class="STpe">bool</span>
<span class="STpe">string</span>
<span class="STpe">rune</span>
<span class="STpe">any</span>
<span class="STpe">typeinfo</span>
<span class="STpe">void</span>
<span class="SKwd">code</span>
<span class="STpe">cstring</span>
<span class="SKwd">cvarargs</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Compiler Instructions </h4>
<p>Compiler instructions are prefixed with <span class="code-inline">#</span> and are reserved for specific operations within the Swag compiler. These keywords are used to control various aspects of compilation and code generation. User-defined identifiers cannot start with <span class="code-inline">#</span>, ensuring that compiler keywords do not conflict with user-defined names. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
<span class="SFct">#ast</span>
<span class="SFct">#test</span>
<span class="SFct">#init</span>
<span class="SFct">#drop</span>
<span class="SFct">#main</span>
<span class="SFct">#premain</span>
<span class="SFct">#message</span>
<span class="SCmp">#dependencies</span>

<span class="SCmp">#global</span>
<span class="SCmp">#load</span>
<span class="SCmp">#foreignlib</span>
<span class="SCmp">#assert</span>
<span class="SCmp">#print</span>
<span class="SCmp">#error</span>
<span class="SCmp">#warning</span>
<span class="SCmp">#import</span>
<span class="SCmp">#placeholder</span>
<span class="SCmp">#if</span>
<span class="SCmp">#else</span>
<span class="SCmp">#elif</span>
<span class="SCmp">#mixin</span>
<span class="SCmp">#macro</span>
<span class="SCmp">#scope</span>

<span class="SItr">#defined</span>
<span class="SItr">#offsetof</span>
<span class="SItr">#alignof</span>
<span class="SItr">#sizeof</span>
<span class="SItr">#typeof</span>
<span class="SItr">#stringof</span>
<span class="SItr">#nameof</span>
<span class="SItr">#isconstexpr</span>
<span class="SItr">#location</span>
<span class="SItr">#decltype</span>
<span class="SItr">#gettag</span>
<span class="SItr">#hastag</span>
<span class="SItr">#runes</span>
<span class="SItr">#safety</span>
<span class="SItr">#include</span>

<span class="SCmp">#cfg</span>
<span class="SCmp">#os</span>
<span class="SCmp">#arch</span>
<span class="SCmp">#cpu</span>
<span class="SCmp">#backend</span>
<span class="SCmp">#module</span>
<span class="SCmp">#file</span>
<span class="SCmp">#line</span>
<span class="SCmp">#self</span>
<span class="SCmp">#curlocation</span>
<span class="SCmp">#callerlocation</span>
<span class="SCmp">#callerfunction</span>
<span class="SCmp">#swagversion</span>
<span class="SCmp">#swagrevision</span>
<span class="SCmp">#swagbuildnum</span>
<span class="SCmp">#swagos</span>

<span class="SItr">#code</span>
<span class="SItr">#type</span>
<span class="SItr">#up</span>
<span class="SItr">#index</span>

<span class="SItr">#alias0</span>
<span class="SItr">#alias1</span>
<span class="SItr">#alias2</span> <span class="SCmt">// and more generally #aliasN</span>
<span class="SItr">#mix0</span>
<span class="SItr">#mix1</span>
<span class="SItr">#mix2</span> <span class="SCmt">// and more generally #mixinN</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Miscellaneous Intrinsics </h4>
<p>Intrinsic functions are prefixed with <span class="code-inline">@</span> and provide low-level operations that are often directly supported by the compiler or underlying hardware. These keywords offer specialized functionality that can be used during both compile time and runtime, depending on the context. </p>
<div class="code-block"><span class="SCde"><span class="SItr">@spread</span>
<span class="SItr">@kindof</span>
<span class="SItr">@countof</span>
<span class="SItr">@dataof</span>
<span class="SItr">@mkslice</span>
<span class="SItr">@mkstring</span>
<span class="SItr">@mkcallback</span>
<span class="SItr">@mkany</span>
<span class="SItr">@mkinterface</span>
<span class="SItr">@err</span>
<span class="SItr">@dbgalloc</span>
<span class="SItr">@sysalloc</span>
<span class="SItr">@args</span>
<span class="SItr">@stringcmp</span>
<span class="SItr">@rtflags</span>
<span class="SItr">@typecmp</span>
<span class="SItr">@is</span>
<span class="SItr">@as</span>
<span class="SItr">@getcontext</span>
<span class="SItr">@pinfos</span>
<span class="SItr">@isbytecode</span>
<span class="SItr">@compiler</span>
<span class="SItr">@modules</span>
<span class="SItr">@gvtd</span>
<span class="SItr">@itftableof</span>

<span class="SItr">@assert</span>
<span class="SItr">@breakpoint</span>
<span class="SItr">@init</span>
<span class="SItr">@drop</span>
<span class="SItr">@postcopy</span>
<span class="SItr">@postmove</span>
<span class="SItr">@compilererror</span>
<span class="SItr">@compilerwarning</span>
<span class="SItr">@panic</span>
<span class="SItr">@print</span>
<span class="SItr">@setcontext</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Intrinsics from libc </h4>
<p>These intrinsic functions provide access to standard libc functionalities, allowing developers to perform common mathematical, memory, and string operations. They are also prefixed with <span class="code-inline">@</span> to avoid conflicts with user-defined identifiers. </p>
<div class="code-block"><span class="SCde"><span class="SItr">@abs</span>
<span class="SItr">@acos</span>
<span class="SItr">@asin</span>
<span class="SItr">@atan</span>
<span class="SItr">@atan2</span>
<span class="SItr">@alloc</span>
<span class="SItr">@atomadd</span>
<span class="SItr">@atomand</span>
<span class="SItr">@atomcmpxchg</span>
<span class="SItr">@atomor</span>
<span class="SItr">@atomxchg</span>
<span class="SItr">@atomxor</span>
<span class="SItr">@bitcountlz</span>
<span class="SItr">@bitcountnz</span>
<span class="SItr">@bitcounttz</span>
<span class="SItr">@byteswap</span>
<span class="SItr">@cvaarg</span>
<span class="SItr">@cvaend</span>
<span class="SItr">@cvastart</span>
<span class="SItr">@ceil</span>
<span class="SItr">@cos</span>
<span class="SItr">@cosh</span>
<span class="SItr">@exp</span>
<span class="SItr">@exp2</span>
<span class="SItr">@floor</span>
<span class="SItr">@free</span>
<span class="SItr">@log</span>
<span class="SItr">@log10</span>
<span class="SItr">@log2</span>
<span class="SItr">@max</span>
<span class="SItr">@memcmp</span>
<span class="SItr">@memcpy</span>
<span class="SItr">@memmove</span>
<span class="SItr">@memset</span>
<span class="SItr">@min</span>
<span class="SItr">@muladd</span>
<span class="SItr">@pow</span>
<span class="SItr">@realloc</span>
<span class="SItr">@rol</span>
<span class="SItr">@ror</span>
<span class="SItr">@round</span>
<span class="SItr">@sin</span>
<span class="SItr">@sinh</span>
<span class="SItr">@sqrt</span>
<span class="SItr">@strcmp</span>
<span class="SItr">@strlen</span>
<span class="SItr">@tan</span>
<span class="SItr">@tanh</span>
<span class="SItr">@trunc</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Modifiers </h4>
<p>Modifiers can be applied to specific keywords or operators to alter their behavior. These modifiers allow developers to fine-tune operations, giving more control over how certain code constructs are executed. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#prom</span>
<span class="SCmp">#over</span>
<span class="SCmp">#nodrop</span>
<span class="SCmp">#move</span>
<span class="SCmp">#moveraw</span>
<span class="SCmp">#back</span>
<span class="SCmp">#ref</span>
<span class="SCmp">#constref</span></span></div>

<h2 id="_003_000_fundamentals_swg">Fundamentals</h2>
<h3 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Basic types</h3><h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Signed Integers </h4>
<p>Swag provides various signed integer types: <span class="code-inline">s8</span>, <span class="code-inline">s16</span>, <span class="code-inline">s32</span>, and <span class="code-inline">s64</span>. These types represent signed integers with different bit widths, allowing for both positive and negative values within their respective ranges. Each type is specifically designed to efficiently handle integer operations at varying levels of precision. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">s8</span> = -<span class="SNum">1</span>               <span class="SCmt">// 8-bit signed integer, range: -128 to 127</span>
    <span class="SKwd">let</span> b: <span class="STpe">s16</span> = -<span class="SNum">2</span>              <span class="SCmt">// 16-bit signed integer, range: -32,768 to 32,767</span>
    <span class="SKwd">let</span> c: <span class="STpe">s32</span> = -<span class="SNum">3</span>              <span class="SCmt">// 32-bit signed integer, range: -2^31 to 2^31-1</span>
    <span class="SKwd">let</span> d: <span class="STpe">s64</span> = -<span class="SNum">4</span>              <span class="SCmt">// 64-bit signed integer, range: -2^63 to 2^63-1</span>

    <span class="SItr">@assert</span>(a == -<span class="SNum">1</span>)             <span class="SCmt">// Verifies that 'a' holds the value -1.</span>
    <span class="SItr">@assert</span>(b == -<span class="SNum">2</span>)             <span class="SCmt">// Verifies that 'b' holds the value -2.</span>
    <span class="SItr">@assert</span>(c == -<span class="SNum">3</span>)             <span class="SCmt">// Verifies that 'c' holds the value -3.</span>
    <span class="SItr">@assert</span>(d == -<span class="SNum">4</span>)             <span class="SCmt">// Verifies that 'd' holds the value -4.</span>

    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">1</span>)     <span class="SCmt">// 'a' is an s8, so its size is 1 byte.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(b) == <span class="SNum">2</span>)     <span class="SCmt">// 'b' is an s16, so its size is 2 bytes.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(c) == <span class="SNum">4</span>)     <span class="SCmt">// 'c' is an s32, so its size is 4 bytes.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(d) == <span class="SNum">8</span>)     <span class="SCmt">// 'd' is an s64, so its size is 8 bytes.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Unsigned Integers </h4>
<p>Swag also supports various unsigned integer types: <span class="code-inline">u8</span>, <span class="code-inline">u16</span>, <span class="code-inline">u32</span>, and <span class="code-inline">u64</span>. These types represent unsigned integers, which can only hold non-negative values, making them ideal for scenarios where negative numbers are not applicable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">u8</span> = <span class="SNum">1</span>               <span class="SCmt">// 8-bit unsigned integer, range: 0 to 255</span>
    <span class="SKwd">let</span> b: <span class="STpe">u16</span> = <span class="SNum">2</span>              <span class="SCmt">// 16-bit unsigned integer, range: 0 to 65,535</span>
    <span class="SKwd">let</span> c: <span class="STpe">u32</span> = <span class="SNum">3</span>              <span class="SCmt">// 32-bit unsigned integer, range: 0 to 2^32-1</span>
    <span class="SKwd">let</span> d: <span class="STpe">u64</span> = <span class="SNum">4</span>              <span class="SCmt">// 64-bit unsigned integer, range: 0 to 2^64-1</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)             <span class="SCmt">// Verifies that 'a' holds the value 1.</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">2</span>)             <span class="SCmt">// Verifies that 'b' holds the value 2.</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">3</span>)             <span class="SCmt">// Verifies that 'c' holds the value 3.</span>
    <span class="SItr">@assert</span>(d == <span class="SNum">4</span>)             <span class="SCmt">// Verifies that 'd' holds the value 4.</span>

    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">1</span>)    <span class="SCmt">// 'a' is a u8, so its size is 1 byte.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(b) == <span class="SNum">2</span>)    <span class="SCmt">// 'b' is a u16, so its size is 2 bytes.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(c) == <span class="SNum">4</span>)    <span class="SCmt">// 'c' is a u32, so its size is 4 bytes.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(d) == <span class="SNum">8</span>)    <span class="SCmt">// 'd' is a u64, so its size is 8 bytes.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Floating-Point Types </h4>
<p>Swag supports floating-point types <span class="code-inline">f32</span> and <span class="code-inline">f64</span>. These types represent single-precision and double-precision floating-point numbers, respectively. They are crucial for calculations requiring fractional values and greater precision. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">f32</span> = <span class="SNum">3.14</span>           <span class="SCmt">// 32-bit floating-point value (single-precision)</span>
    <span class="SKwd">let</span> b: <span class="STpe">f64</span> = <span class="SNum">3.14159</span>        <span class="SCmt">// 64-bit floating-point value (double-precision)</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">3.14</span>)          <span class="SCmt">// Verifies that 'a' holds the value 3.14.</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">3.14159</span>)       <span class="SCmt">// Verifies that 'b' holds the value 3.14159.</span>

    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">4</span>)    <span class="SCmt">// 'a' is an f32, so its size is 4 bytes.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(b) == <span class="SNum">8</span>)    <span class="SCmt">// 'b' is an f64, so its size is 8 bytes.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Boolean Type </h4>
<p>The boolean type <span class="code-inline">bool</span> is used to represent true or false values. In Swag, a boolean is stored as a 1-byte value, offering a straightforward way to handle binary logic within your programs. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">bool</span> = <span class="SKwd">true</span>           <span class="SCmt">// Boolean value, representing 'true'</span>
    <span class="SKwd">let</span> b: <span class="STpe">bool</span> = <span class="SKwd">false</span>          <span class="SCmt">// Boolean value, representing 'false'</span>

    <span class="SItr">@assert</span>(a == <span class="SKwd">true</span>)           <span class="SCmt">// Verifies that 'a' is true.</span>
    <span class="SItr">@assert</span>(b == <span class="SKwd">false</span>)          <span class="SCmt">// Verifies that 'b' is false.</span>

    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">1</span>)     <span class="SCmt">// The size of a boolean is 1 byte.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(b) == <span class="SNum">1</span>)     <span class="SCmt">// The size of a boolean is 1 byte.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">String Type </h4>
<p>The <span class="code-inline">string</span> type represents text. In Swag, strings are <b>UTF-8</b> encoded and are stored as two 64-bit values: one for the pointer to the data and one for the length in bytes. Strings in Swag are designed to handle text efficiently, including international characters, while ensuring compatibility with common text processing routines. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">string</span> = <span class="SStr">"string 是"</span>  <span class="SCmt">// A string containing UTF-8 encoded characters</span>

    <span class="SItr">@assert</span>(a == <span class="SStr">"string 是"</span>)    <span class="SCmt">// Verifies that 'a' holds the correct string.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">2</span> * <span class="SItr">#sizeof</span>(*<span class="STpe">void</span>)) <span class="SCmt">// A string is stored as two 64-bit values (pointer and length).</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Rune Type </h4>
<p>The <span class="code-inline">rune</span> type in Swag represents a 32-bit Unicode code point. It is used to store individual Unicode characters, allowing for the manipulation of text at the character level, supporting a wide range of languages and symbols. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">rune</span> = <span class="SStr">`是`</span>             <span class="SCmt">// A single Unicode character, represented by a 32-bit code point</span>

    <span class="SItr">@assert</span>(a == <span class="SStr">`是`</span>)              <span class="SCmt">// Verifies that 'a' holds the correct Unicode code point.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">4</span>)        <span class="SCmt">// The size of a rune is 4 bytes (32 bits).</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Type Reflection </h4>
<p>Swag supports <b>type reflection</b> both at <b>compile time</b> and at <b>runtime</b>. This powerful feature allows for the inspection and manipulation of types dynamically, enabling more flexible and introspective programming paradigms. Further details on how to leverage type reflection will be explored in subsequent sections. </p>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Type Creation with #decltype </h4>
<p>You can use <span class="code-inline">#decltype</span> to create a type based on an expression. This is useful for cases where you want to infer or mirror the type of a variable dynamically, promoting code reusability and reducing redundancy. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a  = <span class="SNum">0</span>                  <span class="SCmt">// The type of 'a' is inferred to be 's32'.</span>
    <span class="SKwd">let</span> b: <span class="SItr">#decltype</span>(a) = <span class="SNum">1</span>     <span class="SCmt">// 'b' is declared with the same type as 'a' (which is 's32').</span>

    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(a) == <span class="SItr">#typeof</span>(b)) <span class="SCmt">// Verifies that 'a' and 'b' have the same type.</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">s32</span>)        <span class="SCmt">// Verifies that the type of 'a' is 's32'.</span>

    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="SItr">#typeof</span>(b)  <span class="SCmt">// Compile-time validation using '#assert'.</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">s32</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Types as Values </h4>
<p>Types in Swag are also treated as values, both at compile time and at runtime. This allows types to be manipulated, compared, and inspected just like any other value. This feature is particularly useful in metaprogramming and dynamic type manipulation scenarios. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SItr">#typeof</span>(<span class="STpe">s32</span>)        <span class="SCmt">// 'x' is now a variable that holds a type (in this case, 's32').</span>
    <span class="SItr">@assert</span>(x == <span class="STpe">s32</span>)           <span class="SCmt">// Verifies that 'x' is equal to the type 's32'.</span>

    <span class="SItr">@assert</span>(x.name == <span class="SStr">"s32"</span>)    <span class="SCmt">// Retrieves and verifies the name of the type 's32'.</span>

    <span class="SKwd">let</span> y = <span class="STpe">bool</span>                <span class="SCmt">// 'y' is assigned the boolean type</span>
    <span class="SItr">@assert</span>(y == <span class="STpe">bool</span>)          <span class="SCmt">// Verifies that 'y' holds the type 'bool'.</span>
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Number literals</h3><h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Number Representations </h4>
<p>In Swag, integers can be written in multiple formats: <i>decimal</i>, <i>hexadecimal</i>, or <i>binary</i>. These different representations allow you to express numbers in the format that best suits your needs. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">u32</span> = <span class="SNum">123456</span>          <span class="SCmt">// Decimal format representation of the integer</span>
    <span class="SKwd">const</span> b: <span class="STpe">u32</span> = <span class="SNum">0xFFFF</span>          <span class="SCmt">// Hexadecimal format, prefixed with '0x' (representing 65535)</span>
    <span class="SKwd">const</span> c: <span class="STpe">u32</span> = <span class="SNum">0b00001111</span>      <span class="SCmt">// Binary format, prefixed with '0b' (representing 15)</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">123456</span>)           <span class="SCmt">// Verifies that 'a' holds the correct decimal value</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">65535</span>)            <span class="SCmt">// Verifies that 'b' holds the correct hexadecimal value</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">15</span>)               <span class="SCmt">// Verifies that 'c' holds the correct binary value</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Digit Separators </h4>
<p>Numeric literals can be more readable by using the <span class="code-inline">_</span> character as a digit separator. This is  particularly useful for large numbers, without affecting their value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">u32</span> = <span class="SNum">123_456</span>         <span class="SCmt">// Decimal with digit separators for better readability</span>
    <span class="SKwd">const</span> b: <span class="STpe">u32</span> = <span class="SNum">0xF_F_F_F</span>       <span class="SCmt">// Hexadecimal with digit separators</span>
    <span class="SKwd">const</span> c: <span class="STpe">u32</span> = <span class="SNum">0b0000_1111</span>     <span class="SCmt">// Binary with digit separators</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">123456</span>)           <span class="SCmt">// Verifies that 'a' holds the correct value</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">65535</span>)            <span class="SCmt">// Verifies that 'b' holds the correct value</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">15</span>)               <span class="SCmt">// Verifies that 'c' holds the correct value</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Default Integer Types </h4>
<p>In Swag, hexadecimal or binary numbers default to <span class="code-inline">u32</span> if they fit within 32 bits. If the value  exceeds 32 bits, it is automatically inferred as <span class="code-inline">u64</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SNum">0xFF</span>                 <span class="SCmt">// Compiler infers 'a' as 'u32' since value fits within 32 bits</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">u32</span>      <span class="SCmt">// Verifies that 'a' is of type 'u32'</span>

    <span class="SKwd">const</span> b = <span class="SNum">0xF_FFFFF_FFFFFF</span>     <span class="SCmt">// Large value exceeding 32 bits; inferred as 'u64'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(b) == <span class="STpe">u64</span>      <span class="SCmt">// Verifies that 'b' is of type 'u64'</span>

    <span class="SKwd">const</span> c = <span class="SNum">0b00000001</span>           <span class="SCmt">// Binary value within 32 bits, inferred as 'u32'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(c) == <span class="STpe">u32</span>      <span class="SCmt">// Verifies that 'c' is of type 'u32'</span>

    <span class="SKwd">const</span> d = <span class="SNum">0b00000001_00000001_00000001_00000001_00000001</span>  <span class="SCmt">// Exceeds 32 bits, inferred as 'u64'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(d) == <span class="STpe">u64</span>      <span class="SCmt">// Verifies that 'd' is of type 'u64'</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Booleans </h4>
<p>In Swag, a boolean type can be either <span class="code-inline">true</span> or <span class="code-inline">false</span>. As constants are known at compile time, you  can use <span class="code-inline">#assert</span> to verify their values during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SKwd">true</span>
    <span class="SCmp">#assert</span> a == <span class="SKwd">true</span>              <span class="SCmt">// Compile-time check that 'a' holds the value true</span>

    <span class="SKwd">const</span> b, c = <span class="SKwd">false</span>
    <span class="SCmp">#assert</span> b == <span class="SKwd">false</span>             <span class="SCmt">// Compile-time check that 'b' holds the value false</span>
    <span class="SCmp">#assert</span> c == <span class="SKwd">false</span>             <span class="SCmt">// Compile-time check that 'c' holds the value false</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Floating Point Values </h4>
<p>Floating point values in Swag use the standard C/C++ notation for floating-point literals. This  provides familiarity and ease of use for developers. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)              <span class="SCmt">// Verifies that 'a' holds the value 1.5</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">f32</span>      <span class="SCmt">// The type of 'a' is inferred to be 'f32'</span>

    <span class="SKwd">let</span> b = <span class="SNum">0.11</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">0.11</span>)             <span class="SCmt">// Verifies that 'b' holds the value 0.11</span>

    <span class="SKwd">let</span> c = <span class="SNum">15e2</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">15e2</span>)             <span class="SCmt">// Verifies that 'c' holds the value 15e2 (1500)</span>

    <span class="SKwd">let</span> d = <span class="SNum">15e+2</span>
    <span class="SItr">@assert</span>(d == <span class="SNum">15e2</span>)             <span class="SCmt">// Verifies that 'd' holds the same value as 'c'</span>

    <span class="SKwd">let</span> e = -<span class="SNum">1E-1</span>
    <span class="SItr">@assert</span>(e == -<span class="SNum">0.1</span>)             <span class="SCmt">// Verifies that 'e' holds the value -0.1</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Default Floating Point Type </h4>
<p>By default, floating-point literals in Swag are of type <span class="code-inline">f32</span>. This is different from languages like  C/C++, where floating-point literals default to <span class="code-inline">double</span> (<span class="code-inline">f64</span>). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)              <span class="SCmt">// Verifies that 'a' holds the value 1.5</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">f32</span>      <span class="SCmt">// Verifies that 'a' is of type 'f32'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) != <span class="STpe">f64</span>      <span class="SCmt">// Verifies that 'a' is not of type 'f64'</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Suffix </h4>
<p>To specify the type of a literal explicitly, you can add a <b>suffix</b> to the literal. This is useful  when a specific type is required, such as <span class="code-inline">f64</span> or <span class="code-inline">u8</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>'<span class="STpe">f64</span>                <span class="SCmt">// Explicitly declare 'a' as 'f64' with the value 1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)              <span class="SCmt">// Verifies that 'a' holds the value 1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>'<span class="STpe">f64</span>)          <span class="SCmt">// Verifies that 'a' explicitly holds the value 1.5 as 'f64'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">f64</span>      <span class="SCmt">// Verifies that 'a' is of type 'f64'</span>

    <span class="SKwd">let</span> b = <span class="SNum">10</span>'<span class="STpe">u8</span>                  <span class="SCmt">// Declare 'b' as 'u8' and assign it the value 10</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">10</span>)               <span class="SCmt">// Verifies that 'b' holds the value 10</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(b) == <span class="STpe">u8</span>       <span class="SCmt">// Verifies that 'b' is of type 'u8'</span>

    <span class="SKwd">let</span> c = <span class="SNum">1</span>'<span class="STpe">u32</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(c) == <span class="STpe">u32</span>      <span class="SCmt">// Verifies that 'c' is of type 'u32'</span>
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_003_string_swg">String</h3><h4 id="_003_000_fundamentals_swg__003_003_string_swg">UTF-8 Encoding </h4>
<p>Swag uses UTF-8 encoding for strings, which allows representation of a wide range of characters, including those from various languages and symbol sets. </p>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">String Comparison </h4>
<p>Strings in Swag can be compared directly for equality using the <span class="code-inline">==</span> operator. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is a Chinese character: 是"</span>       <span class="SCmt">// String with a Chinese character</span>
    <span class="SCmp">#assert</span> a == <span class="SStr">"this is a Chinese character: 是"</span>   <span class="SCmt">// Assert equality between two identical strings</span>

    <span class="SKwd">const</span> b = <span class="SStr">"these are some Cyrillic characters: ӜИ"</span>  <span class="SCmt">// String with Cyrillic characters</span>
    <span class="SCmp">#assert</span> b == <span class="SStr">"these are some Cyrillic characters: ӜИ"</span> <span class="SCmt">// Assert equality for another string</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Rune Type </h4>
<p>In Swag, a <span class="code-inline">rune</span> represents a Unicode code point and is stored as a 32-bit value, ensuring  it can accommodate any Unicode character. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">rune</span> = <span class="SStr">`是`</span>                             <span class="SCmt">// Define a rune using a Chinese character</span>
    <span class="SCmp">#assert</span> a == <span class="SStr">`是`</span>                                <span class="SCmt">// Assert the rune matches the expected value</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(a) == <span class="SItr">#sizeof</span>(<span class="STpe">u32</span>)               <span class="SCmt">// Confirm the size of a rune is 32 bits (same as u32)</span>
}</span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> Direct indexing of a string to retrieve a <span class="code-inline">rune</span> is not possible, except for ASCII strings.  This is because Swag avoids the runtime overhead of UTF-8 decoding in string operations. However,  the <span class="code-inline">Std.Core</span> module provides utilities for working with UTF-8 encoded strings. </p>
</div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">String Indexing </h4>
<p>When indexing a string, Swag returns a byte (<span class="code-inline">u8</span>), not a <span class="code-inline">rune</span>, which reflects the underlying UTF-8 encoding. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is a Chinese character: 是"</span>      <span class="SCmt">// Define a string with mixed characters</span>

    <span class="SCmt">// Retrieves the first byte of the string, which corresponds to the character 't'</span>
    <span class="SKwd">const</span> b = a[<span class="SNum">0</span>]
    <span class="SCmp">#assert</span> b == <span class="SStr">`t`</span>                                 <span class="SCmt">// Assert the first byte is 't'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(b) == <span class="SItr">#typeof</span>(<span class="STpe">u8</span>)                <span class="SCmt">// Confirm the type is `u8` (byte)</span>

    <span class="SCmt">// UTF-8 encoding affects indexing. 'X' is not at index 1 due to the multibyte encoding of the</span>
    <span class="SCmt">// preceding Chinese character.</span>
    <span class="SKwd">const</span> c = <span class="SStr">"是X是"</span>                              
    <span class="SCmp">#assert</span> c[<span class="SNum">1</span>] != <span class="SStr">`X`</span>                              <span class="SCmt">// Assert that the byte at index 1 is not 'X'</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">String Concatenation </h4>
<p>Swag allows compile-time concatenation of strings and other values using the <span class="code-inline">++</span> operator. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"the devil's number is "</span> ++ <span class="SNum">666</span>       <span class="SCmt">// Concatenation of a string with a number</span>
    <span class="SCmp">#assert</span> a == <span class="SStr">"the devil's number is 666"</span>        <span class="SCmt">// Assert the resulting string is as expected</span>

    <span class="SKwd">const</span> b = <span class="SNum">666</span>
    <span class="SKwd">let</span> c   = <span class="SStr">"the devil's number is not "</span> ++ (b + <span class="SNum">1</span>) ++ <span class="SStr">"!"</span>  
    <span class="SItr">@assert</span>(c == <span class="SStr">"the devil's number is not 667!"</span>)  <span class="SCmt">// Assert the concatenated string after arithmetic</span>

    <span class="SKwd">let</span> d = <span class="SStr">"there are "</span> ++ <span class="SNum">4</span> ++ <span class="SStr">" apples in "</span> ++ (<span class="SNum">2</span> * <span class="SNum">2</span>) ++ <span class="SStr">" baskets"</span>
    <span class="SItr">@assert</span>(d == <span class="SStr">"there are 4 apples in 4 baskets"</span>) <span class="SCmt">// Concatenation with a mix of literals and expressions</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Null Strings </h4>
<p>In Swag, a string can be <span class="code-inline">null</span> if it has not been initialized. This behavior can be used to  check whether a string has been assigned a value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">string</span>                                   <span class="SCmt">// Declare a string variable without initialization</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">null</span>)                              <span class="SCmt">// Initially, the string is null</span>
    a = <span class="SStr">"not null"</span>                                  <span class="SCmt">// Assign a value to the string</span>
    <span class="SItr">@assert</span>(a != <span class="SKwd">null</span>)                              <span class="SCmt">// Assert that the string is no longer null</span>
    a = <span class="SKwd">null</span>                                        <span class="SCmt">// Set the string back to null</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">null</span>)                              <span class="SCmt">// Confirm the string is null again</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Character Literals </h4>
<p>Character literals in Swag are enclosed in backticks. These literals can represent any Unicode  character, not just ASCII characters. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> char0 = <span class="SStr">`a`</span>                                 <span class="SCmt">// ASCII character literal</span>
    <span class="SKwd">let</span> char1 = <span class="SStr">`我`</span>                                <span class="SCmt">// Unicode character literal</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Default Type of Character Literals </h4>
<p>A character literal is a 32-bit integer by default. It can be assigned to any integer type or  a <span class="code-inline">rune</span>, provided the value fits within the target type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> a: <span class="STpe">u8</span> = <span class="SStr">`a`</span>                             <span class="SCmt">// Assign character literal to an 8-bit unsigned integer</span>
        <span class="SKwd">let</span> b: <span class="STpe">u16</span> = <span class="SStr">`a`</span>                            <span class="SCmt">// Assign to a 16-bit unsigned integer</span>
        <span class="SKwd">let</span> c: <span class="STpe">u32</span> = <span class="SStr">`我`</span>                           <span class="SCmt">// Assign to a 32-bit unsigned integer</span>
        <span class="SKwd">let</span> d: <span class="STpe">u64</span> = <span class="SStr">`我`</span>                           <span class="SCmt">// Assign to a 64-bit unsigned integer</span>
        <span class="SKwd">let</span> e: <span class="STpe">rune</span> = <span class="SStr">`我`</span>                          <span class="SCmt">// Assign to a rune (32-bit)</span>
    }

    {
        <span class="SKwd">let</span> a: <span class="STpe">s8</span> = <span class="SStr">`a`</span>                             <span class="SCmt">// Assign to an 8-bit signed integer</span>
        <span class="SKwd">let</span> b: <span class="STpe">s16</span> = <span class="SStr">`a`</span>                            <span class="SCmt">// Assign to a 16-bit signed integer</span>
        <span class="SKwd">let</span> c: <span class="STpe">s32</span> = <span class="SStr">`我`</span>                           <span class="SCmt">// Assign to a 32-bit signed integer</span>
        <span class="SKwd">let</span> d: <span class="STpe">s64</span> = <span class="SStr">`我`</span>                           <span class="SCmt">// Assign to a 64-bit signed integer</span>
    }
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Specifying Character Literal Types </h4>
<p>Swag allows you to specify the type of a character literal using a suffix. This is useful for controlling the storage size of the character. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SStr">`0`</span>'<span class="STpe">u8</span>                                 <span class="SCmt">// Character literal explicitly typed as u8</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">48</span>)                               <span class="SCmt">// ASCII value of '0' is 48</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">u8</span>)                      <span class="SCmt">// Confirm type is u8</span>

    <span class="SKwd">let</span> b = <span class="SStr">`1`</span>'<span class="STpe">u16</span>                                <span class="SCmt">// Character literal explicitly typed as u16</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">49</span>)                               <span class="SCmt">// ASCII value of '1' is 49</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(b) == <span class="STpe">u16</span>)                     <span class="SCmt">// Confirm type is u16</span>

    <span class="SKwd">let</span> c = <span class="SStr">`2`</span>'<span class="STpe">u32</span>                                <span class="SCmt">// Character literal explicitly typed as u32</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">50</span>)                               <span class="SCmt">// ASCII value of '2' is 50</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(c) == <span class="STpe">u32</span>)                     <span class="SCmt">// Confirm type is u32</span>

    <span class="SKwd">let</span> d = <span class="SStr">`3`</span>'<span class="STpe">u64</span>                                <span class="SCmt">// Character literal explicitly typed as u64</span>
    <span class="SItr">@assert</span>(d == <span class="SNum">51</span>)                               <span class="SCmt">// ASCII value of '3' is 51</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(d) == <span class="STpe">u64</span>)                     <span class="SCmt">// Confirm type is u64</span>

    <span class="SKwd">let</span> e = <span class="SStr">`4`</span>'<span class="STpe">rune</span>                               <span class="SCmt">// Character literal explicitly typed as rune</span>
    <span class="SItr">@assert</span>(e == <span class="SNum">52</span>)                               <span class="SCmt">// ASCII value of '4' is 52</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(e) == <span class="STpe">rune</span>)                    <span class="SCmt">// Confirm type is rune</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Escape Sequences </h4>
<p>Swag supports escape sequences in strings and character literals, allowing special characters to be represented within these literals. </p>
<p>An escape sequence starts with a backslash <span class="code-inline">` and is followed by a specific character.</code> </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is ASCII code 0x00:   \0"</span>      <span class="SCmt">// Null character escape sequence</span>
    <span class="SKwd">const</span> b = <span class="SStr">"this is ASCII code 0x07:   \a"</span>      <span class="SCmt">// Bell (alert) escape sequence</span>
    <span class="SKwd">const</span> c = <span class="SStr">"this is ASCII code 0x08:   \b"</span>      <span class="SCmt">// Backspace escape sequence</span>
    <span class="SKwd">const</span> d = <span class="SStr">"this is ASCII code 0x09:   \t"</span>      <span class="SCmt">// Horizontal tab escape sequence</span>
    <span class="SKwd">const</span> e = <span class="SStr">"this is ASCII code 0x0A:   \n"</span>      <span class="SCmt">// Line feed escape sequence</span>
    <span class="SKwd">const</span> f = <span class="SStr">"this is ASCII code 0x0B:   \v"</span>      <span class="SCmt">// Vertical tab escape sequence</span>
    <span class="SKwd">const</span> g = <span class="SStr">"this is ASCII code 0x0C:   \f"</span>      <span class="SCmt">// Form feed escape sequence</span>
    <span class="SKwd">const</span> h = <span class="SStr">"this is ASCII code 0x0D:   \r"</span>      <span class="SCmt">// Carriage return escape sequence</span>
    <span class="SKwd">const</span> i = <span class="SStr">"this is ASCII code 0x22:   \""</span>      <span class="SCmt">// Double quote escape sequence</span>
    <span class="SKwd">const</span> j = <span class="SStr">"this is ASCII code 0x27:   \'"</span>      <span class="SCmt">// Single quote escape sequence</span>
    <span class="SKwd">const</span> k = <span class="SStr">"this is ASCII code 0x60:   \`"</span>      <span class="SCmt">// Backtick escape sequence</span>
    <span class="SKwd">const</span> l = <span class="SStr">"this is ASCII code 0x5C:   \\"</span>      <span class="SCmt">// Backslash escape sequence</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">ASCII and Unicode Escape Sequences </h4>
<p>Escape sequences can also be used to specify characters via their ASCII or Unicode values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">const</span> a = <span class="SStr">"\x26"</span>                           <span class="SCmt">// 1-byte hexadecimal ASCII escape sequence</span>
        <span class="SKwd">const</span> b = <span class="SStr">"\u2626"</span>                         <span class="SCmt">// 2-byte hexadecimal Unicode 16-bit escape sequence</span>
        <span class="SKwd">const</span> c = <span class="SStr">"\U00101234"</span>                     <span class="SCmt">// 4-byte hexadecimal Unicode 32-bit escape sequence</span>
    }

    {
        <span class="SKwd">const</span> d = <span class="SStr">"\u2F46\u2F46"</span>                   <span class="SCmt">// Unicode escape sequences for two identical characters</span>
        <span class="SCmp">#assert</span> d == <span class="SStr">"⽆⽆"</span>                         <span class="SCmt">// Assert the resulting string matches expected characters</span>

        <span class="SKwd">const</span> e = <span class="SStr">`\u2F46`</span>                         <span class="SCmt">// Unicode escape sequence as a rune literal</span>
        <span class="SCmp">#assert</span> e == <span class="SStr">`⽆`</span>                           <span class="SCmt">// Assert the rune matches the expected character</span>
    }
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Raw Strings </h4>
<p>A raw string in Swag is a string where escape sequences and special characters are not processed. This can be useful for strings that contain many special characters or backslashes. </p>
<p>A raw string is enclosed within <span class="code-inline">#</span> characters, which ensures that its content is taken literally. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">#"\u2F46"#</span>                           <span class="SCmt">// Raw string containing a Unicode escape sequence</span>
    <span class="SCmp">#assert</span> a != <span class="SStr">"⽆"</span>                               <span class="SCmt">// Raw string does not interpret the escape sequence</span>
    <span class="SCmp">#assert</span> a == <span class="SStr">#"\u2F46"#</span>                        <span class="SCmt">// Raw string content matches the literal input</span>
}</span></div>
<p>These two strings are equivalent, even though one uses escape sequences and the other is raw: </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"\\hello \\world"</span>                    <span class="SCmt">// String with escape sequences</span>
    <span class="SKwd">const</span> b = <span class="SStr">#"\hello \world"#</span>                    <span class="SCmt">// Equivalent raw string</span>
    <span class="SCmp">#assert</span> a == b                                 <span class="SCmt">// Assert both strings are identical</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Multiline Raw Strings </h4>
<p>Raw strings in Swag can span multiple lines, and all leading spaces before the closing <span class="code-inline">"#</span> are  removed from each line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">#"this is
                a
                string
                "#</span>
}</span></div>
<p>In the above example, the multiline raw string retains its formatting, except that leading spaces before the closing <span class="code-inline">"#</span> are stripped from each line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// The resulting string is:</span>
    <span class="SCmt">// this is</span>
    <span class="SCmt">// a</span>
    <span class="SCmt">// string</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Multiline Strings </h4>
<p>Multiline strings in Swag start and end with <span class="code-inline">"""</span>. Unlike raw strings, they still process escape  sequences. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">""</span><span class="SStr">"this is
                 a
                 string
                 "</span><span class="SStr">""</span>

    <span class="SCmt">// Equivalent to:</span>

    <span class="SCmt">// this is</span>
    <span class="SCmt">// a</span>
    <span class="SCmt">// string</span>
}</span></div>
<p>In a multiline or raw string, ending a line with <span class="code-inline">` prevents the following end of line (EOL) </code> from being included in the string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">""</span><span class="SStr">"\
              this is
              a
              string
              "</span><span class="SStr">""</span>
    <span class="SCmt">// The resulting string is:</span>
    <span class="SCmt">// this is</span>
    <span class="SCmt">// a</span>
    <span class="SCmt">// string</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">#stringof and #nameof Intrinsics </h4>
<p>The <span class="code-inline">#stringof</span> intrinsic in Swag returns the string representation of a constant expression  at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">X</span> = <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">#stringof</span>(<span class="SCst">X</span>) == <span class="SStr">"1"</span>                    <span class="SCmt">// The string representation of X is "1"</span>
    <span class="SCmp">#assert</span> <span class="SItr">#stringof</span>(<span class="SCst">X</span> + <span class="SNum">10</span>) == <span class="SStr">"11"</span>              <span class="SCmt">// Expression evaluation is also possible</span>
}</span></div>
<p>The <span class="code-inline">#nameof</span> intrinsic returns the name of a variable, function, etc., as a string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">X</span> = <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">#nameof</span>(<span class="SCst">X</span>) == <span class="SStr">"X"</span>                      <span class="SCmt">// Returns the variable name "X"</span>
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_004_constants_swg">Constants</h3><h4 id="_003_000_fundamentals_swg__003_004_constants_swg">Constants with <span class="code-inline">const</span> </h4>
<p>Using <span class="code-inline">const</span> in Swag implies that the value must be <b>known by the compiler</b> at compile time.  This ensures that the value is embedded directly into the compiled code, eliminating any runtime  memory usage for simple types like integers or strings. Essentially, the compiler replaces occurrences  of these constants with their respective values wherever they are referenced in the code, leading to  more optimized and efficient code execution. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// These are immutable constants. Once declared, they are fixed and cannot be altered.</span>
    <span class="SKwd">const</span> a = <span class="SNum">666</span>               <span class="SCmt">// 'a' is an integer constant known and resolved at compile time.</span>
    <span class="SCmp">#assert</span> a == <span class="SNum">666</span>            <span class="SCmt">// Assertion to verify the value of 'a'.</span>

    <span class="SKwd">const</span> b: <span class="STpe">string</span> = <span class="SStr">"string"</span>  <span class="SCmt">// 'b' is a string constant known and resolved at compile time.</span>
    <span class="SCmp">#assert</span> b == <span class="SStr">"string"</span>       <span class="SCmt">// Assertion to verify the value of 'b'.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_004_constants_swg">Constants with Complex Types </h4>
<p>Swag also supports constants with more complex data types, such as arrays or structures. When  declaring constants with these types, the data is stored in the program's data segment, which incurs  a memory footprint. Additionally, you can obtain the memory address of these constants at runtime,  allowing you to manipulate their values indirectly through pointers. </p>
<h5 id="_003_000_fundamentals_swg__003_004_constants_swg">Static Arrays </h5>
<p>The following example demonstrates a static array, which is an array with a fixed size. This array  contains three elements of type <span class="code-inline">s32</span>, a signed 32-bit integer. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: [<span class="SNum">3</span>] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]  <span class="SCmt">// 'a' is a constant static array with 3 signed 32-bit integers.</span>

    <span class="SKwd">let</span> ptr = &a[<span class="SNum">0</span>]               <span class="SCmt">// Obtain the memory address of the first element of the array.</span>
    <span class="SItr">@assert</span>(ptr[<span class="SNum">0</span>] == <span class="SNum">0</span>)          <span class="SCmt">// Verify the first element via pointer dereferencing.</span>
    <span class="SItr">@assert</span>(ptr[<span class="SNum">2</span>] == <span class="SNum">2</span>)          <span class="SCmt">// Verify the third element via pointer dereferencing.</span>

    <span class="SCmt">// Compile-time assertions to ensure the array's contents are as expected.</span>
    <span class="SCmp">#assert</span> a[<span class="SNum">0</span>] == <span class="SNum">0</span>             <span class="SCmt">// Verify the first element of the array at compile time.</span>
    <span class="SCmp">#assert</span> a[<span class="SNum">1</span>] == <span class="SNum">1</span>             <span class="SCmt">// Verify the second element of the array at compile time.</span>
    <span class="SCmp">#assert</span> a[<span class="SNum">2</span>] == <span class="SNum">2</span>             <span class="SCmt">// Verify the third element of the array at compile time.</span>
}</span></div>
<h5 id="_003_000_fundamentals_swg__003_004_constants_swg">Multidimensional Arrays </h5>
<p>This example illustrates a multidimensional array declared as a constant. The array is a 4x4 matrix of  32-bit floating-point numbers (<span class="code-inline">f32</span>). We will explore arrays in further detail later in this documentation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">M4x4</span>: [<span class="SNum">4</span>, <span class="SNum">4</span>] <span class="STpe">f32</span> = [   <span class="SCmt">// 'M4x4' is a constant 4x4 matrix of 32-bit floating-point numbers.</span>
        [<span class="SNum">1</span>, <span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">0</span>],            <span class="SCmt">// First row of the matrix.</span>
        [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">0</span>, <span class="SNum">0</span>],            <span class="SCmt">// Second row of the matrix.</span>
        [<span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">0</span>],            <span class="SCmt">// Third row of the matrix.</span>
        [<span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">1</span>]             <span class="SCmt">// Fourth row of the matrix.</span>
    ]
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_004_constants_swg">Key Difference Between <span class="code-inline">let</span> and <span class="code-inline">const</span> </h4>
<p>The primary distinction between <span class="code-inline">let</span> and <span class="code-inline">const</span> lies in the timing of value determination. The value  assigned to a <span class="code-inline">const</span> must be determined at compile time, meaning it is fixed and known before the program  runs. Conversely, a <span class="code-inline">let</span> allows for dynamic assignment, where the value can be computed and assigned  during runtime. Despite this, both <span class="code-inline">let</span> and <span class="code-inline">const</span> ensure that their values are assigned only once,  maintaining immutability. </p>

<h3 id="_003_000_fundamentals_swg__003_005_variables_swg">Variables</h3><h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Variable Declaration </h4>
<p>In Swag, variables are declared using the <span class="code-inline">let</span> or <span class="code-inline">var</span> keyword, followed by a <span class="code-inline">:</span> and the variable's type. </p>
<ul>
<li><b><span class="code-inline">let</span></b>: Used for declaring a constant variable. The value assigned cannot be modified, ensuring immutability.</li>
<li><b><span class="code-inline">var</span></b>: Used for declaring a mutable variable. The value assigned can be modified after initialization.</li>
</ul>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// 'a' is a constant variable of type 'u32', initialized with the value 1.</span>
    <span class="SCmt">// It is immutable, meaning its value cannot be altered after assignment.</span>
    <span class="SKwd">let</span> a: <span class="STpe">u32</span> = <span class="SNum">1</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)

    <span class="SCmt">// 'b' is a constant variable of type 'string', initialized with the value "string".</span>
    <span class="SKwd">let</span> b: <span class="STpe">string</span> = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(b == <span class="SStr">"string"</span>)

    <span class="SCmt">// 'c' is a mutable variable of type 's32'. Its value is initialized to 42 and can be modified later.</span>
    <span class="SKwd">var</span> c: <span class="STpe">s32</span> = <span class="SNum">42</span>
    c += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">43</span>)  <span class="SCmt">// Verifies that 'c' has been correctly incremented to 43.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Multiple Variable Declarations </h4>
<p>Swag allows the declaration of multiple variables of the same type on a single line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a, b: <span class="STpe">u32</span> = <span class="SNum">123</span>  <span class="SCmt">// Both 'a' and 'b' are of type 'u32', initialized with the value 123.</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">123</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">123</span>)
}</span></div>
<p>Alternatively, multiple variables of different types can also be declared on the same line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">u32</span> = <span class="SNum">12</span>, b: <span class="STpe">f32</span> = <span class="SNum">1.5</span>  <span class="SCmt">// 'a' is of type 'u32', and 'b' is of type 'f32'.</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">12</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">1.5</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Default Initialization </h4>
<p>In Swag, if a variable is declared without an initial value, it is automatically initialized with its default value. A variable is <b>always</b> initialized, ensuring it never holds an undefined value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">bool</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">false</span>)  <span class="SCmt">// The default value for a boolean is 'false'.</span>

    <span class="SKwd">var</span> b: <span class="STpe">string</span>
    <span class="SItr">@assert</span>(b == <span class="SKwd">null</span>)  <span class="SCmt">// The default value for a string is 'null'.</span>

    <span class="SKwd">var</span> c: <span class="STpe">f64</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">0</span>)  <span class="SCmt">// The default value for a floating-point number is 0.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Uninitialized Variables </h4>
<p>If you want a variable to remain uninitialized and avoid the default initialization cost, you can assign it <span class="code-inline">undefined</span>. This approach should be used with caution, as the variable will be in an undefined state. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">bool</span> = <span class="SKwd">undefined</span>  <span class="SCmt">// 'a' is intentionally left uninitialized.</span>
    <span class="SKwd">var</span> b: <span class="STpe">string</span> = <span class="SKwd">undefined</span>  <span class="SCmt">// 'b' is intentionally left uninitialized.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Type Inference </h4>
<p>Swag supports type inference, where the type of a variable can be automatically deduced from its assigned value. This allows the omission of explicit type annotations in many cases. </p>
<p>Below are examples demonstrating <b>type inference</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>  <span class="SCmt">// The type of 'a' is inferred to be 'f32' due to the floating-point literal.</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">f32</span>

    <span class="SKwd">let</span> b = <span class="SStr">"string"</span>  <span class="SCmt">// The type of 'b' is inferred to be 'string'.</span>
    <span class="SItr">@assert</span>(b == <span class="SStr">"string"</span>)
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(b) == <span class="STpe">string</span>

    <span class="SKwd">let</span> c = <span class="SNum">1.5</span>'<span class="STpe">f64</span>  <span class="SCmt">// The type of 'c' is explicitly set to 'f64' using a suffix.</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(c) == <span class="STpe">f64</span>
}</span></div>
<p>Type inference also applies when declaring multiple variables simultaneously. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a, b = <span class="SKwd">true</span>  <span class="SCmt">// Both 'a' and 'b' are inferred to be of type 'bool'.</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(b == <span class="SKwd">true</span>)
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="SItr">#typeof</span>(<span class="SKwd">true</span>)
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(b) == <span class="SItr">#typeof</span>(a)

    <span class="SKwd">let</span> c = <span class="SNum">1.5</span>, d = <span class="SStr">"string"</span>  <span class="SCmt">// 'c' is inferred as 'f32', and 'd' as 'string'.</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">1.5</span>)
    <span class="SItr">@assert</span>(d == <span class="SStr">"string"</span>)
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(c) == <span class="STpe">f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(d) == <span class="STpe">string</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Special Variables </h4>
<p>Swag offers special keywords and attributes to manage variable storage and behavior beyond typical usage. </p>
<h5 id="_003_000_fundamentals_swg__003_005_variables_swg">Thread-Local Storage </h5>
<p>By tagging a global variable with <span class="code-inline">#[Swag.Tls]</span>, you can store it in thread-local storage.  Each thread will then have its own independent copy of the variable. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Tls]</span>
<span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span>  <span class="SCmt">// 'G' is a global variable stored in thread-local storage.</span></span></div>
<h5 id="_003_000_fundamentals_swg__003_005_variables_swg">Global Variables </h5>
<p>A local variable can be tagged with <span class="code-inline">#[Swag.Global]</span> to make it global, functioning similarly to the <span class="code-inline">static</span> keyword in C/C++. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>() -&gt; <span class="STpe">s32</span>
    {
        <span class="SAtr">#[Swag.Global]</span>
        <span class="SKwd">var</span> <span class="SCst">G1</span> = <span class="SNum">0</span>  <span class="SCmt">// 'G1' is a static-like variable that retains its value across function calls.</span>

        <span class="SCst">G1</span> += <span class="SNum">1</span>
        <span class="SLgc">return</span> <span class="SCst">G1</span>
    }

    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">1</span>)  <span class="SCmt">// First call increments G1 to 1.</span>
    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">2</span>)  <span class="SCmt">// Second call increments G1 to 2.</span>
    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">3</span>)  <span class="SCmt">// Third call increments G1 to 3.</span>
}</span></div>
<h5 id="_003_000_fundamentals_swg__003_005_variables_swg">Compile-Time Variables </h5>
<p>Global variables marked with <span class="code-inline">#[Swag.Compiler]</span> are only accessible during compile-time and are excluded from the runtime code. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Compiler]</span>
<span class="SKwd">var</span> <span class="SCst">G2</span> = <span class="SNum">0</span>  <span class="SCmt">// 'G2' is a compile-time-only variable.</span>

<span class="SFct">#run</span>
{
    <span class="SCst">G2</span> += <span class="SNum">5</span>  <span class="SCmt">// This increment occurs at compile-time.</span>
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_006_operators_swg">Operators</h3><h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Arithmetic Operators </h4>
<p>These operators perform basic arithmetic operations such as addition, subtraction, multiplication, and division. Modulus operation is also supported to get the remainder of a division. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    <span class="SCmt">// Addition: Increments x by 1</span>
    x = x + <span class="SNum">1</span>                                                              

    <span class="SCmt">// Subtraction: Decrements x by 1</span>
    x = x - <span class="SNum">1</span>                                                              

    <span class="SCmt">// Multiplication: Multiplies x by 2</span>
    x = x * <span class="SNum">2</span>                                                              

    <span class="SCmt">// Division: Divides x by 2</span>
    x = x / <span class="SNum">2</span>                                                              

    <span class="SCmt">// Modulus: Finds remainder when x is divided by 2</span>
    x = x % <span class="SNum">2</span>                                                              
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Bitwise Operators </h4>
<p>Bitwise operators manipulate individual bits of integral types. These operators perform operations  such as XOR, AND, OR, and bit shifting. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    <span class="SCmt">// XOR: Bitwise XOR with 2</span>
    x = x ^ <span class="SNum">2</span>                                                              

    <span class="SCmt">// Bitwise AND: Applies a bitmask to retain only the least significant bit</span>
    x = x & <span class="SNum">0b0000_0001</span>'<span class="STpe">s32</span>                                                

    <span class="SCmt">// Bitwise OR: Sets the least significant bit to 1</span>
    x = x | <span class="SKwd">cast</span>(<span class="STpe">s32</span>) <span class="SNum">0b0000_0001</span>                                          

    <span class="SCmt">// Shift Left: Shifts bits to the left by 1 position</span>
    x = x &lt;&lt; <span class="SNum">1</span>                                                             

    <span class="SCmt">// Shift Right: Shifts bits to the right by 1 position</span>
    x = x &gt;&gt; <span class="SNum">1</span>                                                             
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Assignment Operators </h4>
<p>These operators perform the basic arithmetic or bitwise operation and assign the result directly  to the left operand. The <span class="code-inline">affect</span> versions of these operators make the code concise and clear. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    x += <span class="SNum">1</span>           <span class="SCmt">// Addition assignment</span>
    x -= <span class="SNum">1</span>           <span class="SCmt">// Subtraction assignment</span>
    x *= <span class="SNum">2</span>           <span class="SCmt">// Multiplication assignment</span>
    x /= <span class="SNum">2</span>           <span class="SCmt">// Division assignment</span>
    x %= <span class="SNum">2</span>           <span class="SCmt">// Modulus assignment</span>
    x ^= <span class="SNum">2</span>           <span class="SCmt">// XOR assignment</span>
    x |= <span class="SNum">0b0000_0001</span> <span class="SCmt">// Bitwise OR assignment</span>
    x &= <span class="SNum">0b0000_0001</span> <span class="SCmt">// Bitwise AND assignment</span>
    x &lt;&lt;= <span class="SNum">1</span>          <span class="SCmt">// Shift left assignment</span>
    x &gt;&gt;= <span class="SNum">1</span>          <span class="SCmt">// Shift right assignment</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Unary Operators </h4>
<p>Unary operators operate on a single operand. These include logical NOT, bitwise NOT, and negation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SKwd">true</span>
    <span class="SKwd">var</span> y = <span class="SNum">0b0000_0001</span>'<span class="STpe">u8</span>
    <span class="SKwd">var</span> z = <span class="SNum">1</span>

    <span class="SCmt">// Invert boolean: Logical NOT</span>
    x = !x                                                               

    <span class="SCmt">// Invert bits: Bitwise NOT</span>
    y = ~y                                                               

    <span class="SCmt">// Negation: Unary minus</span>
    z = -z                                                               

    <span class="SItr">@assert</span>(z == -<span class="SNum">1</span>)
    <span class="SItr">@assert</span>(x == <span class="SKwd">false</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">0b1111_1110</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Comparison Operators </h4>
<p>Comparison operators compare two values and return a boolean result. They include equality, inequality, and relational operators. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">var</span> a = <span class="SKwd">false</span>

        <span class="SCmt">// Equal: Checks if two values are equal</span>
        a = <span class="SNum">1</span> == <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>                                        

        <span class="SCmt">// Not equal: Checks if two values are not equal</span>
        a = <span class="SNum">1</span> != <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>                                        

        <span class="SCmt">// Less than or equal: Checks if the left value is less than or equal to the right value</span>
        a = <span class="SNum">1</span> &lt;= <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>                                        

        <span class="SCmt">// Greater than or equal: Checks if the left value is greater than or equal to the right value</span>
        a = <span class="SNum">1</span> &gt;= <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>                                        

        <span class="SCmt">// Less than: Checks if the left value is less than the right value</span>
        a = <span class="SNum">1</span> &lt; <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>                                         

        <span class="SCmt">// Greater than: Checks if the left value is greater than the right value</span>
        a = <span class="SNum">1</span> &gt; <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>                                         
    }

    {
        <span class="SKwd">let</span> x = <span class="SNum">5</span>
        <span class="SKwd">let</span> y = <span class="SNum">10</span>
        <span class="SItr">@assert</span>(x == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x != <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(x &lt;= <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x &lt; <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(x &gt;= <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x &gt; <span class="SNum">0</span>)
    }
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Logical Operators </h4>
<p>Logical operators evaluate expressions to return a boolean value. Swag uses <span class="code-inline">and</span> and <span class="code-inline">or</span> instead  of <span class="code-inline">&&</span> and <span class="code-inline">||</span> found in C/C++. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SKwd">false</span>
    a = (<span class="SNum">1</span> &gt; <span class="SNum">10</span>) <span class="SLgc">and</span> (<span class="SNum">10</span> &lt; <span class="SNum">1</span>)  <span class="SCmt">// Logical AND</span>
    a = (<span class="SNum">1</span> &gt; <span class="SNum">10</span>) <span class="SLgc">or</span> (<span class="SNum">10</span> &lt; <span class="SNum">1</span>)   <span class="SCmt">// Logical OR</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Ternary Operator </h4>
<p>The ternary operator tests an expression and returns one of two values depending on the result of  the test. The syntax is <span class="code-inline">A = Expression ? B : C</span>, where <span class="code-inline">B</span> is returned if the expression is true, and <span class="code-inline">C</span> is returned if the expression is false. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Returns 1 because the expression 'true' is... true.</span>
    <span class="SKwd">let</span> x = <span class="SKwd">true</span> ? <span class="SNum">1</span> : <span class="SNum">666</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>)

    <span class="SCmt">// Returns 666 because the expression 'x == 52' is false.</span>
    <span class="SKwd">let</span> y = (x == <span class="SNum">52</span>) ? <span class="SNum">1</span> : <span class="SNum">666</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">666</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Spaceshift Operator </h4>
<p>Operator <span class="code-inline">&lt;=&gt;</span> returns -1, 0, or 1 if the left expression is lower, equal, or greater than the right  expression, respectively. The returned type is <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> == -<span class="SNum">1</span> <span class="SLgc">if</span> <span class="SCst">A</span> &lt; <span class="SCst">B</span>
<span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> == <span class="SNum">0</span>  <span class="SLgc">if</span> <span class="SCst">A</span> == <span class="SCst">B</span>
<span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> == <span class="SNum">1</span>  <span class="SLgc">if</span> <span class="SCst">A</span> &gt; <span class="SCst">B</span></span></div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> a = -<span class="SNum">1.5</span> &lt;=&gt; <span class="SNum">2.31</span>
        <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">s32</span>
        <span class="SItr">@assert</span>(a == -<span class="SNum">1</span>)

        <span class="SItr">@assert</span>(-<span class="SNum">10</span> &lt;=&gt; <span class="SNum">10</span> == -<span class="SNum">1</span>)
        <span class="SItr">@assert</span>(<span class="SNum">10</span> &lt;=&gt; -<span class="SNum">10</span> == <span class="SNum">1</span>)
        <span class="SItr">@assert</span>(<span class="SNum">10</span> &lt;=&gt; <span class="SNum">10</span> == <span class="SNum">0</span>)
    }

    {
        <span class="SKwd">let</span> x1 = <span class="SNum">10</span> &lt;=&gt; <span class="SNum">20</span>
        <span class="SItr">@assert</span>(x1 == -<span class="SNum">1</span>)
        <span class="SKwd">let</span> x2 = <span class="SNum">20</span> &lt;=&gt; <span class="SNum">10</span>
        <span class="SItr">@assert</span>(x2 == <span class="SNum">1</span>)
        <span class="SKwd">let</span> x3 = <span class="SNum">20</span> &lt;=&gt; <span class="SNum">20</span>
        <span class="SItr">@assert</span>(x3 == <span class="SNum">0</span>)
    }
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Null-Coalescing Operator </h4>
<p>The operator <span class="code-inline">orelse</span> returns the left expression if it is not null, otherwise it returns the right  expression. </p>
<p>Works with strings, pointers, and structures with the <span class="code-inline">opData</span> special function (covered later). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SStr">"string1"</span>
    <span class="SKwd">let</span> b = <span class="SStr">"string2"</span>

    <span class="SCmt">// c = a if a is not null, else c = b.</span>
    <span class="SKwd">var</span> c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == <span class="SStr">"string1"</span>)

    a = <span class="SKwd">null</span>
    c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == <span class="SStr">"string2"</span>)
}</span></div>
<p>Works also for basic types like integers. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">0</span>
    <span class="SKwd">let</span> b = <span class="SNum">1</span>
    <span class="SKwd">let</span> c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == b)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Type Promotion </h4>
<p>Unlike C, types are not promoted to 32 bits when dealing with 8 or 16-bit types. However, types will  be promoted if the two sides of an operation do not have the same type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u8</span>) == <span class="STpe">u8</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u16</span>) == <span class="STpe">u16</span> <span class="SCmt">// Priority to bigger type</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u32</span>) == <span class="STpe">u32</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u64</span>) == <span class="STpe">u64</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s8</span>) == <span class="STpe">s8</span>   <span class="SCmt">// Priority to signed type</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s16</span>) == <span class="STpe">s16</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s32</span>) == <span class="STpe">s32</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s64</span>) == <span class="STpe">s64</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">f32</span>) == <span class="STpe">f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">f64</span>) == <span class="STpe">f64</span>

    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">s8</span> + <span class="SNum">1</span>'<span class="STpe">u16</span>) == <span class="STpe">u16</span> <span class="SCmt">// Priority to bigger type also</span>
}</span></div>
<p>This means that an 8/16-bit operation (like an addition) can more easily overflow if you do not take  care. In that case, you can use the <span class="code-inline"> #prom</span> modifier on the operation, which will promote the type  to at least 32 bits. The operation will be done accordingly. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SNum">255</span>'<span class="STpe">u8</span> + <span class="SCmp">#prom</span> <span class="SNum">1</span>'<span class="STpe">u8</span>) == <span class="STpe">u32</span>
    <span class="SCmp">#assert</span> <span class="SNum">255</span>'<span class="STpe">u8</span> + <span class="SCmp">#prom</span> <span class="SNum">1</span>'<span class="STpe">u8</span> == <span class="SNum">256</span> <span class="SCmt">// No overflow, because the operation is done in 32 bits.</span>
}</span></div>
<p>We'll see later how Swag deals with that kind of overflow, and more generally, with <b>safety</b>. </p>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Operator Precedence </h4>
<div class="code-block"><span class="SCde">~
* / %
+ -
&gt;&gt; &lt;&lt;
&
|
^
&lt;=&gt;
== !=
&lt; &lt;= &gt; &gt;=
<span class="SLgc">and</span>
<span class="SLgc">or</span></span></div>
<p>If two operators have the same precedence, the expression is evaluated from left to right. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Multiplication before addition</span>
    <span class="SItr">@assert</span>(<span class="SNum">10</span> + <span class="SNum">2</span> * <span class="SNum">3</span> == <span class="SNum">16</span>)
    <span class="SCmt">// Parentheses change precedence</span>
    <span class="SItr">@assert</span>((<span class="SNum">10</span> + <span class="SNum">2</span>) * <span class="SNum">3</span> == <span class="SNum">36</span>)
    <span class="SCmt">// Addition and subtraction before comparison</span>
    <span class="SItr">@assert</span>((<span class="SNum">5</span> + <span class="SNum">3</span> &lt; <span class="SNum">10</span> - <span class="SNum">2</span>) == <span class="SKwd">false</span>)
    <span class="SCmt">// 'and' before 'or'</span>
    <span class="SItr">@assert</span>((<span class="SKwd">false</span> <span class="SLgc">and</span> <span class="SKwd">false</span> <span class="SLgc">or</span> <span class="SKwd">true</span>) == <span class="SKwd">true</span>)
    <span class="SCmt">// '&lt;&lt;' before '&'</span>
    <span class="SItr">@assert</span>((<span class="SNum">10</span> & <span class="SNum">2</span> &lt;&lt; <span class="SNum">1</span>) == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(((<span class="SNum">10</span> & <span class="SNum">2</span>) &lt;&lt; <span class="SNum">1</span>) == <span class="SNum">4</span>)
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_007_cast_swg">Cast</h3><h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Explicit Cast with <span class="code-inline">cast</span> </h4>
<p>Explicit casting is necessary when you need to convert a value from one type to another manually. This can be achieved using the <span class="code-inline">cast(type) value</span> syntax, which transforms the <span class="code-inline">value</span> into the specified <span class="code-inline">type</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// 'x' is initialized as a floating-point number (f32 by default)</span>
    <span class="SKwd">let</span> x = <span class="SNum">1.0</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(x) == <span class="STpe">f32</span>

    <span class="SCmt">// 'y' is explicitly cast to a 32-bit signed integer (s32)</span>
    <span class="SKwd">let</span> y = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) x
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(y) == <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)                            <span class="SCmt">// The floating-point value 1.0 is cast to the integer value 1</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Automatic Cast with <span class="code-inline">cast()</span> </h4>
<p>A <span class="code-inline">cast()</span> without an expression stands for <span class="code-inline">automatic cast</span>, allowing the compiler to automatically determine and perform the cast to match the type on the left-hand side of the assignment. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">f32</span> = <span class="SNum">1.0</span>
    <span class="SKwd">let</span> y: <span class="STpe">s32</span> = <span class="SKwd">cast</span>() x                       <span class="SCmt">// Automatically cast 'x' to 's32'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(y) == <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)
}</span></div>
<p>This also works for a function call argument. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">testAutoCast</span>(x: <span class="STpe">s32</span>)
{
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>)
}

<span class="SFct">#test</span>
{
    <span class="SFct">testAutoCast</span>(<span class="SKwd">cast</span>() <span class="SNum">1.4</span>)        <span class="SCmt">// Automatic cast to the type 's32' of 'x'</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Bitcast </h4>
<p>The <span class="code-inline">bit</span> cast mode enables bit-level reinterpretation of a value's type without altering the underlying bit pattern. This operation, known as a <b>bitcast</b>, is only valid when the source and destination types share the same size. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">f32</span> = <span class="SNum">1.0</span>
    <span class="SKwd">let</span> y: <span class="STpe">u32</span> = <span class="SKwd">cast</span>&lt;bit&gt;(<span class="STpe">u32</span>) x              <span class="SCmt">// Reinterpret the bits of 'x' as a 'u32'</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">0x3f800000</span>)                   <span class="SCmt">// 1.0 in IEEE 754 floating-point format equals 0x3f800000 in hex</span>

    <span class="SCmt">// Casting back to the original type should yield the original value</span>
    <span class="SCmp">#assert</span> <span class="SKwd">cast</span>&lt;bit&gt;(<span class="STpe">u32</span>) <span class="SNum">1.0</span> == <span class="SNum">0x3f800000</span>
    <span class="SCmp">#assert</span> <span class="SKwd">cast</span>&lt;bit&gt;(<span class="STpe">f32</span>) <span class="SNum">0x3f800000</span> == <span class="SNum">1.0</span>   <span class="SCmt">// Reinterpreting the bits back to 'f32' gives 1.0</span>
}</span></div>
<p>This example demonstrates the reverse operation, where an integer representing a bit pattern is reinterpreted as a floating-point number. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> rawBits: <span class="STpe">u32</span> = <span class="SNum">0x40490FDB</span>              <span class="SCmt">// Hexadecimal representation of the float 3.1415927</span>
    <span class="SKwd">let</span> pi: <span class="STpe">f32</span>      = <span class="SKwd">cast</span>&lt;bit&gt;(<span class="STpe">f32</span>) rawBits  <span class="SCmt">// Interpret the bit pattern as a floating-point number</span>
    <span class="SItr">@assert</span>(pi == <span class="SNum">3.1415927</span>)                   <span class="SCmt">// This now represents the value of pi as a floating-point number</span>

    <span class="SCmt">// Verifying that casting back to the original bit pattern restores the initial value</span>
    <span class="SKwd">let</span> backToBits: <span class="STpe">u32</span> = <span class="SKwd">cast</span>&lt;bit&gt;(<span class="STpe">u32</span>) pi
    <span class="SItr">@assert</span>(backToBits == <span class="SNum">0x40490FDB</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Implicit Casts </h4>
<p>Swag allows automatic type conversions, known as <i>implicit casts</i>, when assigning a value of one type to a variable of another type. This occurs without requiring an explicit <span class="code-inline">cast</span> statement. However, implicit casts are only permitted when there is no risk of precision loss or range overflow, ensuring that the value remains intact and no data is lost during the conversion. </p>
<h5 id="_003_000_fundamentals_swg__003_007_cast_swg">Implicit Cast Rules </h5>
<ol>
<li><b>Widening Conversions</b>: Implicit casts are allowed when converting a smaller type to a larger type, such as from <span class="code-inline">s8</span> to <span class="code-inline">s16</span>, or from <span class="code-inline">f32</span> to <span class="code-inline">f64</span>. These conversions are safe because the larger type can represent all possible values of the smaller type.</li>
<li><b>Sign Preservation</b>: When implicitly casting between signed and unsigned types, Swag ensures that no data loss occurs by verifying that the value can be represented in both types. Implicit casts from unsigned to signed types (and vice versa) are only allowed when the value is positive and within the range of the target type.</li>
<li><b>No Implicit Narrowing</b>: Swag does not permit implicit casts that could potentially lose data or precision, such as from <span class="code-inline">s32</span> to <span class="code-inline">s8</span>. These narrowing conversions require an explicit cast to indicate that the developer is aware of the potential data loss.</li>
</ol>
<h5 id="_003_000_fundamentals_swg__003_007_cast_swg">Examples of Implicit Casts </h5>
<p>Let's explore some examples to illustrate these rules. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Implicit cast from 8-bit signed integer (s8) to 16-bit signed integer (s16)</span>
    <span class="SKwd">let</span> x: <span class="STpe">s16</span> = <span class="SNum">1</span>'<span class="STpe">s8</span>                         <span class="SCmt">// Safe conversion, no loss of precision</span>

    <span class="SCmt">// Implicit cast from 16-bit signed integer (s16) to 32-bit signed integer (s32)</span>
    <span class="SKwd">let</span> y: <span class="STpe">s32</span> = <span class="SNum">1</span>'<span class="STpe">s16</span>                        <span class="SCmt">// Safe conversion, no loss of precision</span>

    <span class="SCmt">// Implicit cast from 32-bit signed integer (s32) to 64-bit signed integer (s64)</span>
    <span class="SKwd">let</span> z: <span class="STpe">s64</span> = <span class="SNum">1</span>'<span class="STpe">s32</span>                        <span class="SCmt">// Safe conversion, no loss of precision</span>

    <span class="SCmt">// Implicit cast from 8-bit unsigned integer (u8) to 16-bit unsigned integer (u16)</span>
    <span class="SKwd">let</span> a: <span class="STpe">u16</span> = <span class="SNum">255</span>'<span class="STpe">u8</span>                       <span class="SCmt">// Safe conversion, no loss of precision</span>

    <span class="SCmt">// Implicit cast from 16-bit unsigned integer (u16) to 32-bit unsigned integer (u32)</span>
    <span class="SKwd">let</span> b: <span class="STpe">u32</span> = <span class="SNum">65535</span>'<span class="STpe">u16</span>                    <span class="SCmt">// Safe conversion, no loss of precision</span>

    <span class="SCmt">// Implicit cast from 32-bit unsigned integer (u32) to 64-bit unsigned integer (u64)</span>
    <span class="SKwd">let</span> c: <span class="STpe">u64</span> = <span class="SNum">4294967295</span>'<span class="STpe">u32</span>               <span class="SCmt">// Safe conversion, no loss of precision</span>

    <span class="SCmt">// Implicit cast from 32-bit floating-point (f32) to 64-bit floating-point (f64)</span>
    <span class="SKwd">let</span> d: <span class="STpe">f64</span> = <span class="SNum">1.23</span>'<span class="STpe">f32</span>                     <span class="SCmt">// Safe conversion, f64 can represent all f32 values accurately</span>
}</span></div>
<h5 id="_003_000_fundamentals_swg__003_007_cast_swg">Examples Where Implicit Casts Are Not Allowed </h5>
<p>There are cases where implicit casts are not permitted due to the risk of data loss or precision issues. In such situations, Swag requires an explicit cast to ensure that the developer is aware of and accepts the risks. </p>
<p>Additionally, the cast mode <span class="code-inline">unsafe</span> can be used in explicit casts to indicate that the value may lose some precision without raising an error. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Implicit cast from 16-bit signed integer (s16) to 8-bit signed integer (s8)</span>
    <span class="SCmt">// This would generate a compilation error because s8 cannot represent all s16 values.</span>
    <span class="SCmt">// Uncommenting the following lines would cause an error:</span>

    <span class="SCmt">// let z0: s16 = 100</span>
    <span class="SCmt">// let z1: s8 = z0                          // Error: Implicit cast from 's16' to 's8' is not allowed</span>

    <span class="SCmt">// To perform this cast, an explicit cast is required:</span>
    <span class="SKwd">let</span> z0: <span class="STpe">s16</span> = <span class="SNum">256</span>
    <span class="SKwd">let</span> z1: <span class="STpe">s8</span> = <span class="SKwd">cast</span>&lt;overflow&gt;(<span class="STpe">s8</span>) z0          <span class="SCmt">// Explicit cast needed to convert from s16 to s8</span>
    <span class="SItr">@assert</span>(z1 == <span class="SNum">0</span>)                            <span class="SCmt">// This may cause data loss as 256 cannot be represented in s8 (max is 127)</span>

    <span class="SCmt">// Implicit cast from unsigned to signed type where the value is out of range</span>
    <span class="SKwd">let</span> u_val: <span class="STpe">u16</span> = <span class="SNum">65535</span>
    <span class="SCmt">// let s_val: s16 = u_val                   // Error: Implicit cast from 'u16' to 's16' is not allowed due to potential data loss</span>

    <span class="SCmt">// To perform this cast, an explicit cast is required, with the risk of data loss:</span>
    <span class="SKwd">let</span> s_val: <span class="STpe">s16</span> = <span class="SKwd">cast</span>&lt;overflow&gt;(<span class="STpe">s16</span>) u_val  <span class="SCmt">// This could result in an unexpected negative value</span>
    <span class="SItr">@assert</span>(s_val == -<span class="SNum">1</span>)                        <span class="SCmt">// 65535 in u16 becomes -1 in s16 due to overflow</span>

    <span class="SCmt">// Implicit cast from f64 to f32, which can lose precision</span>
    <span class="SKwd">let</span> large_float: <span class="STpe">f64</span> = <span class="SNum">1.23456789012345611111</span>
    <span class="SCmt">// let smaller_float: f32 = large_float     // Error: Implicit cast from 'f64' to 'f32' is not allowed due to precision loss</span>

    <span class="SCmt">// Explicit cast is required when converting from f64 to f32</span>
    <span class="SKwd">let</span> smaller_float: <span class="STpe">f32</span> = <span class="SKwd">cast</span>(<span class="STpe">f32</span>) large_float
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_008_alias_swg">Alias</h3><h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Type Alias </h4>
<p>An <span class="code-inline">alias</span> allows you to create a shorthand for an existing type, making it possible to refer to that type using a new, potentially more descriptive name. This can enhance code clarity, reduce repetition, and make complex types easier to work with. </p>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Basic Type Alias </h4>
<p>Using <span class="code-inline">alias</span>, you can define an alias for an existing type. This alias can then be used in place of the original type, simplifying the code or improving its readability. It’s important to note that a type alias does not create a new type but merely provides an alternative name for an existing one. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span> == <span class="SNum">0</span>)

    <span class="SKwd">alias</span> <span class="SCst">Color</span> = <span class="SCst">RGB</span>                   <span class="SCmt">// 'Color' is now a shorthand for 'RGB'</span>
    <span class="SItr">@assert</span>(<span class="SCst">Color</span>.<span class="SCst">G</span> == <span class="SNum">1</span>)                   <span class="SCmt">// 'Color' can be used wherever 'RGB' is expected.</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Aliasing Primitive Types </h4>
<p>You can create aliases for primitive types, making your code more readable and meaningful, especially when the alias represents a specific domain concept. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">alias</span> <span class="SCst">Float32</span> = <span class="STpe">f32</span>                 <span class="SCmt">// 'Float32' is an alias for 'f32'</span>
    <span class="SKwd">alias</span> <span class="SCst">Float64</span> = <span class="STpe">f64</span>                 <span class="SCmt">// 'Float64' is an alias for 'f64'</span>

    <span class="SKwd">var</span> x: <span class="SCst">Float32</span> = <span class="SNum">1.0</span>                    <span class="SCmt">// Equivalent to declaring 'var x: f32'</span>
    <span class="SKwd">var</span> y: <span class="SCst">Float64</span> = <span class="SNum">1.0</span>                    <span class="SCmt">// Equivalent to declaring 'var y: f64'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SCst">Float32</span>) == <span class="STpe">f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SCst">Float64</span>) == <span class="STpe">f64</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Strict Type Alias </h4>
<p>In cases where you need to enforce type safety, Swag provides the <span class="code-inline">Swag.Strict</span> attribute, which can be applied to a <span class="code-inline">alias</span>. This makes the alias a distinct type, preventing implicit casting between the alias and the original type. Explicit casting is still allowed, but the distinct type ensures that operations requiring type specificity are clear and deliberate. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Strict]</span>
    <span class="SKwd">alias</span> <span class="SCst">MyType</span> = <span class="STpe">s32</span>                  <span class="SCmt">// 'MyType' is a distinct type, not interchangeable with 's32'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SCst">MyType</span>) != <span class="STpe">s32</span>

    <span class="SKwd">let</span> x: <span class="SCst">MyType</span> = <span class="SKwd">cast</span>(<span class="SCst">MyType</span>) <span class="SNum">0</span>          <span class="SCmt">// Explicit cast is required to assign a value</span>
    <span class="SKwd">let</span> y: <span class="STpe">s32</span> = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) x                <span class="SCmt">// Casting back to 's32' also requires an explicit cast</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Name Alias </h4>
<p>An <span class="code-inline">alias</span> allows you also to create an alternative name or shortcut for functions, variables, or namespaces. This can be particularly useful for simplifying code, managing long or complex names, or improving the readability and maintainability of your code. </p>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Function Name Alias </h4>
<p>With <span class="code-inline">alias</span>, you can define a shorter or more convenient name for a function. This is particularly helpful when dealing with functions that have long or descriptive names, allowing you to simplify your code without sacrificing functionality. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">thisIsABigFunctionName</span>(x: <span class="STpe">s32</span>) =&gt; x * x

    <span class="SKwd">alias</span> myFunc = thisIsABigFunctionName
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">4</span>) == <span class="SNum">16</span>)                <span class="SCmt">// 'myFunc' is now an alias for 'thisIsABigFunctionName'</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Variable and Namespace Alias </h4>
<p><span class="code-inline">alias</span> can also be used to alias variables and namespaces, offering a shorter or more convenient reference that can be used throughout your code. This is particularly useful in large codebases where certain variables or namespaces are frequently referenced. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myLongVariableName: <span class="STpe">s32</span> = <span class="SNum">0</span>
    <span class="SKwd">alias</span> short = myLongVariableName

    short += <span class="SNum">2</span>                              <span class="SCmt">// 'short' is an alias for 'myLongVariableName'</span>
    <span class="SItr">@assert</span>(myLongVariableName == <span class="SNum">2</span>)        <span class="SCmt">// The original variable reflects changes made via the alias</span>
}</span></div>

<h2 id="_004_000_data_structures_swg">Data structures</h2>
<h3 id="_004_000_data_structures_swg__004_001_array_swg">Array</h3><h4 id="_004_000_data_structures_swg__004_001_array_swg">Static Arrays in Swag </h4>
<p>Static arrays are fixed-size arrays where the size is known and set at compile time. Unlike dynamic arrays from the <span class="code-inline">Std.Core</span> module, static arrays do not change in size during runtime. They are ideal for situations where memory and size constraints are predictable and fixed. </p>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Declaring a Static Array </h4>
<p>A static array is declared using the syntax <span class="code-inline">[N]</span> followed by the type, where <span class="code-inline">N</span> is the number of elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>               <span class="SCmt">// Declare a static array with two 32-bit signed integers (s32)</span>
    array[<span class="SNum">0</span>] = <span class="SNum">1</span>                     <span class="SCmt">// Assign the value 1 to the first element</span>
    array[<span class="SNum">1</span>] = <span class="SNum">2</span>                     <span class="SCmt">// Assign the value 2 to the second element</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Array Size and Memory </h4>
<p>The <span class="code-inline">@countof</span> intrinsic can be used to get the number of elements in an array, while <span class="code-inline">#sizeof</span> provides the total size of the array in bytes. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Declare a static array with two 32-bit signed integer (s32) elements</span>
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>                          

    <span class="SCmt">// Use '#typeof' to get the array type and check the number of elements with '.count'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(array).count == <span class="SNum">2</span>

    <span class="SCmt">// '@countof' is a runtime intrinsic that also works with compile-time elements</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array) == <span class="SNum">2</span>                <span class="SCmt">// Ensure the array contains 2 elements</span>

    <span class="SCmt">// '#sizeof' is a compile-time intrinsic that returns the size in bytes of the given element</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(array) == <span class="SNum">2</span> * <span class="SItr">#sizeof</span>(<span class="STpe">s32</span>)  <span class="SCmt">// Verify the total size in bytes</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Obtaining the Address of an Array </h4>
<p>The <span class="code-inline">@dataof</span> intrinsic retrieves the address of the first element in an array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>               <span class="SCmt">// Declare a static array of two s32 elements</span>
    <span class="SKwd">var</span> ptr0   = <span class="SItr">@dataof</span>(array)      <span class="SCmt">// Get the base address of the array</span>
    ptr0[<span class="SNum">0</span>] = <span class="SNum">1</span>                      <span class="SCmt">// Access the first element via the pointer</span>

    <span class="SCmt">// Alternatively, obtain the address of a specific element</span>
    <span class="SKwd">var</span> ptr1 = &array[<span class="SNum">0</span>]             <span class="SCmt">// Get the address of the first element</span>
    ptr1[<span class="SNum">1</span>] = <span class="SNum">2</span>                      <span class="SCmt">// Access the second element via the pointer</span>

    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">1</span>)           <span class="SCmt">// Confirm that the first element is 1</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">2</span>)           <span class="SCmt">// Confirm that the second element is 2</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Array Literals </h4>
<p>An array literal is a list of elements enclosed in square brackets <span class="code-inline">[A, B, ...]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]           <span class="SCmt">// Declare and initialize a static array of four s32 elements</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>       <span class="SCmt">// Verify the array contains 4 elements</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(arr) == <span class="SItr">#type</span> [<span class="SNum">4</span>] <span class="STpe">s32</span>  <span class="SCmt">// Verify the array's type is [4] s32</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Type Deduction in Arrays </h4>
<p>Swag can deduce the size of the array from the initialization expression, eliminating the need to specify the dimension explicitly. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Array dimension is deduced from the initialization with 2 elements</span>
    <span class="SKwd">var</span> array: [] <span class="STpe">s32</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>]       
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">1</span>)           
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">2</span>)           
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array) == <span class="SNum">2</span>     

    <span class="SCmt">// Both dimensions and types are deduced from the initialization expression</span>
    <span class="SKwd">var</span> array1 = [<span class="SStr">"10"</span>, <span class="SStr">"20"</span>, <span class="SStr">"30"</span>]  
    <span class="SItr">@assert</span>(array1[<span class="SNum">0</span>] == <span class="SStr">"10"</span>)       
    <span class="SItr">@assert</span>(array1[<span class="SNum">1</span>] == <span class="SStr">"20"</span>)       
    <span class="SItr">@assert</span>(array1[<span class="SNum">2</span>] == <span class="SStr">"30"</span>)       
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array1) == <span class="SNum">3</span>    
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Default Initialization </h4>
<p>Static arrays in Swag are automatically initialized to zero values (0 for integers, null for strings, false for booleans, etc.) unless specified otherwise. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>               <span class="SCmt">// Declare a static array of two s32 elements</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">0</span>)           <span class="SCmt">// Ensure the array is initialized to 0</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">0</span>)           
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Preventing Default Initialization </h4>
<p>To enhance performance, you can bypass the default initialization by using <span class="code-inline">undefined</span>, particularly useful when you plan to manually initialize all array elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">100</span>] <span class="STpe">s32</span> = <span class="SKwd">undefined</span> <span class="SCmt">// Declare a large array without initializing it</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Constant Arrays </h4>
<p>Static arrays with compile-time values can be declared as constants, meaning their values cannot be altered after declaration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> array = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]       <span class="SCmt">// Declare a constant static array</span>
    <span class="SCmp">#assert</span> array[<span class="SNum">0</span>] == <span class="SNum">1</span>            <span class="SCmt">// Compile-time dereference of the first element</span>
    <span class="SCmp">#assert</span> array[<span class="SNum">3</span>] == <span class="SNum">4</span>            <span class="SCmt">// Compile-time dereference of the fourth element</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Type Inference from Array Literals </h4>
<p>If the array's type is not explicitly specified, Swag infers the type based on the first literal value, which then applies to all other elements in the array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>'<span class="STpe">f64</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]       <span class="SCmt">// All elements are inferred to be 'f64'</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>       <span class="SCmt">// Verify the array has 4 elements</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(arr) == <span class="SItr">#type</span> [<span class="SNum">4</span>] <span class="STpe">f64</span>  <span class="SCmt">// Confirm that all elements are of type f64</span>
    <span class="SItr">@assert</span>(arr[<span class="SNum">3</span>] == <span class="SNum">4.0</span>)           <span class="SCmt">// Confirm the value of the fourth element</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Multi-Dimensional Arrays </h4>
<p>Swag supports the declaration of multi-dimensional arrays, allowing you to work with arrays with multiple dimensions. </p>
<p>The syntax for declaring multi-dimensional arrays is <span class="code-inline">[X, Y, Z...]</span>, where <span class="code-inline">X</span>, <span class="code-inline">Y</span>, and <span class="code-inline">Z</span> represent each dimension. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span>            <span class="SCmt">// Declare a 2x2 static array of s32</span>
    array[<span class="SNum">0</span>, <span class="SNum">0</span>] = <span class="SNum">1</span>                  <span class="SCmt">// Assign the value 1 to the element at [0, 0]</span>
    array[<span class="SNum">0</span>, <span class="SNum">1</span>] = <span class="SNum">2</span>                  <span class="SCmt">// Assign the value 2 to the element at [0, 1]</span>
    array[<span class="SNum">1</span>, <span class="SNum">0</span>] = <span class="SNum">3</span>                  <span class="SCmt">// Assign the value 3 to the element at [1, 0]</span>
    array[<span class="SNum">1</span>, <span class="SNum">1</span>] = <span class="SNum">4</span>                  <span class="SCmt">// Assign the value 4 to the element at [1, 1]</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">C/C++ Style Multi-Dimensional Arrays </h4>
<p>Swag also allows for the declaration of multi-dimensional arrays using C/C++ syntax, where an array of arrays is created. This method is equivalent to Swag's native multi-dimensional array syntax. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] [<span class="SNum">2</span>] <span class="STpe">s32</span>           <span class="SCmt">// Declare a 2x2 static array of s32 using C/C++ syntax</span>
    array[<span class="SNum">0</span>, <span class="SNum">0</span>] = <span class="SNum">1</span>                  <span class="SCmt">// Assign the value 1 to the element at [0, 0]</span>
    array[<span class="SNum">0</span>, <span class="SNum">1</span>] = <span class="SNum">2</span>                  <span class="SCmt">// Assign the value 2 to the element at [0, 1]</span>
    array[<span class="SNum">1</span>, <span class="SNum">0</span>] = <span class="SNum">3</span>                  <span class="SCmt">// Assign the value 3 to the element at [1, 0]</span>
    array[<span class="SNum">1</span>, <span class="SNum">1</span>] = <span class="SNum">4</span>                  <span class="SCmt">// Assign the value 4 to the element at [1, 1]</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Array Size Deduction </h4>
<p>Swag can deduce the size of arrays, including multi-dimensional arrays, directly from the initialization expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array  = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]        <span class="SCmt">// Size deduced to be 4</span>
    <span class="SKwd">var</span> array1 = [[<span class="SNum">1</span>, <span class="SNum">2</span>], [<span class="SNum">3</span>, <span class="SNum">4</span>]]    <span class="SCmt">// Size deduced to be 2x2</span>

    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array) == <span class="SNum">4</span>     <span class="SCmt">// Verify that the size of the first array is 4</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array1) == <span class="SNum">2</span>    <span class="SCmt">// Verify that the outer array has 2 elements</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Single Value Initialization </h4>
<p>Swag allows the initialization of an entire array with a single value. This feature is available only for variables, not constants, and supports basic types such as integers, floats, strings, booleans, and runes. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Initialize the entire 2x2 boolean array with 'true'</span>
    <span class="SKwd">var</span> arr: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">bool</span> = <span class="SKwd">true</span>      
    <span class="SItr">@assert</span>(arr[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SKwd">true</span>)       
    <span class="SItr">@assert</span>(arr[<span class="SNum">1</span>, <span class="SNum">1</span>] == <span class="SKwd">true</span>)       

    <span class="SCmt">// Initialize the entire 5x10 string array with "string"</span>
    <span class="SKwd">var</span> arr1: [<span class="SNum">5</span>, <span class="SNum">10</span>] <span class="STpe">string</span> = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(arr1[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SStr">"string"</span>)  
    <span class="SItr">@assert</span>(arr1[<span class="SNum">4</span>, <span class="SNum">9</span>] == <span class="SStr">"string"</span>)  
}</span></div>

<h3 id="_004_000_data_structures_swg__004_002_slice_swg">Slice</h3><h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slices in Swag </h4>
<p>A slice in Swag provides a dynamic view over a contiguous block of memory. Unlike static arrays, slices  can be resized or point to different segments of memory at runtime. A slice is composed of a pointer to  the data buffer and a <span class="code-inline">u64</span> value that stores the number of elements in the slice. </p>
<p>This design makes slices a powerful tool for working with subsets of data without the need to copy it,  enabling efficient manipulation of large datasets. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: [..] <span class="STpe">bool</span>  <span class="SCmt">// Declare a slice of boolean values</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(a) == <span class="SItr">#sizeof</span>(*<span class="STpe">void</span>) + <span class="SItr">#sizeof</span>(<span class="STpe">u64</span>)  <span class="SCmt">// Ensure slice size includes pointer and element count</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Initializing Slices </h4>
<p>Slices can be initialized in a similar manner to arrays. By assigning an array literal to a slice,  the slice will reference the elements in the array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="SKwd">const</span> [..] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>, <span class="SNum">50</span>]  <span class="SCmt">// Initialize a slice with an array literal</span>
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">5</span>)                     <span class="SCmt">// Verify that the slice contains 5 elements</span>
    <span class="SItr">@assert</span>(a[<span class="SNum">0</span>] == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">4</span>] == <span class="SNum">50</span>)

    <span class="SCmt">// Slices are dynamic, allowing for modification of the referenced elements at runtime.</span>
    a = [<span class="SNum">1</span>, <span class="SNum">2</span>]                                    <span class="SCmt">// Reassign the slice to a different array</span>
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">1</span>] == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Accessing Slice Data </h4>
<p>At runtime, you can use <span class="code-inline">@dataof</span> to retrieve the address of the data buffer and <span class="code-inline">@countof</span> to  get the number of elements in the slice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="SKwd">const</span> [..] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>, <span class="SNum">50</span>]  <span class="SCmt">// Initialize a slice with an array literal</span>
    <span class="SKwd">let</span> count = <span class="SItr">@countof</span>(a)                       <span class="SCmt">// Get the number of elements in the slice</span>
    <span class="SKwd">let</span> addr  = <span class="SItr">@dataof</span>(a)                        <span class="SCmt">// Get the address of the slice's data buffer</span>
    <span class="SItr">@assert</span>(count == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(addr[<span class="SNum">0</span>] == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(addr[<span class="SNum">4</span>] == <span class="SNum">50</span>)

    a = [<span class="SNum">1</span>, <span class="SNum">2</span>]                                    <span class="SCmt">// Reassign the slice to a different array</span>
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Creating Slices with <span class="code-inline">@mkslice</span> </h4>
<p>The <span class="code-inline">@mkslice</span> function allows you to create a slice using your own pointer and element count. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">4</span>] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]

    <span class="SCmt">// Create a slice of 'array' starting at index 2, with 2 elements.</span>
    <span class="SKwd">let</span> slice: [..] <span class="STpe">u32</span> = <span class="SItr">@mkslice</span>(&array[<span class="SNum">0</span>] + <span class="SNum">2</span>, <span class="SNum">2</span>)

    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)

    <span class="SItr">@assert</span>(array[<span class="SNum">2</span>] == <span class="SNum">30</span>)
    slice[<span class="SNum">0</span>] = <span class="SNum">314</span>                                 <span class="SCmt">// Modify the original array via the slice</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">2</span>] == <span class="SNum">314</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing Strings </h4>
<p>For strings, the slice must be <span class="code-inline">const</span> because strings are immutable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> strSlice: <span class="SKwd">const</span> [..] <span class="STpe">u8</span> = <span class="SItr">@mkslice</span>(<span class="SItr">@dataof</span>(str), <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(strSlice[<span class="SNum">0</span>] == <span class="SStr">`s`</span>)
    <span class="SItr">@assert</span>(strSlice[<span class="SNum">1</span>] == <span class="SStr">`t`</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing with the <span class="code-inline">..</span> Operator </h4>
<p>You can create a slice using the <span class="code-inline">..</span> operator instead of <span class="code-inline">@mkslice</span>. For instance,  you can slice a string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>

    <span class="SCmt">// Create a slice starting at byte 0 and ending at byte 3.</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">1.</span>.<span class="SNum">3</span>]

    <span class="SItr">@assert</span>(slice == <span class="SStr">"tri"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Inclusive and Exclusive Slicing </h4>
<p>By default, the upper limit in a slice is <b>inclusive</b>. To exclude the upper limit, use <span class="code-inline">..&lt;</span>  instead of <span class="code-inline">..</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str   = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">1.</span>.&lt;<span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice == <span class="SStr">"tr"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing to the End </h4>
<p>You can omit the upper bound to create a slice that extends to the end of the sequence. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str   = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">2.</span>.]
    <span class="SItr">@assert</span>(slice == <span class="SStr">"ring"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing from the Start </h4>
<p>To create a slice from the start (index 0), you can omit the lower bound. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str    = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice  = str[..<span class="SNum">2</span>]     <span class="SCmt">// Index 2 is included</span>
    <span class="SItr">@assert</span>(slice == <span class="SStr">"str"</span>)

    <span class="SKwd">let</span> slice1 = str[..&lt;<span class="SNum">2</span>]    <span class="SCmt">// Index 2 is excluded</span>
    <span class="SItr">@assert</span>(slice1 == <span class="SStr">"st"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing Arrays </h4>
<p>Arrays can also be sliced similarly to strings. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> arr   = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> slice = arr[<span class="SNum">2.</span>.<span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)

    <span class="SCmt">// Create a slice for the entire array.</span>
    <span class="SKwd">let</span> slice1 = arr[..]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice1) == <span class="SItr">@countof</span>(arr))
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing a Slice </h4>
<p>It is possible to create a slice from another slice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> arr    = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> slice1 = arr[<span class="SNum">1.</span>.<span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice1[<span class="SNum">0</span>] == <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(slice1[<span class="SNum">1</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice1[<span class="SNum">2</span>] == <span class="SNum">40</span>)

    <span class="SKwd">let</span> slice2 = slice1[<span class="SNum">1.</span>.<span class="SNum">2</span>]
    <span class="SItr">@assert</span>(slice2[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice2[<span class="SNum">1</span>] == <span class="SNum">40</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Transforming a Pointer to a Slice </h4>
<p>You can transform a pointer into a slice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr   = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> ptr   = &arr[<span class="SNum">2</span>]
    <span class="SKwd">let</span> slice = ptr[<span class="SNum">0.</span>.<span class="SNum">1</span>]
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)
}</span></div>

<h3 id="_004_000_data_structures_swg__004_003_tuple_swg">Tuple</h3><h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Tuples in Swag </h4>
<p>In Swag, a tuple represents an anonymous structure, sometimes referred to as a struct literal. Tuples are particularly useful for grouping together elements of various types without requiring a formally defined structure. The syntax for creating a tuple involves enclosing the elements within curly braces <span class="code-inline">{}</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple1 = {<span class="SNum">2</span>, <span class="SNum">2</span>}                    <span class="SCmt">// A tuple containing two integer elements.</span>
    <span class="SKwd">let</span> tuple2 = {<span class="SStr">"string"</span>, <span class="SNum">2</span>, <span class="SKwd">true</span>}       <span class="SCmt">// A tuple with a string, an integer, and a boolean element.</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Accessing Tuple Values </h4>
<p>By default, the values in a tuple are accessed using automatically generated field names. These names follow the pattern <span class="code-inline">itemX</span>, where <span class="code-inline">X</span> represents the zero-based index of the element within the tuple. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple = {<span class="SStr">"string"</span>, <span class="SNum">2</span>, <span class="SKwd">true</span>}        <span class="SCmt">// A tuple containing three elements.</span>
    <span class="SItr">@assert</span>(tuple.item0 == <span class="SStr">"string"</span>)       <span class="SCmt">// Accesses the first element (index 0).</span>
    <span class="SItr">@assert</span>(tuple.item1 == <span class="SNum">2</span>)              <span class="SCmt">// Accesses the second element (index 1).</span>
    <span class="SItr">@assert</span>(tuple.item2 == <span class="SKwd">true</span>)           <span class="SCmt">// Accesses the third element (index 2).</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Named Fields in Tuples </h4>
<p>In Swag, it is possible to assign custom names to tuple fields, enhancing the readability and maintainability of the code. When custom names are assigned, the default <span class="code-inline">itemX</span> access pattern remains available, offering flexibility in how you interact with tuple elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}           <span class="SCmt">// A tuple with named fields 'x' and 'y'.</span>
    <span class="SItr">@assert</span>(tuple.x == <span class="SNum">1.0</span>)                <span class="SCmt">// Accesses the value of 'x' via its custom name.</span>
    <span class="SItr">@assert</span>(tuple.item0 == <span class="SNum">1.0</span>)            <span class="SCmt">// Accesses the value of 'x' using the default 'item0'.</span>
    <span class="SItr">@assert</span>(tuple.y == <span class="SNum">2.0</span>)                <span class="SCmt">// Accesses the value of 'y' via its custom name.</span>
    <span class="SItr">@assert</span>(tuple.item1 == <span class="SNum">2.0</span>)            <span class="SCmt">// Accesses the value of 'y' using the default 'item1'.</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Automatic Naming of Tuple Fields </h4>
<p>When creating a tuple using variables, Swag automatically assigns the field names based on the variable names, unless explicitly overridden. This feature simplifies tuple creation by directly reflecting variable names within the tuple structure. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">555</span>
    <span class="SKwd">let</span> y = <span class="SNum">666</span>
    <span class="SKwd">let</span> t = {x, y}                         <span class="SCmt">// Tuple fields are automatically named 'x' and 'y'.</span>
    <span class="SItr">@assert</span>(t.x == <span class="SNum">555</span>)                    <span class="SCmt">// Accesses the value of 'x' using the variable name.</span>
    <span class="SItr">@assert</span>(t.item0 == t.x)                <span class="SCmt">// 'item0' corresponds to the variable 'x'.</span>
    <span class="SItr">@assert</span>(t.y == <span class="SNum">666</span>)                    <span class="SCmt">// Accesses the value of 'y' using the variable name.</span>
    <span class="SItr">@assert</span>(t.item1 == t.y)                <span class="SCmt">// 'item1' corresponds to the variable 'y'.</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Tuple Assignment and Compatibility </h4>
<p>Swag provides flexibility in assigning tuples to each other, even if the field names differ. As long as the field types are compatible, tuples can be assigned across different structures, facilitating easy data transfer and manipulation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: { a: <span class="STpe">s32</span>, b: <span class="STpe">s32</span> }              <span class="SCmt">// A tuple with fields 'a' and 'b'.</span>
    <span class="SKwd">var</span> y: { c: <span class="STpe">s32</span>, d: <span class="STpe">s32</span> }              <span class="SCmt">// A tuple with fields 'c' and 'd'.</span>

    y = {<span class="SNum">1</span>, <span class="SNum">2</span>}                             <span class="SCmt">// Initializes 'y' with integer values.</span>
    x = y                                  <span class="SCmt">// Assigns 'y' to 'x', field names do not need to match.</span>
    <span class="SItr">@assert</span>(x.a == <span class="SNum">1</span>)                      <span class="SCmt">// 'x.a' acquires the value of 'y.c'.</span>
    <span class="SItr">@assert</span>(x.b == <span class="SNum">2</span>)                      <span class="SCmt">// 'x.b' acquires the value of 'y.d'.</span>

    <span class="SCmt">// Although 'x' and 'y' have different field names, their types are not identical.</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(x) != <span class="SItr">#typeof</span>(y)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Tuple Unpacking </h4>
<p>Swag allows tuples to be unpacked, meaning their individual elements can be extracted into separate variables. This feature is particularly useful for disaggregating a tuple's data for specific operations or further processing. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> tuple1 = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}          <span class="SCmt">// A tuple with fields 'x' and 'y'.</span>

    <span class="SCmt">// Unpacking the tuple: 'value0' gets the value of 'x', and 'value1' gets the value of 'y'.</span>
    <span class="SKwd">let</span> (value0, value1) = tuple1
    <span class="SItr">@assert</span>(value0 == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(value1 == <span class="SNum">2.0</span>)

    <span class="SKwd">var</span> tuple2 = {<span class="SStr">"name"</span>, <span class="SKwd">true</span>}            <span class="SCmt">// A tuple containing a string and a boolean.</span>
    <span class="SKwd">let</span> (name, value) = tuple2             <span class="SCmt">// Unpacking into 'name' and 'value'.</span>
    <span class="SItr">@assert</span>(name == <span class="SStr">"name"</span>)
    <span class="SItr">@assert</span>(value == <span class="SKwd">true</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Ignoring Tuple Fields During Unpacking </h4>
<p>When unpacking a tuple, you can choose to ignore specific fields using the <span class="code-inline">?</span> placeholder. This is particularly useful when only certain elements of a tuple are needed, allowing you to disregard others efficiently. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> tuple1 = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}          <span class="SCmt">// A tuple with fields 'x' and 'y'.</span>
    <span class="SKwd">let</span> (x, ?) = tuple1                    <span class="SCmt">// Unpacks 'x' and ignores the second field.</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">1.0</span>)
    <span class="SKwd">let</span> (?, y) = tuple1                    <span class="SCmt">// Ignores the first field and unpacks 'y'.</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">2.0</span>)
}</span></div>

<h3 id="_004_000_data_structures_swg__004_004_enum_swg">Enum</h3><h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enums in Swag </h4>
<p>Enums in Swag allow you to define a set of named values. Unlike C/C++, enum values in Swag can end with <span class="code-inline">;</span>, <span class="code-inline">,</span>, or an end of line (eol). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values0</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
    }

    <span class="SKwd">enum</span> <span class="SCst">Values1</span>
    {
        <span class="SCst">A</span>,
        <span class="SCst">B</span>,
    }

    <span class="SCmt">// The last comma is not necessary</span>
    <span class="SKwd">enum</span> <span class="SCst">Values2</span>
    {
        <span class="SCst">A</span>,
        <span class="SCst">B</span>
    }

    <span class="SKwd">enum</span> <span class="SCst">Values3</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">enum</span> <span class="SCst">Values4</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }
    <span class="SKwd">enum</span> <span class="SCst">Values5</span> { <span class="SCst">A</span>; <span class="SCst">B</span> }
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enum Underlying Type </h4>
<p>By default, an enum in Swag is of type <span class="code-inline">s32</span>, meaning the underlying storage for each value is a 32-bit signed integer. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">let</span> type = <span class="SItr">#typeof</span>(<span class="SCst">Values</span>)

    <span class="SCmt">// 'type' here is a 'typeinfo' dedicated to the enum type.</span>
    <span class="SCmt">// In that case, 'type.rawType' represents the enum's underlying type.</span>
    <span class="SItr">@assert</span>(type.rawType == <span class="STpe">s32</span>)
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SCst">Values</span>) == <span class="SCst">Values</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Custom Enum Underlying Type </h4>
<p>You can specify a custom underlying type for an enum by appending it after the enum name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values1</span>: <span class="STpe">s64</span> <span class="SCmt">// Force the underlying type to be 's64' instead of 's32'</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
        <span class="SCst">C</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SCst">Values1</span>).rawType == <span class="STpe">s64</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(<span class="SCst">Values1</span>.<span class="SCst">A</span>) == <span class="SCst">Values1</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Default and Custom Enum Values </h4>
<p>Enum values, if not explicitly specified, start at 0 and increase by 1 for each subsequent value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">s64</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
        <span class="SCst">C</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">2</span>
}</span></div>
<p>You can specify custom values for each enum element. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">s64</span>
    {
        <span class="SCst">A</span> = <span class="SNum">10</span>
        <span class="SCst">B</span> = <span class="SNum">20</span>
        <span class="SCst">C</span> = <span class="SNum">30</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">10</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">20</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">30</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Incremental Enum Values </h4>
<p>If you omit a value after assigning a specific one, it will be assigned the previous value plus 1. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">u32</span>
    {
        <span class="SCst">A</span> = <span class="SNum">10</span>
        <span class="SCst">B</span> <span class="SCmt">// Will be 11</span>
        <span class="SCst">C</span> <span class="SCmt">// Will be 12</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">10</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">11</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">12</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Non-Integer Enum Values </h4>
<p>For non-integer types, you <b>must</b> specify the values explicitly, as they cannot be deduced automatically. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value1</span>: <span class="STpe">string</span>
    {
        <span class="SCst">A</span> = <span class="SStr">"string 1"</span>
        <span class="SCst">B</span> = <span class="SStr">"string 2"</span>
        <span class="SCst">C</span> = <span class="SStr">"string 3"</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value1</span>.<span class="SCst">A</span> == <span class="SStr">"string 1"</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value1</span>.<span class="SCst">B</span> == <span class="SStr">"string 2"</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value1</span>.<span class="SCst">C</span> == <span class="SStr">"string 3"</span>

    <span class="SKwd">enum</span> <span class="SCst">Value2</span>: <span class="STpe">f32</span>
    {
        <span class="SCst">A</span> = <span class="SNum">1.0</span>
        <span class="SCst">B</span> = <span class="SNum">3.14</span>
        <span class="SCst">C</span> = <span class="SNum">6.0</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value2</span>.<span class="SCst">A</span> == <span class="SNum">1.0</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value2</span>.<span class="SCst">B</span> == <span class="SNum">3.14</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value2</span>.<span class="SCst">C</span> == <span class="SNum">6.0</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Counting Enum Values </h4>
<p><span class="code-inline">@countof</span> can be used to return the number of values defined in an enum. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">string</span>
    {
        <span class="SCst">A</span> = <span class="SStr">"string 1"</span>
        <span class="SCst">B</span> = <span class="SStr">"string 2"</span>
        <span class="SCst">C</span> = <span class="SStr">"string 3"</span>
    }

    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(<span class="SCst">Value</span>) == <span class="SNum">3</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(<span class="SCst">Value</span>) == <span class="SNum">3</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Using <span class="code-inline">using</span> with Enums </h4>
<p>You can use the <span class="code-inline">using</span> keyword to make enum values accessible without needing to specify the enum name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
        <span class="SCst">C</span>
    }

    <span class="SKwd">using</span> <span class="SCst">Value</span>

    <span class="SCmt">// No need to prefix with 'Value.'</span>
    <span class="SItr">@assert</span>(<span class="SCst">A</span> == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(<span class="SCst">B</span> == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">C</span> == <span class="SNum">2</span>)

    <span class="SCmt">// The normal form is still possible</span>
    <span class="SItr">@assert</span>(<span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(<span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enums as Flags </h4>
<p>Enums can be used as flags if declared with the <span class="code-inline">#[Swag.EnumFlags]</span> attribute. For this, the enum's underlying type should be <span class="code-inline">u8</span>, <span class="code-inline">u16</span>, <span class="code-inline">u32</span>, or <span class="code-inline">u64</span>. By default, enums declared as flags start at 1 (not 0), and each value is typically a power of 2. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumFlags]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyFlags</span>: <span class="STpe">u8</span>
    {
        <span class="SCst">A</span>   <span class="SCmt">// First value is 1</span>
        <span class="SCst">B</span>   <span class="SCmt">// Value is 2</span>
        <span class="SCst">C</span>   <span class="SCmt">// Value is 4</span>
        <span class="SCst">D</span>   <span class="SCmt">// Value is 8</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">MyFlags</span>.<span class="SCst">A</span> == <span class="SNum">0b00000001</span>
    <span class="SCmp">#assert</span> <span class="SCst">MyFlags</span>.<span class="SCst">B</span> == <span class="SNum">0b00000010</span>
    <span class="SCmp">#assert</span> <span class="SCst">MyFlags</span>.<span class="SCst">C</span> == <span class="SNum">0b00000100</span>
    <span class="SCmp">#assert</span> <span class="SCst">MyFlags</span>.<span class="SCst">D</span> == <span class="SNum">0b00001000</span>

    <span class="SKwd">let</span> value = <span class="SCst">MyFlags</span>.<span class="SCst">B</span> | <span class="SCst">MyFlags</span>.<span class="SCst">C</span>
    <span class="SItr">@assert</span>(value == <span class="SNum">0b00000110</span>)
    <span class="SItr">@assert</span>(value & <span class="SCst">MyFlags</span>.<span class="SCst">B</span> == <span class="SCst">MyFlags</span>.<span class="SCst">B</span>)
    <span class="SItr">@assert</span>(value & <span class="SCst">MyFlags</span>.<span class="SCst">C</span> == <span class="SCst">MyFlags</span>.<span class="SCst">C</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enums with Arrays </h4>
<p>You can define an enum where each value is associated with a const static array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="SKwd">const</span> [<span class="SNum">2</span>] <span class="STpe">s32</span>
    {
        <span class="SCst">A</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>]
        <span class="SCst">B</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>]
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span>[<span class="SNum">1</span>] == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span>[<span class="SNum">0</span>] == <span class="SNum">10</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span>[<span class="SNum">1</span>] == <span class="SNum">20</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enums with Slices </h4>
<p>Similarly, you can define an enum where each value is associated with a const slice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="SKwd">const</span> [..] <span class="STpe">s32</span>
    {
        <span class="SCst">A</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>]
        <span class="SCst">B</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    }

    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(<span class="SCst">Value</span>.<span class="SCst">A</span>) == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(<span class="SCst">Value</span>.<span class="SCst">B</span>) == <span class="SNum">4</span>

    <span class="SKwd">let</span> x = <span class="SCst">Value</span>.<span class="SCst">A</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SKwd">let</span> y = <span class="SCst">Value</span>.<span class="SCst">B</span>
    <span class="SItr">@assert</span>(y[<span class="SNum">0</span>] == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(y[<span class="SNum">1</span>] == <span class="SNum">20</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Nested Enums </h4>
<p>Enums can be nested within other enums using the <span class="code-inline">using</span> keyword. Both enums must share the same underlying type. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">enum</span> <span class="SCst">BasicErrors</span>
{
    <span class="SCst">FailedToLoad</span>
    <span class="SCst">FailedToSave</span>
}

<span class="SCmt">// The enum 'BasicErrors' is nested inside 'MyErrors'</span>
<span class="SKwd">enum</span> <span class="SCst">MyErrors</span>
{
    <span class="SKwd">using</span> <span class="SCst">BasicErrors</span>
    <span class="SCst">NotFound</span> = <span class="SNum">100</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Accessing Nested Enums </h4>
<p>To access a value inside a nested enum, use the enum name (a scope is created). </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">MyError0</span> = <span class="SCst">MyErrors</span>.<span class="SCst">BasicErrors</span>.<span class="SCst">FailedToSave</span></span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Automatic Cast with Nested Enums </h4>
<p>An <b>automatic cast</b> occurs when converting a nested enum to its parent enum. For example, a value of type <span class="code-inline">BasicErrors</span> can be passed to a parameter of type <span class="code-inline">MyErrors</span> because <span class="code-inline">MyErrors</span> includes <span class="code-inline">BasicErrors</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">E0</span>: <span class="SCst">MyErrors</span>    = <span class="SCst">MyErrors</span>.<span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>
    <span class="SKwd">const</span> <span class="SCst">E1</span>: <span class="SCst">BasicErrors</span> = <span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>

    <span class="SKwd">func</span> <span class="SFct">toto</span>(err: <span class="SCst">MyErrors</span>)
    {
        <span class="SItr">@assert</span>(err == <span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>)
        <span class="SItr">@assert</span>(err == <span class="SCst">MyErrors</span>.<span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>)
    }

    <span class="SFct">toto</span>(<span class="SCst">E0</span>)
    <span class="SFct">toto</span>(<span class="SCst">E1</span>) <span class="SCmt">// Automatic cast from 'BasicErrors' to 'MyErrors'</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Specific Attributes for Enums </h4>
<p>You can use <span class="code-inline">#[Swag.EnumIndex]</span> to enable an enum value to be used directly as an index without needing to cast it. The underlying enum type must be an integer type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumIndex]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyIndex</span> { <span class="SCst">First</span>, <span class="SCst">Second</span>, <span class="SCst">Third</span> }

    <span class="SKwd">const</span> <span class="SCst">Array</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SKwd">const</span> <span class="SCst">Valu</span> = <span class="SCst">Array</span>[<span class="SCst">MyIndex</span>.<span class="SCst">First</span>]   <span class="SCmt">// No need to cast 'MyIndex.First'</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Preventing Duplicate Enum Values </h4>
<p>You can use <span class="code-inline">#[Swag.NoDuplicate]</span> to prevent duplicated values inside an enum. If the compiler detects a value defined more than once, it will raise an error. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.NoDuplicate]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyEnum</span>
    {
        <span class="SCst">Val0</span> = <span class="SNum">0</span>
        <span class="SCmt">//Val1 = 0      // Will raise an error because '0' is already defined</span>
    }
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enum Type Inference </h4>
<p>Enums in Swag allow type inference, so you can often omit the enum type when assigning a value. </p>
<h5 id="_004_000_data_structures_swg__004_004_enum_swg">Type Inference in Assignments </h5>
<p>The enum type is not necessary in the assignment expression when declaring a variable, as it can be deduced. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }

    <span class="SCmt">// The explicit form</span>
    <span class="SKwd">let</span> x: <span class="SCst">Values</span> = <span class="SCst">Values</span>.<span class="SCst">A</span>

    <span class="SCmt">// The inferred form</span>
    <span class="SKwd">let</span> y: <span class="SCst">Values</span> = <span class="SCst">A</span>

    <span class="SItr">@assert</span>(x == y)
}</span></div>
<h5 id="_004_000_data_structures_swg__004_004_enum_swg">Type Inference in <span class="code-inline">switch</span> Statements </h5>
<p>The enum type is not necessary in a <span class="code-inline">case</span> expression of a <span class="code-inline">switch</span> block, as it is inferred from the switch expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }
    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span>

    <span class="SCmt">// The explicit form</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SCst">Values</span>.<span class="SCst">A</span>: <span class="SLgc">break</span>
    <span class="SLgc">case</span> <span class="SCst">Values</span>.<span class="SCst">B</span>: <span class="SLgc">break</span>
    }

    <span class="SCmt">// The simplified form</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SCst">A</span>: <span class="SLgc">break</span>
    <span class="SLgc">case</span> <span class="SCst">B</span>: <span class="SLgc">break</span>
    }
}</span></div>
<h5 id="_004_000_data_structures_swg__004_004_enum_swg">Simplified Enum Syntax </h5>
<p>In expressions where the enum type can be deduced, you can omit the enum name and use the <span class="code-inline">.Value</span> syntax. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }

    <span class="SCmt">// The explicit form</span>
    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span>

    <span class="SCmt">// The simplified form, since 'Values' can be inferred from 'x'</span>
    <span class="SItr">@assert</span>(x == .<span class="SCst">A</span>)
    <span class="SItr">@assert</span>(x != .<span class="SCst">B</span>)
}</span></div>
<h5 id="_004_000_data_structures_swg__004_004_enum_swg">Simplified Syntax for Enum Flags </h5>
<p>This also works for enums used as flags. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumFlags]</span>
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }

    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span> | <span class="SCst">Values</span>.<span class="SCst">B</span>
    <span class="SItr">@assert</span>((x & .<span class="SCst">A</span>) <span class="SLgc">and</span> (x & .<span class="SCst">B</span>))
}</span></div>
<h5 id="_004_000_data_structures_swg__004_004_enum_swg">Simplified Enum Syntax in Function Calls </h5>
<p>In most cases, the simplified <span class="code-inline">.Value</span> syntax also works when passing enum values to functions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }
    <span class="SKwd">func</span> <span class="SFct">toto</span>(v1, v2: <span class="SCst">Values</span>) {}
    <span class="SFct">toto</span>(.<span class="SCst">A</span>, .<span class="SCst">B</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Visiting Enum Values </h4>
<p>Using type reflection, Swag allows you to iterate over all the values of an enum. This feature is particularly useful when you need to perform operations across all enum values or when you want to dynamically generate behavior based on the values of an enum. </p>
<p>The two primary mechanisms for iterating over enum values are the <span class="code-inline">for</span> construct and the <span class="code-inline">foreach</span> statement. </p>
<h5 id="_004_000_data_structures_swg__004_004_enum_swg">Looping Over Enum Values </h5>
<p>The <span class="code-inline">for</span> construct allows you to iterate over all values in an enum. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }                  <span class="SCmt">// Define a simple enum with three values: R, G, and B</span>

    <span class="SCmt">// Counting Enum Values</span>
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> idx <span class="SLgc">in</span> <span class="SCst">RGB</span>:                       <span class="SCmt">// Iterate over all enum values using 'for'</span>
        cpt += <span class="SNum">1</span>                          <span class="SCmt">// Increment counter for each value</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)                     <span class="SCmt">// Assert that the enum has exactly 3 values</span>

    <span class="SCmt">// Note that '@countof(RGB)' will give you the exact same result</span>
    <span class="SItr">@assert</span>(cpt == <span class="SItr">@countof</span>(<span class="SCst">RGB</span>))
}</span></div>
<p>The <span class="code-inline">for idx in RGB:</span> statement is a powerful construct that allows you to iterate over all values in the <span class="code-inline">RGB</span> enum. During each iteration, <span class="code-inline">idx</span> holds the current enum value, which can be used within the for body. In the example above, the for simply counts the number of values in the enum, asserting that the total is 3. </p>
<p>This method is useful when you need to apply the same operation to each enum value, such as populating a list, checking conditions, or performing calculations. </p>
<h5 id="_004_000_data_structures_swg__004_004_enum_swg">Visiting Enum Values </h5>
<p>The <span class="code-inline">foreach</span> statement offers a more structured way to iterate over an enum and perform specific actions based on the current enum value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }                  <span class="SCmt">// Define a simple enum with three values: R, G, and B</span>

    <span class="SCmt">// Performing Actions Based on Enum Values</span>
    <span class="SLgc">foreach</span> val <span class="SLgc">in</span> <span class="SCst">RGB</span>                    <span class="SCmt">// Use 'foreach' to iterate over each value in the enum</span>
    {
        <span class="SLgc">switch</span> val                        <span class="SCmt">// A switch statement to perform actions based on the enum value</span>
        {
        <span class="SLgc">case</span> <span class="SCst">R</span>:                           <span class="SCmt">// Case for the value 'R'</span>
            <span class="SCmt">// Perform action for 'R'</span>
            <span class="SLgc">break</span>
        <span class="SLgc">case</span> <span class="SCst">G</span>:                           <span class="SCmt">// Case for the value 'G'</span>
            <span class="SCmt">// Perform action for 'G'</span>
            <span class="SLgc">break</span>
        <span class="SLgc">case</span> <span class="SCst">B</span>:                           <span class="SCmt">// Case for the value 'B'</span>
            <span class="SCmt">// Perform action for 'B'</span>
            <span class="SLgc">break</span>
        <span class="SLgc">default</span>:                          
            <span class="SCmt">// This should never be reached as we are covering all enum cases</span>
            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
        }
    }
}</span></div>
<p>The <span class="code-inline">foreach val in RGB</span> statement offers a more structured way to iterate over an enum. Each iteration provides the current enum value in the <span class="code-inline">val</span> variable, which can then be used in a <span class="code-inline">switch</span> statement (or other logic) to perform specific actions based on the value. </p>
<p>In the provided example, the <span class="code-inline">switch</span> statement checks the value of <span class="code-inline">val</span> and executes different blocks of code depending on whether <span class="code-inline">val</span> is <span class="code-inline">R</span>, <span class="code-inline">G</span>, or <span class="code-inline">B</span>. This is particularly useful when you need to perform different actions based on the specific value of the enum, rather than treating all values the same. </p>

<h3 id="_004_000_data_structures_swg__004_005_impl_swg">Impl</h3><h4 id="_004_000_data_structures_swg__004_005_impl_swg">Utilizing the <span class="code-inline">impl</span> Keyword with Enums in Swag </h4>
<p>In Swag, the <span class="code-inline">impl</span> keyword allows you to define methods and functions within the scope of an enum.  This is particularly useful for associating specific behaviors directly with the enum values.  The <span class="code-inline">self</span> keyword within these methods refers to the current enum instance, providing a clean  and organized way to encapsulate logic related to the enum. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Define an enum RGB with three possible values</span>
<span class="SKwd">enum</span> <span class="SCst">RGB</span>
{
    <span class="SCst">R</span>   <span class="SCmt">// Represents the Red color</span>
    <span class="SCst">G</span>   <span class="SCmt">// Represents the Green color</span>
    <span class="SCst">B</span>   <span class="SCmt">// Represents the Blue color</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_005_impl_swg">Implementing Methods for an Enum </h4>
<p>In the following example, we utilize the <span class="code-inline">impl enum</span> syntax to define methods for the <span class="code-inline">RGB</span> enum.  This syntax allows us to extend the functionality of the enum by associating methods with it.  The methods we define will operate on the enum's values, providing a clear and structured approach  to handling logic related to these values. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SKwd">enum</span> <span class="SCst">RGB</span>
{
    <span class="SCmt">// Method to check if the current enum value is `R`.</span>
    <span class="SKwd">func</span> <span class="SFct">isRed</span>(<span class="STpe">self</span>) =&gt; <span class="STpe">self</span> == <span class="SCst">R</span>                        

    <span class="SCmt">// Method to check if the current enum value is either `R` or `B`.</span>
    <span class="SKwd">func</span> <span class="SFct">isRedOrBlue</span>(<span class="STpe">self</span>) =&gt; <span class="STpe">self</span> == <span class="SCst">R</span> <span class="SLgc">or</span> <span class="STpe">self</span> == <span class="SCst">B</span>     
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Testing the `RGB` enum methods</span>

    <span class="SCmt">// Verify if `RGB.R` is recognized as red</span>
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SFct">isRed</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span>))                               

    <span class="SCmt">// Verify if `RGB.B` is recognized as either red or blue</span>
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SFct">isRedOrBlue</span>(<span class="SCst">RGB</span>.<span class="SCst">B</span>))                          
}</span></div>
<h4 id="_004_000_data_structures_swg__004_005_impl_swg">Applying the <span class="code-inline">using</span> Keyword with Enum Methods </h4>
<p>The <span class="code-inline">using</span> keyword simplifies method calls by allowing you to omit the enum type when invoking  methods. This results in more concise and readable code, especially when the enum type is used  frequently within a block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">using</span> <span class="SCst">RGB</span>

    <span class="SCmt">// Test the method without specifying the enum type</span>
    <span class="SItr">@assert</span>(<span class="SFct">isRedOrBlue</span>(<span class="SCst">R</span>))                                 
    <span class="SItr">@assert</span>(<span class="SFct">isRedOrBlue</span>(<span class="SCst">B</span>))      
}</span></div>
<h4 id="_004_000_data_structures_swg__004_005_impl_swg">Introduction to Uniform Function Call Syntax (UFCS) </h4>
<p>Uniform Function Call Syntax (UFCS) in Swag enhances code readability by allowing methods to be  called directly on enum values. This feature leads to more intuitive and clean code, particularly  when working with enums. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span> 
{
    <span class="SKwd">using</span> <span class="SCst">RGB</span>
    
    <span class="SItr">@assert</span>(<span class="SCst">R</span>.<span class="SFct">isRedOrBlue</span>())                                 

    <span class="SCmt">// Verify that `RGB.G` is not recognized as either red or blue</span>
    <span class="SItr">@assert</span>(!<span class="SCst">RGB</span>.<span class="SCst">G</span>.<span class="SFct">isRedOrBlue</span>())                            
}</span></div>

<h3 id="_004_000_data_structures_swg__004_006_union_swg">Union</h3><h4 id="_004_000_data_structures_swg__004_006_union_swg">Understanding <span class="code-inline">union</span> in Swag </h4>
<p>A <span class="code-inline">union</span> is a specialized type of struct where all fields share the same memory location, meaning  they all start at the same offset (0). This allows multiple fields to occupy the same space in memory,  making it possible to store different types of data in the same memory space at different times.  This feature is particularly useful for memory optimization in scenarios where only one of the  fields needs to be used at any given moment. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Define a union with three fields: x, y, and z, all of type f32.</span>
    <span class="SKwd">union</span> <span class="SCst">MyUnion</span>
    {
        x, y, z: <span class="STpe">f32</span>                                              <span class="SCmt">// Each field shares the same memory location</span>
    }

    <span class="SCmt">// Initialize the union, setting the value of the 'x' field to 666.</span>
    <span class="SKwd">var</span> v = <span class="SCst">MyUnion</span>{x: <span class="SNum">666</span>}                                       <span class="SCmt">// 'x' is set, and by extension, 'y' and 'z' as well</span>

    <span class="SCmt">// Since all fields share the same memory, setting 'x' also sets 'y' and 'z' to the same value.</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)                                           <span class="SCmt">// Assert that 'y' equals 666</span>
    <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)                                           <span class="SCmt">// Assert that 'z' equals 666</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_006_union_swg">Explanation of Union Behavior </h4>
<p>In this example, the <span class="code-inline">union</span> type allows you to define multiple fields (<span class="code-inline">x</span>, <span class="code-inline">y</span>, <span class="code-inline">z</span>), all of which  occupy the same memory location. Because these fields overlap in memory, changing the value of one  field automatically changes the others. This behavior is useful in situations where you need to  store and access different data types within the same memory space, albeit not simultaneously.  Here, <span class="code-inline">x</span>, <span class="code-inline">y</span>, and <span class="code-inline">z</span> are all of type <span class="code-inline">f32</span>, so when <span class="code-inline">x</span> is set to 666, both <span class="code-inline">y</span> and <span class="code-inline">z</span> reflect  this change, illustrating the shared memory concept inherent in unions. </p>

<h3 id="_004_000_data_structures_swg__004_007_pointers_swg">Pointers</h3><h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Single Value Pointers </h4>
<p>A pointer to a <b>single element</b> is declared using the <span class="code-inline">*</span> symbol. This allows you to create a pointer that holds the address of one specific instance of a data type. Pointers can be used to reference any type of data, allowing for efficient memory management and manipulation of variables. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr1: *<span class="STpe">u8</span>           <span class="SCmt">// This is a pointer to a single 'u8' value</span>
    <span class="SKwd">var</span> ptr2: **<span class="STpe">u8</span>          <span class="SCmt">// This is a pointer to another pointer, which in turn points to a single 'u8' value</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Null Pointers </h4>
<p>In Swag, a pointer can be <span class="code-inline">null</span>, indicating that it does not point to any valid memory location. A null pointer is commonly used to signify that the pointer is uninitialized or that it intentionally points to "nothing". Checking for null pointers before dereferencing is a good practice to avoid runtime errors. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr1: *<span class="STpe">u8</span>                  <span class="SCmt">// Declaring a pointer to 'u8' without initialization</span>
    <span class="SItr">@assert</span>(ptr1 == <span class="SKwd">null</span>)          <span class="SCmt">// By default, the pointer is null, indicating it doesn't point to any valid memory location</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Taking the Address of a Variable </h4>
<p>You can obtain the address of a variable using the <span class="code-inline">&</span> operator. This operation returns a pointer to the variable, which can then be stored and used to access or modify the variable's value indirectly through its memory address. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = <span class="SNum">1</span>                          <span class="SCmt">// Declare an integer variable</span>
    <span class="SKwd">let</span> ptr = &arr                        <span class="SCmt">// Take the address of the variable 'arr'</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr) == *<span class="STpe">s32</span>)         <span class="SCmt">// The type of 'ptr' is a pointer to 's32', the type of 'arr'</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Dereferencing a Pointer </h4>
<p>Dereferencing a pointer involves accessing the value stored at the memory location that the pointer refers to. In Swag, you use the <span class="code-inline">dref</span> intrinsic for dereferencing, which allows you to retrieve the actual data stored at the pointer's address. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = <span class="SNum">42</span>                          <span class="SCmt">// Declare an integer variable with value 42</span>
    <span class="SKwd">let</span> ptr = &arr                        <span class="SCmt">// Take the address of 'arr'</span>
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">42</span>)               <span class="SCmt">// Dereference the pointer to access the value of 'arr', which should be 42</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Const Pointers </h4>
<p>A <span class="code-inline">const</span> pointer in Swag refers to a pointer that cannot change the memory location it points to. However, the data at that memory location can still be mutable. Const pointers are useful when you want to ensure that a pointer always refers to the same memory address throughout its lifetime. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str  = <span class="SStr">"string"</span>                   <span class="SCmt">// Declare a string variable</span>
    <span class="SKwd">let</span> ptr: <span class="SKwd">const</span> *<span class="STpe">u8</span> = <span class="SItr">@dataof</span>(str)     <span class="SCmt">// A const pointer to a 'u8' value</span>
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SStr">`s`</span>)              <span class="SCmt">// Dereferencing the pointer to get the first character of the string</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Combining <span class="code-inline">const</span> with Pointers </h4>
<p>Swag allows you to combine <span class="code-inline">const</span> with pointers in different ways, depending on the level of immutability you need. You can create a pointer that is constant itself, a pointer to constant data, or both. The choice depends on whether you want to restrict the pointer from changing its target or the data being pointed to, or both. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr:  *<span class="SKwd">const</span> *<span class="STpe">u8</span>              <span class="SCmt">// A pointer to a const pointer to 'u8'</span>
    <span class="SKwd">var</span> ptr1: <span class="SKwd">const</span> *<span class="SKwd">const</span> *<span class="STpe">u8</span>        <span class="SCmt">// A const pointer to a const pointer to 'u8'</span>
    <span class="SKwd">var</span> ptr2: <span class="SKwd">const</span> **<span class="STpe">u8</span>              <span class="SCmt">// A const pointer to a normal pointer to 'u8'</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Multiple Values Pointers </h4>
<p>For cases where you need <b>pointer arithmetic</b> and want a pointer to <b>multiple values</b> (like an array or a memory block), you declare your pointer with <span class="code-inline">^</span> instead of <span class="code-inline">*</span>. This type of pointer is especially useful for iterating over a sequence of elements stored in contiguous memory locations. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Safety("sanity", false)]</span>
<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr: ^<span class="STpe">u8</span>                        <span class="SCmt">// Declaring a pointer to a memory block of 'u8' values</span>

    <span class="SCmt">// Pointer arithmetic allows you to navigate through the memory block by modifying the pointer's address</span>
    ptr = ptr - <span class="SNum">1</span>                       <span class="SCmt">// Move the pointer back by one 'u8'</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Pointer Arithmetic and Array Elements </h4>
<p>When you take the address of an array element, the resulting pointer is treated as pointing to multiple elements, allowing for pointer arithmetic. This enables operations like incrementing or decrementing the pointer, which is useful for traversing arrays. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: [<span class="SNum">4</span>] <span class="STpe">s32</span>                      <span class="SCmt">// Declare an array of 4 's32' elements</span>
    <span class="SKwd">var</span> ptr = &x[<span class="SNum">1</span>]                     <span class="SCmt">// Take the address of the second element</span>

    <span class="SCmt">// Pointer arithmetic is now enabled because 'ptr' is treated as pointing to multiple values</span>
    ptr = ptr - <span class="SNum">1</span>                       <span class="SCmt">// Move the pointer back to the first element</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(ptr) == ^<span class="STpe">s32</span>        <span class="SCmt">// The type of 'ptr' is now a pointer to multiple 's32' values</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Dereferencing with Indexes </h4>
<p>When pointer arithmetic is enabled, you can dereference the pointer using an index, allowing access to elements in an array-like manner. This is particularly useful when working with arrays through pointers, as it allows for flexible element access. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]             <span class="SCmt">// Declare and initialize an array of 's32' elements</span>
    <span class="SKwd">let</span> ptr = &arr[<span class="SNum">0</span>]                  <span class="SCmt">// Take the address of the first element</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr) == ^<span class="STpe">s32</span>)      <span class="SCmt">// The pointer type allows pointer arithmetic</span>

    <span class="SCmt">// Dereferencing by index to access the elements</span>
    <span class="SKwd">let</span> value1 = ptr[<span class="SNum">0</span>]                <span class="SCmt">// Access the first element</span>
    <span class="SItr">@assert</span>(value1 == <span class="SNum">1</span>)               <span class="SCmt">// Verify the first element's value is 1</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(value1) == <span class="STpe">s32</span>     <span class="SCmt">// Assert the type of value1 is 's32'</span>

    <span class="SKwd">let</span> value2 = ptr[<span class="SNum">1</span>]                <span class="SCmt">// Access the second element</span>
    <span class="SItr">@assert</span>(value2 == <span class="SNum">2</span>)               <span class="SCmt">// Verify the second element's value is 2</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(value2) == <span class="STpe">s32</span>     <span class="SCmt">// Assert the type of value2 is 's32'</span>

    <span class="SCmt">// Using 'dref' for the first element, equivalent to ptr[0]</span>
    <span class="SKwd">let</span> value = <span class="SKwd">dref</span> ptr               <span class="SCmt">// Dereference the pointer to access the first element</span>
    <span class="SItr">@assert</span>(value == <span class="SNum">1</span>)                <span class="SCmt">// Verify the dereferenced value is 1</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(value) == <span class="STpe">s32</span>      <span class="SCmt">// Assert the type of the dereferenced value is 's32'</span>
}</span></div>

<h3 id="_004_000_data_structures_swg__004_008_references_swg">References</h3><h4 id="_004_000_data_structures_swg__004_008_references_swg">References in Swag </h4>
<p>Swag also supports <b>references</b>, which are pointers that behave like values. References in Swag provide a convenient way to work with memory addresses while abstracting away the need for explicit pointer syntax, making them easier and safer to use in many cases. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">42</span>

    <span class="SCmt">// Use '&' to declare a reference.</span>
    <span class="SCmt">// Here, we declare a reference to the variable 'x'.</span>
    <span class="SCmt">// Unlike C++, you must take the address of 'x' to convert it into a reference.</span>
    <span class="SKwd">let</span> myRef: <span class="SKwd">const</span> &<span class="STpe">s32</span> = &x       <span class="SCmt">// Declare a constant reference to 'x'</span>

    <span class="SCmt">// References behave like values, so no explicit dereferencing is needed.</span>
    <span class="SCmt">// You can think of this as an alias for 'x'.</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">42</span>)             <span class="SCmt">// Verify the reference holds the value of 'x'</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Assigning to References </h4>
<p>When an assignment is made to a reference outside of its initialization, the operation changes the value of the variable being referenced, not the reference itself. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">42</span>
    <span class="SKwd">var</span> myRef: &<span class="STpe">s32</span> = &x             <span class="SCmt">// The reference is mutable because it's not declared 'const'</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">42</span>)             <span class="SCmt">// Confirm the reference initially points to 'x' (value 42)</span>

    <span class="SCmt">// This changes the value of 'x' through the reference.</span>
    myRef = <span class="SNum">66</span>                       <span class="SCmt">// Update the value through the reference</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">66</span>)             <span class="SCmt">// Ensure the reference now holds the updated value</span>

    <span class="SCmt">// Since 'myRef' is an alias for 'x', 'x' is also updated.</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">66</span>)                 <span class="SCmt">// Confirm the original variable 'x' has been updated as well</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Reassigning References </h4>
<p>Unlike in C++, you can change the reference itself (reassign it) rather than the value it points to. To reassign the reference, use the <span class="code-inline">ref</span> modifier in the assignment. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>
    <span class="SKwd">var</span> y = <span class="SNum">1000</span>

    <span class="SKwd">var</span> myRef: &<span class="STpe">s32</span> = &x             <span class="SCmt">// Initialize reference to point to 'x'</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">1</span>)              <span class="SCmt">// Verify the reference points to 'x' (value 1)</span>

    <span class="SCmt">// Here, we reassign 'myRef' to point to 'y' instead of 'x'.</span>
    <span class="SCmt">// The value of 'x' remains unchanged.</span>
    myRef = <span class="SCmp">#ref</span> &y                  <span class="SCmt">// Reassign reference to point to 'y'</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">1000</span>)           <span class="SCmt">// Ensure the reference now points to 'y' (value 1000)</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Passing References to Functions </h4>
<p>Most of the time, you need to take the address of a variable to create a reference to it. The only exception is when passing a reference to a function parameter, and the reference is declared as <span class="code-inline">const</span>. In such cases, taking the address explicitly is not necessary. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// We can pass a literal directly because 'x' in the function 'toto' is a const reference.</span>
    <span class="SCmt">// No need to take the address manually.</span>
    <span class="SFct">toto</span>(<span class="SNum">4</span>)                          <span class="SCmt">// Pass a literal to the function 'toto'</span>
}

<span class="SKwd">func</span> <span class="SFct">toto</span>(x: <span class="SKwd">const</span> &<span class="STpe">s32</span>)
{
    <span class="SItr">@assert</span>(x == <span class="SNum">4</span>)                  <span class="SCmt">// Validate the received reference matches the passed literal</span>

    <span class="SCmt">// Internally, the reference is still an address to an 's32'.</span>
    <span class="SKwd">let</span> ptr = &x                     <span class="SCmt">// Obtain the address from the reference</span>
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">4</span>)           <span class="SCmt">// Dereference the pointer to validate the value</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Using References with Structs </h4>
<p>This approach is particularly useful for structs, as it allows passing literals directly to functions. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Our first simple struct!</span>
<span class="SKwd">struct</span> <span class="SCst">MyStruct</span> { x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> }

<span class="SFct">#test</span>
{
    <span class="SFct">titi0</span>({<span class="SNum">1</span>, <span class="SNum">2</span>})                    <span class="SCmt">// Test passing a literal tuple to 'titi0'</span>
    <span class="SFct">titi1</span>({<span class="SNum">3</span>, <span class="SNum">4</span>})                    <span class="SCmt">// Test passing a literal tuple to 'titi1'</span>
    <span class="SFct">titi2</span>({<span class="SNum">5</span>, <span class="SNum">6</span>})                    <span class="SCmt">// Test passing a struct to 'titi2'</span>
}

<span class="SKwd">func</span> <span class="SFct">titi0</span>(param: <span class="SKwd">const</span> &{ x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> })
{
    <span class="SCmt">// We'll discuss tuples and field naming later, but for now, we can access tuple items by position.</span>
    <span class="SItr">@assert</span>(param.item0 == <span class="SNum">1</span>)        <span class="SCmt">// Validate first tuple item</span>
    <span class="SItr">@assert</span>(param.item1 == <span class="SNum">2</span>)        <span class="SCmt">// Validate second tuple item</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Equivalent Reference Passing </h4>
<p>Note that declaring a tuple type or a struct type as a parameter is equivalent to passing a constant reference. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">titi1</span>(param: { x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> })
{
    <span class="SItr">@assert</span>(param.x == <span class="SNum">3</span>)            <span class="SCmt">// Access struct fields by name</span>
    <span class="SItr">@assert</span>(param.y == <span class="SNum">4</span>)            <span class="SCmt">// Validate field values</span>
}

<span class="SKwd">func</span> <span class="SFct">titi2</span>(param: <span class="SCst">MyStruct</span>)
{
    <span class="SItr">@assert</span>(param.x == <span class="SNum">5</span>)            <span class="SCmt">// Access fields of 'MyStruct'</span>
    <span class="SItr">@assert</span>(param.y == <span class="SNum">6</span>)            <span class="SCmt">// Validate field values</span>
}</span></div>

<h3 id="_004_000_data_structures_swg__004_009_any_swg">Any</h3><h4 id="_004_000_data_structures_swg__004_009_any_swg">The <span class="code-inline">any</span> Type in Swag </h4>
<p><span class="code-inline">any</span> is a versatile type in Swag that can reference values of any other type. This allows for dynamic type handling within your code. </p>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> <span class="code-inline">any</span> is <b>not a variant</b>. It's a dynamically typed <b>reference</b> to an existing value. This means that <span class="code-inline">any</span> does not store a copy of the value, but rather a reference to the actual value, along with its type information. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">any</span>                        <span class="SCmt">// Declare a variable of type 'any'</span>

    <span class="SCmt">// Store an 's32' literal value in the 'any'</span>
    a = <span class="SNum">6</span>

    <span class="SCmt">// Access the value stored inside 'any' by casting it to the desired type.</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) a == <span class="SNum">6</span>)

    <span class="SCmt">// Now store a string instead of the 's32' value</span>
    a = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) a == <span class="SStr">"string"</span>)

    <span class="SCmt">// Now store a bool instead</span>
    a = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) a == <span class="SKwd">true</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Working with <span class="code-inline">any</span> and Pointers </h4>
<p><span class="code-inline">any</span> acts as a reference to the value it holds, alongside the <span class="code-inline">typeinfo</span> that describes the value's type. You can use <span class="code-inline">@dataof</span> to obtain the pointer to the actual value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">any</span> = <span class="SNum">6</span>                          <span class="SCmt">// Store an s32 value in 'a'</span>
    <span class="SKwd">let</span> ptr = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="STpe">s32</span>) <span class="SItr">@dataof</span>(a)   <span class="SCmt">// Retrieve the pointer to the stored value</span>
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">6</span>)                  <span class="SCmt">// Dereference the pointer to get the value</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Type Information and <span class="code-inline">any</span> </h4>
<p>When <span class="code-inline">#typeof</span> is used on an <span class="code-inline">any</span>, it returns <span class="code-inline">any</span> as the type because <span class="code-inline">any</span> is the type of the reference. To obtain the underlying type of the value stored in <span class="code-inline">any</span>, use <span class="code-inline">@kindof</span>, which is evaluated at runtime. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">any</span> = <span class="SStr">"string"</span>             <span class="SCmt">// Store a string in 'a'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">any</span>         <span class="SCmt">// The type of 'a' is 'any'</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(a) == <span class="STpe">string</span>)     <span class="SCmt">// The underlying type of the value is 'string'</span>

    a = <span class="SKwd">true</span>                          <span class="SCmt">// Change the stored value to a bool</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(a) == <span class="STpe">bool</span>)       <span class="SCmt">// Now the underlying type is 'bool'</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Retrieving Values from <span class="code-inline">any</span> </h4>
<p>You can retrieve the value stored in an <span class="code-inline">any</span> either directly or as a constant reference. This provides flexibility in how you interact with the stored value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">any</span> = <span class="SNum">42</span>                   <span class="SCmt">// Store an s32 value in 'a'</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(a) == <span class="STpe">any</span>         <span class="SCmt">// The type of 'a' is 'any'</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(a) == <span class="STpe">s32</span>)        <span class="SCmt">// The underlying type is 's32'</span>

    <span class="SKwd">let</span> b = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) a               <span class="SCmt">// Get the value itself</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">42</span>)
    <span class="SKwd">let</span> c = <span class="SKwd">cast</span>(<span class="SKwd">const</span> &<span class="STpe">s32</span>) a        <span class="SCmt">// Get a constant reference to the value</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">42</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Arrays of <span class="code-inline">any</span> </h4>
<p>You can create arrays containing multiple types using <span class="code-inline">any</span>. This allows you to maintain a heterogeneous collection where each element can be of a different type, enabling you to manage and manipulate data of various types within a single structure. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [] <span class="STpe">any</span> = [<span class="SKwd">true</span>, <span class="SNum">2</span>, <span class="SNum">3.0</span>, <span class="SStr">"4"</span>]  <span class="SCmt">// An array containing different types</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">0</span>]) == <span class="STpe">bool</span>)       <span class="SCmt">// The first element is a bool</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">1</span>]) == <span class="STpe">s32</span>)        <span class="SCmt">// The second element is an s32</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">2</span>]) == <span class="STpe">f32</span>)        <span class="SCmt">// The third element is an f32</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">3</span>]) == <span class="STpe">string</span>)     <span class="SCmt">// The fourth element is a string</span>

    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) array[<span class="SNum">0</span>] == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) array[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">f32</span>) array[<span class="SNum">2</span>] == <span class="SNum">3.0</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) array[<span class="SNum">3</span>] == <span class="SStr">"4"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Nullability of <span class="code-inline">any</span> </h4>
<p>An <span class="code-inline">any</span> value can be set to null and tested against null, similar to pointers or other nullable types. This allows for flexible handling of cases where a value may or may not be set, providing a robust approach to managing optional values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">any</span>                         <span class="SCmt">// Declare an 'any' type variable</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)                 <span class="SCmt">// Initially, 'x' is null</span>

    x = <span class="SNum">6</span>                              <span class="SCmt">// Store an s32 value in 'x'</span>
    <span class="SItr">@assert</span>(x != <span class="SKwd">null</span>)                 <span class="SCmt">// Now 'x' holds a value</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) x == <span class="SNum">6</span>)

    x = <span class="SStr">"string"</span>                       <span class="SCmt">// Change the stored value to a string</span>
    <span class="SItr">@assert</span>(x != <span class="SKwd">null</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) x == <span class="SStr">"string"</span>)

    x = <span class="SKwd">null</span>                           <span class="SCmt">// Set 'x' back to null</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Type Checking with <span class="code-inline">any</span> </h4>
<p>An <span class="code-inline">any</span> value can be tested against a type using <span class="code-inline">==</span> and <span class="code-inline">!=</span>. This effectively uses <span class="code-inline">@kindof</span> to retrieve the underlying type for comparison. This is particularly useful when you need to confirm the type of the value inside <span class="code-inline">any</span> before performing type-specific operations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">any</span>                         <span class="SCmt">// Declare an 'any' type variable</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)                 <span class="SCmt">// 'x' is null</span>
    <span class="SItr">@assert</span>(x != <span class="STpe">s32</span>)                  <span class="SCmt">// 'x' does not contain an s32</span>

    x = <span class="SNum">6</span>                              <span class="SCmt">// Store an s32 value in 'x'</span>
    <span class="SItr">@assert</span>(x == <span class="STpe">s32</span>)                  <span class="SCmt">// Now 'x' contains an s32</span>
    <span class="SItr">@assert</span>(x != <span class="STpe">bool</span>)                 <span class="SCmt">// But it does not contain a bool</span>

    x = <span class="SStr">"string"</span>                       <span class="SCmt">// Change the stored value to a string</span>
    <span class="SItr">@assert</span>(x != <span class="STpe">s32</span>)                  <span class="SCmt">// Now 'x' contains a string, not an s32</span>
    <span class="SItr">@assert</span>(x == <span class="STpe">string</span>)               <span class="SCmt">// Confirm it holds a string</span>

    <span class="SKwd">struct</span> <span class="SCst">A</span> {}                        <span class="SCmt">// Define a simple struct</span>

    x = <span class="SCst">A</span>{}                            <span class="SCmt">// Store an instance of A in 'x'</span>
    <span class="SItr">@assert</span>(x == <span class="SCst">A</span>)                    <span class="SCmt">// 'x' is of type A</span>
}</span></div>

<h2 id="_005_000_control_flow_swg">Control flow</h2>
<h3 id="_005_000_control_flow_swg__005_001_if_swg">If</h3><h4 id="_005_000_control_flow_swg__005_001_if_swg">Basic Usage of <span class="code-inline">if</span> </h4>
<p>A basic test with an <span class="code-inline">if</span> statement. </p>
<p>In Swag, curly braces <span class="code-inline">{}</span> are optional for control structures like <span class="code-inline">if</span>. However, if you choose to omit them, you must use a colon <span class="code-inline">:</span>. This syntax rule also applies to other control structures such as <span class="code-inline">while</span> and <span class="code-inline">for</span>. </p>
<p>Unlike in C/C++, the condition in an <span class="code-inline">if</span> statement does not need to be enclosed in parentheses. Parentheses can be used for clarity or grouping, but they are not mandatory. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SLgc">if</span> a == <span class="SNum">1</span>:                    <span class="SCmt">// No curly braces, so a colon ':' is required after the condition</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)            <span class="SCmt">// This block will not execute since 'a' is not equal to 1</span>

    <span class="SLgc">if</span> (a == <span class="SNum">1</span>):                  <span class="SCmt">// Parentheses can be used for grouping or clarity, but are optional</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)            <span class="SCmt">// This block will also not execute</span>

    <span class="SLgc">if</span> a == <span class="SNum">0</span>                     <span class="SCmt">// Curly braces are used, no colon is needed here</span>
    {
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)             <span class="SCmt">// This block will execute because 'a' equals 0</span>
    }

    <span class="SCmt">// The 'else' keyword can be used as in most programming languages.</span>
    <span class="SCmt">// When not using curly braces, the colon ':' after the condition is mandatory.</span>
    <span class="SLgc">if</span> a == <span class="SNum">0</span>:
        a += <span class="SNum">1</span>                    <span class="SCmt">// This block will execute, setting 'a' to 1</span>
    <span class="SLgc">else</span>:
        a += <span class="SNum">2</span>                    <span class="SCmt">// This block is skipped because the 'if' condition is true</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)               <span class="SCmt">// Asserts that 'a' is now 1</span>

    <span class="SCmt">// The 'elif' keyword is used for else-if chains, functioning similarly to 'else if' in other languages.</span>
    <span class="SLgc">if</span> a == <span class="SNum">1</span>:
        a += <span class="SNum">1</span>                    <span class="SCmt">// This block will execute, making 'a' equal to 2</span>
    <span class="SLgc">else</span>:
        <span class="SLgc">if</span> a == <span class="SNum">2</span>:                <span class="SCmt">// This nested 'if' will not execute</span>
            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
        <span class="SLgc">elif</span> a == <span class="SNum">3</span>:              <span class="SCmt">// This condition is also false</span>
            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
        <span class="SLgc">elif</span> a == <span class="SNum">4</span>:              <span class="SCmt">// This condition is false as well</span>
            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)

    <span class="SCmt">// Logical expressions using 'and' and 'or' work as expected</span>
    <span class="SLgc">if</span> a == <span class="SNum">0</span> <span class="SLgc">and</span> a == <span class="SNum">1</span>:         <span class="SCmt">// This condition is false because 'a' cannot be both 0 and 1</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)            <span class="SCmt">// This block will not execute</span>
    <span class="SLgc">if</span> a == <span class="SNum">0</span> <span class="SLgc">or</span> a == <span class="SNum">1</span>:          <span class="SCmt">// This condition is false because 'a' is 2</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">if</span> a == <span class="SNum">1</span> <span class="SLgc">or</span> a == <span class="SNum">2</span>:          <span class="SCmt">// This condition is true because 'a' is 2</span>
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)             <span class="SCmt">// This block will execute</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_001_if_swg">Variable Declaration in <span class="code-inline">if</span> </h4>
<p>You can declare and test a variable in an <span class="code-inline">if</span> statement simultaneously. In this context, the use of <span class="code-inline">var</span>, <span class="code-inline">let</span>, or <span class="code-inline">const</span> is mandatory. </p>
<p>The condition in the <span class="code-inline">if</span> statement will automatically convert the declared variable to a boolean. If the variable is non-zero, the condition evaluates to <span class="code-inline">true</span>, and the <span class="code-inline">if</span> block will execute. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Declare and test 'a' within the 'if' statement. Since 'a' is 0, the 'if' block will not execute.</span>
    <span class="SCmt">// The variable 'a' is only scoped within this 'if' block.</span>
    <span class="SLgc">if</span> <span class="SKwd">let</span> a = <span class="SNum">0</span>
    {
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)            <span class="SCmt">// This block will not execute</span>
    }

    <span class="SCmt">// You can redeclare 'a' as a constant in another block.</span>
    <span class="SCmt">// Since 'a' is 1, the 'if' block will execute.</span>
    <span class="SLgc">if</span> <span class="SKwd">const</span> a = <span class="SNum">1</span>:
        <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)           <span class="SCmt">// This block will execute and assert that 'a' is 1</span>
    <span class="SLgc">else</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)            <span class="SCmt">// This block will not execute</span>

    <span class="SCmt">// Another example using 'let'</span>
    <span class="SLgc">if</span> <span class="SKwd">let</span> a = <span class="SNum">1</span>:
        <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)           <span class="SCmt">// This block will execute, confirming that 'a' is 1</span>
    <span class="SLgc">else</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)            <span class="SCmt">// This block will not execute</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_001_if_swg">Adding Conditions with <span class="code-inline">where</span> </h4>
<p>When an <span class="code-inline">if</span> statement includes a variable declaration, you can add an additional condition using a <span class="code-inline">where</span> clause. The <span class="code-inline">where</span> clause is evaluated only if the initial test passes. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">retSomething</span>()-&gt;<span class="STpe">string</span> =&gt; <span class="SStr">"string"</span>
    <span class="SKwd">func</span> <span class="SFct">retNothing</span>()-&gt;<span class="STpe">string</span>   =&gt; <span class="SKwd">null</span>

    <span class="SCmt">// The 'where' clause is only evaluated if 'str' is not null.</span>
    <span class="SLgc">if</span> <span class="SKwd">let</span> str = <span class="SFct">retSomething</span>() <span class="SLgc">where</span> str[<span class="SNum">0</span>] == <span class="SStr">`s`</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)             <span class="SCmt">// This block will execute since 'str' starts with 's'</span>
    <span class="SLgc">else</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)            <span class="SCmt">// This block will not execute</span>

    <span class="SCmt">// In this example, the initial test fails because 'str' is null,</span>
    <span class="SCmt">// so the 'where' clause is not evaluated.</span>
    <span class="SLgc">if</span> <span class="SKwd">let</span> str = <span class="SFct">retNothing</span>() <span class="SLgc">where</span> str[<span class="SNum">0</span>] == <span class="SStr">`s`</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)            <span class="SCmt">// This block will not execute</span>
    <span class="SLgc">else</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)             <span class="SCmt">// This block will execute since the initial test fails</span>
}</span></div>

<h3 id="_005_000_control_flow_swg__005_002_loop_swg">Loop</h3><h4 id="_005_000_control_flow_swg__005_002_loop_swg">Introduction to <span class="code-inline">for</span> </h4>
<p>The <span class="code-inline">for</span> construct in Swag is a tool for iteration, allowing developers to repeat a block of code a specified number of times. This guide provides an in-depth exploration of the <span class="code-inline">for</span> construct, covering its various features, including basic usage, indexing, naming, reverse loops, early exits, and advanced filtering with the <span class="code-inline">where</span> clause. </p>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Basic Usage </h4>
<p>The <span class="code-inline">for</span> expression dictates the number of iterations and is evaluated only <b>once</b> before the loop begins. This value must be a <b>positive integer</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SNum">10</span>:                          <span class="SCmt">// Executes the loop 10 times</span>
        cpt += <span class="SNum">1</span>                     <span class="SCmt">// Increment the counter on each iteration</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)               <span class="SCmt">// Assert that the loop executed exactly 10 times</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Using <span class="code-inline">#index</span> </h4>
<p>Within a <span class="code-inline">for</span>, the compiler automatically provides the <span class="code-inline">#index</span> keyword, which holds the current iteration index, starting from 0. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>'<span class="STpe">u64</span>
    <span class="SLgc">for</span> <span class="SNum">5</span>                             <span class="SCmt">// Loop 5 times</span>
    {
        cpt += <span class="SItr">#index</span>                 <span class="SCmt">// Add the current index value to 'cpt' in each iteration</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>) <span class="SCmt">// Assert that 'cpt' equals the sum of the indices</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Naming the Loop Index </h4>
<p>Assigning a name to the <span class="code-inline">for</span> index can improve code readability and clarify the for's intent. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt  = <span class="SNum">0</span>
    <span class="SKwd">var</span> cpt1 = <span class="SNum">0</span>

    <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SNum">5</span>                        <span class="SCmt">// The `for` index is named 'i'</span>
    {
        cpt += i                      <span class="SCmt">// Use the named index 'i'</span>
        cpt1 += <span class="SItr">#index</span>                <span class="SCmt">// '#index' is still accessible and returns the same value as 'i'</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>) <span class="SCmt">// Confirm that 'cpt' equals the sum of indices</span>
    <span class="SItr">@assert</span>(cpt1 == cpt)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Looping Over Arrays and Slices </h4>
<p>The <span class="code-inline">for</span> construct is versatile and can iterate over any collection type that supports the <span class="code-inline">@countof</span> intrinsic, such as arrays, slices, and strings. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]        <span class="SCmt">// Define an array with 4 elements</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>        <span class="SCmt">// Verify the array has 4 elements</span>

    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> arr:                          <span class="SCmt">// Loop over the array's elements</span>
        cpt += arr[<span class="SItr">#index</span>]            <span class="SCmt">// Add the current element's value to 'cpt'</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span> + <span class="SNum">20</span> + <span class="SNum">30</span> + <span class="SNum">40</span>) <span class="SCmt">// Verify that 'cpt' equals the sum of the array elements</span>
}</span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> When looping over a string, the for will iterate over each byte, <b>not</b> over runes. For handling runes (characters that may be encoded in multiple bytes), consider using the Std.Core module. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SStr">"⻘"</span>:                        <span class="SCmt">// Loop over each byte in the string "⻘"</span>
        cpt += <span class="SNum">1</span>                     <span class="SCmt">// Increment the counter for each byte</span>

    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)                <span class="SCmt">// Assert that the character '⻘' consists of 3 bytes</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Reverse Looping </h4>
<p>To iterate in reverse order, append the <span class="code-inline">#back</span> modifier to the <span class="code-inline">for</span> statement. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// Loop in reverse order, starting from index 2 down to 0</span>
    <span class="SLgc">for</span> <span class="SCmp">#back</span> <span class="SNum">3</span>
    {
        <span class="SLgc">if</span> cpt == <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#index</span> == <span class="SNum">2</span>)     <span class="SCmt">// First iteration, index should be 2</span>
        <span class="SLgc">elif</span> cpt == <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#index</span> == <span class="SNum">1</span>)     <span class="SCmt">// Second iteration, index should be 1</span>
        <span class="SLgc">elif</span> cpt == <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#index</span> == <span class="SNum">0</span>)     <span class="SCmt">// Third iteration, index should be 0</span>

        cpt += <span class="SNum">1</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg"><span class="code-inline">break</span> and <span class="code-inline">continue</span> </h4>
<p>The <span class="code-inline">break</span> and <span class="code-inline">continue</span> keywords provide control over the for's execution flow. <span class="code-inline">break</span> exits the loop early, while <span class="code-inline">continue</span> skips the remainder of the current iteration and proceeds with the next. </p>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Exiting Early with <span class="code-inline">break</span> </h4>
<p>The <span class="code-inline">break</span> keyword allows you to exit the loop before completing all iterations, useful for optimizing performance or when a specific condition is met. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> x <span class="SLgc">in</span> <span class="SNum">10</span>                     <span class="SCmt">// Loop 10 times with index named 'x'</span>
    {
        <span class="SLgc">if</span> x == <span class="SNum">5</span>:
            <span class="SLgc">break</span>                   <span class="SCmt">// Exit the loop when 'x' equals 5</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">5</span>)               <span class="SCmt">// Confirm that the loop executed 5 times</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Skipping Iterations with <span class="code-inline">continue</span> </h4>
<p>The <span class="code-inline">continue</span> keyword skips the rest of the current for iteration and jumps to the next, which is useful when certain conditions should bypass processing. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> x <span class="SLgc">in</span> <span class="SNum">10</span>                      <span class="SCmt">// Loop 10 times with index named 'x'</span>
    {
        <span class="SLgc">if</span> x == <span class="SNum">5</span>:
            <span class="SLgc">continue</span>                 <span class="SCmt">// Skip the iteration when 'x' equals 5</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">9</span>)                <span class="SCmt">// Confirm that the loop executed 9 times, skipping the 5th iteration</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Ranges </h4>
<p>The <span class="code-inline">for</span> construct supports iteration over a <b>range</b> of signed values, enabling flexible iteration over specified intervals. </p>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Looping Over a Range with <span class="code-inline">to</span> </h4>
<p>The <span class="code-inline">to</span> keyword defines a loop that iterates from one value to another, inclusive.  </p>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> The start value must be less than or equal to the end value. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> count = <span class="SNum">0</span>
    <span class="SKwd">var</span> sum   = <span class="SNum">0</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> -<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">1</span>                 <span class="SCmt">// Loop from -1 to 1, inclusive</span>
    {
        count += <span class="SNum">1</span>                   <span class="SCmt">// Count the number of iterations</span>
        sum += i                     <span class="SCmt">// Sum the current index value</span>
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">0</span>)                <span class="SCmt">// Verify that the sum is 0 (-1 + 0 + 1)</span>
    <span class="SItr">@assert</span>(count == <span class="SNum">3</span>)              <span class="SCmt">// Confirm that the loop executed 3 times</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Excluding the Last Value with <span class="code-inline">until</span> </h4>
<p>The <span class="code-inline">until</span> keyword enables iteration up to, but not including, the end value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SNum">1</span> <span class="SLgc">until</span> <span class="SNum">3</span>              <span class="SCmt">// Loop from 1 up to, but excluding, 3</span>
    {
        cpt += i                    <span class="SCmt">// Add the current index value to 'cpt'</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span> + <span class="SNum">2</span>)            <span class="SCmt">// Verify that 'cpt' equals the sum of 1 and 2</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Reverse Range Looping </h4>
<p>When using ranges, you can also iterate in reverse order by adding the <span class="code-inline">#back</span> modifier after the for statement. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">for</span> <span class="SCmp">#back</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">5</span>                <span class="SCmt">// Loop from 5 down to 0, inclusive</span>
    {
    }

    <span class="SLgc">for</span> <span class="SCmp">#back</span> -<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">1</span>               <span class="SCmt">// Loop from 1 down to -1, inclusive</span>
    {
    }

    <span class="SLgc">for</span> <span class="SCmp">#back</span> -<span class="SNum">2</span> <span class="SLgc">until</span> <span class="SNum">2</span>            <span class="SCmt">// Loop from 1 down to -2, excluding 2</span>
    {
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Infinite Loop </h4>
<p>A <span class="code-inline">for</span> without an expression but with a block of code creates an infinite loop, functionally equivalent to <span class="code-inline">while true {}</span>. Infinite loops are often controlled with <span class="code-inline">break</span> statements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">for</span>
    {
        <span class="SLgc">if</span> <span class="SItr">#index</span> == <span class="SNum">4</span>:              <span class="SCmt">// Use `#index` to break the for after 4 iterations</span>
            <span class="SLgc">break</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Using <span class="code-inline">where</span> Clause </h4>
<p>The <span class="code-inline">where</span> clause provides conditional filtering within a loop, allowing specific iterations to execute based on defined criteria. </p>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Basic <span class="code-inline">where</span> Clause </h4>
<p>The <span class="code-inline">where</span> clause is appended directly after the <span class="code-inline">for</span> statement, applying a condition to the loop's index or value. Only iterations that satisfy this condition are executed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> result = <span class="SNum">0</span>

    <span class="SCmt">// Loop over the range from 0 to 9, but only process even indices.</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SNum">10</span> <span class="SLgc">where</span> i % <span class="SNum">2</span> == <span class="SNum">0</span>
    {
        result += i                      <span class="SCmt">// Sum only even indices</span>
    }

    <span class="SItr">@assert</span>(result == <span class="SNum">0</span> + <span class="SNum">2</span> + <span class="SNum">4</span> + <span class="SNum">6</span> + <span class="SNum">8</span>) <span class="SCmt">// Verify that 'result' equals the sum of even indices</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg"><span class="code-inline">where</span> with Arrays </h4>
<p>When looping over arrays, the <span class="code-inline">where</span> clause can filter elements based on their value or index, enabling targeted iteration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">10</span>, <span class="SNum">21</span>, <span class="SNum">30</span>, <span class="SNum">41</span>, <span class="SNum">50</span>]
    <span class="SKwd">var</span> sumOfEvens = <span class="SNum">0</span>

    <span class="SCmt">// Loop over the array, summing only the even numbers.</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> arr <span class="SLgc">where</span> arr[i] % <span class="SNum">2</span> == <span class="SNum">0</span>
    {
        sumOfEvens += arr[i]          <span class="SCmt">// Add the even element values to 'sumOfEvens'</span>
    }

    <span class="SItr">@assert</span>(sumOfEvens == <span class="SNum">10</span> + <span class="SNum">30</span> + <span class="SNum">50</span>) <span class="SCmt">// Verify that 'sumOfEvens' equals the sum of even numbers</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Complex Conditions with <span class="code-inline">where</span> </h4>
<p>The <span class="code-inline">where</span> supports combining multiple logical expressions, allowing for complex filtering conditions directly within the for. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">10</span>, <span class="SNum">15</span>, <span class="SNum">20</span>, <span class="SNum">25</span>, <span class="SNum">30</span>, <span class="SNum">35</span>]
    <span class="SKwd">var</span> filteredSum = <span class="SNum">0</span>

    <span class="SCmt">// Loop over the array, summing only even numbers greater than 15.</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> arr 
        <span class="SLgc">where</span> arr[i] % <span class="SNum">2</span> == <span class="SNum">0</span> <span class="SLgc">and</span> arr[i] &gt; <span class="SNum">15</span>
    {
        filteredSum += arr[i]         <span class="SCmt">// Add the element values that meet the condition</span>
    }

    <span class="SItr">@assert</span>(filteredSum == <span class="SNum">20</span> + <span class="SNum">30</span>)   <span class="SCmt">// Verify that 'filteredSum' equals the sum of 20 and 30</span>
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">10</span>, <span class="SNum">25</span>, <span class="SNum">30</span>, <span class="SNum">45</span>, <span class="SNum">50</span>, <span class="SNum">65</span>]
    <span class="SKwd">var</span> complexSum = <span class="SNum">0</span>

    <span class="SCmt">// Loop over the array, summing elements that are either even or greater than 40.</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> arr <span class="SLgc">where</span> arr[i] % <span class="SNum">2</span> == <span class="SNum">0</span> <span class="SLgc">or</span> arr[i] &gt; <span class="SNum">40</span>
    {
        complexSum += arr[i]          <span class="SCmt">// Add the values that meet the complex condition to 'complexSum'</span>
    }

    <span class="SItr">@assert</span>(complexSum == <span class="SNum">10</span> + <span class="SNum">30</span> + <span class="SNum">45</span> + <span class="SNum">50</span> + <span class="SNum">65</span>) <span class="SCmt">// Verify that 'complexSum' equals the sum of matching values</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg"><span class="code-inline">where</span> with Ranges </h4>
<p>The <span class="code-inline">where</span> clause can also be applied to loops over ranges, providing precise control over which range values are processed in the <span class="code-inline">for</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> sumOfPositiveEvens = <span class="SNum">0</span>

    <span class="SCmt">// Loop over the range from -5 to 5, but process only positive even numbers.</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> -<span class="SNum">5</span> <span class="SLgc">to</span> <span class="SNum">5</span> <span class="SLgc">where</span> i &gt; <span class="SNum">0</span> <span class="SLgc">and</span> i % <span class="SNum">2</span> == <span class="SNum">0</span>
    {
        sumOfPositiveEvens += i       <span class="SCmt">// Add the positive even values to 'sumOfPositiveEvens'</span>
    }

    <span class="SItr">@assert</span>(sumOfPositiveEvens == <span class="SNum">2</span> + <span class="SNum">4</span>) <span class="SCmt">// Verify that 'sumOfPositiveEvens' equals the sum of 2 and 4</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_loop_swg">Combining <span class="code-inline">back</span> and <span class="code-inline">where</span> </h4>
<p>You can combine the <span class="code-inline">#back</span> modifier with the <span class="code-inline">where</span> clause to filter values while iterating in reverse order. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>, <span class="SNum">50</span>]
    <span class="SKwd">var</span> reversedSum = <span class="SNum">0</span>

    <span class="SCmt">// Loop through the array in reverse order, summing only even values.</span>
    <span class="SLgc">for</span> <span class="SCmp">#back</span> i <span class="SLgc">in</span> arr <span class="SLgc">where</span> arr[i] % <span class="SNum">2</span> == <span class="SNum">0</span>
    {
        reversedSum += arr[i]         <span class="SCmt">// Add the even values to 'reversedSum'</span>
    }

    <span class="SItr">@assert</span>(reversedSum == <span class="SNum">50</span> + <span class="SNum">40</span> + <span class="SNum">30</span> + <span class="SNum">20</span> + <span class="SNum">10</span>) <span class="SCmt">// Verify the sum of even values in reverse</span>
}</span></div>

<h3 id="_005_000_control_flow_swg__005_003_for_swg">For</h3><h4 id="_005_000_control_flow_swg__005_003_for_swg">Introduction to <span class="code-inline">for</span> Loops </h4>
<p>The <span class="code-inline">for</span> loop also offers a versatile way to iterate over a range of values. The structure closely follows that of C/C++ loops, consisting of a <i>variable declaration statement</i>, a <i>test expression</i>, and an <i>ending statement</i>. This provides fine-grained control over the for's execution, making it a powerful tool for various iteration scenarios. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    
    <span class="SCmt">// A standard 'for' loop with initialization, condition, and increment.</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>:
        cpt += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)

    <span class="SCmt">// Alternative syntax: Semicolons ';' can be replaced by newlines for cleaner, more readable code.</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>
        i &lt; <span class="SNum">10</span>
        i += <span class="SNum">1</span>
    {
        cpt += <span class="SNum">1</span>
    }
    <span class="SItr">@assert</span>(cpt == <span class="SNum">20</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_for_swg">Accessing Loop Index with <span class="code-inline">#index</span> </h4>
<p>Similar to other looping constructs like <span class="code-inline">for</span>, <span class="code-inline">foreach</span>, and <span class="code-inline">while</span>, the <span class="code-inline">for</span> loop in Swag provides access to the <span class="code-inline">#index</span> keyword. This keyword represents the <b>current for index</b> and is particularly useful when you need to keep track of the iteration count separately from the for variable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>'<span class="STpe">u64</span>
    
    <span class="SCmt">// Using `#index` to accumulate the for indices.</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i: <span class="STpe">u32</span> = <span class="SNum">10</span>; i &lt; <span class="SNum">15</span>; i += <span class="SNum">1</span>:
        cpt += <span class="SItr">#index</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span>+<span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)

    <span class="SKwd">var</span> cpt1 = <span class="SNum">0</span>'<span class="STpe">u64</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">10</span>; i &lt; <span class="SNum">15</span>; i += <span class="SNum">1</span>:
        cpt1 += <span class="SItr">#index</span>
    <span class="SItr">@assert</span>(cpt1 == <span class="SNum">0</span>+<span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_for_swg">Using <span class="code-inline">break</span> and <span class="code-inline">continue</span> in <span class="code-inline">for</span> Loops </h4>
<p>In Swag, <span class="code-inline">break</span> and <span class="code-inline">continue</span> work within <span class="code-inline">for</span> loops just as they do in other for structures. Use <span class="code-inline">break</span> to exit the loop prematurely, effectively terminating the loop when a specific condition is met. The <span class="code-inline">continue</span> statement, on the other hand, skips the remainder of the current for iteration and jumps to the next iteration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>
    
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>
    {
        <span class="SLgc">if</span> i == <span class="SNum">5</span>:
            <span class="SLgc">break</span>  <span class="SCmt">// Exit the for when 'i' equals 5</span>
        sum += i
    }
    
    <span class="SItr">@assert</span>(sum == <span class="SNum">0</span>+<span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)  <span class="SCmt">// Sum is 10</span>

    sum = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>
    {
        <span class="SLgc">if</span> i % <span class="SNum">2</span> == <span class="SNum">0</span>:
            <span class="SLgc">continue</span>  <span class="SCmt">// Skip even numbers</span>
        sum += i
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">1</span>+<span class="SNum">3</span>+<span class="SNum">5</span>+<span class="SNum">7</span>+<span class="SNum">9</span>)  <span class="SCmt">// Sum is 25</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_for_swg">Nested <span class="code-inline">for</span> Loops </h4>
<p>Swag supports nested <span class="code-inline">for</span> loops, which are useful for more complex iteration patterns. In nested loops, the <span class="code-inline">#index</span> keyword refers to the current index of the innermost for. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> result = <span class="SNum">0</span>'<span class="STpe">u64</span>
    
    <span class="SCmt">// Outer for</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">5</span>; i += <span class="SNum">1</span>
    {
        <span class="SCmt">// Inner for</span>
        <span class="SLgc">for</span> <span class="SKwd">var</span> j = <span class="SNum">0</span>; j &lt; <span class="SNum">5</span>; j += <span class="SNum">1</span>
        {
            result += <span class="SItr">#index</span>  <span class="SCmt">// Adds the index of the inner for</span>
        }
    }

    <span class="SItr">@assert</span>(result == <span class="SNum">10</span> * <span class="SNum">5</span>)  <span class="SCmt">// Each inner for runs 5 times, so the sum of indices (0+1+2+3+4) * 5 = 10*5</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_for_swg">Iterating Over Arrays with <span class="code-inline">for</span> </h4>
<p>The <span class="code-inline">for</span> for can also be used to iterate over elements of an array or other iterable collections. This method provides a straightforward way to process or manipulate each element within a collection (but we'll see later that <span class="code-inline">foreach</span> is better). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>, <span class="SNum">5</span>]
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>

    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SItr">@countof</span>(array); i += <span class="SNum">1</span>
    {
        sum += array[i]
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>+<span class="SNum">5</span>)  <span class="SCmt">// Sum is 15</span>
}</span></div>

<h3 id="_005_000_control_flow_swg__005_004_while_swg">While</h3><h4 id="_005_000_control_flow_swg__005_004_while_swg">Introduction to <span class="code-inline">while</span> Loops </h4>
<p>A <span class="code-inline">while</span> loop is a control flow statement that allows repeated execution of a block of code as long as the specified condition evaluates to <span class="code-inline">true</span>. Once the condition becomes <span class="code-inline">false</span>, the loop terminates. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> i = <span class="SNum">0</span>
    <span class="SLgc">while</span> i &lt; <span class="SNum">10</span>:                <span class="SCmt">// Loop executes repeatedly until 'i' is no longer less than 10</span>
        i += <span class="SNum">1</span>                   <span class="SCmt">// Increment 'i' by 1 on each iteration</span>
    <span class="SItr">@assert</span>(i == <span class="SNum">10</span>)             <span class="SCmt">// Verify that 'i' equals 10 after loop completion</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_004_while_swg">Breaking Out of a <span class="code-inline">while</span> Loop </h4>
<p>The <span class="code-inline">break</span> statement provides a way to exit a <span class="code-inline">while</span> loop before the loop’s condition becomes <span class="code-inline">false</span>. This is particularly useful when an early termination of the loop is needed based on a specific condition. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> i = <span class="SNum">0</span>
    <span class="SLgc">while</span> i &lt; <span class="SNum">10</span>
    {
        <span class="SLgc">if</span> i == <span class="SNum">5</span>:
            <span class="SLgc">break</span>                <span class="SCmt">// Exit the loop immediately when 'i' reaches 5</span>
        i += <span class="SNum">1</span>                   <span class="SCmt">// Increment 'i' by 1 on each iteration</span>
    }

    <span class="SItr">@assert</span>(i == <span class="SNum">5</span>)              <span class="SCmt">// Confirm that 'i' equals 5 after breaking out of the loop</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_004_while_swg">Skipping Iterations with <span class="code-inline">continue</span> </h4>
<p>The <span class="code-inline">continue</span> statement allows you to skip the current iteration and proceed directly to the next iteration of the loop. This is useful for ignoring specific conditions within the loop while continuing its execution. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>
    <span class="SKwd">var</span> i = <span class="SNum">0</span>
    <span class="SLgc">while</span> i &lt; <span class="SNum">10</span>
    {
        i += <span class="SNum">1</span>                   <span class="SCmt">// Increment 'i' by 1 at the start of each iteration</span>
        <span class="SLgc">if</span> i % <span class="SNum">2</span> == <span class="SNum">0</span>:
            <span class="SLgc">continue</span>             <span class="SCmt">// Skip adding 'i' to 'sum' if 'i' is an even number</span>
        sum += i                 <span class="SCmt">// Add only odd numbers to 'sum'</span>
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">25</span>)           <span class="SCmt">// Ensure that the sum of odd numbers from 1 to 9 equals 25</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_004_while_swg">Nested <span class="code-inline">while</span> Loops </h4>
<p>A <span class="code-inline">while</span> loop can contain another <span class="code-inline">while</span> loop, forming a nested loop structure. In such cases, the <span class="code-inline">break</span> and <span class="code-inline">continue</span> statements apply only to the loop in which they are directly placed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> i = <span class="SNum">0</span>
    <span class="SKwd">var</span> j = <span class="SNum">0</span>
    <span class="SKwd">var</span> count = <span class="SNum">0</span>

    <span class="SLgc">while</span> i &lt; <span class="SNum">3</span>
    {
        j = <span class="SNum">0</span>
        <span class="SLgc">while</span> j &lt; <span class="SNum">3</span>
        {
            <span class="SLgc">if</span> j == <span class="SNum">2</span>:
                <span class="SLgc">break</span>            <span class="SCmt">// Exit the inner loop when 'j' equals 2</span>
            count += <span class="SNum">1</span>           <span class="SCmt">// Increment 'count' each time the inner loop completes an iteration</span>
            j += <span class="SNum">1</span>               <span class="SCmt">// Increment 'j' by 1 on each iteration of the inner loop</span>
        }
        i += <span class="SNum">1</span>                   <span class="SCmt">// Increment 'i' by 1 on each iteration of the outer loop</span>
    }

    <span class="SItr">@assert</span>(count == <span class="SNum">6</span>)          <span class="SCmt">// Confirm that 'count' equals 6, indicating the inner loop ran 6 times</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_004_while_swg">Using <span class="code-inline">while</span> with Complex Conditions </h4>
<p>The condition in a <span class="code-inline">while</span> loop can involve complex logical expressions, allowing for more sophisticated and controlled execution of the loop. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SKwd">var</span> b = <span class="SNum">1</span>
    <span class="SKwd">var</span> iterations = <span class="SNum">0</span>

    <span class="SLgc">while</span> a &lt; <span class="SNum">100</span> <span class="SLgc">and</span> b &lt; <span class="SNum">200</span>
    {
        a += <span class="SNum">10</span>                 <span class="SCmt">// Increment 'a' by 10 on each iteration</span>
        b += <span class="SNum">20</span>                 <span class="SCmt">// Increment 'b' by 20 on each iteration</span>
        iterations += <span class="SNum">1</span>         <span class="SCmt">// Increment 'iterations' to track the number of loop executions</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">100</span>)           <span class="SCmt">// Ensure that 'a' reaches 100 upon loop completion</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">201</span>)           <span class="SCmt">// Ensure that 'b' reaches 201 upon loop completion</span>
    <span class="SItr">@assert</span>(iterations == <span class="SNum">10</span>)   <span class="SCmt">// Confirm that the loop executed 10 times</span>
}</span></div>

<h3 id="_005_000_control_flow_swg__005_005_switch_swg">Switch</h3><h4 id="_005_000_control_flow_swg__005_005_switch_swg">Introduction to <span class="code-inline">switch</span> in Swag </h4>
<p>The <span class="code-inline">switch</span> statement in Swag operates similarly to those in C/C++, with a key distinction: Swag does not require an explicit <span class="code-inline">break</span> statement at the end of each <span class="code-inline">case</span> block. Instead, it prevents unintentional <span class="code-inline">fallthrough</span> behavior by design, except when the <span class="code-inline">case</span> is empty, where a <span class="code-inline">break</span> statement is necessary. This ensures that each <span class="code-inline">case</span> is independent unless explicitly designed otherwise, reducing the risk of errors in control flow. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SCmt">// The `switch` statement evaluates the value of 'value'.</span>
    <span class="SCmt">// The corresponding `case` block is executed based on the match.</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">0</span>:  
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if 'value' is 0.</span>
    <span class="SLgc">case</span> <span class="SNum">5</span>:  
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if 'value' is 5.</span>
    <span class="SLgc">case</span> <span class="SNum">6</span>:  
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)   <span class="SCmt">// Assertion passes if 'value' is 6.</span>
    <span class="SLgc">default</span>: 
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if no cases match.</span>
    }

    <span class="SKwd">let</span> ch = <span class="SStr">`A`</span>'<span class="STpe">rune</span>

    <span class="SCmt">// This `switch` checks the value of 'ch'.</span>
    <span class="SLgc">switch</span> ch
    {
    <span class="SLgc">case</span> <span class="SStr">`B`</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if 'ch' is 'B'.</span>
    <span class="SLgc">case</span> <span class="SStr">`A`</span>: 
        <span class="SLgc">break</span>           <span class="SCmt">// Exits the switch when 'ch' is 'A'.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Multiple Values in a <span class="code-inline">case</span> </h4>
<p>Swag allows you to assign multiple values to a single <span class="code-inline">case</span> statement, simplifying the code when the same block of code should execute for several potential matches. This feature enhances the readability and maintainability of your switch statements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SCmt">// In this switch, the `case` statement handles multiple values.</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">2</span>, <span class="SNum">4</span>, <span class="SNum">6</span>:   
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)   <span class="SCmt">// Assertion passes if 'value' is 2, 4, or 6.</span>
    <span class="SLgc">default</span>:        
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if 'value' does not match any case.</span>
    }

    <span class="SCmt">// Listing each value on its own line for enhanced readability.</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">2</span>,
         <span class="SNum">4</span>,
         <span class="SNum">6</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)   <span class="SCmt">// Assertion passes for any listed value.</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if no cases match.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Using <span class="code-inline">switch</span> with Various Types </h4>
<p>The <span class="code-inline">switch</span> statement in Swag is versatile, supporting any type that implements the <span class="code-inline">==</span> operator. This flexibility extends beyond numeric types to include strings and other comparable types, making it a powerful tool for various decision-making scenarios. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SStr">"myString"</span>

    <span class="SCmt">// A `switch` statement can match string values as well.</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SStr">"myString"</span>:    
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)   <span class="SCmt">// Assertion passes if 'value' matches "myString".</span>
    <span class="SLgc">case</span> <span class="SStr">"otherString"</span>: 
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if 'value' matches "otherString".</span>
    <span class="SLgc">default</span>:            
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if no cases match.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Intentional Fallthrough with <span class="code-inline">fallthrough</span> </h4>
<p>Swag allows for intentional <span class="code-inline">fallthrough</span> behavior, similar to C/C++, using the <span class="code-inline">fallthrough</span> keyword. This feature provides the option to continue execution from one <span class="code-inline">case</span> block to the next, which can be useful in scenarios where multiple cases share common logic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SCmt">// Demonstrating fallthrough where execution continues from `case 6` to `case 7`.</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">6</span>:
        <span class="SLgc">fallthrough</span>     <span class="SCmt">// Explicitly continues to the next `case`.</span>
    <span class="SLgc">case</span> <span class="SNum">7</span>:
        <span class="SItr">@assert</span>(value == <span class="SNum">6</span>) <span class="SCmt">// Assertion passes, confirming 'value' is 6.</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)   <span class="SCmt">// Default case is a safeguard; true assertion keeps the test passing.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Exiting a <span class="code-inline">case</span> Early with <span class="code-inline">break</span> </h4>
<p>The <span class="code-inline">break</span> statement in Swag allows for early exit from a <span class="code-inline">case</span> block. This is particularly useful when only a portion of the block should be executed under specific conditions, enhancing control flow within your <span class="code-inline">switch</span> statements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SCmt">// Demonstrating the use of `break` to exit the switch early.</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">6</span>:
        <span class="SLgc">if</span> value == <span class="SNum">6</span>:
            <span class="SLgc">break</span>       <span class="SCmt">// Exits the switch if the condition is true.</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// This line is never reached if `value` is 6.</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if no cases match.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Handling Empty Cases with <span class="code-inline">break</span> </h4>
<p>In Swag, a <span class="code-inline">case</span> statement cannot be left empty. If no action is required for a particular <span class="code-inline">case</span>, the <span class="code-inline">break</span> statement must be used explicitly to avoid compilation errors, ensuring clarity in control flow. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SCmt">// Handling cases where no action is needed using `break`.</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">5</span>:     
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if `value` is 5.</span>
    <span class="SLgc">case</span> <span class="SNum">6</span>:     
        <span class="SLgc">break</span>           <span class="SCmt">// No action is taken; switch exits cleanly.</span>
    <span class="SLgc">default</span>:    
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if no cases match.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Variable and Expression Cases </h4>
<p>Swag’s <span class="code-inline">switch</span> statement offers the flexibility to use variables and expressions in <span class="code-inline">case</span> conditions. This allows for dynamic evaluation based on runtime values, further extending the utility of the <span class="code-inline">switch</span> statement. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> test = <span class="SNum">2</span>
    <span class="SKwd">let</span> a = <span class="SNum">0</span>
    <span class="SKwd">let</span> b = <span class="SNum">1</span>

    <span class="SCmt">// Demonstrating the use of variables and expressions in switch cases.</span>
    <span class="SLgc">switch</span> test
    {
    <span class="SLgc">case</span> a:     <span class="SCmt">// `a` is a variable here, not a constant.</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if `test` equals `a` (0).</span>
    <span class="SLgc">case</span> b:     <span class="SCmt">// `b` is another variable.</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if `test` equals `b` (1).</span>
    <span class="SLgc">case</span> b + <span class="SNum">1</span>: <span class="SCmt">// This case uses an expression.</span>
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)   <span class="SCmt">// Assertion passes if `test` equals `b + 1` (2).</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">The <span class="code-inline">Swag.Complete</span> Attribute </h4>
<p>The <span class="code-inline">Swag.Complete</span> attribute ensures exhaustive handling of all possible cases in an enum within a <span class="code-inline">switch</span> statement. If any enum value is not explicitly handled, the compiler will raise an error, enforcing robust and complete logic coverage. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Color</span> { <span class="SCst">Red</span>, <span class="SCst">Green</span>, <span class="SCst">Blue</span> }
    <span class="SKwd">let</span> color = <span class="SCst">Color</span>.<span class="SCst">Red</span>

    <span class="SAtr">#[Swag.Complete]</span>
    <span class="SLgc">switch</span> color
    {
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Red</span>:     
        <span class="SLgc">break</span>           <span class="SCmt">// Handles the `Red` case.</span>
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Green</span>:   
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if `color` is Green.</span>
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Blue</span>:    
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if `color` is Blue.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Matching Ranges in a <span class="code-inline">switch</span> Statement </h4>
<p>Swag supports matching a <b>range of values</b> in a <span class="code-inline">switch</span> statement, allowing you to group and handle multiple values that fall within a specific range efficiently. This is useful for concise and clear range-based logic within your code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> success = <span class="SKwd">false</span>
    <span class="SKwd">let</span> x = <span class="SNum">6</span>

    <span class="SCmt">// Switch statement using ranges to match a group of values.</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">5</span>:  
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if `x` is between 0 and 5.</span>
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">to</span> <span class="SNum">15</span>: 
        success = <span class="SKwd">true</span>  <span class="SCmt">// Sets `success` to true if `x` is between 6 and 15.</span>
    }

    <span class="SItr">@assert</span>(success)   <span class="SCmt">// Ensures the correct case was matched.</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Overlapping Ranges </h4>
<p>In Swag, if ranges within a <span class="code-inline">switch</span> statement overlap, the first valid range that matches will be executed, while subsequent overlapping ranges are ignored. This order of precedence must be carefully considered in your logic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> success = <span class="SKwd">false</span>
    <span class="SKwd">let</span> x = <span class="SNum">6</span>

    <span class="SCmt">// Demonstrating overlapping ranges and their precedence.</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">10</span>:    
        success = <span class="SKwd">true</span>  <span class="SCmt">// This case matches first; subsequent cases are ignored.</span>
    <span class="SLgc">case</span> <span class="SNum">5</span> <span class="SLgc">until</span> <span class="SNum">15</span>: 
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// This is not reached because the first range matches.</span>
    }

    <span class="SItr">@assert</span>(success)   <span class="SCmt">// Confirms that the first range was applied correctly.</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Using the <span class="code-inline">where</span> Clause in <span class="code-inline">switch</span> </h4>
<p>The <span class="code-inline">where</span> clause in Swag allows you to add additional conditions to a <span class="code-inline">case</span> in a <span class="code-inline">switch</span> statement. This provides finer control over the logic, enabling complex decision-making scenarios where multiple variables influence the outcome. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">6</span>
    <span class="SKwd">let</span> y = <span class="SNum">10</span>

    <span class="SCmt">// Each `case` checks the value of 'x' and applies an additional condition with 'where'.</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">where</span> y == <span class="SNum">9</span>:    
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)   <span class="SCmt">// Skipped because `y` is not 9.</span>
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">where</span> y == <span class="SNum">10</span>:   
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)    <span class="SCmt">// Executes because both `x` and `y` match the conditions.</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)   <span class="SCmt">// Fallback case; should not be executed here.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Using <span class="code-inline">where</span> with <span class="code-inline">default</span> </h4>
<p>The <span class="code-inline">where</span> clause can also be applied to a <span class="code-inline">default</span> case, providing conditional logic even when no specific <span class="code-inline">case</span> matches. This allows you to handle default scenarios with more precision, based on additional criteria. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">7</span>
    <span class="SKwd">let</span> y = <span class="SNum">10</span>

    <span class="SCmt">// Demonstrates different outcomes based on 'where' clauses in default.</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">where</span> y == <span class="SNum">10</span>: 
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)   <span class="SCmt">// Skipped because `x` is not 6.</span>
    <span class="SLgc">case</span> <span class="SNum">7</span> <span class="SLgc">where</span> y == <span class="SNum">9</span>:  
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)   <span class="SCmt">// Skipped because `y` is not 9.</span>
    <span class="SLgc">default</span> <span class="SLgc">where</span> y == <span class="SNum">10</span>: 
        <span class="SLgc">break</span>            <span class="SCmt">// Executes because `y` is 10 and no previous case matched.</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)   <span class="SCmt">// General fallback case; should not be executed.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Switching on Type with <span class="code-inline">any</span> or <span class="code-inline">interface</span> </h4>
<p>When using a <span class="code-inline">switch</span> statement with a variable of type <span class="code-inline">any</span> or <span class="code-inline">interface</span>, Swag matches cases based on the underlying type of the variable. This behavior is akin to the <span class="code-inline">@kindof</span> intrinsic, which allows for dynamic type checking within a switch construct. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"value"</span>

    <span class="SCmt">// Switch statement based on the underlying type of 'x'.</span>
    <span class="SLgc">switch</span> x    <span class="SCmt">// Implicitly checks the type of `x` using `@kindof`.</span>
    {
    <span class="SLgc">case</span> <span class="STpe">string</span>: 
        <span class="SLgc">break</span>           <span class="SCmt">// Executes if `x` is of type string.</span>
    <span class="SLgc">default</span>:     
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Assertion fails if `x` is not a string.</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Switch Statement with Type Guard and Variable Binding </h4>
<p>You can declare a variable with the <span class="code-inline">var</span> keyword before the case value to bind the matched value to a variable, which can then be used within the corresponding case block. Additionally, you can apply conditional checks directly within the case using the <span class="code-inline">where</span> clause to further refine the matching logic. </p>
<p>The switch statement implicitly checks the type of the variable <span class="code-inline">x</span> using a type guard (<span class="code-inline">@kindof</span>), allowing for more precise case matching based on the variable's runtime type. </p>
<p>Key Features: </p>
<ol>
<li>Type Guarding: The switch statement evaluates the type of <span class="code-inline">x</span>, allowing cases to be matched based on its type.</li>
<li>Variable Binding: The matched value can be bound to a variable using the <span class="code-inline">var</span> keyword, making the value accessible within the case block.</li>
<li>Conditional Matching: The <span class="code-inline">where</span> clause enables additional conditions to be checked during case matching.</li>
</ol>
<p>Example 1: </p>
<p>The first example checks if <span class="code-inline">x</span> is a string. If it is, the value is bound to the variable <span class="code-inline">str</span>. The <span class="code-inline">@assert</span> function is then used to ensure that the value of <span class="code-inline">str</span> is equal to "value". </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"value"</span>

    <span class="SCmt">// Switch statement based on the underlying type of 'x'.</span>
    <span class="SLgc">switch</span> x    <span class="SCmt">// Implicitly checks the type of `x` using `@kindof`.</span>
    {
    <span class="SLgc">case</span> <span class="SKwd">let</span> str <span class="SLgc">as</span> <span class="STpe">string</span>:    <span class="SCmt">// 'str' will contain the value if 'x' is a string</span>
        <span class="SItr">@assert</span>(str == <span class="SStr">"value"</span>)
        <span class="SLgc">break</span>    

    <span class="SLgc">default</span>:     
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  
    }
}</span></div>
<p>Example 2: </p>
<p>The second example showcases conditional matching using the <span class="code-inline">where</span> clause. The switch statement evaluates  whether <span class="code-inline">x</span> is a string and checks additional conditions specified in each case. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"value"</span>

    <span class="SLgc">switch</span> x    <span class="SCmt">// Implicitly checks the type of `x` using `@kindof`.</span>
    {
    <span class="SLgc">case</span> <span class="SKwd">let</span> str <span class="SLgc">as</span> <span class="STpe">string</span> <span class="SLgc">where</span> str == <span class="SStr">"value"</span>:       <span class="SCmt">// Matches if `x` is a string and equals "value"</span>
        <span class="SItr">@assert</span>(str == <span class="SStr">"value"</span>)                     <span class="SCmt">// Asserts that `str` is equal to "value"</span>
        <span class="SLgc">break</span>   

    <span class="SLgc">case</span> <span class="SKwd">let</span> str <span class="SLgc">as</span> <span class="STpe">string</span> <span class="SLgc">where</span> str == <span class="SStr">"not_a_value"</span>: <span class="SCmt">// Matches if `x` is a string and equals "not_a_value"</span>
        <span class="SItr">@assert</span>(str == <span class="SStr">"not_a_value"</span>)               <span class="SCmt">// Asserts that `str` is equal to "not_a_value"</span>
        <span class="SLgc">break</span>     

    <span class="SLgc">default</span>:     
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>) <span class="SCmt">// Asserts false if no case matches</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Switch Without an Expression </h4>
<p>A <span class="code-inline">switch</span> statement in Swag can operate without an expression, behaving like a series of <span class="code-inline">if/else</span> statements. Each <span class="code-inline">case</span> is evaluated sequentially, and the first one that evaluates to <span class="code-inline">true</span> is executed, allowing for more complex conditional logic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>
    <span class="SKwd">let</span> value1 = <span class="SStr">"true"</span>

    <span class="SCmt">// Switch statement without an expression, behaving like an if-else chain.</span>
    <span class="SLgc">switch</span>
    {
    <span class="SLgc">case</span> value == <span class="SNum">6</span> <span class="SLgc">or</span> value &gt; <span class="SNum">10</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)   <span class="SCmt">// Passes if `value` is 6 or greater than 10.</span>
        <span class="SLgc">fallthrough</span>     <span class="SCmt">// Continues to the next case regardless.</span>
    <span class="SLgc">case</span> value1 == <span class="SStr">"true"</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)   <span class="SCmt">// Passes if `value1` is "true".</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Fails if no cases match.</span>
    }
}</span></div>

<h3 id="_005_000_control_flow_swg__005_006_break_swg">Break</h3><h4 id="_005_000_control_flow_swg__005_006_break_swg">Introduction to <span class="code-inline">break</span> in Swag </h4>
<p>The <span class="code-inline">break</span> statement is a control structure in Swag, allowing you to exit from <span class="code-inline">for</span>, <span class="code-inline">foreach</span>, <span class="code-inline">while</span>, <span class="code-inline">for</span>, and <span class="code-inline">switch</span> constructs. Understanding how and when to use <span class="code-inline">break</span> is essential for effective flow control in your programs. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">for</span> <span class="SNum">10</span>:
        <span class="SLgc">break</span>                 <span class="SCmt">// Immediately exits the loop, no further iterations occur</span>

    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>:
        <span class="SLgc">break</span>                 <span class="SCmt">// Exits the loop instantly after the first iteration</span>

    <span class="SLgc">while</span> <span class="SKwd">false</span>:
        <span class="SLgc">break</span>                 <span class="SCmt">// Demonstrates usage, but this line is never reached due to the false condition</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Default Behavior of <span class="code-inline">break</span> </h4>
<p>By default, the <span class="code-inline">break</span> statement exits only the innermost loop or control structure in which it resides. This ensures that nested loops or structures can be controlled independently. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        <span class="SLgc">for</span> <span class="SNum">10</span>
        {
            <span class="SLgc">break</span>             <span class="SCmt">// Exits the inner loop only, allowing the outer loop to continue</span>
        }

        <span class="SCmt">// The outer loop continues its execution here</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)        <span class="SCmt">// Verifies that the outer loop has run exactly 10 times</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Named Scopes with <span class="code-inline">break</span> </h4>
<p>Swag allows you to define named scopes using the <span class="code-inline">#scope</span> keyword. The <span class="code-inline">break</span> statement can then be directed to exit from the named scope, offering a structured approach to control flow within complex nested loops or conditions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// Defining a scope named 'BigScope'</span>
    <span class="SCmp">#scope</span> <span class="SCst">BigScope</span>
    {
        <span class="SLgc">for</span> <span class="SNum">10</span>
        {
            cpt += <span class="SNum">1</span>
            <span class="SLgc">break</span> <span class="SLgc">in</span> <span class="SCst">BigScope</span>    <span class="SCmt">// Exits the entire 'BigScope' scope after incrementing `cpt`</span>
        }

        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)        <span class="SCmt">// This assertion is never reached due to the break in statement above</span>
    }

    <span class="SCmt">// Execution resumes after 'BigScope'</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span>)         <span class="SCmt">// Confirms that the loop inside 'BigScope' executed only once</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Using <span class="code-inline">continue</span> with Named Scopes </h4>
<p>The <span class="code-inline">continue</span> statement can be used with a named scope to restart the execution from the beginning of the scope. This can be useful for iterating until a specific condition is met. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmp">#scope</span> <span class="SCst">Loop</span>
    {
        cpt += <span class="SNum">1</span>
        <span class="SLgc">if</span> cpt == <span class="SNum">5</span>:
            <span class="SLgc">break</span>            <span class="SCmt">// Exits the 'Loop' scope when `cpt` equals 5, ending the loop</span>
        <span class="SLgc">continue</span>             <span class="SCmt">// Restarts the 'Loop' scope, incrementing `cpt` each time</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">5</span>)        <span class="SCmt">// Verifies that the loop runs exactly 5 times before exiting</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Unnamed Scopes for Flow Control </h4>
<p>Named scopes are optional. You can also use unnamed scopes to manage control flow, offering a structured alternative to traditional if/else statements. This can help simplify complex conditions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> cpt = <span class="SNum">0</span>
    <span class="SCmp">#scope</span>
    {
        <span class="SLgc">if</span> cpt == <span class="SNum">1</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span>)
            <span class="SLgc">break</span>            <span class="SCmt">// Exits the unnamed scope if `cpt` equals 1</span>
        }

        <span class="SLgc">if</span> cpt == <span class="SNum">2</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">2</span>)
            <span class="SLgc">break</span>            <span class="SCmt">// Exits the unnamed scope if `cpt` equals 2</span>
        }

        <span class="SLgc">if</span> cpt == <span class="SNum">3</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
            <span class="SLgc">break</span>            <span class="SCmt">// Exits the unnamed scope if `cpt` equals 3</span>
        }
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Using <span class="code-inline">break</span> with Simple Statements </h4>
<p>A scope in Swag can also be followed by a simple statement rather than a block, providing additional flexibility in controlling the flow of execution. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#scope</span> <span class="SCst">Up</span>
    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        <span class="SLgc">for</span> <span class="SNum">10</span>
        {
            <span class="SLgc">if</span> <span class="SItr">#index</span> == <span class="SNum">5</span>:
                <span class="SLgc">break</span> <span class="SLgc">in</span> <span class="SCst">Up</span>      <span class="SCmt">// Exits to the 'Up' scope when the inner loop index equals 5</span>
        }

        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)        <span class="SCmt">// This assertion is never reached due to the break in statement above</span>
    }
}</span></div>

<h3 id="_005_000_control_flow_swg__005_007_visit_swg">Visit</h3><h4 id="_005_000_control_flow_swg__005_007_visit_swg">Introduction to <span class="code-inline">foreach</span> </h4>
<p>The <span class="code-inline">foreach</span> statement is designed to iterate over all elements within a collection. It provides a streamlined  and efficient way to process each item in a collection, which can be an array, slice, string and even a struct. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Iterating through each byte in the string "ABC".</span>
    <span class="SCmt">// The current byte will be stored in the variable 'value'.</span>
    <span class="SLgc">foreach</span> value <span class="SLgc">in</span> <span class="SStr">"ABC"</span>
    {
        <span class="SCmt">// '#index' is available to store the loop index.</span>
        <span class="SKwd">let</span> a = <span class="SItr">#index</span>                                     <span class="SCmt">// Index of the current iteration</span>
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`A`</span>)                          <span class="SCmt">// Check if the first value is 'A'</span>
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`B`</span>)                          <span class="SCmt">// Check if the second value is 'B'</span>
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`C`</span>)                          <span class="SCmt">// Check if the third value is 'C'</span>
        }
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_007_visit_swg">Naming the Value and Index </h4>
<p>Both the <b>value</b> and the loop <b>index</b> can be named explicitly. This enhances code readability,  especially in cases involving nested loops or complex data structures. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">foreach</span> value, index <span class="SLgc">in</span> <span class="SStr">"ABC"</span>
    {
        <span class="SKwd">let</span> a = index                                      <span class="SCmt">// The current loop index</span>
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`A`</span>)                          <span class="SCmt">// Check if the first value is 'A'</span>
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`B`</span>)                          <span class="SCmt">// Check if the second value is 'B'</span>
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`C`</span>)                          <span class="SCmt">// Check if the third value is 'C'</span>
        }
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_007_visit_swg">Using Default Aliases </h4>
<p>Both the <b>value</b> and the <b>index</b> are optional. If names are not explicitly provided,  the default aliases <span class="code-inline">#alias0</span> for the value and <span class="code-inline">#alias1</span> for the index can be used. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">foreach</span> <span class="SStr">"ABC"</span>
    {
        <span class="SKwd">let</span> a = <span class="SItr">#alias1</span>                                    <span class="SCmt">// Default alias for the index</span>
        <span class="SItr">@assert</span>(a == <span class="SItr">#index</span>)                               <span class="SCmt">// Ensure alias matches the index</span>
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SStr">`A`</span>)                        <span class="SCmt">// Check if the first alias is 'A'</span>
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SStr">`B`</span>)                        <span class="SCmt">// Check if the second alias is 'B'</span>
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SStr">`C`</span>)                        <span class="SCmt">// Check if the third alias is 'C'</span>
        }
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_007_visit_swg">Reverse Order with <span class="code-inline">#back</span> </h4>
<p>To iterate over elements in reverse order, use the <span class="code-inline">#back</span> modifier. This is particularly useful  when processing a collection from the last element to the first. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Visiting each byte in the string "ABC" in reverse order.</span>
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> <span class="SCmp">#back</span> value <span class="SLgc">in</span> <span class="SStr">"ABC"</span>
    {
        <span class="SCmt">// '#index' still stores the loop index, even in reverse order.</span>
        <span class="SLgc">switch</span> cpt
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`C`</span>)                          <span class="SCmt">// First value should be 'C'</span>
            <span class="SItr">@assert</span>(<span class="SItr">#index</span> == <span class="SNum">2</span>)                           <span class="SCmt">// Index should be 2</span>
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`B`</span>)                          <span class="SCmt">// Second value should be 'B'</span>
            <span class="SItr">@assert</span>(<span class="SItr">#index</span> == <span class="SNum">1</span>)                           <span class="SCmt">// Index should be 1</span>
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">`A`</span>)                          <span class="SCmt">// Third value should be 'A'</span>
            <span class="SItr">@assert</span>(<span class="SItr">#index</span> == <span class="SNum">0</span>)                           <span class="SCmt">// Index should be 0</span>
        }

        cpt += <span class="SNum">1</span>                                           <span class="SCmt">// Increment the counter</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_007_visit_swg">Visiting Arrays and Slices </h4>
<p>The <span class="code-inline">foreach</span> statement can be used to iterate over arrays or slices,  enabling straightforward processing of each element. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>]                               <span class="SCmt">// Define an array of integers</span>

    <span class="SKwd">var</span> result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> it <span class="SLgc">in</span> array:                                   <span class="SCmt">// Iterate over each element in the array</span>
        result += it                                       <span class="SCmt">// Accumulate the values</span>

    <span class="SItr">@assert</span>(result == <span class="SNum">10</span> + <span class="SNum">20</span> + <span class="SNum">30</span>)                        <span class="SCmt">// Ensure the sum matches the expected result</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_007_visit_swg">Multi-dimensional Arrays </h4>
<p><span class="code-inline">foreach</span> supports multi-dimensional arrays, facilitating the processing of complex data structures. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span> = [[<span class="SNum">10</span>, <span class="SNum">20</span>], [<span class="SNum">30</span>, <span class="SNum">40</span>]]           <span class="SCmt">// Define a 2x2 array</span>

    <span class="SKwd">var</span> result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> it <span class="SLgc">in</span> array:                                   <span class="SCmt">// Iterate over each element in the 2D array</span>
        result += it                                       <span class="SCmt">// Accumulate the values</span>

    <span class="SItr">@assert</span>(result == <span class="SNum">10</span> + <span class="SNum">20</span> + <span class="SNum">30</span> + <span class="SNum">40</span>)                   <span class="SCmt">// Ensure the sum matches the expected result</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_007_visit_swg">Modifying Elements with <span class="code-inline">&</span> </h4>
<p>By prefixing the value name with <span class="code-inline">&</span>, <span class="code-inline">foreach</span> allows you to visit elements by address,  enabling in-place modification of the elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span> = [[<span class="SNum">1</span>, <span class="SNum">2</span>], [<span class="SNum">3</span>, <span class="SNum">4</span>]]               <span class="SCmt">// Define a 2x2 array</span>

    <span class="SKwd">var</span> result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> &it <span class="SLgc">in</span> array
    {
        result += <span class="SKwd">dref</span> it                                  <span class="SCmt">// Accumulate the values</span>
        <span class="SKwd">dref</span> it = <span class="SNum">555</span>                                      <span class="SCmt">// Modify each element in place</span>
    }

    <span class="SItr">@assert</span>(result == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)                       <span class="SCmt">// Ensure the sum matches the expected result</span>

    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SNum">555</span>)                            <span class="SCmt">// Verify the first element is modified</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>, <span class="SNum">1</span>] == <span class="SNum">555</span>)                            <span class="SCmt">// Verify the second element is modified</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>, <span class="SNum">0</span>] == <span class="SNum">555</span>)                            <span class="SCmt">// Verify the third element is modified</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>, <span class="SNum">1</span>] == <span class="SNum">555</span>)                            <span class="SCmt">// Verify the fourth element is modified</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_007_visit_swg">Filtering with <span class="code-inline">where</span> </h4>
<p>The <span class="code-inline">where</span> clause can be used with <span class="code-inline">foreach</span> to filter the elements processed based on specific conditions. This approach is efficient for conditionally applying logic to only the elements that meet certain criteria. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [] <span class="STpe">s32</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]                       <span class="SCmt">// Define an array of integers</span>
    <span class="SKwd">var</span> result = <span class="SNum">0</span>

    <span class="SCmt">// Process only even values using `where`.</span>
    <span class="SLgc">foreach</span> value <span class="SLgc">in</span> array <span class="SLgc">where</span> value & <span class="SNum">1</span> == <span class="SNum">0</span>:
        result += value                                    <span class="SCmt">// Accumulate only even values</span>

    <span class="SItr">@assert</span>(result == <span class="SNum">6</span>)                                   <span class="SCmt">// Ensure the sum of even values is correct</span>

    <span class="SCmt">// Equivalent using an if statement inside the `foreach` loop:</span>
    result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> value <span class="SLgc">in</span> array:
        <span class="SLgc">if</span> value & <span class="SNum">1</span> == <span class="SNum">0</span>:                                 <span class="SCmt">// Check if the value is even</span>
            result += value                                <span class="SCmt">// Accumulate even values</span>
    <span class="SItr">@assert</span>(result == <span class="SNum">6</span>)                                   <span class="SCmt">// Ensure the sum of even values is correct</span>

    <span class="SCmt">// Equivalent using `continue` to skip odd values:</span>
    result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> value <span class="SLgc">in</span> array
    {
        <span class="SLgc">if</span> (value & <span class="SNum">1</span>) != <span class="SNum">0</span>:                               <span class="SCmt">// Skip odd values</span>
            <span class="SLgc">continue</span>
        result += value                                    <span class="SCmt">// Accumulate even values</span>
    }
    <span class="SItr">@assert</span>(result == <span class="SNum">6</span>)                                   <span class="SCmt">// Ensure the sum of even values is correct</span>
}</span></div>

<h2 id="_006_000_structs_swg">Structs</h2>
<h3 id="_006_000_structs_swg__006_001_declaration_swg">Declaration</h3><h4 id="_006_000_structs_swg__006_001_declaration_swg">Basic Struct Declaration </h4>
<p>This section illustrates a basic <span class="code-inline">struct</span> declaration in Swag. Notice that the <span class="code-inline">var</span> keyword is  not required when declaring fields within the struct. Each field is defined with a specific type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        name: <span class="STpe">string</span>  <span class="SCmt">// Field 'name' of type 'string'                       </span>
    }

    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:    <span class="STpe">s32</span>          <span class="SCmt">// Field 'x' of type 's32'                                </span>
        y, z: <span class="STpe">s32</span>          <span class="SCmt">// Fields 'y' and 'z' of type 's32', declared together  </span>
        val:  <span class="STpe">bool</span>         <span class="SCmt">// Field 'val' of type 'bool'                           </span>
        myS:  <span class="SCst">MyStruct</span>     <span class="SCmt">// Field 'myS' of type 'MyStruct', demonstrating a nested struct</span>
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Field Separators </h4>
<p>Fields within a struct can be separated by either a comma <span class="code-inline">,</span> or a semicolon <span class="code-inline">;</span>. The trailing  separator is optional and can be omitted. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span> { name: <span class="STpe">string</span>, val1: <span class="STpe">bool</span> }  <span class="SCmt">// Fields separated by commas</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span> { x: <span class="STpe">s32</span>; y, z: <span class="STpe">s32</span>; val: <span class="STpe">bool</span>; myS: <span class="SCst">MyStruct</span> }  <span class="SCmt">// Fields separated by semicolons</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Anonymous Structs </h4>
<p>Structs can be declared anonymously when used as variable types. This is particularly useful  for lightweight, temporary groupings of data. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> tuple: <span class="SKwd">struct</span>
    {
        x: <span class="STpe">f32</span>    <span class="SCmt">// Field 'x' of type 'f32'                                  </span>
        y: <span class="STpe">f32</span>    <span class="SCmt">// Field 'y' of type 'f32'                                  </span>
    }

    <span class="SKwd">var</span> tuple1: <span class="SKwd">struct</span>{ x, y: <span class="STpe">f32</span> }  <span class="SCmt">// Anonymous struct with fields 'x' and 'y' of type 'f32'</span>

    tuple.x = <span class="SNum">1.0</span>              <span class="SCmt">// Assigning value 1.0 to 'x'                      </span>
    tuple.y = <span class="SNum">2.0</span>              <span class="SCmt">// Assigning value 2.0 to 'y'                      </span>
    <span class="SItr">@assert</span>(tuple.x == <span class="SNum">1.0</span>)    <span class="SCmt">// Asserting 'x' is 1.0                            </span>
    <span class="SItr">@assert</span>(tuple.y == <span class="SNum">2.0</span>)    <span class="SCmt">// Asserting 'y' is 2.0                            </span>
}

<span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        rgb: <span class="SKwd">struct</span>{ x, y, z: <span class="STpe">f32</span> }  <span class="SCmt">// Nested anonymous struct for RGB values          </span>
        hsl: <span class="SKwd">struct</span>{ h, s, l: <span class="STpe">f32</span> }  <span class="SCmt">// Nested anonymous struct for HSL values          </span>
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Default Field Values </h4>
<p>Fields within a struct can be initialized with default values, providing a convenient way to  ensure fields are set to a known state. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x: <span class="STpe">s32</span>    = <span class="SNum">666</span>      <span class="SCmt">// Field 'x' initialized with default value 666                 </span>
        y: <span class="STpe">string</span> = <span class="SStr">"454"</span>    <span class="SCmt">// Field 'y' initialized with default value "454"               </span>
    }

    <span class="SKwd">var</span> v = <span class="SCst">MyStruct</span>{}       <span class="SCmt">// Initializing struct with default values                    </span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">666</span>)      <span class="SCmt">// Asserting 'x' has the default value 666                    </span>
    <span class="SItr">@assert</span>(v.y == <span class="SStr">"454"</span>)    <span class="SCmt">// Asserting 'y' has the default value "454"                  </span>
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Struct Initialization </h4>
<p>Struct variables can be initialized in multiple ways, providing flexibility in how you set up  your structs. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Initializing fields directly within the struct declaration</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x, y: <span class="STpe">s32</span> = <span class="SNum">1</span>  <span class="SCmt">// Both 'x' and 'y' initialized to 1                              </span>
    }

    <span class="SCmt">// Without parameters, all fields take their default values as defined in the struct</span>
    <span class="SKwd">var</span> v0: <span class="SCst">MyStruct</span>         <span class="SCmt">// Struct with default initialization                        </span>
    <span class="SItr">@assert</span>(v0.x == <span class="SNum">1</span>)       <span class="SCmt">// Asserting 'x' is 1                                        </span>
    <span class="SItr">@assert</span>(v0.y == <span class="SNum">1</span>)       <span class="SCmt">// Asserting 'y' is 1                                        </span>

    <span class="SCmt">// Initializing with parameters within {..}, in the order of field declarations</span>
    <span class="SKwd">var</span> v1: <span class="SCst">MyStruct</span>{<span class="SNum">10</span>, <span class="SNum">20</span>}  <span class="SCmt">// Initializing 'x' with 10 and 'y' with 20                </span>
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">10</span>)       <span class="SCmt">// Asserting 'x' is 10                                      </span>
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">20</span>)       <span class="SCmt">// Asserting 'y' is 20                                      </span>

    <span class="SCmt">// Named initialization of fields, allowing omission of some fields</span>
    <span class="SKwd">var</span> v2 = <span class="SCst">MyStruct</span>{y: <span class="SNum">20</span>}  <span class="SCmt">// 'x' takes the default value, 'y' initialized to 20       </span>
    <span class="SItr">@assert</span>(v2.x == <span class="SNum">1</span>)        <span class="SCmt">// Asserting 'x' is the default value 1                     </span>
    <span class="SItr">@assert</span>(v2.y == <span class="SNum">20</span>)       <span class="SCmt">// Asserting 'y' is 20                                      </span>

    <span class="SCmt">// Initializing using a tuple, as long as types match</span>
    <span class="SKwd">var</span> v3: <span class="SCst">MyStruct</span> = {<span class="SNum">10</span>, <span class="SNum">20</span>}  <span class="SCmt">// Initializing using a tuple                           </span>
    <span class="SItr">@assert</span>(v3.x == <span class="SNum">10</span>)          <span class="SCmt">// Asserting 'x' is 10                                   </span>
    <span class="SItr">@assert</span>(v3.y == <span class="SNum">20</span>)          <span class="SCmt">// Asserting 'y' is 20                                   </span>
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Const Structs </h4>
<p>A struct can be defined as a constant, provided that its values can be evaluated at compile-time. This ensures that the struct's values remain immutable throughout the program's execution. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x: <span class="STpe">s32</span>    = <span class="SNum">666</span>     <span class="SCmt">// Field 'x' initialized with default value 666                </span>
        y: <span class="STpe">string</span> = <span class="SStr">"454"</span>   <span class="SCmt">// Field 'y' initialized with default value "454"              </span>
    }

    <span class="SKwd">const</span> <span class="SCst">X</span>: <span class="SCst">MyStruct</span>{<span class="SNum">50</span>, <span class="SStr">"value"</span>}  <span class="SCmt">// Constant struct with specified values              </span>
    <span class="SCmp">#assert</span> <span class="SCst">X</span>.x == <span class="SNum">50</span>               <span class="SCmt">// Compile-time assertion that 'x' is 50              </span>
    <span class="SCmp">#assert</span> <span class="SCst">X</span>.y == <span class="SStr">"value"</span>          <span class="SCmt">// Compile-time assertion that 'y' is "value"         </span>
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Structs as Function Arguments </h4>
<p>Functions can take a struct as an argument. This operation is performed by reference,  with no copy made, which is equivalent to passing a const reference in C++. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct3</span>
{
    x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span>  <span class="SCmt">// Struct with default values for 'x', 'y', and 'z'              </span>
}

<span class="SKwd">func</span> <span class="SFct">toto</span>(v: <span class="SCst">Struct3</span>)
{
    <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)   <span class="SCmt">// Asserting 'x' is 5                                             </span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">5</span>)   <span class="SCmt">// Asserting 'y' is 5                                             </span>
    <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>) <span class="SCmt">// Asserting 'z' is the default value 666                         </span>
}

<span class="SKwd">func</span> <span class="SFct">titi</span>(v: <span class="SCst">Struct3</span>)
{
    <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)   <span class="SCmt">// Asserting 'x' is 5                                             </span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>) <span class="SCmt">// Asserting 'y' is the default value 666                         </span>
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Calling with a struct literal</span>
    <span class="SFct">toto</span>(<span class="SCst">Struct3</span>{<span class="SNum">5</span>, <span class="SNum">5</span>, <span class="SNum">666</span>})  <span class="SCmt">// Passing explicit values for 'x', 'y', and 'z'            </span>
    
    <span class="SCmt">// Type can be inferred from the argument</span>
    <span class="SFct">toto</span>({<span class="SNum">5</span>, <span class="SNum">5</span>, <span class="SNum">666</span>})         <span class="SCmt">// Inferring the struct type from the provided values       </span>

    <span class="SCmt">// Initializing only some parts of the struct, in the order of field declarations</span>
    <span class="SFct">titi</span>({<span class="SNum">5</span>})                 <span class="SCmt">// Initializes 'x' only, 'y' and 'z' take default values    </span>
    <span class="SFct">titi</span>({<span class="SNum">5</span>, <span class="SNum">666</span>})            <span class="SCmt">// Initializes 'x' and 'y', 'z' takes the default value     </span>

    <span class="SCmt">// Initializing using named fields, with the ability to omit some fields</span>
    <span class="SFct">titi</span>({x: <span class="SNum">5</span>, z: <span class="SNum">5</span>})        <span class="SCmt">// 'y' remains at its default value of 666, 'x' and 'z' are set</span>
}</span></div>

<h3 id="_006_000_structs_swg__006_002_impl_swg">Impl</h3><h4 id="_006_000_structs_swg__006_002_impl_swg">Struct Methods and Constants </h4>
<p>In Swag, structs can encapsulate methods and constants within them using the <span class="code-inline">impl</span> block.  This encapsulation allows for better organization and modularity of the code, keeping  the functionality related to the struct within the struct itself. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ExportType("methods")]</span>           <span class="SCmt">// This attribute enables method reflection for this struct type</span>
<span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
{
    x:     <span class="STpe">s32</span> = <span class="SNum">5</span>   <span class="SCmt">// Field 'x' with a default value of 5                          </span>
    y:     <span class="STpe">s32</span> = <span class="SNum">10</span>  <span class="SCmt">// Field 'y' with a default value of 10                         </span>
    z:     <span class="STpe">s32</span> = <span class="SNum">20</span>  <span class="SCmt">// Field 'z' with a default value of 20                         </span>
}

<span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SKwd">const</span> <span class="SCst">MyConst</span> = <span class="SKwd">true</span>                <span class="SCmt">// Constant defined within the struct's scope</span>

    <span class="SKwd">func</span> <span class="SFct">returnTrue</span>() =&gt; <span class="SKwd">true</span>           <span class="SCmt">// Function defined within the struct's scope, returns 'true'</span>
}</span></div>
<p>To access the constant or the function, use the <span class="code-inline">MyStruct</span> namespace. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SCst">MyStruct</span>.<span class="SCst">MyConst</span>)           <span class="SCmt">// Accessing the constant 'MyConst' within the struct's scope</span>
    <span class="SItr">@assert</span>(<span class="SCst">MyStruct</span>.<span class="SFct">returnTrue</span>())      <span class="SCmt">// Invoking the function 'returnTrue' within the struct's scope</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_002_impl_swg">Multiple <span class="code-inline">impl</span> Blocks </h4>
<p>Swag allows multiple <span class="code-inline">impl</span> blocks for a single struct. This feature helps organize  methods logically. Within an <span class="code-inline">impl</span> block, <span class="code-inline">self</span> and <span class="code-inline">Self</span> are defined to refer to  the current instance and the struct type, respectively. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SCmt">// 'self' is implicitly defined as 'var self: Self', where 'Self' refers to 'MyStruct'</span>
    <span class="SKwd">func</span> <span class="SFct">returnX</span>(<span class="SKwd">using</span> <span class="STpe">self</span>) =&gt; x       <span class="SCmt">// Method to return 'x', using 'self' implicitly</span>

    <span class="SKwd">func</span> <span class="SFct">returnY</span>(<span class="STpe">self</span>)       =&gt; <span class="STpe">self</span>.y  <span class="SCmt">// Method to return 'y', explicitly using 'self'</span>

    <span class="SCmt">// 'Self' refers to the type 'MyStruct', used here as a type alias</span>
    <span class="SKwd">func</span> <span class="SFct">returnZ</span>(me: <span class="STpe">Self</span>) =&gt; me.z      <span class="SCmt">// Method to return 'z', using 'me' as a type alias for 'Self'</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_002_impl_swg">Method Syntax Sugar </h4>
<p>Swag provides syntactic sugar for method definitions. If you use <span class="code-inline">mtd</span> (method) instead  of <span class="code-inline">func</span>, the first parameter is implicitly <span class="code-inline">using self</span>. If you use <span class="code-inline">mtd const</span>,  it becomes <span class="code-inline">const using self</span>. This feature simplifies method definitions,  especially for common cases where <span class="code-inline">self</span> is required. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">methodReturnX</span>()          =&gt; x  <span class="SCmt">// Equivalent to 'func methodReturnX(using self) =&gt; x'</span>
    <span class="SKwd">func</span> <span class="SFct">funcReturnX</span>(<span class="SKwd">using</span> <span class="STpe">self</span>) =&gt; x  <span class="SCmt">// Explicitly using 'self' to return 'x'</span>
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> c: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(c.<span class="SFct">returnX</span>() == <span class="SNum">5</span>)          <span class="SCmt">// Calling 'returnX' method, expected to return 'x'</span>
    <span class="SItr">@assert</span>(c.<span class="SFct">methodReturnX</span>() == <span class="SNum">5</span>)    <span class="SCmt">// Using the 'mtd' syntax, expected to return 'x'</span>
    <span class="SItr">@assert</span>(c.<span class="SFct">funcReturnX</span>() == <span class="SNum">5</span>)      <span class="SCmt">// Explicitly using 'func' syntax, expected to return 'x'</span>
    <span class="SItr">@assert</span>(c.<span class="SFct">returnY</span>() == <span class="SNum">10</span>)         <span class="SCmt">// Calling 'returnY' method, expected to return 'y'</span>
    <span class="SItr">@assert</span>(c.<span class="SFct">returnZ</span>() == <span class="SNum">20</span>)         <span class="SCmt">// Calling 'returnZ' method, expected to return 'z'</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_002_impl_swg">Method Reflection </h4>
<p>To enable reflection on methods within an <span class="code-inline">impl</span> block, the struct must be annotated with  <span class="code-inline">#[Swag.ExportType("methods")]</span>. By default, methods are not exported for reflection,  but with this annotation, they can be accessed programmatically. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Define a type alias 'Lambda' for a function pointer taking 'MyStruct' and returning 's32'</span>
    <span class="SKwd">alias</span> <span class="SCst">Lambda</span> = <span class="SKwd">func</span>(<span class="SCst">MyStruct</span>)-&gt;<span class="STpe">s32</span>

    <span class="SKwd">var</span> fnX: <span class="SCst">Lambda</span>  <span class="SCmt">// Function pointer for 'returnX'</span>
    <span class="SKwd">var</span> fnY: <span class="SCst">Lambda</span>  <span class="SCmt">// Function pointer for 'returnY'</span>
    <span class="SKwd">var</span> fnZ: <span class="SCst">Lambda</span>  <span class="SCmt">// Function pointer for 'returnZ'</span>

    <span class="SCmt">// The 'typeinfo' of a struct contains a 'methods' field, which is an array of method pointers</span>
    <span class="SKwd">let</span> t = <span class="SCst">MyStruct</span>
    <span class="SLgc">foreach</span> p <span class="SLgc">in</span> t.methods
    {
        <span class="SCmt">// The 'value' field of 'methods' contains the function pointer, which we cast to the correct type</span>
        <span class="SLgc">switch</span> p.name
        {
        <span class="SLgc">case</span> <span class="SStr">"returnX"</span>:
            fnX = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value  <span class="SCmt">// Cast the method pointer to 'Lambda' and assign to 'fnX'</span>
        <span class="SLgc">case</span> <span class="SStr">"returnY"</span>:
            fnY = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value  <span class="SCmt">// Cast the method pointer to 'Lambda' and assign to 'fnY'</span>
        <span class="SLgc">case</span> <span class="SStr">"returnZ"</span>:
            fnZ = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value  <span class="SCmt">// Cast the method pointer to 'Lambda' and assign to 'fnZ'</span>
        }
    }

    <span class="SCmt">// The function pointers 'fnX', 'fnY', and 'fnZ' are now callable</span>
    <span class="SKwd">var</span> v: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(<span class="SFct">fnX</span>(v) == <span class="SNum">5</span>)   <span class="SCmt">// Calling the function pointer 'fnX', expected to return 5</span>
    <span class="SItr">@assert</span>(<span class="SFct">fnY</span>(v) == <span class="SNum">10</span>)  <span class="SCmt">// Calling the function pointer 'fnY', expected to return 10</span>
    <span class="SItr">@assert</span>(<span class="SFct">fnZ</span>(v) == <span class="SNum">20</span>)  <span class="SCmt">// Calling the function pointer 'fnZ', expected to return 20</span>
}</span></div>

<h3 id="_006_000_structs_swg__006_003_offset_swg">Offset</h3><h4 id="_006_000_structs_swg__006_003_offset_swg">Custom Field Layout with <span class="code-inline">Swag.Offset</span> </h4>
<p>You can force the layout of a field within a struct using the <span class="code-inline">Swag.Offset</span> attribute.  This allows you to manually specify the memory offset of a field, which can be useful  for creating custom memory layouts, such as overlapping fields or sharing memory space  between different fields. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x: <span class="STpe">s32</span>

        <span class="SCmt">// 'y' is located at the same offset as 'x', meaning they share the same memory space.</span>
        <span class="SCmt">// This effectively creates an overlay, where changes to one field affect the other.</span>
        <span class="SAtr">#[Swag.Offset("x")]</span>
        y: <span class="STpe">s32</span>
    }

    <span class="SCmt">// Although there are two fields defined, they occupy the same space, so the struct only uses 4 bytes.</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct</span>) == <span class="SNum">4</span>

    <span class="SKwd">var</span> v = <span class="SCst">MyStruct</span>{}
    v.x = <span class="SNum">666</span>

    <span class="SCmt">// Since 'x' and 'y' share the same memory space, modifying 'x' also modifies 'y'.</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_003_offset_swg">Using <span class="code-inline">Swag.Offset</span> for Indexed Field Access </h4>
<p>In this example, <span class="code-inline">Swag.Offset</span> is used to reference a group of fields by index,  enabling indexed access to multiple fields through a single array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x, y, z: <span class="STpe">f32</span>

        <span class="SCmt">// 'idx' is an array that references the same memory locations as 'x', 'y', and 'z'.</span>
        <span class="SCmt">// This allows you to access 'x', 'y', and 'z' via indexed access through 'idx'.</span>
        <span class="SAtr">#[Swag.Offset("x")]</span>
        idx: [<span class="SNum">3</span>] <span class="STpe">f32</span>
    }

    <span class="SKwd">var</span> v: <span class="SCst">MyStruct</span>
    v.x = <span class="SNum">10</span>; v.y = <span class="SNum">20</span>; v.z = <span class="SNum">30</span>

    <span class="SCmt">// Each index in 'idx' directly references 'x', 'y', and 'z'.</span>
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">0</span>] == v.x)
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">1</span>] == v.y)
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">2</span>] == v.z)
}</span></div>

<h3 id="_006_000_structs_swg__006_004_packing_swg">Packing</h3><h4 id="_006_000_structs_swg__006_004_packing_swg">Default Struct Packing </h4>
<p>By default, Swag aligns struct fields similarly to the C programming language. Each field is aligned based on the size of its type, ensuring optimal memory access and usage. This default behavior can be explicitly specified using <span class="code-inline">#[Swag.Pack(0)]</span>, meaning no additional packing adjustments are applied. Below is an example illustrating this default alignment strategy. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x:     <span class="STpe">bool</span>    <span class="SCmt">// offset 0: aligned to 1 byte (no padding needed)</span>
        y:     <span class="STpe">s32</span>     <span class="SCmt">// offset 4: aligned to 4 bytes (3 bytes of padding before y)</span>
        z:     <span class="STpe">s64</span>     <span class="SCmt">// offset 8: aligned to 8 bytes (no padding needed)</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct</span>.y) == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct</span>.z) == <span class="SNum">8</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct</span>) == <span class="SNum">16</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_004_packing_swg">Reducing Packing </h4>
<p>Swag allows you to reduce the packing of struct fields using the <span class="code-inline">#[Swag.Pack]</span> attribute. This attribute specifies the alignment value to be applied to each field, enabling more compact struct representations. Below are examples demonstrating different levels of packing. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Pack(1)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:     <span class="STpe">bool</span>    <span class="SCmt">// offset 0: 1 byte (no padding)</span>
        y:     <span class="STpe">s32</span>     <span class="SCmt">// offset 1: 4 bytes (no padding)</span>
    }
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct1</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct1</span>.y) == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">5</span>

    <span class="SAtr">#[Swag.Pack(2)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x:     <span class="STpe">bool</span>    <span class="SCmt">// offset 0: 1 byte</span>
        y:     <span class="STpe">s32</span>     <span class="SCmt">// offset 2: 4 bytes (1 byte of padding before y)</span>
    }
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct2</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct2</span>.y) == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct2</span>) == <span class="SNum">6</span>

    <span class="SAtr">#[Swag.Pack(4)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct3</span>
    {
        x:     <span class="STpe">bool</span>    <span class="SCmt">// offset 0: 1 byte</span>
        y:     <span class="STpe">s64</span>     <span class="SCmt">// offset 4: 8 bytes (3 bytes of padding before y)</span>
    }
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct3</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct3</span>.y) == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct3</span>) == <span class="SNum">12</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_004_packing_swg">Struct Size and Alignment </h4>
<p>The total size of a struct in Swag is always a multiple of the largest alignment value among its fields. This ensures that the struct remains correctly aligned when used within larger data structures or arrays. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:     <span class="STpe">s32</span>     <span class="SCmt">// 4 bytes</span>
        y:     <span class="STpe">bool</span>    <span class="SCmt">// 1 byte</span>
        <span class="SCmt">// 3 bytes of padding to align with s32 size</span>
    }
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">8</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_004_packing_swg">Enforcing Alignment with <span class="code-inline">Swag.Align</span> </h4>
<p>Swag provides the <span class="code-inline">#[Swag.Align]</span> attribute to enforce specific alignment constraints on an entire struct. This attribute can be used to ensure that a struct's alignment meets specific hardware or performance requirements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:     <span class="STpe">bool</span>    <span class="SCmt">// 1 byte</span>
        y:     <span class="STpe">bool</span>    <span class="SCmt">// 1 byte</span>
    }
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct1</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct1</span>.y) == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">2</span>

    <span class="SAtr">#[Swag.Align(8)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x:     <span class="STpe">bool</span>    <span class="SCmt">// 1 byte</span>
        y:     <span class="STpe">bool</span>    <span class="SCmt">// 1 byte</span>
        <span class="SCmt">// 6 bytes of padding to align struct size to 8</span>
    }
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct2</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">#offsetof</span>(<span class="SCst">MyStruct2</span>.y) == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct2</span>) == <span class="SNum">8</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_004_packing_swg">Field-Specific Alignment </h4>
<p>Swag allows setting specific alignment values for individual struct fields using the <span class="code-inline">#[Swag.Align]</span> attribute. This enables fine-grained control over memory layout, which can be crucial for certain low-level optimizations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x: <span class="STpe">bool</span>         <span class="SCmt">// offset 0: 1 byte</span>
        <span class="SAtr">#[Swag.Align(8)]</span>
        y: <span class="STpe">bool</span>         <span class="SCmt">// offset 8: aligned to 8 bytes (7 bytes of padding before y)</span>
    }
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">9</span>

    <span class="SAtr">#[Swag.Align(8)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x: <span class="STpe">bool</span>         <span class="SCmt">// offset 0: 1 byte</span>
        <span class="SAtr">#[Swag.Align(4)]</span>
        y: <span class="STpe">bool</span>         <span class="SCmt">// offset 4: aligned to 4 bytes (3 bytes of padding before y)</span>
        <span class="SCmt">// 3 bytes of padding to align struct size to 8</span>
    }
    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(<span class="SCst">MyStruct2</span>) == <span class="SNum">8</span>
}</span></div>

<h3 id="_006_000_structs_swg__006_005_special_functions_swg">Special functions</h3><p>A struct in Swag can define special operations within the <span class="code-inline">impl</span> block. These operations are predefined and recognized by the compiler. This enables the ability to <b>overload operators</b> and customize behavior when interacting with the struct. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct</span>
{
    x, y: <span class="STpe">s32</span>   <span class="SCmt">// Define two properties, x and y, of type s32 (signed 32-bit integer)</span>
}

<span class="SKwd">alias</span> <span class="SCst">OneType</span>      = <span class="STpe">bool</span>   <span class="SCmt">// Alias for boolean type</span>
<span class="SKwd">alias</span> <span class="SCst">AnotherType</span>  = <span class="STpe">s32</span>    <span class="SCmt">// Alias for signed 32-bit integer type</span>
<span class="SKwd">alias</span> <span class="SCst">WhateverType</span> = <span class="STpe">bool</span>   <span class="SCmt">// Another alias for boolean type</span>

<span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SCmt">// Called whenever a variable of this struct is about to be destroyed (similar to a destructor in C++)</span>
    <span class="SKwd">func</span> <span class="SFct">opDrop</span>(<span class="SKwd">using</span> <span class="STpe">self</span>) {}

    <span class="SCmt">// Invoked after a raw copy operation has been performed from one value to another</span>
    <span class="SKwd">func</span> <span class="SFct">opPostCopy</span>(<span class="SKwd">using</span> <span class="STpe">self</span>) {}

    <span class="SCmt">// Called after a move semantic operation has been executed from one value to another</span>
    <span class="SKwd">func</span> <span class="SFct">opPostMove</span>(<span class="SKwd">using</span> <span class="STpe">self</span>) {}

    <span class="SCmt">// Access a value by slicing with the [low..up] notation. Returns a string or a slice.</span>
    <span class="SKwd">func</span> <span class="SFct">opSlice</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, low, up: <span class="STpe">u64</span>)-&gt;<span class="STpe">string</span> { <span class="SLgc">return</span> <span class="SStr">"true"</span>; }

    <span class="SCmt">// Access a value by its index. The index is of type OneType, and it returns a WhateverType.</span>
    <span class="SKwd">func</span> <span class="SFct">opIndex</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, index: <span class="SCst">OneType</span>)-&gt;<span class="SCst">WhateverType</span> { <span class="SLgc">return</span> <span class="SKwd">true</span>; }

    <span class="SCmt">// Called when @countof is used, typically in a 'for' block, to return the count of elements</span>
    <span class="SKwd">func</span> <span class="SFct">opCount</span>(<span class="SKwd">using</span> <span class="STpe">self</span>)-&gt;<span class="STpe">u64</span> { <span class="SLgc">return</span> <span class="SNum">0</span>; }

    <span class="SCmt">// Called when @dataof is used, returns a pointer to the underlying data of type WhateverType</span>
    <span class="SKwd">func</span> <span class="SFct">opData</span>(<span class="SKwd">using</span> <span class="STpe">self</span>)-&gt;*<span class="SCst">WhateverType</span> { <span class="SLgc">return</span> <span class="SKwd">null</span>; }

    <span class="SCmt">// Custom casting between the struct and another type, can be overloaded with different return types</span>
    <span class="SCmt">// Example usage: var x = cast(OneType) v</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opCast</span>(<span class="SKwd">using</span> <span class="STpe">self</span>)-&gt;<span class="SCst">OneType</span> { <span class="SLgc">return</span> <span class="SKwd">true</span>; }
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opCast</span>(<span class="SKwd">using</span> <span class="STpe">self</span>)-&gt;<span class="SCst">AnotherType</span> { <span class="SLgc">return</span> <span class="SNum">0</span>; }

    <span class="SCmt">// Compare the struct value with another, can be overloaded. </span>
    <span class="SCmt">// Returns true if equal, otherwise false. Used in '==', '!=' operations.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opEquals</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="STpe">bool</span> { <span class="SLgc">return</span> <span class="SKwd">false</span>; }
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opEquals</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="STpe">bool</span> { <span class="SLgc">return</span> <span class="SKwd">false</span>; }

    <span class="SCmt">// Compares the struct value with another, returns -1, 0, or 1. </span>
    <span class="SCmt">// Used in comparison operations like '&lt;', '&gt;', '&lt;=', '&gt;=', '&lt;=&gt;'.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opCmp</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="STpe">s32</span> { <span class="SLgc">return</span> <span class="SNum">0</span>; }
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opCmp</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="STpe">s32</span> { <span class="SLgc">return</span> <span class="SNum">0</span>; }

    <span class="SCmt">// Assigns a value to the struct, can be overloaded. </span>
    <span class="SCmt">// This is triggered by the '=' operator.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opAffect</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opAffect</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Assign a literal value with a specific suffix to the struct. </span>
    <span class="SCmt">// This is a generic function and can be overloaded.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(suffix: <span class="STpe">string</span>) <span class="SFct">opAffectLiteral</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(suffix: <span class="STpe">string</span>) <span class="SFct">opAffectLiteral</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Assign a value to a specific index in the struct. </span>
    <span class="SCmt">// Can be overloaded, used by '[] =' syntax.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opIndexAffect</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, index: <span class="SCst">OneType</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opIndexAffect</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, index: <span class="SCst">OneType</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Perform a binary operation, with 'op' representing the operator as a string. </span>
    <span class="SCmt">// This is a generic function that can be overloaded.</span>
    <span class="SCmt">// Examples include '+', '-', '*', '/', '%', '|', '&', '^', '&lt;&lt;', '&gt;&gt;'</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opBinary</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="STpe">Self</span> { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opBinary</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="STpe">Self</span> { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }

    <span class="SCmt">// Perform a unary operation, with 'op' representing the operator as a string. </span>
    <span class="SCmt">// This is a generic function.</span>
    <span class="SCmt">// Examples include '!', '-', '~'</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opUnary</span>(<span class="SKwd">using</span> <span class="STpe">self</span>)-&gt;<span class="STpe">Self</span> { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }

    <span class="SCmt">// Perform an assignment operation, with 'op' representing the operator as a string. </span>
    <span class="SCmt">// This is a generic function that can be overloaded.</span>
    <span class="SCmt">// Examples include '+=', '-=', '*=', '/=', '%=', '|=', '&=', '^=', '&lt;&lt;=', '&gt;&gt;='</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opAssign</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opAssign</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, other: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Assign a value to an indexed position with an operator, </span>
    <span class="SCmt">// 'op' represents the operator as a string. Can be overloaded.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opIndexAssign</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, index: <span class="SCst">OneType</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opIndexAssign</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, index: <span class="SCst">OneType</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Called in a 'foreach' block to iterate over the struct's elements. </span>
    <span class="SCmt">// Multiple versions can be defined by adding a name after 'opVisit'.</span>
    <span class="SAtr">#[Swag.Macro]</span>
    {
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisit</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, stmt: <span class="SKwd">code</span>) {}
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitWhatever</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, stmt: <span class="SKwd">code</span>) {}
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitAnother</span>(<span class="SKwd">using</span> <span class="STpe">self</span>, stmt: <span class="SKwd">code</span>) {}
    }
}</span></div>

<h3 id="_006_000_structs_swg__006_006_custom_assignment_swg">Custom assignment</h3><h4 id="_006_000_structs_swg__006_006_custom_assignment_swg">Custom Assignment Behavior with <span class="code-inline">opAffect</span> </h4>
<p>The <span class="code-inline">opAffect</span> method in Swag allows you to define custom assignment behaviors for your struct using the <span class="code-inline">=</span> operator. By overloading <span class="code-inline">opAffect</span>, you can handle assignments of different types, enabling you to specify how your struct should  behave when different types of values are assigned. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct</span>
{
    x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span>  <span class="SCmt">// Fields 'x', 'y', and 'z' with a default value of 666</span>
}

<span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SCmt">// Overloaded `opAffect` to handle assignments of type `s32`</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">s32</span>) { 
        x, y = value  <span class="SCmt">// Assign the provided `value` to both 'x' and 'y'</span>
    }

    <span class="SCmt">// Overloaded `opAffect` to handle assignments of type `bool`</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">bool</span>) { 
        x, y = value ? <span class="SNum">1</span> : <span class="SNum">0</span>  <span class="SCmt">// Assign 1 if `value` is true, otherwise 0, to both 'x' and 'y'</span>
    }
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Initialize 'v' and invoke `opAffect(s32)` with the value '4'</span>
    <span class="SKwd">var</span> v: <span class="SCst">Struct</span> = <span class="SNum">4</span>'<span class="STpe">s32</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">4</span>)    <span class="SCmt">// 'x' is set to 4</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">4</span>)    <span class="SCmt">// 'y' is set to 4</span>
    <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)  <span class="SCmt">// 'z' remains at its default value since `opAffect` doesn't modify it</span>

    <span class="SCmt">// Initialize 'v1' and invoke `opAffect(bool)` with 'true'</span>
    <span class="SKwd">var</span> v1: <span class="SCst">Struct</span> = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">1</span>)   <span class="SCmt">// 'x' is set to 1 because 'true' was assigned</span>
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">1</span>)   <span class="SCmt">// 'y' is also set to 1 because 'true' was assigned</span>

    <span class="SCmt">// Assign 'false' to 'v1', triggering `opAffect(bool)`</span>
    v1 = <span class="SKwd">false</span>
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">0</span>)   <span class="SCmt">// 'x' is set to 0 (false)</span>
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">0</span>)   <span class="SCmt">// 'y' is set to 0 (false)</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_006_custom_assignment_swg">Optimizing Initialization with <span class="code-inline">Swag.Complete</span> </h4>
<p>When <span class="code-inline">opAffect</span> fully initializes the struct, you can annotate it with <span class="code-inline">#[Swag.Complete]</span>. This prevents the struct from being initialized with default values before the assignment, enhancing performance by avoiding redundant assignments. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SCmt">// Mark `opAffect` with `Swag.Complete` to ensure only one initialization step</span>
    <span class="SAtr">#[Swag.Complete, Swag.Overload]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">u64</span>) { 
        x, y, z = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) value  <span class="SCmt">// Convert `value` from u64 to s32 and assign it to 'x', 'y', and 'z'</span>
    }

    <span class="SCmt">// Implicit conversion example for u16 assignments</span>
    <span class="SAtr">#[Swag.Implicit, Swag.Overload]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">u16</span>) { 
        x, y = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) value  <span class="SCmt">// Convert `value` from u16 to s32 and assign it to 'x' and 'y'</span>
    }
}</span></div>
<p>In this case, the struct <span class="code-inline">v</span> is directly initialized by <span class="code-inline">opAffect(u64)</span>, skipping the default initialization step.  This optimization leads to more efficient code by reducing unnecessary initializations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v: <span class="SCst">Struct</span> = <span class="SNum">2</span>'<span class="STpe">u64</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">2</span>)    <span class="SCmt">// 'x' is directly set to 2</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">2</span>)    <span class="SCmt">// 'y' is directly set to 2</span>
    <span class="SItr">@assert</span>(v.z == <span class="SNum">2</span>)    <span class="SCmt">// 'z' is directly set to 2</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_006_custom_assignment_swg">Handling Function Arguments and Automatic Conversion </h4>
<p>By default, function arguments do not automatically undergo conversion via <span class="code-inline">opAffect</span>. Explicit casting is necessary unless <span class="code-inline">Swag.Implicit</span> is used to allow automatic conversion. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>(v: <span class="SCst">Struct</span>)
    {
        <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(v.y == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)  <span class="SCmt">// 'z' remains unchanged</span>
    }

    <span class="SKwd">func</span> <span class="SFct">titi</span>(v: <span class="SCst">Struct</span>)
    {
        <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)  <span class="SCmt">// 'y' remains at its default value</span>
    }

    <span class="SCmt">// Explicit cast required to invoke `opAffect(s32)`</span>
    <span class="SFct">toto</span>(<span class="SKwd">cast</span>(<span class="SCst">Struct</span>) <span class="SNum">5</span>'<span class="STpe">s32</span>)

    <span class="SCmt">// With `#[Swag.Implicit]`, casting is not required, and automatic conversion occurs</span>
    <span class="SFct">toto</span>(<span class="SNum">5</span>'<span class="STpe">u16</span>)  <span class="SCmt">// Implicitly calls `opAffect(u16)`</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_006_custom_assignment_swg">Using <span class="code-inline">opAffect</span> in Constant Expressions </h4>
<p>To use <span class="code-inline">opAffect</span> in a context where the struct needs to be a constant, you can mark the method with <span class="code-inline">#[Swag.ConstExpr]</span>. This allows the struct to be initialized at compile-time via <span class="code-inline">opAffect</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Vector2</span>
{
    x, y: <span class="STpe">f32</span>  <span class="SCmt">// Fields of type f32 representing coordinates</span>
}

<span class="SKwd">impl</span> <span class="SCst">Vector2</span>
{
    <span class="SCmt">// Enables the use of `opAffect(f32)` for constant initialization</span>
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(one: <span class="STpe">f32</span>)
    {
        x, y = one  <span class="SCmt">// Assign the same value to both 'x' and 'y'</span>
    }
}

<span class="SCmt">// Using `opAffect(f32)` to initialize a compile-time constant</span>
<span class="SKwd">const</span> <span class="SCst">One</span>: <span class="SCst">Vector2</span> = <span class="SNum">1.0</span>
<span class="SCmp">#assert</span> <span class="SCst">One</span>.x == <span class="SNum">1.0</span>
<span class="SCmp">#assert</span> <span class="SCst">One</span>.y == <span class="SNum">1.0</span></span></div>

<h3 id="_006_000_structs_swg__006_007_custom_loop_swg">Custom loop</h3><div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">MyStruct</span> {}</span></div>
<h4 id="_006_000_structs_swg__006_007_custom_loop_swg">Implementing <span class="code-inline">opCount</span> for Iteration </h4>
<p>The <span class="code-inline">opCount</span> method in Swag allows you to specify the number of iterations when looping over an instance of a struct. By defining this method, you can control how many times a loop executes, effectively treating the struct as an iterable object. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SCmt">// Define 'opCount' to return the number of iterations for loops involving this struct.</span>
    <span class="SCmt">// Returns 4 as the count value, meaning any loop over this struct will run 4 times.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opCount</span>() =&gt; <span class="SNum">4</span>'<span class="STpe">u64</span>  
}</span></div>
<p>With <span class="code-inline">opCount</span> defined, an instance of <span class="code-inline">MyStruct</span> can be looped over similarly to an array or other iterable types. This allows you to use the struct in a loop context, where the loop will execute a number of times based on the value returned by <span class="code-inline">opCount</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v = <span class="SCst">MyStruct</span>{}

    <span class="SCmt">// '@countof' utilizes 'opCount' to determine the number of elements (iterations)</span>
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(v) == <span class="SNum">4</span>)  <span class="SCmt">// Verifies that the struct is considered to have 4 elements</span>

    <span class="SCmt">// Loop through the struct 'v', with the loop running as many times as 'opCount' returns</span>
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> v:
        cpt += <span class="SNum">1</span>  <span class="SCmt">// Increment the counter each iteration</span>

    <span class="SItr">@assert</span>(cpt == <span class="SNum">4</span>)  <span class="SCmt">// Ensure the loop ran 4 times, as specified by 'opCount'</span>
}</span></div>

<h3 id="_006_000_structs_swg__006_008_custom_iteration_swg">Custom iteration</h3><div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
{
    x:     <span class="STpe">s32</span> = <span class="SNum">10</span>  <span class="SCmt">// Field 'x' initialized with default value 10</span>
    y:     <span class="STpe">s32</span> = <span class="SNum">20</span>  <span class="SCmt">// Field 'y' initialized with default value 20</span>
    z:     <span class="STpe">s32</span> = <span class="SNum">30</span>  <span class="SCmt">// Field 'z' initialized with default value 30</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Introduction to <span class="code-inline">opVisit</span> </h4>
<p><span class="code-inline">opVisit</span> is a highly flexible macro used for iterating over the elements in a struct.  This macro is not confined to just the struct's fields; it can also be used to traverse  any data the struct contains, such as elements in dynamic arrays, internal buffers, or  complex object graphs. </p>
<p>The <span class="code-inline">#[Swag.Macro]</span> attribute is mandatory when using <span class="code-inline">opVisit</span>. It defines the macro's  behavior, allowing it to be integrated seamlessly into the codebase. </p>
<p><span class="code-inline">opVisit</span> is a generic function that accepts two compile-time boolean parameters: </p>
<ul>
<li><span class="code-inline">ptr</span>: When set to <span class="code-inline">true</span>, elements are visited by pointer (address), enabling reference-based operations.</li>
<li><span class="code-inline">back</span>: When set to <span class="code-inline">true</span>, elements are visited in reverse order (from last to first).</li>
</ul>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisit</span>(<span class="STpe">self</span>, stmt: <span class="SKwd">code</span>)
    {
        <span class="SCmt">// The `ptr` and `back` parameters offer flexibility, allowing for reference-based </span>
        <span class="SCmt">// or reverse-order iterations.</span>

        <span class="SCmp">#if</span> ptr:
            <span class="SCmp">#error</span> <span class="SStr">"Visiting by pointer is not supported in this example."</span>

        <span class="SCmp">#if</span> back:
            <span class="SCmp">#error</span> <span class="SStr">"Reverse visiting is not supported in this example."</span>

        <span class="SCmt">// Example of visiting the fields of `MyStruct`. This demonstrates a common use case of `opVisit`.</span>
        <span class="SLgc">for</span> idx <span class="SLgc">in</span> <span class="SNum">3</span>
        {
            <span class="SCmt">// The `#macro` directive ensures that the code is injected into the caller's scope.</span>
            <span class="SCmp">#macro</span>
            {
                <span class="SCmt">// `#alias0` is used to represent the current value being visited.</span>
                <span class="SKwd">var</span> <span class="SItr">#alias0</span>: <span class="STpe">s32</span> = <span class="SKwd">undefined</span>

                <span class="SCmt">// Access the appropriate field based on the current `idx`.</span>
                <span class="SLgc">switch</span> <span class="SItr">#up</span> idx
                {
                <span class="SLgc">case</span> <span class="SNum">0</span>:
                    <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">self</span>.x  <span class="SCmt">// Accessing field 'x'</span>
                <span class="SLgc">case</span> <span class="SNum">1</span>:
                    <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">self</span>.y  <span class="SCmt">// Accessing field 'y'</span>
                <span class="SLgc">case</span> <span class="SNum">2</span>:
                    <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">self</span>.z  <span class="SCmt">// Accessing field 'z'</span>
                }

                <span class="SCmt">// `#alias1` holds the current index of the iteration.</span>
                <span class="SKwd">var</span> <span class="SItr">#alias1</span> = <span class="SItr">#index</span>

                <span class="SCmt">// Insert user-defined logic from the calling scope.</span>
                <span class="SCmp">#mixin</span> <span class="SItr">#up</span> stmt
            }
        }
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Iterating Over Struct Fields </h4>
<p>This example demonstrates one way to use <span class="code-inline">opVisit</span> for iterating over the fields of a struct. The same approach can be extended to foreach more complex data structures. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myStruct = <span class="SCst">MyStruct</span>{}
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// Visit each field of `MyStruct` in declaration order.</span>
    <span class="SCmt">// `v` corresponds to the value (i.e., #alias0).</span>
    <span class="SCmt">// `i` corresponds to the index (i.e., #alias1).</span>
    <span class="SLgc">foreach</span> v, i <span class="SLgc">in</span> myStruct
    {
        <span class="SLgc">switch</span> i
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(v == <span class="SNum">10</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(v == <span class="SNum">20</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(v == <span class="SNum">30</span>)
        }

        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Extending <span class="code-inline">opVisit</span>: Reverse Order Iteration </h4>
<p>You can also implement different versions of <span class="code-inline">opVisit</span> to handle other data structures.  For instance, you may want to foreach the fields in reverse order. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">mtd</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitReverse</span>(stmt: <span class="SKwd">code</span>)
    {
        <span class="SCmt">// In this version, we foreach the fields in reverse order.</span>
        <span class="SLgc">for</span> idx <span class="SLgc">in</span> <span class="SNum">3</span>
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SKwd">var</span> <span class="SItr">#alias0</span>: <span class="STpe">s32</span> = <span class="SKwd">undefined</span>
                <span class="SLgc">switch</span> <span class="SItr">#up</span> idx
                {
                <span class="SLgc">case</span> <span class="SNum">0</span>:
                    <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">self</span>.z  <span class="SCmt">// Accessing field 'z' in reverse order</span>
                <span class="SLgc">case</span> <span class="SNum">1</span>:
                    <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">self</span>.y  <span class="SCmt">// Accessing field 'y' in reverse order</span>
                <span class="SLgc">case</span> <span class="SNum">2</span>:
                    <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">self</span>.x  <span class="SCmt">// Accessing field 'x' in reverse order</span>
                }

                <span class="SKwd">var</span> <span class="SItr">#alias1</span> = <span class="SItr">#index</span>
                <span class="SCmp">#mixin</span> <span class="SItr">#up</span> stmt
            }
        }
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Reverse Order Iteration </h4>
<p>The <span class="code-inline">opVisitReverse</span> variant allows us to foreach the struct's fields in reverse order,  providing flexibility depending on the needs of your application. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myStruct = <span class="SCst">MyStruct</span>{}
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// Call the variant `opVisitReverse` to iterate over the fields in reverse order.</span>
    <span class="SLgc">foreach</span>&lt;<span class="SCst">Reverse</span>&gt; v, i <span class="SLgc">in</span> myStruct
    {
        <span class="SLgc">switch</span> i
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(v == <span class="SNum">30</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(v == <span class="SNum">20</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(v == <span class="SNum">10</span>)
        }

        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Visiting Elements in Dynamic Arrays </h4>
<p>Beyond struct fields, <span class="code-inline">opVisit</span> can be designed to foreach elements in dynamic arrays, buffers,  or other types of data. The flexibility of <span class="code-inline">opVisit</span> means it can adapt to whatever data  structure the struct holds. </p>
<p>For example, consider a struct with a slice: </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">SliceStruct</span>
{
    buffer: [] <span class="STpe">s32</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>, <span class="SNum">5</span>]  <span class="SCmt">// A dynamic array (slice) initialized with values</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Custom <span class="code-inline">opVisit</span> for Dynamic Arrays </h4>
<p>You could define an <span class="code-inline">opVisit</span> that iterates over the elements of the <span class="code-inline">buffer</span> rather than  the struct's fields. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">SliceStruct</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisit</span>(<span class="STpe">self</span>, stmt: <span class="SKwd">code</span>)
    {
        <span class="SLgc">for</span> idx <span class="SLgc">in</span> <span class="SItr">@countof</span>(<span class="STpe">self</span>.buffer)
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SCmt">// #alias0 represents the value of the current buffer element.</span>
                <span class="SKwd">var</span> <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">self</span>.buffer[<span class="SItr">#up</span> idx]

                <span class="SCmt">// #alias1 represents the current index.</span>
                <span class="SKwd">var</span> <span class="SItr">#alias1</span> = <span class="SItr">#index</span>

                <span class="SCmt">// Insert the user-provided logic from the caller.</span>
                <span class="SCmp">#mixin</span> <span class="SItr">#up</span> stmt
            }
        }
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Iterating Over a Dynamic Array </h4>
<p>This example shows how to foreach each element in a dynamic array (slice) and perform  operations such as summing the elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arrStruct = <span class="SCst">SliceStruct</span>{}
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>

    <span class="SCmt">// Visit each element in the dynamic array buffer.</span>
    <span class="SLgc">foreach</span> v, i <span class="SLgc">in</span> arrStruct
    {
        sum += v
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span> + <span class="SNum">5</span>)  <span class="SCmt">// Ensuring the sum of the elements is correct</span>
}</span></div>

<h3 id="_006_000_structs_swg__006_009_custom_copy_and_move_swg">Custom copy and move</h3><p>Swag supports both copy and move semantics for structures. In this example, we demonstrate these concepts using a <span class="code-inline">Vector3</span> struct. Although a <span class="code-inline">Vector3</span> struct typically wouldn't require move semantics (as it doesn't involve heap allocation), this example serves to illustrate how these features are implemented and can be utilized within the Swag language. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Vector3</span>
{
    x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span>
}

<span class="SKwd">impl</span> <span class="SCst">Vector3</span>
{
    <span class="SCmt">// This method is invoked following a copy operation.</span>
    <span class="SCmt">// It exemplifies "copy semantics" and can be customized for specific behaviors post-copy.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opPostCopy</span>()
    {
        x, y, z += <span class="SNum">1</span>    <span class="SCmt">// Increment all fields by 1 to signify a copy operation has occurred.</span>
    }

    <span class="SCmt">// This method is invoked following a move operation.</span>
    <span class="SCmt">// It represents "move semantics" and can be customized for specific behaviors post-move.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opPostMove</span>()
    {
        x, y, z += <span class="SNum">2</span>    <span class="SCmt">// Increment all fields by 2 to signify a move operation has occurred.</span>
    }

    <span class="SCmt">// This method is invoked when an object is about to be destroyed.</span>
    <span class="SCmt">// While `Vector3` does not manage resources, this is where resource cleanup would typically occur, such as releasing heap-allocated memory.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opDrop</span>() {}
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SCst">Vector3</span>{}               <span class="SCmt">// Default initialization of `a`.</span>
    <span class="SKwd">var</span> b = <span class="SCst">Vector3</span>{<span class="SNum">100</span>, <span class="SNum">200</span>, <span class="SNum">300</span>}  <span class="SCmt">// Custom initialization of `b`.</span>

    <span class="SCmt">// Copy Semantics (default behavior):</span>
    <span class="SCmt">// 1. If 'a' already holds a value, 'opDrop' on 'a' is invoked.</span>
    <span class="SCmt">// 2. 'b' is copied to 'a'.</span>
    <span class="SCmt">// 3. 'opPostCopy' on 'a' is invoked to finalize the copy operation.</span>

    a = b
    <span class="SItr">@assert</span>(a.x == <span class="SNum">101</span>)       <span class="SCmt">// +1 due to 'opPostCopy'.</span>
    <span class="SItr">@assert</span>(a.y == <span class="SNum">201</span>)
    <span class="SItr">@assert</span>(a.z == <span class="SNum">301</span>)

    <span class="SCmt">// Move Semantics:</span>
    <span class="SCmt">// The `#move` modifier triggers move semantics:</span>
    <span class="SCmt">// 1. 'opDrop' on 'a' is invoked (if it exists).</span>
    <span class="SCmt">// 2. 'b' is moved to 'a'.</span>
    <span class="SCmt">// 3. 'opPostMove' on 'a' is invoked to finalize the move operation.</span>
    <span class="SCmt">// 4. 'b' is reinitialized to default values (666) if 'opDrop' exists.</span>

    a = <span class="SCmp">#move</span> b
    <span class="SItr">@assert</span>(a.x == <span class="SNum">102</span>)       <span class="SCmt">// +2 due to 'opPostMove'.</span>
    <span class="SItr">@assert</span>(a.y == <span class="SNum">202</span>)
    <span class="SItr">@assert</span>(a.z == <span class="SNum">302</span>)

    <span class="SCmt">// Post-move, 'b' is reinitialized to its default values (666) as 'opDrop' is present.</span>
    <span class="SItr">@assert</span>(b.x == <span class="SNum">666</span>)

    <span class="SCmt">// The `#nodrop` modifier bypasses the initial 'opDrop' invocation.</span>
    <span class="SCmt">// Use this when 'a' is in an undefined state and does not require cleanup.</span>

    a = <span class="SCmp">#nodrop</span> b                <span class="SCmt">// Copy 'b' to 'a' without invoking 'opDrop' on 'a' first.</span>
    a = <span class="SCmp">#nodrop</span> <span class="SCmp">#move</span> b          <span class="SCmt">// Move 'b' to 'a' without invoking 'opDrop' on 'a' first.</span>

    <span class="SCmt">// The `#moveraw` modifier prevents the reinitialization of 'b' after the move.</span>
    <span class="SCmt">// This approach is risky and should be employed only when certain that 'b' won't be dropped or </span>
    <span class="SCmt">// when reinitialization is handled manually.</span>

    a = <span class="SCmp">#moveraw</span> b               <span class="SCmt">// Move 'b' to 'a' without resetting 'b'.</span>
    a = <span class="SCmp">#nodrop</span> <span class="SCmp">#moveraw</span> b       <span class="SCmt">// Move 'b' to 'a' without invoking 'opDrop' on 'a' first and without resetting 'b'.</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_009_custom_copy_and_move_swg">Move Semantics in Functions </h4>
<p>Move semantics can be explicitly indicated in function parameters by utilizing <span class="code-inline">&&</span> instead of <span class="code-inline">&</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// This variant of 'assign' takes ownership of 'from' by moving its contents into 'assignTo'.</span>
    <span class="SCmt">// The 'moveref' keyword informs the compiler that this version of 'assign' assumes ownership of 'from'.</span>

    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">assign</span>(assignTo: &<span class="SCst">Vector3</span>, from: &&<span class="SCst">Vector3</span>)
    {
        assignTo = <span class="SCmp">#move</span> from  <span class="SCmt">// Move 'from' into 'assignTo'.</span>
    }

    <span class="SCmt">// This variant of 'assign' performs a copy instead of a move.</span>
    <span class="SCmt">// 'from' remains unchanged and is passed by value.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">assign</span>(assignTo: &<span class="SCst">Vector3</span>, from: <span class="SCst">Vector3</span>)
    {
        assignTo = from  <span class="SCmt">// Copy 'from' into 'assignTo'.</span>
    }

    <span class="SKwd">var</span> a = <span class="SCst">Vector3</span>{<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>}  <span class="SCmt">// Initialize 'a'.</span>
    <span class="SKwd">var</span> b: <span class="SCst">Vector3</span>            <span class="SCmt">// Declare 'b'.</span>

    <span class="SCmt">// Invoke the copy version of 'assign'.</span>
    <span class="SFct">assign</span>(&b, a)
    <span class="SItr">@assert</span>(b.x == <span class="SNum">2</span> <span class="SLgc">and</span> b.y == <span class="SNum">3</span> <span class="SLgc">and</span> b.z == <span class="SNum">4</span>)  <span class="SCmt">// +1 on each field due to 'opPostCopy'.</span>
    <span class="SItr">@assert</span>(a.x == <span class="SNum">1</span> <span class="SLgc">and</span> a.y == <span class="SNum">2</span> <span class="SLgc">and</span> a.z == <span class="SNum">3</span>)  <span class="SCmt">// 'a' remains unchanged.</span>

    <span class="SCmt">// Invoke the move version of 'assign' using 'moveref'.</span>
    <span class="SFct">assign</span>(&b, <span class="SKwd">moveref</span> &a)
    <span class="SItr">@assert</span>(b.x == <span class="SNum">3</span> <span class="SLgc">and</span> b.y == <span class="SNum">4</span> <span class="SLgc">and</span> b.z == <span class="SNum">5</span>)        <span class="SCmt">// +2 on each field due to 'opPostMove'.</span>
    <span class="SItr">@assert</span>(a.x == <span class="SNum">666</span> <span class="SLgc">and</span> a.y == <span class="SNum">666</span> <span class="SLgc">and</span> a.z == <span class="SNum">666</span>)  <span class="SCmt">// 'a' is reset to default values post-move.</span>
}</span></div>

<h3 id="_006_000_structs_swg__006_010_custom_literals_swg">Custom literals</h3><h4 id="_006_000_structs_swg__006_010_custom_literals_swg">User-Defined Literals </h4>
<p>User-defined literals allow you to extend the meaning of literals in the language, enabling the creation of custom types that can be initialized directly using literal values with specific suffixes. This feature is particularly useful for defining types like <span class="code-inline">Duration</span>, where different units of time (e.g., seconds, milliseconds, minutes) can be intuitively represented and manipulated. </p>
<h4 id="_006_000_structs_swg__006_010_custom_literals_swg">Literal Suffixes </h4>
<p>A literal suffix is a string of characters that immediately follows a numeric literal to specify a particular unit or type. For example, in <span class="code-inline">4'ms</span>, <span class="code-inline">'ms'</span> is the suffix indicating that the value is in milliseconds. </p>
<p>To define user-defined literals, you typically provide: </p>
<ol>
<li>A structure representing the custom type (e.g., <span class="code-inline">Duration</span>).</li>
<li>Methods that handle the conversion of the literal values based on the suffix provided.</li>
</ol>
<h4 id="_006_000_structs_swg__006_010_custom_literals_swg">Defining a Custom Type: <span class="code-inline">Duration</span> </h4>
<p>The <span class="code-inline">Duration</span> type is a struct designed to represent time intervals, internally stored in seconds. The type allows initialization through various time units like seconds, milliseconds, minutes, and hours. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Represents a delay, expressed in seconds.</span>
<span class="SKwd">struct</span> <span class="SCst">Duration</span>
{
    timeInSeconds: <span class="STpe">f32</span> <span class="SCmt">// The duration in seconds</span>
}

<span class="SKwd">impl</span> <span class="SCst">Duration</span>
{
    <span class="SCmt">// Method to initialize Duration using milliseconds directly (without suffix)</span>
    <span class="SAtr">#[Swag.ConstExpr, Swag.Implicit, Swag.Inline]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(valueMs: <span class="STpe">s32</span>)
    {
        timeInSeconds = valueMs / <span class="SNum">1000.0</span>
    }
}</span></div>
<p>To convert a given value and suffix to another value, you will use the <span class="code-inline">opAffectLiteral</span> special function. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">Duration</span>
{
    <span class="SCmt">// Method to handle user-defined literals with a suffix (e.g., 5's, 500'ms)</span>
    <span class="SAtr">#[Swag.ConstExpr, Swag.Implicit, Swag.Inline]</span>
    <span class="SKwd">mtd</span>(suffix: <span class="STpe">string</span>) <span class="SFct">opAffectLiteral</span>(value: <span class="STpe">s32</span>)
    {
        <span class="SCmt">// This method is triggered when a literal with a suffix is used.</span>
        <span class="SCmt">// The `suffix` parameter indicates the unit of the literal.</span>
        <span class="SCmt">// The `value` parameter is the numeric part of the literal.</span>

        <span class="SCmt">// Check if the suffix is 's' (seconds)</span>
        <span class="SCmp">#if</span> suffix == <span class="SStr">"s"</span>:
            <span class="SCmt">// Directly assign the value as seconds</span>
            timeInSeconds = value

        <span class="SCmt">// Check if the suffix is 'ms' (milliseconds)</span>
        <span class="SCmp">#elif</span> suffix == <span class="SStr">"ms"</span>:
            <span class="SCmt">// Convert milliseconds to seconds and assign</span>
            timeInSeconds = value / <span class="SNum">1000.0</span>

        <span class="SCmt">// Check if the suffix is 'min' (minutes)</span>
        <span class="SCmp">#elif</span> suffix == <span class="SStr">"min"</span>:
            <span class="SCmt">// Convert minutes to seconds (1 min = 60 seconds)</span>
            timeInSeconds = value * <span class="SNum">60.0</span>

        <span class="SCmt">// Check if the suffix is 'h' (hours)</span>
        <span class="SCmp">#elif</span> suffix == <span class="SStr">"h"</span>:
            <span class="SCmt">// Convert hours to seconds (1 hour = 3600 seconds)</span>
            timeInSeconds = value * <span class="SNum">3600.0</span>

        <span class="SCmt">// Handle unsupported or invalid suffixes</span>
        <span class="SCmp">#else</span>:
            <span class="SCmt">// Raise a compile-time error if an invalid suffix is encountered</span>
            <span class="SCmp">#error</span> <span class="SStr">"invalid duration literal suffix '"</span> ++ suffix ++ <span class="SStr">"'"</span>
    }
}</span></div>
<p>You can then use the suffix right after the literal value, as long as the type <span class="code-inline">Duration</span> is specified. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">toto</span>(x: <span class="SCst">Duration</span>) {}

<span class="SFct">#test</span>
{
    <span class="SKwd">let</span> delay1: <span class="SCst">Duration</span> = <span class="SNum">5</span>'s    <span class="SCmt">// Represents 5 seconds</span>
    <span class="SKwd">let</span> delay2: <span class="SCst">Duration</span> = <span class="SNum">500</span>'ms <span class="SCmt">// Represents 500 milliseconds</span>
    <span class="SKwd">let</span> delay3: <span class="SCst">Duration</span> = <span class="SNum">2</span>'min  <span class="SCmt">// Represents 2 minutes</span>
    <span class="SKwd">let</span> delay4: <span class="SCst">Duration</span> = <span class="SNum">1</span>'h    <span class="SCmt">// Represents 1 hour</span>

    <span class="SCmt">// Use the `Duration` type in functions</span>
    <span class="SFct">toto</span>(<span class="SNum">5</span>'ms)
    <span class="SFct">toto</span>(<span class="SNum">100</span>'h)
}</span></div>

<h3 id="_006_000_structs_swg__006_011_interface_swg">Interface</h3><p>Interfaces in Swag are <b>virtual tables</b> (a list of function pointers) that can be associated with a struct. </p>
<p>Unlike C++, the virtual table is not embedded within the struct. It is a <b>separate</b> object. This allows for implementing an interface for a given struct without altering the struct's definition. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Point2</span>
{
    x, y: <span class="STpe">f32</span>  <span class="SCmt">// Represents the coordinates of a point in a 2D space</span>
}

<span class="SKwd">struct</span> <span class="SCst">Point3</span>
{
    x, y, z: <span class="STpe">f32</span>  <span class="SCmt">// Represents the coordinates of a point in a 3D space</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Interface Declaration </h4>
<p>Here we declare an interface <span class="code-inline">IReset</span>, with two functions <span class="code-inline">set</span> and <span class="code-inline">reset</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">interface</span> <span class="SCst">IReset</span>
{
    <span class="SCmt">// The first parameter must be 'self'</span>
    <span class="SKwd">func</span> <span class="SFct">set</span>(<span class="STpe">self</span>, val: <span class="STpe">f32</span>);

    <span class="SCmt">// You can also use the 'mtd' declaration to avoid specifying the 'self' yourself</span>
    <span class="SKwd">mtd</span> <span class="SFct">reset</span>();
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Implementing an Interface </h4>
<p>You can implement an interface for any given struct with <span class="code-inline">impl</span> and <span class="code-inline">for</span>. For example, here we implement interface <span class="code-inline">IReset</span> for struct <span class="code-inline">Point2</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">IReset</span> <span class="SLgc">for</span> <span class="SCst">Point2</span>
{
    <span class="SCmt">// You must add 'impl' to indicate that you want to implement a function of the interface.</span>
    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">set</span>(val: <span class="STpe">f32</span>)
    {
        x = val              <span class="SCmt">// Set x to the given value</span>
        y = val + <span class="SNum">1</span>          <span class="SCmt">// Set y to the value incremented by 1</span>
    }

    <span class="SCmt">// Don't forget that 'mtd' is just syntactic sugar. 'func' still works.</span>
    <span class="SKwd">func</span> <span class="SKwd">impl</span> <span class="SFct">reset</span>(<span class="STpe">self</span>)
    {
        <span class="STpe">self</span>.x, <span class="STpe">self</span>.y = <span class="SNum">0</span>   <span class="SCmt">// Reset x and y to 0</span>
    }

    <span class="SCmt">// Note that you can also declare 'normal' functions or methods in an 'impl' block.</span>
    <span class="SKwd">mtd</span> <span class="SFct">myOtherMethod</span>() {}   <span class="SCmt">// Example of an additional method</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Implementing the Interface for Another Struct </h4>
<p>Similarly, we implement the <span class="code-inline">IReset</span> interface for struct <span class="code-inline">Point3</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">IReset</span> <span class="SLgc">for</span> <span class="SCst">Point3</span>
{
    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">set</span>(val: <span class="STpe">f32</span>)
    {
        x = val              <span class="SCmt">// Set x to the given value</span>
        y = val + <span class="SNum">1</span>          <span class="SCmt">// Set y to the value incremented by 1</span>
        z = val + <span class="SNum">2</span>          <span class="SCmt">// Set z to the value incremented by 2</span>
    }

    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">reset</span>()
    {
        x, y, z = <span class="SNum">0</span>          <span class="SCmt">// Reset x, y, and z to 0</span>
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Using the Interface </h4>
<p>We can then use these interfaces on either <span class="code-inline">Point2</span> or <span class="code-inline">Point3</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>

    <span class="SCmt">// To get the interface associated with a given struct, use the 'cast' operator.</span>
    <span class="SCmt">// If the compiler does not find the corresponding implementation, it will raise an error.</span>
    <span class="SKwd">var</span> itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    itf.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt2.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt2.y == <span class="SNum">10</span> + <span class="SNum">1</span>)

    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    itf.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt3.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt3.y == <span class="SNum">10</span> + <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt3.z == <span class="SNum">10</span> + <span class="SNum">2</span>)
    itf.<span class="SFct">reset</span>()
    <span class="SItr">@assert</span>(pt3.x == <span class="SNum">0</span> <span class="SLgc">and</span> pt3.y == <span class="SNum">0</span> <span class="SLgc">and</span> pt3.z == <span class="SNum">0</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Accessing Interface Methods Directly </h4>
<p>You can also access all functions declared in an interface implementation block for a given struct with a normal call. They are located in a dedicated scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>

    <span class="SCmt">// The scope where all functions are located has the same name as the interface.</span>
    pt2.<span class="SCst">IReset</span>.<span class="SFct">set</span>(<span class="SNum">10</span>)
    pt2.<span class="SCst">IReset</span>.<span class="SFct">reset</span>()
    pt3.<span class="SCst">IReset</span>.<span class="SFct">set</span>(<span class="SNum">10</span>)
    pt3.<span class="SCst">IReset</span>.<span class="SFct">reset</span>()
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Interface as a Type </h4>
<p>An interface is a real type, with a size equivalent to 2 pointers: a pointer to the <i>object</i> and a pointer to the <i>virtual table</i>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>
    <span class="SKwd">var</span> itf  = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2

    <span class="SCmp">#assert</span> <span class="SItr">#sizeof</span>(itf) == <span class="SNum">2</span> * <span class="SItr">#sizeof</span>(*<span class="STpe">void</span>)

    <span class="SCmt">// You can retrieve the concrete type associated with an interface instance with '@kindof'.</span>
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(itf) == <span class="SCst">Point2</span>)
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(itf) == <span class="SCst">Point3</span>)

    <span class="SCmt">// You can retrieve the concrete data associated with an interface instance with '@dataof'</span>
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    <span class="SItr">@assert</span>(<span class="SItr">@dataof</span>(itf) == &pt2)
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    <span class="SItr">@assert</span>(<span class="SItr">@dataof</span>(itf) == &pt3)
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Default Implementation in Interfaces </h4>
<p>When you declare an interface, you can define a default implementation for each function.  If a struct does not redefine the function, then the default implementation will be called instead. </p>
<p>Just declare a body in the interface function to provide a default implementation. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">interface</span> <span class="SCst">ITest</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">isImplemented</span>()-&gt;<span class="STpe">bool</span> { <span class="SLgc">return</span> <span class="SKwd">false</span>; }  <span class="SCmt">// Default implementation returns false</span>
}</span></div>
<p>Here we define a specific version of <span class="code-inline">isImplemented</span> for <span class="code-inline">Point2</span>, and no specific implementation for <span class="code-inline">Point3</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">ITest</span> <span class="SLgc">for</span> <span class="SCst">Point2</span>
{
    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">isImplemented</span>()-&gt;<span class="STpe">bool</span> { <span class="SLgc">return</span> <span class="SKwd">true</span>; }  <span class="SCmt">// Override to return true for Point2</span>
}

<span class="SKwd">impl</span> <span class="SCst">ITest</span> <span class="SLgc">for</span> <span class="SCst">Point3</span>
{
    <span class="SCmt">// No override, so the default implementation will be used.</span>
}</span></div>
<p>For <span class="code-inline">Point3</span>, <span class="code-inline">isImplemented()</span> will return <span class="code-inline">false</span> because this is the default implementation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> v3: <span class="SCst">Point3</span>

    <span class="SCmt">// 'isImplemented' has been redefined, and will return 'true' for Point2.</span>
    <span class="SKwd">let</span> i2 = <span class="SKwd">cast</span>(<span class="SCst">ITest</span>) v2
    <span class="SItr">@assert</span>(i2.<span class="SFct">isImplemented</span>())

    <span class="SCmt">// 'isImplemented' is not redefined, it will return false for Point3.</span>
    <span class="SKwd">let</span> i3 = <span class="SKwd">cast</span>(<span class="SCst">ITest</span>) v3
    <span class="SItr">@assert</span>(!i3.<span class="SFct">isImplemented</span>())
}</span></div>

<h2 id="_007_000_functions_swg">Functions</h2>
<h3 id="_007_000_functions_swg__007_001_declaration_swg">Declaration</h3><h4 id="_007_000_functions_swg__007_001_declaration_swg">Introduction to Function Declarations </h4>
<p>A function declaration typically starts with the <span class="code-inline">func</span> keyword, followed by the function name and  a pair of parentheses. If no parameters are needed, the parentheses are empty. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Overload]</span>
<span class="SKwd">func</span> <span class="SFct">toto</span>() {}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Returning Values from Functions </h4>
<p>If a function is intended to return a value, use <span class="code-inline">-&gt;</span> followed by the return type. The function body  must include a <span class="code-inline">return</span> statement with the corresponding value. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">toto1</span>() -&gt; <span class="STpe">s32</span>
{
    <span class="SLgc">return</span> <span class="SNum">0</span>                                        <span class="SCmt">// Returns an integer value of 0</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Inferring Return Types </h4>
<p>For simple expressions, the return type can be inferred automatically using the <span class="code-inline">=&gt;</span> operator  instead of explicitly declaring it with <span class="code-inline">-&gt;</span>. This reduces verbosity in cases where the type  is obvious. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y                        <span class="SCmt">// Return type is inferred as s32</span></span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Shorter Syntax for Functions Without Return Values </h4>
<p>When a function does not return a value, a concise syntax can be used. Instead of a full function  body, a single expression can be provided after <span class="code-inline">=</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">print</span>(val: <span class="STpe">string</span>) = <span class="SItr">@print</span>(val)               <span class="SCmt">// Prints the given string value</span></span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Defining Parameters in Functions </h4>
<p>Function parameters are defined within parentheses following the function name. Each parameter is  declared with a name and type, separated by a colon. In this example, two parameters <span class="code-inline">x</span> and <span class="code-inline">y</span>  of type <span class="code-inline">s32</span>, and an additional <span class="code-inline">unused</span> parameter of type <span class="code-inline">f32</span> are defined. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum1</span>(x, y: <span class="STpe">s32</span>, unused: <span class="STpe">f32</span>) -&gt; <span class="STpe">s32</span>
{
    <span class="SLgc">return</span> x + y                                    <span class="SCmt">// Returns the sum of x and y</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Using Default Parameter Values </h4>
<p>Parameters can be assigned default values. If the caller does not provide a value for such a  parameter, the default value is used. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum2</span>(x, y: <span class="STpe">s32</span>, unused: <span class="STpe">f32</span> = <span class="SNum">666</span>) -&gt; <span class="STpe">s32</span>
{
    <span class="SLgc">return</span> x + y                                    <span class="SCmt">// Returns the sum of x and y</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Inferred Parameter Types </h4>
<p>If a parameter has a default value, its type can be inferred from the value provided.  In this example, <span class="code-inline">x</span> and <span class="code-inline">y</span> are inferred as <span class="code-inline">f32</span> due to the <span class="code-inline">0.0</span> literal. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum3</span>(x, y = <span class="SNum">0.0</span>)
{
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(x) == <span class="STpe">f32</span>                       <span class="SCmt">// Asserts that x is of type f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(y) == <span class="STpe">f32</span>                       <span class="SCmt">// Asserts that y is of type f32</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Overloading Functions </h4>
<p>Swag allows function overloading, where multiple functions can share the same name but differ  in their parameter types or counts. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }

<span class="SAtr">#[Swag.Overload]</span>
<span class="SKwd">func</span> <span class="SFct">toto</span>(x: <span class="STpe">s32</span>, y = <span class="SCst">Values</span>.<span class="SCst">A</span>)
{
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(y) == <span class="SCst">Values</span>                    <span class="SCmt">// Asserts that y is of type Values</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Nested Functions </h4>
<p>Functions can be nested within other functions to provide encapsulation and organize code.  These nested functions are not closures but are limited to the scope in which they are declared. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sub</span>(x, y: <span class="STpe">s32</span>) =&gt; x - y                    <span class="SCmt">// Defines a nested function</span>

    <span class="SKwd">let</span> x = <span class="SFct">sub</span>(<span class="SNum">5</span>, <span class="SNum">2</span>)                               <span class="SCmt">// Calls the nested function</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">3</span>)                                 <span class="SCmt">// Asserts the result of the function call</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Named Parameters and Parameter Order </h4>
<p>Swag supports named parameters, allowing you to specify arguments in any order when calling  a function. This can enhance code readability and flexibility. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sub</span>(x, y: <span class="STpe">s32</span>) =&gt; x - y                    <span class="SCmt">// Defines a function for subtraction</span>
    {
        <span class="SKwd">let</span> x1 = <span class="SFct">sub</span>(x: <span class="SNum">5</span>, y: <span class="SNum">2</span>)                    <span class="SCmt">// Calls with named parameters</span>
        <span class="SItr">@assert</span>(x1 == <span class="SNum">3</span>)                            <span class="SCmt">// Asserts that the result is correct</span>
        <span class="SKwd">let</span> x2 = <span class="SFct">sub</span>(y: <span class="SNum">5</span>, x: <span class="SNum">2</span>)                    <span class="SCmt">// Calls with parameters in reversed order</span>
        <span class="SItr">@assert</span>(x2 == -<span class="SNum">3</span>)                           <span class="SCmt">// Asserts that the result is correct</span>
    }

    {
        <span class="SKwd">func</span> <span class="SFct">returnMe</span>(x, y: <span class="STpe">s32</span> = <span class="SNum">0</span>) =&gt; x + y * <span class="SNum">2</span>   <span class="SCmt">// Defines a function with a default parameter</span>
        <span class="SItr">@assert</span>(<span class="SFct">returnMe</span>(x: <span class="SNum">10</span>) == <span class="SNum">10</span>)              <span class="SCmt">// Calls with one parameter</span>
        <span class="SItr">@assert</span>(<span class="SFct">returnMe</span>(y: <span class="SNum">10</span>) == <span class="SNum">20</span>)              <span class="SCmt">// Calls with the second parameter only</span>
    }
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Returning Multiple Values with Anonymous Structs </h4>
<p>Anonymous structs provide a convenient way to return multiple values from a function.  This method facilitates accessing returned data either by destructuring or directly from  the struct. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>() -&gt; { x, y: <span class="STpe">f32</span> }
    {
        <span class="SLgc">return</span> {<span class="SNum">1.0</span>, <span class="SNum">2.0</span>}                          <span class="SCmt">// Returns a struct with two float values</span>
    }

    <span class="SKwd">var</span> result = <span class="SFct">myFunction</span>()                      <span class="SCmt">// Stores the result in a variable</span>
    <span class="SItr">@assert</span>(result.item0 == <span class="SNum">1.0</span>)                   <span class="SCmt">// Asserts the first item</span>
    <span class="SItr">@assert</span>(result.item1 == <span class="SNum">2.0</span>)                   <span class="SCmt">// Asserts the second item</span>

    <span class="SKwd">let</span> (x, y) = <span class="SFct">myFunction</span>()                      <span class="SCmt">// Destructures the result into variables</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">1.0</span>)                              <span class="SCmt">// Asserts the value of x</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">2.0</span>)                              <span class="SCmt">// Asserts the value of y</span>

    <span class="SKwd">let</span> (z, w) = <span class="SFct">myFunction</span>()                      <span class="SCmt">// Another destructuring example</span>
    <span class="SItr">@assert</span>(z == <span class="SNum">1.0</span>)                              <span class="SCmt">// Asserts the value of z</span>
    <span class="SItr">@assert</span>(w == <span class="SNum">2.0</span>)                              <span class="SCmt">// Asserts the value of w</span>
}</span></div>

<h3 id="_007_000_functions_swg__007_002_lambda_swg">Lambda</h3><h4 id="_007_000_functions_swg__007_002_lambda_swg">Introduction to Lambdas in Swag </h4>
<p>A lambda in Swag is a <b>pointer to a function</b>. This allows functions to be stored in variables, passed as arguments, or returned from other functions, making them versatile in functional programming. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction0</span>() {}
    <span class="SKwd">func</span> <span class="SFct">myFunction1</span>(x: <span class="STpe">s32</span>) =&gt; x * x

    <span class="SCmt">// 'ptr0' is a pointer to a function that takes no parameters and returns nothing.</span>
    <span class="SKwd">let</span> ptr0: <span class="SKwd">func</span>() = &myFunction0
    <span class="SFct">ptr0</span>() <span class="SCmt">// Call the function through the pointer</span>

    <span class="SCmt">// The type of 'ptr1' is inferred from 'myFunction1'.</span>
    <span class="SKwd">let</span> ptr1 = &myFunction1
    <span class="SItr">@assert</span>(<span class="SFct">myFunction1</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SFct">ptr1</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>) <span class="SCmt">// Call the function using the pointer</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Null Lambdas </h4>
<p>A lambda can also be null, indicating that it does not point to any function. This is useful for optional callbacks or deferred initialization of function pointers. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> lambda: <span class="SKwd">func</span>()-&gt;<span class="STpe">bool</span>
    <span class="SItr">@assert</span>(lambda == <span class="SKwd">null</span>) <span class="SCmt">// Confirm that the lambda is initially null</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Using Lambdas as Function Parameters </h4>
<p>Lambdas can be passed as parameters, enabling higher-order functions where other functions are executed dynamically based on input. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">alias</span> <span class="SCst">Callback</span> = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: <span class="SCst">Callback</span>)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value) <span class="SCmt">// Execute the lambda with the given value</span>

    <span class="SKwd">func</span> <span class="SFct">square</span>(x: <span class="STpe">s32</span>) =&gt; x * x
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, &square) == <span class="SNum">16</span>) <span class="SCmt">// Pass the square function as a callback</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Anonymous Functions </h4>
<p>Anonymous functions, or function literals, can be defined directly in your code without the need for a named identifier, making them convenient for quick, inline functionality. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cb = <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> =&gt; x * x <span class="SCmt">// Define an anonymous function that squares a number</span>
    <span class="SItr">@assert</span>(<span class="SFct">cb</span>(<span class="SNum">4</span>) == <span class="SNum">16</span>)

    cb = <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> =&gt; x * x * x <span class="SCmt">// Reassign to an anonymous function that cubes a number</span>
    <span class="SItr">@assert</span>(<span class="SFct">cb</span>(<span class="SNum">4</span>) == <span class="SNum">64</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Passing Anonymous Functions as Parameters </h4>
<p>Anonymous functions can be passed directly as arguments to other functions, without first being assigned to variables. This enables concise and flexible code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">alias</span> <span class="SCst">Callback</span> = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: <span class="SCst">Callback</span>)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value)

    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>) =&gt; x * x) == <span class="SNum">16</span>) <span class="SCmt">// Passing anonymous functions as arguments</span>
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>) =&gt; x + x) == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> { <span class="SLgc">return</span> x - x; }) == <span class="SNum">0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Inferred Parameter Types in Anonymous Functions </h4>
<p>Swag allows for inferred parameter types in anonymous functions, resulting in cleaner and more concise code, especially when the type can be unambiguously deduced from context. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">alias</span> <span class="SCst">Callback</span> = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: <span class="SCst">Callback</span>)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value)

    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) =&gt; x * x) == <span class="SNum">16</span>) <span class="SCmt">// The type of 'x' is inferred from context</span>
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) =&gt; x + x) == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) { <span class="SLgc">return</span> x - x; }) == <span class="SNum">0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Omitting Types When Assigning Lambdas </h4>
<p>When assigning a lambda to a variable, parameter and return types can be omitted if they are inferable from the variable's type. This reduces verbosity while maintaining type safety. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> fct: <span class="SKwd">func</span>(<span class="STpe">s32</span>, <span class="STpe">s32</span>)-&gt;<span class="STpe">bool</span>

    fct = <span class="SKwd">func</span>(x, y) =&gt; x == y <span class="SCmt">// Assign a lambda with inferred parameter types</span>
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">10</span>, <span class="SNum">10</span>))

    <span class="SCmt">// Assign a lambda with a block body</span>
    fct = <span class="SKwd">func</span>(x, y)
    {
        <span class="SLgc">return</span> x != y
    }
    
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">20</span>, <span class="SNum">120</span>))
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Lambdas with Default Parameter Values </h4>
<p>Lambdas in Swag can have default parameter values, enhancing their flexibility and allowing them to adapt to various contexts with minimal adjustments. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> x = <span class="SKwd">func</span>(val = <span class="SKwd">true</span>)
        {
            <span class="SItr">@assert</span>(val == <span class="SKwd">true</span>)
        }

        <span class="SFct">x</span>() <span class="SCmt">// Call the lambda without arguments</span>
    }

    {
        <span class="SKwd">var</span> x: <span class="SKwd">func</span>(val: <span class="STpe">bool</span> = <span class="SKwd">true</span>)
        x = <span class="SKwd">func</span>(val)
        {
            <span class="SItr">@assert</span>(val == <span class="SKwd">true</span>)
        }

        <span class="SFct">x</span>() <span class="SCmt">// Call with the default value</span>
        <span class="SFct">x</span>(<span class="SKwd">true</span>) <span class="SCmt">// Explicitly pass the value</span>
    }
}</span></div>

<h3 id="_007_000_functions_swg__007_003_closure_swg">Closure</h3><h4 id="_007_000_functions_swg__007_003_closure_swg">Introduction to Closures in Swag </h4>
<p>Swag supports a limited implementation of the closure concept. A closure allows capturing variables  from its surrounding scope. Swag currently permits capturing up to 48 bytes, ensuring no hidden  allocations. However, only simple variables (i.e., variables without custom behaviors such as <span class="code-inline">opDrop</span>,  <span class="code-inline">opPostCopy</span>, or <span class="code-inline">opPostMove</span>) are eligible for capture. </p>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Declaring a Closure </h4>
<p>A closure is declared similarly to a lambda, with captured variables specified between <span class="code-inline">|...|</span> before  the function parameters. For a type, the syntax is <span class="code-inline">func||(...)</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">125</span>                      <span class="SCmt">// Initialize variable 'a' with a value of 125.</span>
    <span class="SKwd">let</span> b = <span class="SNum">521</span>                      <span class="SCmt">// Initialize variable 'b' with a value of 521.</span>

    <span class="SCmt">// Capture 'a' and 'b' by value, meaning copies of these variables are captured.</span>
    <span class="SKwd">let</span> fct: <span class="SKwd">func</span>||() = <span class="SKwd">func</span>|a, b|()
    {
        <span class="SCmt">// Inside the func, the captured values 'a' and 'b' are accessible.</span>
        <span class="SItr">@assert</span>(a == <span class="SNum">125</span>)            <span class="SCmt">// Verify that the captured 'a' equals 125.</span>
        <span class="SItr">@assert</span>(b == <span class="SNum">521</span>)            <span class="SCmt">// Verify that the captured 'b' equals 521.</span>
    }

    <span class="SFct">fct</span>()                            <span class="SCmt">// Invoke the func.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Capturing Variables by Reference </h4>
<p>Variables can also be captured by reference using <span class="code-inline">&</span>. By default, variables are captured by value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SNum">125</span>                      <span class="SCmt">// Declare a mutable variable 'a' with an initial value of 125.</span>

    <span class="SCmt">// Capture 'a' by reference, meaning changes to 'a' inside the func will affect 'a' outside the func.</span>
    <span class="SKwd">let</span> fct: <span class="SKwd">func</span>||() = <span class="SKwd">func</span>|&a|()
    {
        a += <span class="SNum">1</span>                       <span class="SCmt">// Modify the captured variable 'a' by incrementing it.</span>
    }

    <span class="SFct">fct</span>()                            <span class="SCmt">// Invoke the func, which increments 'a' by 1.</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">126</span>)                <span class="SCmt">// Check that 'a' has been incremented to 126.</span>

    <span class="SFct">fct</span>()                            <span class="SCmt">// Invoke the func again, further incrementing 'a'.</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">127</span>)                <span class="SCmt">// Check that 'a' has been incremented to 127.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Assigning Lambdas to Closure Variables </h4>
<p>A closure variable can also hold a standard lambda (without capture). This provides flexibility in  assigning different types of functions to the same variable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> fct: <span class="SKwd">func</span>||(<span class="STpe">s32</span>, <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span> <span class="SCmt">// Declare a func variable that takes two integers and returns an integer.</span>

    <span class="SCmt">// Assign a simple lambda that adds two integers to the func variable 'fct'.</span>
    fct = <span class="SKwd">func</span>(x, y) =&gt; x + y

    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">1</span>, <span class="SNum">2</span>) == <span class="SNum">3</span>)          <span class="SCmt">// Test the lambda by passing values 1 and 2, expecting the result to be 3.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Capturing Complex Types </h4>
<p>You can capture arrays, structs, slices, etc., as long as they fit within the maximum capture size and  the struct is a Plain Old Data (POD) type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>]                <span class="SCmt">// Declare and initialize an array 'x' of integers.</span>

    <span class="SKwd">var</span> fct: <span class="SKwd">func</span>||(<span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>      <span class="SCmt">// Declare a closure variable that takes an integer and returns an integer.</span>

    <span class="SCmt">// Capture the array 'x' by value (a copy of the array is made).</span>
    fct = <span class="SKwd">func</span>|x|(toAdd)
    {
        <span class="SKwd">var</span> res = <span class="SNum">0</span>                  <span class="SCmt">// Initialize a result variable 'res' to accumulate the sum.</span>
        <span class="SLgc">foreach</span> v <span class="SLgc">in</span> x:              <span class="SCmt">// Iterate over the captured array 'x' and sum its elements.</span>
            res += v
        res += toAdd                 <span class="SCmt">// Add the 'toAdd' parameter to the sum.</span>
        <span class="SLgc">return</span> res
    }

    <span class="SKwd">let</span> result = <span class="SFct">fct</span>(<span class="SNum">4</span>)              <span class="SCmt">// Invoke the closure with the value 4.</span>
    <span class="SItr">@assert</span>(result == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>) <span class="SCmt">// Verify the result is the sum of 1 + 2 + 3 + 4.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Modifying Captured Variables </h4>
<p>Captured variables are mutable and part of the closure, allowing you to modify them. This enables the  creation of stateful functions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// A function that returns a closure, which increments a captured variable 'x' each time it's called.</span>
    <span class="SKwd">func</span> <span class="SFct">getInc</span>() -&gt; <span class="SKwd">func</span>||() -&gt; <span class="STpe">s32</span>
    {
        <span class="SKwd">let</span> x = <span class="SNum">10</span>                   <span class="SCmt">// Initialize 'x' with 10.</span>

        <span class="SCmt">// Return a closure that captures 'x' by value.</span>
        <span class="SLgc">return</span> <span class="SKwd">func</span>|x|() -&gt; <span class="STpe">s32</span>
        {
            x += <span class="SNum">1</span>                   <span class="SCmt">// Increment the captured 'x' and return its new value.</span>
            <span class="SLgc">return</span> x
        }
    }

    <span class="SKwd">let</span> fct = <span class="SFct">getInc</span>()               <span class="SCmt">// Obtain the closure returned by 'getInc'.</span>

    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">11</span>)             <span class="SCmt">// First call, 'x' becomes 11.</span>
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">12</span>)             <span class="SCmt">// Second call, 'x' becomes 12.</span>
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">13</span>)             <span class="SCmt">// Third call, 'x' becomes 13.</span>
}</span></div>

<h3 id="_007_000_functions_swg__007_004_mixin_swg">Mixin</h3><h4 id="_007_000_functions_swg__007_004_mixin_swg">Introduction to Swag Mixins </h4>
<p>A mixin in Swag is declared similarly to a function but with the attribute <span class="code-inline">#[Swag.Mixin]</span>.  Mixins allow injecting code into the caller's scope, manipulating variables, or executing code as if it were part of that scope. This documentation provides an overview of Swag Mixins with various examples, demonstrating their flexibility and use cases. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>() {}  <span class="SCmt">// Declaring a basic mixin with no functionality</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Basic Example of a Mixin </h4>
<p>A mixin function can directly modify variables in the caller's scope.  In this example, the mixin increments a variable <span class="code-inline">a</span> by 1 each time it is called. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>()
    {
        a += <span class="SNum">1</span>                          <span class="SCmt">// Incrementing 'a' by 1</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">myMixin</span>()                           <span class="SCmt">// Equivalent to writing 'a += 1' directly in the scope</span>
    <span class="SFct">myMixin</span>()                           <span class="SCmt">// Again, equivalent to 'a += 1'</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)                     <span class="SCmt">// Verifies that 'a' has been incremented twice</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Mixins with Parameters </h4>
<p>Mixins behave like functions, allowing parameters, default values, and even return values. This example demonstrates a mixin with an <span class="code-inline">increment</span> parameter that defaults to 1. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>(increment: <span class="STpe">s32</span> = <span class="SNum">1</span>)
    {
        a += increment                  <span class="SCmt">// Incrementing 'a' by the value of 'increment'</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">myMixin</span>()                           <span class="SCmt">// Equivalent to 'a += 1', using the default value</span>
    <span class="SFct">myMixin</span>(<span class="SNum">2</span>)                          <span class="SCmt">// Equivalent to 'a += 2', using the passed parameter</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">3</span>)                     <span class="SCmt">// Verifies that 'a' has been incremented by 1 and 2</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Mixins with Code Blocks </h4>
<p>A mixin can accept a special parameter of type <span class="code-inline">code</span>, representing a Swag code block defined at the call site.  The mixin can execute this code block multiple times using the <span class="code-inline">#mixin</span> keyword. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">doItTwice</span>(what: <span class="SKwd">code</span>)
    {
        <span class="SCmp">#mixin</span> what                      <span class="SCmt">// Executing the passed code block the first time</span>
        <span class="SCmp">#mixin</span> what                      <span class="SCmt">// Executing the passed code block the second time</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SFct">doItTwice</span>(<span class="SItr">#code</span> { a += <span class="SNum">1</span>; })         <span class="SCmt">// Incrementing 'a' twice through the mixin</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)                      <span class="SCmt">// Verifies that 'a' was incremented twice</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Mixing Code Blocks in Separate Statements </h4>
<p>When the last parameter of a mixin is of type <span class="code-inline">code</span>, the code can be declared in a separate statement after the mixin call. This provides a more natural syntax for passing code blocks. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">doItTwice</span>(value: <span class="STpe">s32</span>, what: <span class="SKwd">code</span>)
    {
        <span class="SCmp">#mixin</span> what                      <span class="SCmt">// Executing the passed code block the first time</span>
        <span class="SCmp">#mixin</span> what                      <span class="SCmt">// Executing the passed code block the second time</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SFct">doItTwice</span>(<span class="SNum">4</span>, <span class="SItr">#code</span> { a += value; })  <span class="SCmt">// Passing code block with direct syntax</span>

    <span class="SFct">doItTwice</span>(<span class="SNum">2</span>)                         <span class="SCmt">// Alternatively, pass the code block naturally</span>
    {
        a += value                       <span class="SCmt">// Incrementing 'a' by 'value' twice</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">12</span>)                     <span class="SCmt">// Verifies that 'a' was incremented as expected</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Creating Aliases with Mixins </h4>
<p>You can use the special name <span class="code-inline">#alias</span> to create a named alias for an identifier.  This enables flexible manipulation of variables through mixins. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">inc10</span>()
    {
        <span class="SItr">#alias0</span> += <span class="SNum">10</span>                    <span class="SCmt">// Incrementing the aliased variable by 10</span>
    }

    <span class="SKwd">var</span> a, b = <span class="SNum">0</span>
    <span class="SFct">inc10</span>(|a|)                           <span class="SCmt">// Use 'a' as the alias</span>
    <span class="SFct">inc10</span>(|b|)                           <span class="SCmt">// Use 'b' as the alias</span>
    <span class="SItr">@assert</span>(a == b <span class="SLgc">and</span> b == <span class="SNum">10</span>)          <span class="SCmt">// Verifies that both 'a' and 'b' were incremented by 10</span>
}

<span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">setVar</span>(value: <span class="STpe">s32</span>)
    {
        <span class="SKwd">let</span> <span class="SItr">#alias0</span> = value              <span class="SCmt">// Setting the aliased variable to 'value'</span>
    }

    <span class="SFct">setVar</span>(|a| <span class="SNum">10</span>)                       <span class="SCmt">// Set 'a' to 10</span>
    <span class="SFct">setVar</span>(|b| <span class="SNum">20</span>)                       <span class="SCmt">// Set 'b' to 20</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">10</span>)                     <span class="SCmt">// Verifies that 'a' was set to 10</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">20</span>)                     <span class="SCmt">// Verifies that 'b' was set to 20</span>
    <span class="SFct">setVar</span>(<span class="SNum">30</span>)                           <span class="SCmt">// No alias provided, so default alias '#alias0' is used</span>
    <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SNum">30</span>)               <span class="SCmt">// Verifies that '#alias0' was set to 30</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Unique Variable Names with <span class="code-inline">#mix?</span> </h4>
<p>Mixins can declare special variables named <span class="code-inline">#mix?</span>.  These variables receive a unique name each time the mixin is invoked, preventing naming conflicts and allowing multiple mixin invocations in the same scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> total: <span class="STpe">s32</span>

    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">toScope</span>()
    {
        <span class="SKwd">var</span> <span class="SItr">#mix0</span>: <span class="STpe">s32</span> = <span class="SNum">1</span>               <span class="SCmt">// Declaring a unique variable named '#mix0'</span>
        total += <span class="SItr">#mix0</span>                   <span class="SCmt">// Adding the value of '#mix0' to 'total'</span>
    }

    <span class="SFct">toScope</span>()                            <span class="SCmt">// First invocation of the mixin</span>
    <span class="SFct">toScope</span>()                            <span class="SCmt">// Second invocation</span>
    <span class="SFct">toScope</span>()                            <span class="SCmt">// Third invocation</span>

    <span class="SItr">@assert</span>(total == <span class="SNum">3</span>)                  <span class="SCmt">// Verifies that 'total' is the sum of all mixin invocations</span>
}</span></div>

<h3 id="_007_000_functions_swg__007_005_macro_swg">Macro</h3><h4 id="_007_000_functions_swg__007_005_macro_swg">Introduction to Swag Macros </h4>
<p>Macros in Swag are defined similarly to functions, with the key distinction being the <span class="code-inline">#[Swag.Macro]</span> attribute. This attribute indicates that the function is intended to be a macro, which can be reused and expanded at compile-time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>() {}
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Macro Scope </h4>
<p>Macros operate within their own scope, which is separate and isolated from the caller's scope.  This is different from mixins, which share the caller's scope.  The isolation provided by macros ensures that any variables defined inside the macro do not interfere  with or modify variables outside the macro, preventing potential naming conflicts. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>()
    {
        <span class="SCmt">// This variable 'a' is local to the macro and does not affect or interfere </span>
        <span class="SCmt">// with any 'a' outside the macro.</span>

        <span class="SKwd">var</span> a = <span class="SNum">666</span>     <span class="SCmt">// 'a' is confined to the macro's scope</span>
    }

    <span class="SCmt">// Declare a variable 'a' in the outer scope and initialize it to 0.</span>
    <span class="SKwd">let</span> a = <span class="SNum">0</span>

    <span class="SCmt">// Call the macro `myMacro()`. The macro defines its own 'a', but this does not </span>
    <span class="SCmt">// conflict with the outer 'a'.</span>

    <span class="SFct">myMacro</span>()          <span class="SCmt">// No conflict with the outer 'a'</span>

    <span class="SCmt">// Verify that the outer 'a' remains unchanged.</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Resolving Identifiers Outside the Macro Scope </h4>
<p>Macros typically have their own scope, which means variables inside them are isolated from the outer environment. However, using the <span class="code-inline">#up</span> keyword, you can explicitly reference and modify variables that are defined outside the macro. This allows the macro to interact with the caller's environment. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>()
    {
        <span class="SCmt">// Use `#up` to access and modify the variable `a` from the outer scope (the scope where the </span>
        <span class="SCmt">// macro is called). Without `#up`, `a` would be assumed to be a variable within the macro's </span>
        <span class="SCmt">// own scope (which might not exist).</span>

        <span class="SItr">#up</span> a += <span class="SNum">1</span>  <span class="SCmt">// Increments the outer 'a' by 1</span>
    }

    <span class="SCmt">// Declare a variable `a` in the outer scope</span>
    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SCmt">// Call the macro `myMacro()`, which increments the outer `a` by 1 using `#up`</span>
    <span class="SFct">myMacro</span>()   <span class="SCmt">// `a` becomes 1</span>

    <span class="SCmt">// Call the macro `myMacro()` again, which increments `a` by 1 again</span>
    <span class="SFct">myMacro</span>()   <span class="SCmt">// `a` becomes 2</span>

    <span class="SCmt">// Verify that `a` has been incremented twice</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Macros with Code Parameters </h4>
<p>Macros can take <span class="code-inline">code</span> parameters, enabling you to pass and insert code blocks dynamically within the macro. This feature is similar to mixins but within the macro's scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>(what: <span class="SKwd">code</span>)
    {
        <span class="SCmp">#mixin</span> what                            <span class="SCmt">// Inserts the provided code block</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SFct">myMacro</span>(<span class="SItr">#code</span>
    {
        <span class="SItr">#up</span> a += <span class="SNum">1</span>                             <span class="SCmt">// Increment 'a' within the code block</span>
    })

    <span class="SFct">myMacro</span>()
    {
        <span class="SItr">#up</span> a += <span class="SNum">1</span>                             <span class="SCmt">// Alternative way to pass the code block directly</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)                            <span class="SCmt">// Verifies that 'a' has been incremented twice</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Forcing Code into the Caller’s Scope with <span class="code-inline">#macro</span> </h4>
<p>The <span class="code-inline">#macro</span> keyword can be used to ensure that the code within a macro operates in the caller's scope. This technique negates the need for the <span class="code-inline">#up</span> keyword when referencing the caller's variables. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>(what: <span class="SKwd">code</span>)
    {
        <span class="SKwd">var</span> a = <span class="SNum">666</span>                            <span class="SCmt">// Declare 'a' in the macro's own scope</span>

        <span class="SCmp">#macro</span>                                 <span class="SCmt">// Ensures the following code operates in the caller's scope</span>
        {
            <span class="SCmp">#mixin</span> <span class="SItr">#up</span> what                    <span class="SCmt">// References the caller's 'a'</span>
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">1</span>
    <span class="SFct">myMacro</span>()
    {
        a += <span class="SNum">2</span>                                 <span class="SCmt">// 'a' references the caller's 'a' due to '#macro'</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">3</span>)                            <span class="SCmt">// Verifies that the caller's 'a' was incremented</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Performance Considerations with Macros </h4>
<p>Macros in Swag can extend the language capabilities without relying on function pointers. This avoids the overhead associated with lambda calls, making macros a performance-efficient choice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">repeat</span>(count: <span class="STpe">s32</span>, what: <span class="SKwd">code</span>)
    {
        <span class="SKwd">var</span> a = <span class="SNum">0</span>
        <span class="SLgc">while</span> a &lt; count
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SKwd">var</span> index = <span class="SItr">#up</span> a              <span class="SCmt">// 'index' references 'a' from the caller's scope</span>
                <span class="SCmp">#mixin</span> <span class="SItr">#up</span> what                <span class="SCmt">// Insert the provided code block</span>
            }
            a += <span class="SNum">1</span>
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">repeat</span>(<span class="SNum">5</span>)
    {
        a += index                             <span class="SCmt">// Sum 'index' values from the macro's loop</span>
    }
    <span class="SItr">@assert</span>(a == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)            <span class="SCmt">// Verifies the sum after the first repeat</span>

    <span class="SFct">repeat</span>(<span class="SNum">3</span>)
    {
        a += index                             <span class="SCmt">// Continue summing with a new loop</span>
    }
    <span class="SItr">@assert</span>(a == <span class="SNum">10</span> + <span class="SNum">3</span>)                       <span class="SCmt">// Verifies the final sum after both repeats</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Handling <span class="code-inline">break</span> and <span class="code-inline">continue</span> in User Code with Macros </h4>
<p>Macros allow you to customize the behavior of <span class="code-inline">break</span> and <span class="code-inline">continue</span> statements in loops. This can be particularly useful in complex nested loops where you want a <span class="code-inline">break</span> or <span class="code-inline">continue</span> statement to affect an outer loop, not just the immediate one. </p>
<p>By using a macro, you can define aliases for <span class="code-inline">break</span> and <span class="code-inline">continue</span> that allow you to control exactly which loop they affect. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">repeatSquare</span>(count: <span class="STpe">u32</span>, what: <span class="SKwd">code</span>)
    {
        <span class="SCmt">// Define a label `Up` for the scope that will allow us to break out of the outermost loop</span>
        <span class="SCmp">#scope</span> <span class="SCst">Up</span>                              
        
        <span class="SCmt">// Outer for: this will run `count` times</span>
        <span class="SLgc">for</span> count
        {
            <span class="SCmt">// Inner for: also runs `count` times</span>
            <span class="SLgc">for</span> count
            {
                <span class="SCmp">#macro</span>
                {
                    <span class="SCmt">// Injects the user code `what` here.</span>
                    <span class="SCmt">// The `#mixin` directive replaces certain parts of the user code:</span>
                    <span class="SCmt">// - `break` in the user code is replaced with `break in Up`, meaning it will break </span>
                    <span class="SCmt">//   out of the `Up` scope (i.e., the outer `for`).</span>
                    <span class="SCmt">// - You can similarly redefine `continue` if needed.</span>
                    <span class="SCmp">#mixin</span> <span class="SItr">#up</span> what <span class="SLgc">where</span> { <span class="SLgc">break</span> = <span class="SLgc">break</span> <span class="SLgc">in</span> <span class="SCst">Up</span>; }
                }
            }
        }
    }

    <span class="SCmt">// Initialize a variable `a` to 0</span>
    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SCmt">// Call the `repeatSquare` function with `count = 5`</span>
    <span class="SCmt">// The provided code block increments `a` and breaks when `a == 10`</span>
    <span class="SFct">repeatSquare</span>(<span class="SNum">5</span>)
    {
        a += <span class="SNum">1</span>
        <span class="SLgc">if</span> a == <span class="SNum">10</span>:
            <span class="SCmt">// This `break` statement is replaced by `break in Up` due to the macro,</span>
            <span class="SCmt">// meaning it will exit the outermost `for`, not just the inner `for`.</span>
            <span class="SLgc">break</span>  
    }

    <span class="SCmt">// Assertion to check if `a` is indeed 10 after the `for` exits</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">10</span>)  <span class="SCmt">// Verifies that the loop exited when `a` reached 10</span>
}</span></div>
<h5 id="_007_000_functions_swg__007_005_macro_swg">Another example: </h5>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">repeatSquare</span>(count: <span class="STpe">u32</span>, what: <span class="SKwd">code</span>)
    {
        <span class="SCmt">// Define a label `Outer` for the scope that will allow us to </span>
        <span class="SCmt">// break or continue from the outermost loop</span>
        <span class="SCmp">#scope</span> <span class="SCst">Outer</span>

        <span class="SCmt">// Outer for: this will run `count` times</span>
        <span class="SLgc">for</span> count
        {
            <span class="SCmt">// Inner for: also runs `count` times</span>
            <span class="SLgc">for</span> count
            {
                <span class="SCmp">#macro</span>
                {
                    <span class="SCmt">// `break` in the user code is replaced with `break in Outer`, exiting the outer loop.</span>
                    <span class="SCmt">// `continue` is replaced with `break`, skipping to the next iteration of the inner loop.</span>
                    <span class="SCmp">#mixin</span> <span class="SItr">#up</span> what <span class="SLgc">where</span> { <span class="SLgc">break</span> = <span class="SLgc">break</span> <span class="SLgc">in</span> <span class="SCst">Outer</span>; <span class="SLgc">continue</span> = <span class="SLgc">break</span>; }
                }
            }
        }
    }

    <span class="SCmt">// Initialize a variable `a` to 0 and a variable `b` to 0</span>
    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SKwd">var</span> b = <span class="SNum">0</span>

    <span class="SCmt">// Call the `repeatSquare` function with `count = 5`</span>
    <span class="SCmt">// The provided code block increments `a` and uses `continue` and `break` under certain conditions</span>
    <span class="SFct">repeatSquare</span>(<span class="SNum">5</span>)
    {
        a += <span class="SNum">1</span>

        <span class="SCmt">// If `a` is divisible by 3, skip to the next iteration of the outer loop (both loops)</span>
        <span class="SLgc">if</span> a % <span class="SNum">3</span> == <span class="SNum">0</span>:
            <span class="SLgc">continue</span>

        <span class="SCmt">// Increment `b` only if `continue` was not called</span>
        b += <span class="SNum">1</span>

        <span class="SCmt">// If `a` equals 8, exit both loops</span>
        <span class="SLgc">if</span> a == <span class="SNum">8</span>:
            <span class="SLgc">break</span>
    }
   
    <span class="SCmt">// Verifies that the loop exited when `a` reached 8</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">8</span>) 

    <span class="SCmt">// Verifies that `b` was incremented 6 times, skipping increments when `a` was divisible by 3</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">6</span>) 
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Using Aliases in Macros </h4>
<p>Special variables named <span class="code-inline">#alias&lt;num&gt;</span> can be used within macros, similar to mixins. These aliases allow you to define and access specific variables within a macro. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">call</span>(v: <span class="STpe">s32</span>, stmt: <span class="SKwd">code</span>)
    {
        <span class="SKwd">let</span> <span class="SItr">#alias0</span> = v                        <span class="SCmt">// Assign 'v' to '#alias0'</span>
        <span class="SKwd">let</span> <span class="SItr">#alias1</span> = v * <span class="SNum">2</span>                    <span class="SCmt">// Assign 'v * 2' to '#alias1'</span>
        <span class="SCmp">#mixin</span> stmt                            <span class="SCmt">// Insert the provided code block</span>
    }

    <span class="SFct">call</span>(<span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SNum">20</span>)                 <span class="SCmt">// Verifies '#alias0' equals 20</span>
        <span class="SItr">@assert</span>(<span class="SItr">#alias1</span> == <span class="SNum">40</span>)                 <span class="SCmt">// Verifies '#alias1' equals 40</span>
    }

    <span class="SFct">call</span>(|x| <span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(x == <span class="SNum">20</span>)                       <span class="SCmt">// 'x' is used as an alias for '#alias0'</span>
        <span class="SItr">@assert</span>(<span class="SItr">#alias1</span> == <span class="SNum">40</span>)                 <span class="SCmt">// '#alias1' remains unchanged</span>
    }

    <span class="SFct">call</span>(|x, y| <span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(x == <span class="SNum">20</span>)                       <span class="SCmt">// 'x' replaces '#alias0'</span>
        <span class="SItr">@assert</span>(y == <span class="SNum">40</span>)                       <span class="SCmt">// 'y' replaces '#alias1'</span>
    }
}</span></div>

<h3 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Variadic parameters</h3><h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Introduction to Variadic Functions </h4>
<p>Variadic functions accept a variable number of arguments using <span class="code-inline">...</span>. This capability enables functions to handle a flexible number of parameters, making them more versatile in scenarios where the exact number of arguments is not known in advance. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(value: <span class="STpe">bool</span>, parameters: ...)
    {
        <span class="SCmt">// This function can now accept any number of additional arguments after 'value'.</span>
    }

    <span class="SFct">myFunction</span>(<span class="SKwd">true</span>, <span class="SNum">4</span>, <span class="SStr">"true"</span>, <span class="SNum">5.6</span>)   <span class="SCmt">// Passes 4, "true", and 5.6 as additional parameters.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Working with Variadic Parameters as Slices </h4>
<p>When a function takes a variadic parameter, the <span class="code-inline">parameters</span> variable is treated as a slice of type  <span class="code-inline">any</span>. This feature allows the function to flexibly handle different types of arguments at runtime. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(parameters: ...)
    {
        <span class="SCmt">// Determine the number of parameters passed.</span>
        <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(parameters) == <span class="SNum">3</span>)

        <span class="SCmt">// Each parameter is initially treated as 'any' type.</span>
        <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(parameters[<span class="SNum">0</span>]) == <span class="STpe">any</span>
        <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(parameters[<span class="SNum">1</span>]) == <span class="STpe">any</span>
        <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">any</span>

        <span class="SCmt">// Use '@kindof' to determine the actual type of each parameter at runtime.</span>
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">0</span>]) == <span class="STpe">s32</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">1</span>]) == <span class="STpe">string</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">f32</span>)
    }

    <span class="SFct">myFunction</span>(<span class="SNum">4</span>, <span class="SStr">"true"</span>, <span class="SNum">5.6</span>)         <span class="SCmt">// Passes an integer, string, and float.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Forcing Variadic Parameters to a Specific Type </h4>
<p>If all variadic parameters are of the same type, you can enforce that type using type annotations. This practice makes the parameters' type explicit, ensuring they are not treated as <span class="code-inline">any</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(value: <span class="STpe">bool</span>, parameters: <span class="STpe">s32</span>...)
    {
        <span class="SCmt">// All parameters in 'parameters' must be of type 's32'.</span>
        <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(parameters[<span class="SNum">0</span>]).name == <span class="SStr">"s32"</span>
        <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(parameters[<span class="SNum">1</span>]).name == <span class="SStr">"s32"</span>
        <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">s32</span>
        <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(parameters[<span class="SNum">3</span>]) == <span class="STpe">s32</span>

        <span class="SCmt">// Verify that the parameters have been passed correctly.</span>
        <span class="SItr">@assert</span>(parameters[<span class="SNum">0</span>] == <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">1</span>] == <span class="SNum">20</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">2</span>] == <span class="SNum">30</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">3</span>] == <span class="SNum">40</span>)
    }

    <span class="SFct">myFunction</span>(<span class="SKwd">true</span>, <span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>)   <span class="SCmt">// Passes four integers.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Passing Variadic Parameters Between Functions </h4>
<p>You can pass variadic parameters from one function to another, preserving their types and values. This technique is useful when you need to delegate tasks to other functions without losing the  variadic nature of the arguments. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">A</span>(params: ...)
    {
        <span class="SCmt">// Expecting a string and a boolean.</span>
        <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(params) == <span class="SNum">2</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(params[<span class="SNum">0</span>]) == <span class="STpe">string</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(params[<span class="SNum">1</span>]) == <span class="STpe">bool</span>)
        <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) params[<span class="SNum">0</span>] == <span class="SStr">"value"</span>)
        <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) params[<span class="SNum">1</span>] == <span class="SKwd">true</span>)
    }

    <span class="SKwd">func</span> <span class="SFct">B</span>(params: ...)
    {
        <span class="SCmt">// Pass the variadic parameters from B to A.</span>
        <span class="SFct">A</span>(params)
    }

    <span class="SFct">B</span>(<span class="SStr">"value"</span>, <span class="SKwd">true</span>)                   <span class="SCmt">// Passes the parameters to function A through B.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Spreading Arrays or Slices to Variadic Parameters </h4>
<p>You can spread the contents of an array or slice into variadic parameters using <span class="code-inline">@spread</span>. This  feature is handy when you have a collection of values that you want to pass as individual arguments. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sum</span>(params: <span class="STpe">s32</span>...)-&gt;<span class="STpe">s32</span>
    {
        <span class="SCmt">// Variadic parameters can be iterated as they are slices.</span>
        <span class="SKwd">var</span> total = <span class="SNum">0</span>
        <span class="SLgc">foreach</span> v <span class="SLgc">in</span> params:
            total += v
        <span class="SLgc">return</span> total
    }

    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SKwd">let</span> res = <span class="SFct">sum</span>(<span class="SItr">@spread</span>(arr))        <span class="SCmt">// Equivalent to sum(1, 2, 3, 4).</span>
    <span class="SItr">@assert</span>(res == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)

    <span class="SKwd">let</span> res1 = <span class="SFct">sum</span>(<span class="SItr">@spread</span>(arr[<span class="SNum">1.</span>.<span class="SNum">3</span>])) <span class="SCmt">// Equivalent to sum(2, 3, 4).</span>
    <span class="SItr">@assert</span>(res1 == <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Advanced Example: Combining Variadic and Non-Variadic Parameters </h4>
<p>This example demonstrates how to combine fixed parameters with variadic parameters and use them  together in a function. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">private</span> <span class="SKwd">func</span> <span class="SFct">print</span>()
{
    <span class="SKwd">func</span> <span class="SFct">logMessage</span>(prefix: <span class="STpe">string</span>, messages: ...)
    {
        <span class="SCmt">// Print each message with the given prefix.</span>
        <span class="SLgc">foreach</span> msg <span class="SLgc">in</span> messages
        {
            <span class="SItr">@print</span>(prefix, <span class="SStr">" =&gt; "</span>, <span class="SKwd">cast</span>(<span class="STpe">string</span>) msg)
        }
    }

    <span class="SFct">logMessage</span>(<span class="SStr">"Error: "</span>, <span class="SStr">"File not found"</span>, <span class="SStr">"Access denied"</span>, <span class="SStr">"Disk full"</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Example: Handling Different Types in Variadic Parameters </h4>
<p>This example shows how to handle different types within a variadic function, such as summing  integers and concatenating strings. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">processParameters</span>(params: ...)-&gt;<span class="STpe">s32</span>
    {
        <span class="SKwd">var</span> sum = <span class="SNum">0</span>
        
        <span class="SLgc">foreach</span> p <span class="SLgc">in</span> params
        {
            <span class="SLgc">switch</span> <span class="SItr">@kindof</span>(p)
            {
            <span class="SLgc">case</span> <span class="STpe">s32</span>:
                sum += <span class="SNum">1</span>
            <span class="SLgc">case</span> <span class="STpe">string</span>:
                sum += <span class="SNum">10</span>
            }   
        }

        <span class="SLgc">return</span> sum    
    }

    <span class="SKwd">let</span> result = <span class="SFct">processParameters</span>(<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SStr">"Hello, "</span>, <span class="SNum">3</span>, <span class="SStr">"World!"</span>)
    <span class="SItr">@assert</span>(result == <span class="SNum">1</span> + <span class="SNum">1</span> + <span class="SNum">10</span> + <span class="SNum">1</span> + <span class="SNum">10</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_007_ufcs_swg">Ufcs</h3><h4 id="_007_000_functions_swg__007_007_ufcs_swg">Introduction to Uniform Function Call Syntax (UFCS) </h4>
<p><i>UFCS</i> stands for <i>Uniform Function Call Syntax</i>. It allows any function to be called using the  <span class="code-inline">param.func()</span> form when the first parameter of <span class="code-inline">func()</span> matches the type of <span class="code-inline">param</span>. This syntax  provides a way to call static functions as if they were methods on an instance, enhancing  readability and method-like behavior. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunc</span>(param: <span class="STpe">bool</span>) =&gt; param

    <span class="SKwd">let</span> b = <span class="SKwd">false</span>
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(b) == b.<span class="SFct">myFunc</span>()) <span class="SCmt">// Using UFCS to call 'myFunc' as if it were a method on 'b'.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_007_ufcs_swg">Static Functions as Methods </h4>
<p>In Swag, all functions are <i>static</i>, meaning they are not inherently bound to instances of structs  or classes. However, UFCS allows these functions to be called in a method-like style, making  struct manipulation more intuitive and the code more readable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x, y: <span class="STpe">s32</span> }

    <span class="SKwd">func</span> <span class="SFct">set</span>(<span class="SKwd">using</span> pt: *<span class="SCst">Point</span>, value: <span class="STpe">s32</span>)
    {
        x, y = value
    }

    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>

    <span class="SCmt">// Using UFCS to call 'set' as if it were a method of 'pt'.</span>
    pt.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">10</span>)

    <span class="SCmt">// Normal static function call.</span>
    <span class="SFct">set</span>(&pt, <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">20</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_007_ufcs_swg">UFCS with Multiple Parameters </h4>
<p>UFCS works seamlessly with functions that take multiple parameters, as long as the first parameter  matches the type of the instance. This allows for consistent and readable function calls, even with  more complex function signatures. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Vector</span> { x, y: <span class="STpe">f32</span> }

    <span class="SKwd">func</span> <span class="SFct">add</span>(<span class="SKwd">using</span> vec: *<span class="SCst">Vector</span>, dx: <span class="STpe">f32</span>, dy: <span class="STpe">f32</span>)
    {
        x += dx
        y += dy
    }

    <span class="SKwd">var</span> v: <span class="SCst">Vector</span>

    <span class="SCmt">// Using UFCS to call 'add' as if it were a method of 'v'.</span>
    v.<span class="SFct">add</span>(<span class="SNum">1.0</span>, <span class="SNum">2.0</span>)
    <span class="SItr">@assert</span>(v.x == <span class="SNum">1.0</span> <span class="SLgc">and</span> v.y == <span class="SNum">2.0</span>)

    <span class="SCmt">// Normal static function call.</span>
    <span class="SFct">add</span>(&v, <span class="SNum">3.0</span>, <span class="SNum">4.0</span>)
    <span class="SItr">@assert</span>(v.x == <span class="SNum">4.0</span> <span class="SLgc">and</span> v.y == <span class="SNum">6.0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_007_ufcs_swg">UFCS and Function Overloading </h4>
<p>UFCS supports function overloading, where the appropriate function is chosen based on the types  of the parameters provided. This feature ensures that UFCS remains versatile and applicable across  a wide range of function signatures, allowing for flexible and context-appropriate behavior. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Complex</span> { real, imag: <span class="STpe">f32</span> }

    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">multiply</span>(c: *<span class="SCst">Complex</span>, scalar: <span class="STpe">f32</span>)
    {
        c.real *= scalar
        c.imag *= scalar
    }

    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">multiply</span>(<span class="SKwd">using</span> c: *<span class="SCst">Complex</span>, other: *<span class="SCst">Complex</span>)
    {
        real = (real * other.real) - (imag * other.imag)
        imag = (real * other.imag) + (imag * other.real)
    }

    <span class="SKwd">var</span> c1 = <span class="SCst">Complex</span>{<span class="SNum">2.0</span>, <span class="SNum">3.0</span>}
    <span class="SKwd">var</span> c2 = <span class="SCst">Complex</span>{<span class="SNum">4.0</span>, <span class="SNum">5.0</span>}

    <span class="SCmt">// Using UFCS to multiply by a scalar.</span>
    c1.<span class="SFct">multiply</span>(<span class="SNum">2.0</span>)
    <span class="SItr">@assert</span>(c1.real == <span class="SNum">4.0</span> <span class="SLgc">and</span> c1.imag == <span class="SNum">6.0</span>)

    <span class="SCmt">// Using UFCS to multiply by another Complex number.</span>
    c1.<span class="SFct">multiply</span>(&c2)
    <span class="SItr">@assert</span>(c1.real == -<span class="SNum">14.0</span> <span class="SLgc">and</span> c1.imag == -<span class="SNum">46.0</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_008_constexpr_swg">Constexpr</h3><h4 id="_007_000_functions_swg__007_008_constexpr_swg"><span class="code-inline">Swag.ConstExpr</span> Functions </h4>
<p>A function marked with <span class="code-inline">Swag.ConstExpr</span> can be executed at compile time by the compiler if  the input values are known at that stage. This allows the function's result to be "baked"  into the code, reducing runtime computation and potentially improving performance. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">f32</span>) =&gt; x + y     <span class="SCmt">// This function can be executed at compile time.</span></span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Compile-Time Computation </h4>
<p>In the example below, the compiler will execute the <span class="code-inline">sum</span> function at compile time,  embedding the result directly into the constant <span class="code-inline">G</span>. The value of <span class="code-inline">G</span> will be <span class="code-inline">3</span>,  computed during the compilation process, ensuring no runtime overhead for this calculation. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">G</span> = <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)
<span class="SCmp">#assert</span> <span class="SCst">G</span> == <span class="SNum">3</span>                   <span class="SCmt">// The result of `sum(1, 2)` is computed at compile time and verified.</span></span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Using <span class="code-inline">Swag.ConstExpr</span> with Complex Expressions </h4>
<p><span class="code-inline">Swag.ConstExpr</span> functions can handle more complex expressions as well. The following example  shows how a compile-time function can perform multiple operations and still have its result  computed during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">complexCalc</span>(a, b, c: <span class="STpe">f32</span>) =&gt; (a + b) * c / <span class="SNum">2</span>

<span class="SKwd">const</span> result = <span class="SFct">complexCalc</span>(<span class="SNum">4</span>, <span class="SNum">5</span>, <span class="SNum">6</span>)
<span class="SCmp">#assert</span> result == <span class="SNum">27.0</span>           <span class="SCmt">// The complex expression is evaluated at compile time.</span></span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Compile-Time Execution of Array Initializations </h4>
<p><span class="code-inline">Swag.ConstExpr</span> functions can also be used to initialize arrays or other data structures at  compile time. This example demonstrates how an array of precomputed values is created. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">square</span>(n: <span class="STpe">s32</span>) =&gt; n * n

<span class="SKwd">const</span> <span class="SCst">Squares</span> = [<span class="SFct">square</span>(<span class="SNum">1</span>), <span class="SFct">square</span>(<span class="SNum">2</span>), <span class="SFct">square</span>(<span class="SNum">3</span>), <span class="SFct">square</span>(<span class="SNum">4</span>), <span class="SFct">square</span>(<span class="SNum">5</span>)]
<span class="SCmp">#assert</span> <span class="SCst">Squares</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>
<span class="SCmp">#assert</span> <span class="SCst">Squares</span>[<span class="SNum">1</span>] == <span class="SNum">4</span>
<span class="SCmp">#assert</span> <span class="SCst">Squares</span>[<span class="SNum">2</span>] == <span class="SNum">9</span>
<span class="SCmp">#assert</span> <span class="SCst">Squares</span>[<span class="SNum">3</span>] == <span class="SNum">16</span>
<span class="SCmp">#assert</span> <span class="SCst">Squares</span>[<span class="SNum">4</span>] == <span class="SNum">25</span></span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Forcing Compile-Time Execution with <span class="code-inline">#run</span> </h4>
<p>If a function is not marked with <span class="code-inline">Swag.ConstExpr</span>, but you still want to execute it at compile time,  you can use the <span class="code-inline">#run</span> directive. This forces the compiler to execute the function during  compilation and use the result in your code. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">mul</span>(x, y: <span class="STpe">f32</span>) =&gt; x * y      <span class="SCmt">// This is a normal function, not marked as `Swag.ConstExpr`.</span>

<span class="SCmt">// The `#run` directive forces the compile-time execution of `mul(3, 6)`.</span>
<span class="SKwd">const</span> <span class="SCst">G1</span> = <span class="SFct">#run</span> <span class="SFct">mul</span>(<span class="SNum">3</span>, <span class="SNum">6</span>)
<span class="SCmp">#assert</span> <span class="SCst">G1</span> == <span class="SNum">18</span>                  <span class="SCmt">// The result of `mul(3, 6)` is computed at compile time and verified.</span></span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Compile-Time Evaluation of Conditional Logic </h4>
<p>Using <span class="code-inline">Swag.ConstExpr</span> or <span class="code-inline">#run</span>, you can evaluate conditional logic at compile time,  enabling the embedding of decision results directly into your constants. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">max</span>(a, b: <span class="STpe">s32</span>) =&gt; a &gt; b ? a : b

<span class="SKwd">const</span> <span class="SCst">MaxValue</span> = <span class="SFct">max</span>(<span class="SNum">10</span>, <span class="SNum">20</span>)
<span class="SCmp">#assert</span> <span class="SCst">MaxValue</span> == <span class="SNum">20</span>            <span class="SCmt">// The comparison is performed at compile time.</span></span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Compile-Time Initialization of Structs </h4>
<p>You can initialize complex data structures, such as structs, at compile time using <span class="code-inline">Swag.ConstExpr</span>.  This ensures that the structure's values are determined before runtime. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">struct</span> <span class="SCst">Point</span> { x, y: <span class="STpe">s32</span> }

<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">createPoint</span>(a, b: <span class="STpe">s32</span>) =&gt; <span class="SCst">Point</span>{a, b}

<span class="SKwd">const</span> <span class="SCst">Origin</span> = <span class="SFct">createPoint</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)
<span class="SCmp">#assert</span> <span class="SCst">Origin</span>.x == <span class="SNum">1</span> <span class="SLgc">and</span> <span class="SCst">Origin</span>.y == <span class="SNum">2</span>  <span class="SCmt">// The Point is initialized at compile time.</span></span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Using <span class="code-inline">#run</span> with User-Defined Types </h4>
<p>In cases where <span class="code-inline">Swag.ConstExpr</span> is not used, <span class="code-inline">#run</span> can force compile-time execution even  for user-defined types like structs or enums. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Rectangle</span> { width, height: <span class="STpe">s32</span> }

<span class="SKwd">func</span> <span class="SFct">area</span>(rect: <span class="SCst">Rectangle</span>) =&gt; rect.width * rect.height

<span class="SKwd">const</span> <span class="SCst">RectStatic</span> = <span class="SCst">Rectangle</span>{ <span class="SNum">5</span>, <span class="SNum">10</span> }
<span class="SKwd">const</span> <span class="SCst">RectArea</span> = <span class="SFct">#run</span> <span class="SFct">area</span>(<span class="SCst">RectStatic</span>)
<span class="SCmp">#assert</span> <span class="SCst">RectArea</span> == <span class="SNum">50</span>            <span class="SCmt">// The area of the rectangle is computed at compile time.</span></span></div>

<h3 id="_007_000_functions_swg__007_009_function_overloading_swg">Function overloading</h3><h4 id="_007_000_functions_swg__007_009_function_overloading_swg">Function Overloading with <span class="code-inline">Swag.Overload</span> </h4>
<p>In Swag, it is possible to define multiple functions with the same name as long as their parameter signatures differ.  This capability, known as function overloading, allows you to provide different implementations of a function  depending on the number or types of arguments passed. To enable function overloading, the functions must be  decorated with the <span class="code-inline">Swag.Overload</span> attribute. This ensures that the compiler can correctly distinguish between  the different versions based on the arguments provided at the call site. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr, Swag.Overload]</span>
{
    <span class="SCmt">// Overloaded function with two parameters</span>
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y                                <span class="SCmt">// Sums two integers</span>

    <span class="SCmt">// Overloaded function with three parameters</span>
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y, z: <span class="STpe">s32</span>) =&gt; x + y + z                         <span class="SCmt">// Sums three integers</span>
}</span></div>
<p>In the example above, the <span class="code-inline">sum</span> function is overloaded to handle both two-parameter and three-parameter cases.  When the function is called, the compiler automatically selects the appropriate version based on the number of arguments. This allows for more flexible and intuitive code, where the same function name can be used for different operations  depending on the context. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span> <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>) == <span class="SNum">3</span>        <span class="SCmt">// Calls the two-parameter version of `sum`, which returns 3</span>
<span class="SCmp">#assert</span> <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>) == <span class="SNum">6</span>     <span class="SCmt">// Calls the three-parameter version of `sum`, which returns 6</span></span></div>

<h3 id="_007_000_functions_swg__007_010_discard_swg">Discard</h3><h4 id="_007_000_functions_swg__007_010_discard_swg">Return Value Usage </h4>
<p>In Swag, there is a strict requirement that every function's return value must be utilized. This design choice  helps prevent potential bugs that can arise from accidentally ignoring the result of a function call. If a function  is invoked and its return value is not used, the compiler will generate an error. This ensures that developers are  consciously handling all return values, which can be critical for maintaining the correctness of the code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y

    <span class="SCmt">// Uncommenting the following line would generate a compiler error,</span>
    <span class="SCmt">// because the return value of 'sum' is not used.</span>
    <span class="SCmt">// sum(2, 3)</span>

    <span class="SCmt">// To explicitly discard the return value when you don't need it, use 'discard' at the call site.</span>
    <span class="SCmt">// The return value of 'sum' is intentionally ignored here.</span>
    <span class="SKwd">discard</span> <span class="SFct">sum</span>(<span class="SNum">2</span>, <span class="SNum">3</span>)                            
}</span></div>
<h4 id="_007_000_functions_swg__007_010_discard_swg"><span class="code-inline">Swag.Discardable</span> Attribute </h4>
<p>There are scenarios where the return value of a function may be optional or non-critical to the operation.  In such cases, the function can be marked with the <span class="code-inline">Swag.Discardable</span> attribute. This attribute permits the caller  to ignore the return value without triggering a compiler error, making it clear that the result is not necessarily  intended to be used. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Discardable]</span>
    <span class="SKwd">func</span> <span class="SFct">mul</span>(x, y: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span> =&gt; x * y

    <span class="SCmt">// It's allowed to ignore the return value of 'mul' without using 'discard'.</span>
    <span class="SFct">mul</span>(<span class="SNum">2</span>, <span class="SNum">4</span>)                                    
}</span></div>

<h3 id="_007_000_functions_swg__007_011_retval_swg">Retval</h3><h4 id="_007_000_functions_swg__007_011_retval_swg">The <span class="code-inline">retval</span> special type </h4>
<p>In Swag, the <span class="code-inline">retval</span> type acts as an alias to the function's return type. This feature allows developers to handle  the return value within the function in a more convenient and flexible manner. By using <span class="code-inline">retval</span>, you can define  and manipulate the variable intended to be returned, without explicitly specifying its type. This abstraction  simplifies code maintenance and enhances readability, especially when dealing with complex return types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>() -&gt; <span class="STpe">s32</span>
    {
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span>                         <span class="SCmt">// 'retval' is equivalent to 's32' in this context.</span>
        result = <span class="SNum">10</span>                                <span class="SCmt">// Assign a value to 'result'.</span>
        <span class="SLgc">return</span> result                              <span class="SCmt">// Return the value stored in 'result'.</span>
    }

    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">10</span>)                          <span class="SCmt">// The function returns 10 using the `retval` type.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_011_retval_swg">Optimizing return values </h4>
<p>The <span class="code-inline">retval</span> type also serves as an optimization hint to the compiler. When used correctly, it allows the compiler  to reference the caller's storage directly, bypassing unnecessary copies of the return value. This is particularly  beneficial for functions returning large or complex types, such as structs, tuples, or arrays, where performance  can be significantly improved by reducing memory operations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { x, y, z: <span class="STpe">f64</span> }

    <span class="SKwd">func</span> <span class="SFct">getWhite</span>() -&gt; <span class="SCst">RGB</span>
    {
        <span class="SCmt">// Using `retval = undefined` avoids unnecessary clearing of the returned struct.</span>
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span> = <span class="SKwd">undefined</span>             <span class="SCmt">// 'retval' here is equivalent to 'RGB'.</span>
        result.x = <span class="SNum">0.5</span>                             <span class="SCmt">// Assign value to the 'x' field.</span>
        result.y = <span class="SNum">0.1</span>                             <span class="SCmt">// Assign value to the 'y' field.</span>
        result.z = <span class="SNum">1.0</span>                             <span class="SCmt">// Assign value to the 'z' field.</span>
        <span class="SLgc">return</span> result                              <span class="SCmt">// Return the fully initialized struct.</span>
    }

    <span class="SCmt">// The `getWhite` function allows direct assignment to the tuple (r, g, b) without additional storage.</span>
    <span class="SKwd">let</span> (r, g, b) = <span class="SFct">getWhite</span>()
    <span class="SItr">@assert</span>(r == <span class="SNum">0.5</span>)                              <span class="SCmt">// Verifies the 'x' field is correctly assigned.</span>
    <span class="SItr">@assert</span>(g == <span class="SNum">0.1</span>)                              <span class="SCmt">// Verifies the 'y' field is correctly assigned.</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">1.0</span>)                              <span class="SCmt">// Verifies the 'z' field is correctly assigned.</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_011_retval_swg">Returning arrays efficiently </h4>
<p>The use of <span class="code-inline">retval</span> is highly recommended when returning large data structures like arrays or structs.  By leveraging <span class="code-inline">retval</span>, you can avoid unnecessary memory operations, such as clearing or copying large objects,  resulting in more efficient and performant code. This approach is especially useful in performance-critical  applications where minimizing overhead is crucial. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>() -&gt; [<span class="SNum">255</span>] <span class="STpe">s32</span>
    {
        <span class="SCmt">// Using `retval = undefined` avoids clearing the array, improving performance.</span>
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span> = <span class="SKwd">undefined</span>             <span class="SCmt">// 'retval' here is an array of 255 integers.</span>
        <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SNum">255</span>:                              <span class="SCmt">// Loop through each index in the array.</span>
            result[i] = i                          <span class="SCmt">// Assign the index value to each array element.</span>
        <span class="SLgc">return</span> result                              <span class="SCmt">// Return the fully populated array.</span>
    }

    <span class="SKwd">var</span> arr = <span class="SFct">toto</span>()
    <span class="SItr">@assert</span>(arr[<span class="SNum">0</span>] == <span class="SNum">0</span>)                           <span class="SCmt">// Verifies that the first element is correctly set.</span>
    <span class="SItr">@assert</span>(arr[<span class="SNum">100</span>] == <span class="SNum">100</span>)                       <span class="SCmt">// Verifies that the 101st element is correctly set.</span>
    <span class="SItr">@assert</span>(arr[<span class="SNum">254</span>] == <span class="SNum">254</span>)                       <span class="SCmt">// Verifies that the last element is correctly set.</span>
}</span></div>

<h3 id="_007_000_functions_swg__007_012_foreign_swg">Foreign</h3><h4 id="_007_000_functions_swg__007_012_foreign_swg">Interoperability with External Modules </h4>
<p>Swag provides the ability to interoperate with external modules, such as Dynamic Link Libraries (DLLs) on Windows,  which export C functions. This interoperability allows Swag code to invoke functions from these external libraries,  enabling seamless integration with system-level APIs and third-party libraries. This feature is particularly  powerful for extending Swag applications with capabilities provided by external systems. </p>
<h4 id="_007_000_functions_swg__007_012_foreign_swg">Declaring External Functions </h4>
<p>To use functions from external modules, you declare them in your Swag code with the <span class="code-inline">Swag.Foreign</span> attribute.  This attribute specifies the external module where the function is located. The module name can refer to either  a Swag-compiled module or an external system module, depending on your needs. The exact location of these external  modules varies by operating system, so it is important to specify the correct module name based on the target platform. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Foreign("kernel32")]</span>
<span class="SKwd">func</span> <span class="SFct">ExitProcess</span>(uExitCode: <span class="STpe">u32</span>);                 <span class="SCmt">// Declares the 'ExitProcess' function from 'kernel32.dll'</span>

<span class="SAtr">#[Swag.Foreign("kernel32")]</span>
{
    <span class="SKwd">func</span> <span class="SFct">Sleep</span>(dwMilliseconds: <span class="STpe">u32</span>);              <span class="SCmt">// Declares the 'Sleep' function from 'kernel32.dll'</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_012_foreign_swg">Example: Windows API </h4>
<p>In this example, two functions (<span class="code-inline">ExitProcess</span> and <span class="code-inline">Sleep</span>) are declared as external functions that reside in the  <span class="code-inline">kernel32.dll</span> module, a core system library on Windows. By declaring these functions with <span class="code-inline">Swag.Foreign</span>, you  can directly invoke Windows API functions within your Swag code, allowing for system-level operations such as  exiting a process or pausing execution for a specified amount of time. </p>
<h4 id="_007_000_functions_swg__007_012_foreign_swg">Linking to External Libraries </h4>
<p>When working with external modules, it is essential to ensure that the corresponding library is linked to the  final executable. This linking process is crucial because it allows the linker to resolve the references to  the external functions declared in your code. </p>
<ul>
<li>Use the <span class="code-inline">#foreignlib</span> directive to specify which external library should be linked during the compilation process.</li>
<li>This directive informs the Swag compiler to include the specified external module during the linking stage, ensuring</li>
</ul>
<p>  that all external function calls are correctly resolved at runtime. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Links the 'kernel32.dll' library to the executable, resolving external function calls.</span>
<span class="SCmp">#foreignlib</span> <span class="SStr">"kernel32"</span></span></div>

<h3 id="_007_000_functions_swg__007_013_special_functions_swg">Special functions</h3><div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Main Function (<span class="code-inline">#main</span>) </h4>
<p>The <span class="code-inline">#main</span> function is the primary entry point for the program, similar to the <span class="code-inline">main()</span>  function in languages like C or C++. This function is unique within each module, meaning  you can only define it <b>once</b> per module.  </p>
<p>In the context of an executable program, <span class="code-inline">#main</span> is where the program's execution begins.  Any code placed within this function will be the first to execute when the program runs. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Handling Program Arguments </h4>
<p>Unlike the <span class="code-inline">main()</span> function in C, the <span class="code-inline">#main</span> function in this language does not  take arguments directly. Instead, command-line arguments can be retrieved using the  intrinsic <span class="code-inline">@args</span>, which provides a slice containing all the arguments passed to the program. </p>
<p>Here’s an example demonstrating how to work with command-line arguments: </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SCmt">// Retrieve the program arguments using the @args intrinsic</span>
    <span class="SKwd">var</span> myArgs = <span class="SItr">@args</span>()
    
    <span class="SCmt">// Determine the number of arguments passed</span>
    <span class="SKwd">var</span> count = <span class="SItr">@countof</span>(myArgs)
    
    <span class="SCmt">// Handle a specific argument, for example, enabling fullscreen mode</span>
    <span class="SLgc">if</span> myArgs[<span class="SNum">0</span>] == <span class="SStr">"fullscreen"</span>
    {
        <span class="SCmt">// Logic to initiate fullscreen mode would go here</span>
        ...
    }
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Pre-Main Function (<span class="code-inline">#premain</span>) </h4>
<p>The <span class="code-inline">#premain</span> function is executed after all <span class="code-inline">#init</span> functions across all modules have  completed, but before the <span class="code-inline">#main</span> function begins.  </p>
<p>This function is typically used for tasks that need to be performed after module  initialization, yet before the main program logic is executed. It's useful for setup  tasks that depend on the initial state of the program being fully established. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#premain</span>
{
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Initialization Function (<span class="code-inline">#init</span>) </h4>
<p>The <span class="code-inline">#init</span> function is executed at runtime during the module initialization phase.  You can define multiple <span class="code-inline">#init</span> functions within the same module, allowing different  parts of the module to initialize independently. </p>
<p>The execution order of <span class="code-inline">#init</span> functions within the same module is undefined,  so you should not rely on a specific sequence of initialization tasks. However,  all <span class="code-inline">#init</span> functions will execute before any code in the <span class="code-inline">#main</span> or <span class="code-inline">#premain</span> functions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#init</span>
{
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Drop Function (<span class="code-inline">#drop</span>) </h4>
<p>The <span class="code-inline">#drop</span> function acts as a cleanup function and is called when a module is unloaded  at runtime. It serves as the counterpart to <span class="code-inline">#init</span>, ensuring that any resources allocated  during initialization are properly released. </p>
<p>Just like <span class="code-inline">#init</span>, you can define multiple <span class="code-inline">#drop</span> functions within a module, and  the order of their execution is undefined. However, <span class="code-inline">#drop</span> functions are guaranteed  to run in the reverse order of their corresponding <span class="code-inline">#init</span> functions, ensuring a  logical cleanup process. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#drop</span>
{
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Test Function (<span class="code-inline">#test</span>) </h4>
<p>The <span class="code-inline">#test</span> function is a specialized function designed for testing purposes.  It is typically used within the <span class="code-inline">tests/</span> folder of your workspace and is executed  only when the program is run in test mode. </p>
<p>This function is crucial for validating the correctness and functionality of your  code in a controlled environment before it is deployed or released. It allows you  to define test cases and assertions to ensure that your code behaves as expected. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
}</span></div>

<h2 id="_008_000_intrinsics_swg">Intrinsics</h2><h3 id="_008_000_intrinsics_swg">Intrinsics in Swag </h3>
<p>Intrinsics are built-in functions provided by the Swag compiler that offer low-level operations, often directly mapping to  specific machine instructions or providing essential compiler utilities. All intrinsics in Swag are prefixed with <span class="code-inline">@</span>,  which is reserved exclusively for these functions. </p>
<p>This document provides a categorized list of all intrinsics available in Swag. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip</span></div>
<h3 id="_008_000_intrinsics_swg">Base Intrinsics </h3>
<p>These base intrinsics provide fundamental functionalities that are commonly needed across various Swag programs. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@assert</span>(value: <span class="STpe">bool</span>);                       <span class="SCmt">// Asserts that a condition is true, used for debugging.</span>
<span class="SKwd">func</span> <span class="SItr">@breakpoint</span>();                              <span class="SCmt">// Triggers a breakpoint in the debugger.</span>
<span class="SKwd">func</span> <span class="SItr">@getcontext</span>() -&gt; *<span class="SCst">Swag</span>.<span class="SCst">Context</span>;             <span class="SCmt">// Retrieves the current execution context.</span>
<span class="SKwd">func</span> <span class="SItr">@setcontext</span>(context: <span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">Context</span>);  <span class="SCmt">// Sets the current execution context.</span>
<span class="SKwd">func</span> <span class="SItr">@isbytecode</span>() -&gt; <span class="STpe">bool</span>;                      <span class="SCmt">// Checks if the code is being executed as bytecode.</span>
<span class="SKwd">func</span> <span class="SItr">@compiler</span>() -&gt; <span class="SCst">Swag</span>.<span class="SCst">ICompiler</span>;              <span class="SCmt">// Retrieves the current compiler interface.</span>

<span class="SKwd">func</span> <span class="SItr">@args</span>() -&gt; <span class="SKwd">const</span> [..] <span class="STpe">string</span>;               <span class="SCmt">// Returns the command-line arguments passed to the program.</span>
<span class="SItr">@panic</span>()                                         <span class="SCmt">// Triggers a panic, stopping program execution.</span>
<span class="SItr">@compilererror</span>()                                 <span class="SCmt">// Generates a compile-time error.</span>
<span class="SItr">@compilerwarning</span>()                               <span class="SCmt">// Generates a compile-time warning.</span></span></div>
<h3 id="_008_000_intrinsics_swg">Built-in Intrinsics </h3>
<p>These intrinsics provide essential built-in operations related to type and memory management, typically for  low-level or performance-critical code. </p>
<div class="code-block"><span class="SCde"><span class="SItr">@spread</span>()                   <span class="SCmt">// Expands a value into a wider context.</span>
<span class="SItr">@init</span>()                     <span class="SCmt">// Initializes a variable or memory area.</span>
<span class="SItr">@drop</span>()                     <span class="SCmt">// Destroys a variable or memory area.</span>
<span class="SItr">@postmove</span>()                 <span class="SCmt">// Called after a move operation to handle post-move logic.</span>
<span class="SItr">@postcopy</span>()                 <span class="SCmt">// Called after a copy operation to handle post-copy logic.</span>
<span class="SItr">#sizeof</span>()                   <span class="SCmt">// Returns the size, in bytes, of a type or variable.</span>
<span class="SItr">#alignof</span>()                  <span class="SCmt">// Returns the alignment requirement of a type.</span>
<span class="SItr">#offsetof</span>()                 <span class="SCmt">// Returns the offset, in bytes, of a field within a struct.</span>
<span class="SItr">#typeof</span>()                   <span class="SCmt">// Returns the type of a given expression.</span>
<span class="SItr">@kindof</span>()                   <span class="SCmt">// Returns the kind (e.g., primitive, struct) of a type.</span>
<span class="SItr">@countof</span>()                  <span class="SCmt">// Returns the number of elements in an array.</span>
<span class="SItr">#stringof</span>()                 <span class="SCmt">// Returns the string representation of a type or expression.</span>
<span class="SItr">@dataof</span>()                   <span class="SCmt">// Returns a pointer to the underlying data of a type.</span>
<span class="SItr">@mkslice</span>()                  <span class="SCmt">// Creates a slice from a given data pointer and length.</span>
<span class="SItr">@mkstring</span>()                 <span class="SCmt">// Creates a string from a given data pointer and length.</span>
<span class="SItr">@mkany</span>()                    <span class="SCmt">// Creates a generic `any` type from a given value.</span>
<span class="SItr">@mkinterface</span>()              <span class="SCmt">// Creates an interface type from a given implementation.</span>
<span class="SItr">@mkcallback</span>()               <span class="SCmt">// Creates a callback from a given function pointer.</span>
<span class="SItr">@pinfos</span>()                   <span class="SCmt">// Retrieves program information.</span>
<span class="SItr">#isconstexpr</span>()              <span class="SCmt">// Checks if an expression is a constant expression.</span>
<span class="SItr">@itftableof</span>()               <span class="SCmt">// Returns the interface table for a given type.</span></span></div>
<h3 id="_008_000_intrinsics_swg">Memory-related Intrinsics </h3>
<p>These intrinsics offer memory management operations, allowing for fine-grained control over memory allocation,  deallocation, and manipulation. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@alloc</span>(size: <span class="STpe">u64</span>) -&gt; *<span class="STpe">void</span>;                         <span class="SCmt">// Allocates a block of memory of the given size.</span>
<span class="SKwd">func</span> <span class="SItr">@realloc</span>(ptr: *<span class="STpe">void</span>, size: <span class="STpe">u64</span>) -&gt; *<span class="STpe">void</span>;           <span class="SCmt">// Reallocates a block of memory to a new size.</span>
<span class="SKwd">func</span> <span class="SItr">@free</span>(ptr: *<span class="STpe">void</span>);                                  <span class="SCmt">// Frees a previously allocated block of memory.</span>
<span class="SKwd">func</span> <span class="SItr">@memset</span>(dst: *<span class="STpe">void</span>, value: <span class="STpe">u8</span>, size: <span class="STpe">u64</span>);          <span class="SCmt">// Sets a block of memory to a specific value.</span>
<span class="SKwd">func</span> <span class="SItr">@memcpy</span>(dst: *<span class="STpe">void</span>, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>);   <span class="SCmt">// Copies a block of memory from one location to another.</span>
<span class="SKwd">func</span> <span class="SItr">@memmove</span>(dst: *<span class="STpe">void</span>, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>);  <span class="SCmt">// Moves a block of memory, handling overlapping areas.</span>
<span class="SKwd">func</span> <span class="SItr">@memcmp</span>(dst, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>) -&gt; <span class="STpe">s32</span>;   <span class="SCmt">// Compares two blocks of memory.</span>
<span class="SKwd">func</span> <span class="SItr">@strlen</span>(value: <span class="SKwd">const</span> *<span class="STpe">u8</span>) -&gt; <span class="STpe">u64</span>;                   <span class="SCmt">// Returns the length of a null-terminated string.</span></span></div>
<h3 id="_008_000_intrinsics_swg">Atomic Operations </h3>
<p>Atomic operations provide thread-safe manipulation of variables in shared memory, ensuring data consistency  without the need for explicit locking mechanisms. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s8</span>, value: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u8</span>, value: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s8</span>, value: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u8</span>, value: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s8</span>, value: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u8</span>, value: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s8</span>, value: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u8</span>, value: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s8</span>, exchangeWith: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s16</span>, exchangeWith: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s32</span>, exchangeWith: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s64</span>, exchangeWith: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u8</span>, exchangeWith: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u16</span>, exchangeWith: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u32</span>, exchangeWith: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u64</span>, exchangeWith: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s8</span>, compareTo, exchangeWith: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s16</span>, compareTo, exchangeWith: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s32</span>, compareTo, exchangeWith: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s64</span>, compareTo, exchangeWith: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u8</span>, compareTo, exchangeWith: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u16</span>, compareTo, exchangeWith: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u32</span>, compareTo, exchangeWith: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u64</span>, compareTo, exchangeWith: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;</span></div>
<h3 id="_008_000_intrinsics_swg">Math Intrinsics </h3>
<p>These intrinsics provide various mathematical operations, including trigonometric, logarithmic, and other common  functions, offering precise control over mathematical calculations in Swag programs. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@sqrt</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the square root of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@sqrt</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the square root of a 64-bit floating-point number.</span>

<span class="SKwd">func</span> <span class="SItr">@sin</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;             <span class="SCmt">// Computes the sine of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@sin</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;             <span class="SCmt">// Computes the sine of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@cos</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;             <span class="SCmt">// Computes the cosine of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@cos</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;             <span class="SCmt">// Computes the cosine of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@tan</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;             <span class="SCmt">// Computes the tangent of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@tan</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;             <span class="SCmt">// Computes the tangent of a 64-bit floating-point number.</span>

<span class="SKwd">func</span> <span class="SItr">@sinh</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the hyperbolic sine of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@sinh</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the hyperbolic sine of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@cosh</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the hyperbolic cosine of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@cosh</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the hyperbolic cosine of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@tanh</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the hyperbolic tangent of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@tanh</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the hyperbolic tangent of a 64-bit floating-point number.</span>

<span class="SKwd">func</span> <span class="SItr">@asin</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the arc sine of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@asin</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the arc sine of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@acos</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the arc cosine of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@acos</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the arc cosine of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@atan</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the arc tangent of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@atan</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the arc tangent of a 64-bit floating-point number.</span>

<span class="SKwd">func</span> <span class="SItr">@log</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;             <span class="SCmt">// Computes the natural logarithm of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@log</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;             <span class="SCmt">// Computes the natural logarithm of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@log2</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the base-2 logarithm of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@log2</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the base-2 logarithm of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@log10</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;           <span class="SCmt">// Computes the base-10 logarithm of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@log10</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;           <span class="SCmt">// Computes the base-10 logarithm of a 64-bit floating-point number.</span>

<span class="SKwd">func</span> <span class="SItr">@floor</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;           <span class="SCmt">// Computes the floor of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@floor</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;           <span class="SCmt">// Computes the floor of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@ceil</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes the ceiling of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@ceil</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes the ceiling of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@trunc</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;           <span class="SCmt">// Truncates a 32-bit floating-point number to its integer part.</span>
<span class="SKwd">func</span> <span class="SItr">@trunc</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;           <span class="SCmt">// Truncates a 64-bit floating-point number to its integer part.</span>
<span class="SKwd">func</span> <span class="SItr">@round</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;           <span class="SCmt">// Rounds a 32-bit floating-point number to the nearest integer.</span>
<span class="SKwd">func</span> <span class="SItr">@round</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;           <span class="SCmt">// Rounds a 64-bit floating-point number to the nearest integer.</span>

<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;               <span class="SCmt">// Computes the absolute value of an 8-bit signed integer.</span>
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;             <span class="SCmt">// Computes the absolute value of a 16-bit signed integer.</span>
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;             <span class="SCmt">// Computes the absolute value of a 32-bit signed integer.</span>
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;             <span class="SCmt">// Computes the absolute value of a 64-bit signed integer.</span>
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;             <span class="SCmt">// Computes the absolute value of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;             <span class="SCmt">// Computes the absolute value of a 64-bit floating-point number.</span>

<span class="SKwd">func</span> <span class="SItr">@exp</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;             <span class="SCmt">// Computes the exponential function of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@exp</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;             <span class="SCmt">// Computes the exponential function of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@exp2</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;            <span class="SCmt">// Computes 2 raised to the power of a 32-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@exp2</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;            <span class="SCmt">// Computes 2 raised to the power of a 64-bit floating-point number.</span>
<span class="SKwd">func</span> <span class="SItr">@pow</span>(value1, value2: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;    <span class="SCmt">// Computes the power function for 32-bit floating-point numbers.</span>
<span class="SKwd">func</span> <span class="SItr">@pow</span>(value1, value2: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;    <span class="SCmt">// Computes the power function for 64-bit floating-point numbers.</span>

<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;      <span class="SCmt">// Returns the minimum of two 8-bit signed integers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;    <span class="SCmt">// Returns the minimum of two 16-bit signed integers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;    <span class="SCmt">// Returns the minimum of two 32-bit signed integers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;    <span class="SCmt">// Returns the minimum of two 64-bit signed integers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;      <span class="SCmt">// Returns the minimum of two 8-bit unsigned integers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;    <span class="SCmt">// Returns the minimum of two 16-bit unsigned integers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;    <span class="SCmt">// Returns the minimum of two 32-bit unsigned integers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;    <span class="SCmt">// Returns the minimum of two 64-bit unsigned integers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;    <span class="SCmt">// Returns the minimum of two 32-bit floating-point numbers.</span>
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;    <span class="SCmt">// Returns the minimum of two 64-bit floating-point numbers.</span>

<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">s8</span>) -&gt; <span class="STpe">s8</span>;      <span class="SCmt">// Returns the maximum of two 8-bit signed integers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;    <span class="SCmt">// Returns the maximum of two 16-bit signed integers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;    <span class="SCmt">// Returns the maximum of two 32-bit signed integers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;    <span class="SCmt">// Returns the maximum of two 64-bit signed integers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;      <span class="SCmt">// Returns the maximum of two 8-bit unsigned integers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;    <span class="SCmt">// Returns the maximum of two 16-bit unsigned integers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;    <span class="SCmt">// Returns the maximum of two 32-bit unsigned integers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;    <span class="SCmt">// Returns the maximum of two 64-bit unsigned integers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;    <span class="SCmt">// Returns the maximum of two 32-bit floating-point numbers.</span>
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;    <span class="SCmt">// Returns the maximum of two 64-bit floating-point numbers.</span>

<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;        <span class="SCmt">// Counts the number of set bits in an 8-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;      <span class="SCmt">// Counts the number of set bits in a 16-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;      <span class="SCmt">// Counts the number of set bits in a 32-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;      <span class="SCmt">// Counts the number of set bits in a 64-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;        <span class="SCmt">// Counts the number of trailing zeros in an 8-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;      <span class="SCmt">// Counts the number of trailing zeros in a 16-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;      <span class="SCmt">// Counts the number of trailing zeros in a 32-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;      <span class="SCmt">// Counts the number of trailing zeros in a 64-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;        <span class="SCmt">// Counts the number of leading zeros in an 8-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;      <span class="SCmt">// Counts the number of leading zeros in a 16-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;      <span class="SCmt">// Counts the number of leading zeros in a 32-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;      <span class="SCmt">// Counts the number of leading zeros in a 64-bit unsigned integer.</span>

<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;        <span class="SCmt">// Swaps the byte order of a 16-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;        <span class="SCmt">// Swaps the byte order of a 32-bit unsigned integer.</span>
<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;        <span class="SCmt">// Swaps the byte order of a 64-bit unsigned integer.</span>

<span class="SKwd">func</span> <span class="SItr">@rol</span>(value, num: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;          <span class="SCmt">// Rotates an 8-bit unsigned integer left by a specified number of bits.</span>
<span class="SKwd">func</span> <span class="SItr">@rol</span>(value, num: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;        <span class="SCmt">// Rotates a 16-bit unsigned integer left by a specified number of bits.</span>
<span class="SKwd">func</span> <span class="SItr">@rol</span>(value, num: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;        <span class="SCmt">// Rotates a 32-bit unsigned integer left by a specified number of bits.</span>
<span class="SKwd">func</span> <span class="SItr">@rol</span>(value, num: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;        <span class="SCmt">// Rotates a 64-bit unsigned integer left by a specified number of bits.</span>

<span class="SKwd">func</span> <span class="SItr">@ror</span>(value, num: <span class="STpe">u8</span>) -&gt; <span class="STpe">u8</span>;          <span class="SCmt">// Rotates an 8-bit unsigned integer right by a specified number of bits.</span>
<span class="SKwd">func</span> <span class="SItr">@ror</span>(value, num: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;        <span class="SCmt">// Rotates a 16-bit unsigned integer right by a specified number of bits.</span>
<span class="SKwd">func</span> <span class="SItr">@ror</span>(value, num: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;        <span class="SCmt">// Rotates a 32-bit unsigned integer right by a specified number of bits.</span>
<span class="SKwd">func</span> <span class="SItr">@ror</span>(value, num: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;        <span class="SCmt">// Rotates a 64-bit unsigned integer right by a specified number of bits.</span>

<span class="SKwd">func</span> <span class="SItr">@muladd</span>(val1, val2, val3: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;     <span class="SCmt">// Performs a multiply-add operation for 32-bit floating-point numbers.</span>
<span class="SKwd">func</span> <span class="SItr">@muladd</span>(val1, val2, val3: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;     <span class="SCmt">// Performs a multiply-add operation for 64-bit floating-point numbers.</span></span></div>

<h3 id="_008_000_intrinsics_swg__008_001_init_swg">Init</h3><h4 id="_008_000_intrinsics_swg__008_001_init_swg"><span class="code-inline">@init</span> Intrinsic </h4>
<p>The <span class="code-inline">@init</span> intrinsic in Swag is used to reinitialize a variable or a memory block to its default value. This intrinsic is especially useful when you need to reset the state of variables or memory blocks without manually setting each field or element. The ability to reset variables to their default states or to a specific value simplifies state management in Swag applications. </p>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Reinitializing a Single Variable </h4>
<p>To reinitialize a single variable to its default value, simply pass the variable as an argument to <span class="code-inline">@init</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">666</span>
    <span class="SItr">@init</span>(x)           <span class="SCmt">// Reinitialize 'x' to its default value</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)    <span class="SCmt">// The default value for a simple variable like 'x' is 0</span>
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Reinitializing Multiple Elements </h4>
<p>You can also specify a pointer to a memory block and the count of elements to reinitialize a specific number of elements within that memory block. This is useful for resetting arrays or parts of them. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@init</span>(&x, <span class="SNum">2</span>)       <span class="SCmt">// Reinitialize the first 2 elements of the array 'x'</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">0</span>) <span class="SCmt">// Both elements are reset to 0</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">0</span>)

    x[<span class="SNum">0</span>] = <span class="SNum">1</span>
    x[<span class="SNum">1</span>] = <span class="SNum">2</span>
    <span class="SItr">@init</span>(x)           <span class="SCmt">// You can also reinitialize the entire variable directly</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">0</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Initializing with a Specific Value </h4>
<p>The <span class="code-inline">@init</span> intrinsic can also initialize a variable with a specific value instead of its default. This provides a flexible way to reset variables to any desired state. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">666</span>'<span class="STpe">f32</span>
    <span class="SItr">@init</span>(x)(<span class="SNum">3.14</span>)      <span class="SCmt">// Reinitialize 'x' to 3.14 instead of 0</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">3.14</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Initializing Arrays with a Specific Value </h4>
<p>The <span class="code-inline">@init</span> intrinsic can be applied to arrays to reinitialize all elements with a specific value, ensuring consistency across the array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@init</span>(&x, <span class="SNum">2</span>)(<span class="SNum">555</span>)  <span class="SCmt">// Reinitialize both elements of the array to 555</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">555</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Reinitializing Structs </h4>
<p>When applied to structs, <span class="code-inline">@init</span> restores the struct to its default state as defined in its declaration. This is particularly useful for resetting complex data structures. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span> }

    <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span>{<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>}

    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">30</span>)

    <span class="SItr">@init</span>(rgb)          <span class="SCmt">// Reset 'rgb' to its default values</span>
    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">3</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Specifying Initialization Values for Structs </h4>
<p>You can also initialize a struct with specific values directly using <span class="code-inline">@init</span>, providing a convenient way to set all fields at once. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span> }

    <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span>{<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>}

    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">30</span>)

    <span class="SItr">@init</span>(rgb)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>) <span class="SCmt">// Initialize 'rgb' with specific values</span>
    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">7</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Reinitializing Arrays of Structs </h4>
<p>The <span class="code-inline">@init</span> intrinsic can be used with arrays of structs, allowing you to reinitialize each element with specific values. This is particularly useful for resetting large data structures efficiently. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span> }

    <span class="SKwd">var</span> rgb: [<span class="SNum">4</span>] <span class="SCst">RGB</span>
    <span class="SItr">@init</span>(&rgb, <span class="SNum">4</span>)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>) <span class="SCmt">// Initialize all elements of the array to (5, 6, 7)</span>
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].b == <span class="SNum">7</span>)

    <span class="SItr">@init</span>(rgb)(<span class="SNum">50</span>, <span class="SNum">60</span>, <span class="SNum">70</span>)  <span class="SCmt">// Reinitialize the array with new values</span>
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].r == <span class="SNum">50</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].g == <span class="SNum">60</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].b == <span class="SNum">70</span>)
}</span></div>

<h3 id="_008_000_intrinsics_swg__008_002_drop_swg">Drop</h3><h4 id="_008_000_intrinsics_swg__008_002_drop_swg"><span class="code-inline">@drop</span> Intrinsic </h4>
<p>The <span class="code-inline">@drop</span> intrinsic calls the <span class="code-inline">opDrop</span> method if it is defined for the struct. This ensures that any necessary cleanup operations (such as freeing resources) are performed before the variable is reinitialized. <span class="code-inline">@drop</span> is particularly useful in resource management, where explicit cleanup is required before resetting the variable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span> }

    <span class="SKwd">var</span> rgb: [<span class="SNum">4</span>] <span class="SCst">RGB</span>

    <span class="SCmt">// Calling `@drop` on the array. If `RGB` had an `opDrop` defined, it would be called here.</span>
    <span class="SItr">@drop</span>(&rgb, <span class="SNum">4</span>)

    <span class="SItr">@init</span>(&rgb, <span class="SNum">4</span>)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>) <span class="SCmt">// Reinitialize after dropping</span>
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].b == <span class="SNum">7</span>)
}</span></div>

<h2 id="_009_000_generics_swg">Generics</h2>
<h3 id="_009_000_generics_swg__009_001_functions_swg">Functions</h3><h4 id="_009_000_generics_swg__009_001_functions_swg">Generic Functions </h4>
<p>A function can be made generic by specifying type parameters after the <span class="code-inline">func</span> keyword. These type  parameters allow the function to operate on various types using the same implementation. The generic  type parameters are placed within parentheses after <span class="code-inline">func</span>. When calling the function, the generic  types are specified using <span class="code-inline">funcCall'(type1, type2, ...)</span>. If there is only one generic parameter,  you can omit the parentheses. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Example of a generic function where 'T' is the generic type.</span>
        <span class="SKwd">func</span>(<span class="SKwd">var</span> <span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">s32</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)             <span class="SCmt">// Explicitly passing 's32' as the generic type.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>)         <span class="SCmt">// Explicitly passing 'f32' as the generic type.</span>
    }

    {
        <span class="SCmt">// Declaring the generic type without 'var'.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">s32</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)             <span class="SCmt">// Type 's32' is inferred as the generic type.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>)         <span class="SCmt">// Type 'f32' is inferred as the generic type.</span>
    }

    {
        <span class="SCmt">// Setting a default value for the generic type.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span> = <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">4</span>)             <span class="SCmt">// Uses default type 's32'.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>)         <span class="SCmt">// Overrides the default type with 'f32'.</span>
    }

    {
        <span class="SCmt">// Using multiple generic parameters.</span>
        <span class="SKwd">func</span>(<span class="SCst">K</span>, <span class="SCst">V</span>) <span class="SFct">myFunc</span>(key: <span class="SCst">K</span>, value: <span class="SCst">V</span>) =&gt; value

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>, <span class="SStr">"value"</span>) == <span class="SStr">"value"</span>)     <span class="SCmt">// Both K and V are deduced from the parameters.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="STpe">string</span>)(<span class="SNum">2</span>, <span class="SStr">"value"</span>) == <span class="SStr">"value"</span>) <span class="SCmt">// K and V are specified explicitly.</span>

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>, <span class="SKwd">true</span>) == <span class="SKwd">true</span>)           <span class="SCmt">// Type deduction used for both K and V.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="STpe">bool</span>)(<span class="SNum">2</span>, <span class="SKwd">true</span>) == <span class="SKwd">true</span>)   <span class="SCmt">// Explicit type declaration for K and V.</span>
    }
}</span></div>
<h4 id="_009_000_generics_swg__009_001_functions_swg">Type Deduction </h4>
<p>Generic types can often be deduced from the function's parameters, eliminating the need to specify  the type explicitly at the call site. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">4</span>)               <span class="SCmt">// The type 'T' is deduced as 's32'.</span>
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2.0</span>'<span class="STpe">f32</span>) == <span class="SNum">4.0</span>)           <span class="SCmt">// The type 'T' is deduced as 'f32'.</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_001_functions_swg">Using Constants as Generic Parameters </h4>
<p>In addition to types, you can also specify constants as generic parameters. </p>
<p>In the example below, <span class="code-inline">N</span> is a constant of type <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SKwd">const</span> <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() = <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>'<span class="SNum">10</span>()                                <span class="SCmt">// Call the function with a constant value of 10.</span>
}</span></div>
<p><span class="code-inline">const</span> can be omitted when declaring constants, as an identifier followed by a type is considered  a constant. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() = <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>'<span class="SNum">10</span>()                                <span class="SCmt">// Function called with a constant value of 10.</span>
}</span></div>
<p>You can also assign a default value to a constant parameter. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">N</span>: <span class="STpe">s32</span> = <span class="SNum">10</span>) <span class="SFct">myFunc</span>() = <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>()                                   <span class="SCmt">// Calls the function using the default value of 10.</span>
}</span></div>
<p>If you declare the constant using <span class="code-inline">const</span>, the type can be omitted, and it will be deduced from  the assignment expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SKwd">const</span> <span class="SCst">N</span> = <span class="SNum">10</span>) <span class="SFct">myFunc</span>() = <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>()                                   <span class="SCmt">// Constant value is deduced as 's32'.</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_001_functions_swg">Mixing Types and Constants </h4>
<p>You can mix types and constants in generic parameters. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Example where `T` is a type and `N` is a constant of type `s32`.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(x: <span class="SCst">T</span>) =&gt; x * <span class="SCst">N</span>

        <span class="SKwd">alias</span> call = <span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(<span class="SFct">call</span>(<span class="SNum">2</span>) == <span class="SNum">20</span>)                 <span class="SCmt">// Function call with 's32' type and 10 constant.</span>
        <span class="SItr">@assert</span>(<span class="SFct">call</span>(<span class="SNum">100</span>) == <span class="SNum">1000</span>)             <span class="SCmt">// Another call with the same type and constant.</span>
    }

    {
        <span class="SCmt">// Declaring multiple constants requires specifying the type for each.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>: <span class="STpe">s32</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() =&gt; <span class="SCst">T</span> * <span class="SCst">N</span>

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="SNum">5</span>, <span class="SNum">10</span>)() == <span class="SNum">50</span>)        <span class="SCmt">// Function call with two 's32' constants.</span>
    }

    {
        <span class="SCmt">// Declaring multiple types with default values.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span> = <span class="STpe">s32</span>, <span class="SCst">V</span> = <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(x: <span class="SCst">T</span>, y: <span class="SCst">V</span>) =&gt; x * y

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">1</span>'<span class="STpe">s32</span>, <span class="SNum">2</span>'<span class="STpe">f32</span>) == <span class="SNum">2.0</span>)   <span class="SCmt">// Calls with 's32' and 'f32', type deduced.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">1</span>'<span class="STpe">s32</span>, <span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">2</span>)     <span class="SCmt">// Calls with 's32' for both parameters.</span>
    }
}</span></div>

<h3 id="_009_000_generics_swg__009_002_structs_swg">Structs</h3><h4 id="_009_000_generics_swg__009_002_structs_swg">Generic Structs </h4>
<p>Structs in Swag can also be made generic, allowing them to operate with different types and constants. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Example of a generic struct where `T` is the generic type.</span>
        <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">Struct</span>
        {
            val: <span class="SCst">T</span>
        }

        <span class="SKwd">var</span> x: <span class="SFct">Struct</span>'<span class="STpe">s32</span>
        <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(x.val) == <span class="STpe">s32</span>)         <span class="SCmt">// The type of 'val' is deduced as 's32'.</span>
        <span class="SKwd">var</span> x1: <span class="SFct">Struct</span>'<span class="STpe">f32</span>
        <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(x1.val) == <span class="STpe">f32</span>)        <span class="SCmt">// The type of 'val' is deduced as 'f32'.</span>
    }

    {
        <span class="SCmt">// A more complex example with both a type and a constant as generic parameters.</span>
        <span class="SKwd">struct</span>(<span class="SCst">T</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SCst">Struct</span>
        {
            val: [<span class="SCst">N</span>] <span class="SCst">T</span>  <span class="SCmt">// An array of 'N' elements of type 'T'.</span>
        }

        <span class="SKwd">var</span> x: <span class="SFct">Struct</span>'(<span class="STpe">bool</span>, <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(x.val) == <span class="SItr">#type</span> [<span class="SNum">10</span>] <span class="STpe">bool</span>) <span class="SCmt">// The type is an array of 10 booleans.</span>
    }
}</span></div>

<h3 id="_009_000_generics_swg__009_003_where_constraints_swg">Where constraints</h3><h4 id="_009_000_generics_swg__009_003_where_constraints_swg">Single Evaluation </h4>
<p>The <span class="code-inline">where</span> clause in Swag is a powerful tool for applying constraints on function invocations, ensuring that they can only be called when specific conditions are met. This feature is particularly useful in generic functions where you want to restrict the permissible types or values passed as arguments. </p>
<p>When the <span class="code-inline">where</span> expression evaluates to <span class="code-inline">false</span>, the function will not be considered during the call. If no alternative overloads match, the compiler will raise an error. Notably, the <span class="code-inline">where</span> expression is evaluated <b>only once</b>, usually during the function's instantiation. This makes it ideal for applying constraints on generic parameters in a consistent and predictable manner. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// This function validates the type and executes only if the generic type is `s32` or `s64`.</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x: <span class="SCst">T</span>...)-&gt;<span class="SCst">T</span>                            
        <span class="SLgc">where</span> <span class="SCst">T</span> == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">s64</span>                      <span class="SCmt">// Restricting `T` to `s32` or `s64`</span>
    {
        <span class="SKwd">var</span> total = <span class="SNum">0</span>'<span class="SCst">T</span>
        <span class="SLgc">foreach</span> it <span class="SLgc">in</span> x:
            total += it                                 <span class="SCmt">// Accumulate the values</span>
        <span class="SLgc">return</span> total                                    <span class="SCmt">// Return the sum</span>
    }

    <span class="SCmt">// These calls are valid since `T` is `s32` or `s64`.</span>
    <span class="SKwd">let</span> res1 = <span class="SFct">sum</span>'<span class="STpe">s32</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)                            <span class="SCmt">// Sum with `s32`</span>
    <span class="SItr">@assert</span>(res1 == <span class="SNum">3</span>)                                  <span class="SCmt">// Assert that result is 3</span>
    <span class="SKwd">let</span> res2 = <span class="SFct">sum</span>'<span class="STpe">s64</span>(<span class="SNum">10</span>, <span class="SNum">20</span>)                          <span class="SCmt">// Sum with `s64`</span>
    <span class="SItr">@assert</span>(res2 == <span class="SNum">30</span>)                                 <span class="SCmt">// Assert that result is 30</span>

    <span class="SCmt">// The following would generate an error since `f32` is not a matching type.</span>

    <span class="SCmt">// var res3 = sum'f32(1, 2)</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">Generic Specialization </h4>
<p>The <span class="code-inline">where</span> clause also facilitates the creation of specialized versions of generic functions. This feature allows you to provide distinct implementations based on the type or value of the parameters, enhancing flexibility and efficiency. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Specialized implementation for `s32`.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">isNull</span>(x: <span class="SCst">T</span>)-&gt;<span class="STpe">bool</span>                          <span class="SCmt">// Specializing for `s32`</span>
        <span class="SLgc">where</span> <span class="SCst">T</span> == <span class="STpe">s32</span>
    {
        <span class="SLgc">return</span> x == <span class="SNum">0</span>                                   <span class="SCmt">// Return true if `x` is zero</span>
    }

    <span class="SCmt">// Specialized implementation for `f32` and `f64`.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">isNull</span>(x: <span class="SCst">T</span>)-&gt;<span class="STpe">bool</span>                          <span class="SCmt">// Specializing for `f32` or `f64`</span>
        <span class="SLgc">where</span> <span class="SCst">T</span> == <span class="STpe">f32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">f64</span>
    {
        <span class="SLgc">return</span> <span class="SItr">@abs</span>(x) &lt; <span class="SNum">0.01</span>                           <span class="SCmt">// Return true if `x` is close to zero</span>
    }

    <span class="SItr">@assert</span>(<span class="SFct">isNull</span>(<span class="SNum">0</span>'<span class="STpe">s32</span>))                              <span class="SCmt">// Assert true for `s32` zero</span>
    <span class="SItr">@assert</span>(<span class="SFct">isNull</span>(<span class="SNum">0.001</span>'<span class="STpe">f32</span>))                          <span class="SCmt">// Assert true for `f32` close to zero</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">Block-based <span class="code-inline">where</span> Clause </h4>
<p>The <span class="code-inline">where</span> clause can also take the form of a block returning a <span class="code-inline">bool</span> value. This allows for more complex conditional logic that may involve multiple checks, making it suitable for advanced validation scenarios. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x: <span class="SCst">T</span>...)-&gt;<span class="SCst">T</span>                             <span class="SCmt">// Function with a block-based `where`</span>
        <span class="SLgc">where</span>
        {
            <span class="SLgc">if</span> <span class="SItr">#typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SItr">#typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s64</span>:  <span class="SCmt">// Check if `T` is `s32` or `s64`</span>
                <span class="SLgc">return</span> <span class="SKwd">true</span>                             <span class="SCmt">// Return true if valid</span>
            <span class="SLgc">return</span> <span class="SKwd">false</span>                                <span class="SCmt">// Return false otherwise</span>
        }
    {
        <span class="SKwd">var</span> total = <span class="SNum">0</span>'<span class="SCst">T</span>                                 <span class="SCmt">// Initialize total with type `T`</span>
        <span class="SLgc">foreach</span> it <span class="SLgc">in</span> x:
            total += it                                 <span class="SCmt">// Accumulate the values</span>
        <span class="SLgc">return</span> total                                    <span class="SCmt">// Return the sum</span>
    }
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">Custom Compile-time Errors </h4>
<p>Using the <span class="code-inline">@compilererror</span> intrinsic, you can trigger custom compile-time errors when the <span class="code-inline">where</span> condition is not met. This provides a mechanism for generating clear and specific error messages, guiding users when a function is used incorrectly. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x, y: <span class="SCst">T</span>)-&gt;<span class="SCst">T</span>                             <span class="SCmt">// Function with custom compile-time error</span>
        <span class="SLgc">where</span>
        {
            <span class="SLgc">if</span> <span class="SCst">T</span> == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">s64</span>:                    <span class="SCmt">// Check if `T` is `s32` or `s64`</span>
                <span class="SLgc">return</span> <span class="SKwd">true</span>                             <span class="SCmt">// Return true if valid</span>

            <span class="SItr">@compilererror</span>(<span class="SStr">"Invalid type "</span> ++ <span class="SItr">#stringof</span>(<span class="SCst">T</span>), <span class="SItr">#location</span>(<span class="SCst">T</span>))
            <span class="SLgc">return</span> <span class="SKwd">false</span>                                <span class="SCmt">// Return false after error</span>
        }
    {
        <span class="SLgc">return</span> x + y                                    <span class="SCmt">// Return the sum of `x` and `y`</span>
    }

    <span class="SCmt">// This will trigger a compile-time error as `f32` is not a valid type.</span>

    <span class="SCmt">// var x = sum'f32(1, 2)</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">Generic Structs with <span class="code-inline">where</span> </h4>
<p>The <span class="code-inline">where</span> clause can also be applied to generic structs. If the condition is not met, an error will be generated immediately since there is no overload resolution for structs, providing a direct mechanism for enforcing constraints on struct instantiation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">Point</span>                                     <span class="SCmt">// Struct with type constraints</span>
        <span class="SLgc">where</span> <span class="SCst">T</span> == <span class="STpe">f32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">f64</span>
    {
        x, y: <span class="SCst">T</span>                                         <span class="SCmt">// Coordinates with type `T`</span>
    }

    <span class="SCmt">// Valid instantiation with `f32`.</span>
    <span class="SKwd">var</span> v: <span class="SFct">Point</span>'<span class="STpe">f32</span>                                    <span class="SCmt">// Create a Point with `f32`</span>

    <span class="SCmt">// The following would generate an error since `s32` is not allowed.</span>

    <span class="SCmt">// var v: Point's32</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">Multiple Evaluations </h4>
<p>By utilizing the <span class="code-inline">where&lt;call&gt;</span> mode, the <span class="code-inline">where</span> clause is evaluated for <b>each</b> function call, rather than just once per function instantiation. This is particularly useful for conditions that depend on the actual arguments passed to the function, as long as these arguments can be evaluated at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Function to ensure that `y` is not zero at compile time.</span>
        <span class="SKwd">func</span> <span class="SFct">div</span>(x, y: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>                        <span class="SCmt">// Division function with compile-time check</span>
            <span class="SLgc">where</span>&lt;call&gt;
            {
                <span class="SCmt">// Verify if `y` is a compile-time constant.</span>
                <span class="SLgc">if</span> !<span class="SItr">#isconstexpr</span>(y):
                    <span class="SLgc">return</span> <span class="SKwd">true</span>                         <span class="SCmt">// Allow if `y` is not constant</span>
                <span class="SLgc">if</span> y == <span class="SNum">0</span>:
                    <span class="SItr">@compilererror</span>(<span class="SStr">"Division by zero"</span>, <span class="SItr">#location</span>(y))
                <span class="SLgc">return</span> <span class="SKwd">true</span>                             <span class="SCmt">// Allow otherwise</span>
            }
        {
            <span class="SLgc">return</span> x / y
        }

        <span class="SCmt">// Valid division.</span>
        <span class="SKwd">var</span> x1 = <span class="SFct">div</span>(<span class="SNum">1</span>, <span class="SNum">1</span>)                              <span class="SCmt">// Division with non-zero `y`</span>

        <span class="SCmt">// The following would generate a compile-time error due to division by zero.</span>

        <span class="SCmt">// var x2 = div(1, 0)</span>
    }

    {
        <span class="SCmt">// Function with different implementations based on whether `x` is known at compile time.</span>
        <span class="SAtr">#[Swag.Overload]</span>
        <span class="SKwd">func</span> <span class="SFct">first</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>                         <span class="SCmt">// Overload for constexpr `x`</span>
            <span class="SLgc">where</span>&lt;call&gt; <span class="SItr">#isconstexpr</span>(x)
        {
            <span class="SLgc">return</span> <span class="SNum">555</span>                                  <span class="SCmt">// Return 555 if `x` is constexpr</span>
        }

        <span class="SCmt">// Overload for the case where `x` is not known at compile time.</span>
        <span class="SAtr">#[Swag.Overload]</span>
        <span class="SKwd">func</span> <span class="SFct">first</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>                         <span class="SCmt">// Overload for non-constexpr `x`</span>
            <span class="SLgc">where</span>&lt;call&gt; !<span class="SItr">#isconstexpr</span>(x)
        {
            <span class="SLgc">return</span> <span class="SNum">666</span>                                  <span class="SCmt">// Return 666 if `x` is not constexpr</span>
        }

        <span class="SCmt">// Will call the first version because `x` is a literal.</span>
        <span class="SItr">@assert</span>(<span class="SFct">first</span>(<span class="SNum">0</span>) == <span class="SNum">555</span>)

        <span class="SCmt">// Will call the second version because `x` is a variable.</span>
        <span class="SKwd">var</span> a: <span class="STpe">s32</span>
        <span class="SItr">@assert</span>(<span class="SFct">first</span>(a) == <span class="SNum">666</span>)
    }
}</span></div>

<h2 id="_010_000_attributes_swg">Attributes</h2><p>Attributes are tags associated with functions, structures etc... </p>

<h3 id="_010_000_attributes_swg__010_001_user_attributes_swg">User attributes</h3><h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">User Attributes in Swag </h4>
<p>Attributes in Swag serve as a powerful mechanism for annotating various elements of the code, such as functions and structs, with metadata. These annotations, defined using the <span class="code-inline">attr</span> keyword, can be leveraged for a variety of purposes, including code generation, documentation enhancement, and runtime reflection. By attaching attributes, developers can enrich their code with additional information that can be accessed both at compile-time and runtime. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Swag</span>
<span class="SKwd">attr</span> <span class="SFct">AttributeA</span>()   <span class="SCmt">// A simple attribute without parameters</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">Attributes with Parameters </h4>
<p>Attributes in Swag can accept parameters in a manner similar to functions. These parameters enable the customization of the attribute's behavior or configuration when it is applied to a code element. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">attr</span> <span class="SFct">AttributeB</span>(x, y: <span class="STpe">s32</span>, z: <span class="STpe">string</span>)   <span class="SCmt">// Attribute with multiple parameters</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">Attributes with Default Values </h4>
<p>Swag attributes support parameters with default values, providing flexibility when applying attributes. This means that when such attributes are used, some or all of the parameters can be omitted, and the default values will be applied automatically. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">attr</span> <span class="SFct">AttributeBA</span>(x: <span class="STpe">s32</span>, y: <span class="STpe">string</span> = <span class="SStr">"string"</span>)  <span class="SCmt">// Attribute with a default parameter</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">Restricting Attribute Usage </h4>
<p>Swag allows developers to control where an attribute can be applied through the <span class="code-inline">AttrUsage</span> specifier. By restricting an attribute's usage to specific elements (such as functions or structs), you ensure that the attribute is only used in appropriate contexts, thereby enhancing code safety and clarity. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">AttributeC</span>()   <span class="SCmt">// Attribute restricted to function usage</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">Applying Attributes </h4>
<p>To apply attributes in Swag, use the syntax <span class="code-inline">#[attribute, attribute...]</span> immediately before the element you wish to annotate. This syntax supports the application of multiple attributes to a single element by listing them sequentially, separated by commas. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttributeA, AttributeB(0, 0, "string")]</span>
<span class="SKwd">func</span> <span class="SFct">function1</span>() {}   <span class="SCmt">// Function annotated with multiple attributes</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">Multiple Usages </h4>
<p>An attribute in Swag can be designed to be applicable to multiple types of code elements by specifying a combination of <span class="code-inline">AttrUsage</span> values using a bitwise OR operation. This capability allows a single attribute to be reused across different contexts, such as both functions and structs. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">AttributeD</span>(x: <span class="STpe">s32</span>)  <span class="SCmt">// Attribute applicable to both functions and structs</span>

<span class="SAtr">#[AttributeD(6)]</span>
<span class="SKwd">func</span> <span class="SFct">function2</span>() {}      <span class="SCmt">// Function annotated with a multi-usage attribute</span>

<span class="SAtr">#[AttributeD(150)]</span>
<span class="SKwd">struct</span> struct1 {}        <span class="SCmt">// Struct annotated with the same attribute</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">Retrieving Attributes at Runtime </h4>
<p>Swag supports the retrieval and inspection of attributes at runtime through type reflection. This feature enables dynamic interaction with the metadata associated with various code elements, allowing developers to adapt behavior based on the presence or configuration of attributes. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> type = <span class="SItr">#typeof</span>(function2)  <span class="SCmt">// Retrieve the type of the function</span>
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(type.attributes) == <span class="SNum">1</span>)  <span class="SCmt">// Assert that the function has exactly one attribute</span>
}</span></div>

<h3 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Predefined attributes</h3><p>This is the list of predefined attributes. All are located in the reserved <span class="code-inline">Swag</span> namespace. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip

<span class="SCmt">// Can be executed at compile time</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">ConstExpr</span>()

<span class="SCmt">// On a function or a struct, this will print the associated generated bytecode </span>
<span class="SCmt">// (right after generation, without bytecode optimizations)</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SFct">PrintGenBc</span>()

<span class="SCmt">// On a function or a struct, this will print the associated generated bytecode (after bytecode optimizations)</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SFct">PrintBc</span>()

<span class="SCmt">// The following function or variable is only defined at compile time</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.GlobalVariable | AttributeUsage.Constant)]</span>
<span class="SKwd">attr</span> <span class="SFct">Compiler</span>()

<span class="SCmt">// Force a function to be inlined</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Inline</span>()

<span class="SCmt">// Never inline the following function.</span>
<span class="SCmt">// This is a hint for the 'llvm' backend.</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">NoInline</span>()

<span class="SCmt">// The following function is a 'macro'</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Macro</span>()

<span class="SCmt">// The following function is a 'mixin'</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Mixin</span>()

<span class="SCmt">// Can force an 'opCast' special function to work as implicit</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Implicit</span>()

<span class="SCmt">// The following switch must be complete</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Complete</span>()

<span class="SCmt">// The following function can be overloaded</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Overload</span>()

<span class="SCmt">// A 'return' in the following inlined function must be done in the callee context</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">CalleeReturn</span>()

<span class="SCmt">// The following function is foreign (imported)</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Foreign</span>(module: <span class="STpe">string</span>, function: <span class="STpe">string</span> = <span class="SStr">""</span>)

<span class="SCmt">// The following function accepts that the called does not use its return value</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Variable)]</span>
<span class="SKwd">attr</span> <span class="SFct">Discardable</span>()

<span class="SCmt">// The following definition is deprecated and should not be used</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.Enum | AttributeUsage.EnumValue)]</span>
<span class="SKwd">attr</span> <span class="SFct">Deprecated</span>(msg: <span class="STpe">string</span> = <span class="SKwd">null</span>)

<span class="SCmt">// The following function is forced to not be generic, even if defined inside a generic 'struct'.</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">NotGeneric</span>()

<span class="SCmt">// Put the following global variable in the 'tls' segment.</span>
<span class="SCmt">// A copy of the variable will be available for each thread.</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.GlobalVariable)]</span>
<span class="SKwd">attr</span> <span class="SFct">Tls</span>()

<span class="SCmt">// 'struct' packing information</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">Pack</span>(value: <span class="STpe">u8</span>)

<span class="SCmt">// The following struct should never be copied</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">NoCopy</span>()

<span class="SCmt">// When exporting the following struct,: not export its content</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">Opaque</span>()

<span class="SCmt">// Struct field member relocation.</span>
<span class="SCmt">// The field offset in the struct should be the same as the variable 'name'</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.StructVariable)]</span>
<span class="SKwd">attr</span> <span class="SFct">Offset</span>(name: <span class="STpe">string</span>)

<span class="SCmt">// The following enum is a set of flags</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SFct">EnumFlags</span>()

<span class="SCmt">// The following enum can be used to index arrays without casting</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SFct">EnumIndex</span>()

<span class="SCmt">// The following enum can't have duplicated values</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SFct">NoDuplicate</span>()

<span class="SCmt">// The following switch is incomplete</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SFct">Incomplete</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">ExportType</span>(what: <span class="STpe">string</span>)

<span class="SCmt">// Do not generate documentation.</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.All | AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SFct">NoDoc</span>()

<span class="SCmt">// Enable/Disable one or more safety checks.</span>
<span class="SCmt">// For example:</span>
<span class="SCmt">// ```swag</span>
<span class="SCmt">// #[Swag.Safety("", false)]                    // Disable all</span>
<span class="SCmt">// #[Swag.Safety("boundcheck|nan", false)]      // Disable 'boundcheck' and 'nan' checks</span>
<span class="SCmt">// ```</span>
<span class="SCmt">// Safety checks are:</span>
<span class="SCmt">// | 'boundcheck'   | Check out of bound access</span>
<span class="SCmt">// | 'overflow'     | Check type conversion lost of bits or precision</span>
<span class="SCmt">// | 'math'         | Various math checks (like a negative '@sqrt')</span>
<span class="SCmt">// | 'switch'       | Check an invalid case in a '#[Swag.Complete]' switch</span>
<span class="SCmt">// | 'unreachable'  | Panic if an '@unreachable' instruction is executed</span>
<span class="SCmt">// | 'any'          | Panic if a cast from a 'any' variable does not match the real underlying type</span>
<span class="SCmt">// | 'bool'         | Panic if a 'bool' does not have a valid value ('true' or 'false')</span>
<span class="SCmt">// | 'nan'          | Panic if a 'nan' is used in a float arithmetic operation</span>
<span class="SCmt">// | 'sanity'       | Do a 'sanity' check (per function)</span>
<span class="SCmt">// | 'null'         | Panic on dereferencing some null pointers</span>
<span class="SCmt">// If 'what' is null or empty, every options are will be affected.</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.All | AttributeUsage.File), AttrMulti]</span>
<span class="SKwd">attr</span> <span class="SFct">Safety</span>(what: <span class="STpe">string</span>, value: <span class="STpe">bool</span>)

<span class="SCmt">// Enable/Disable a given function optimization.</span>
<span class="SCmt">// Options are:</span>
<span class="SCmt">// | 'bytecode'   | Enable/Disable bytecode optimization for the function</span>
<span class="SCmt">// | 'backend'    | Enable/Disable backend machine code optimization for the function (llvm only)</span>
<span class="SCmt">// If 'what' is null or empty, every options will be affected.</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.File), AttrMulti]</span>
<span class="SKwd">attr</span> <span class="SFct">Optimize</span>(what: <span class="STpe">string</span>, value: <span class="STpe">bool</span>)

<span class="SAtr">#[AttrUsage(AttributeUsage.All | AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SFct">AllowOverflow</span>(value: <span class="STpe">bool</span>)

<span class="SCmt">// Warning behavior for [[Warning]] attribute</span>
<span class="SKwd">enum</span> <span class="SCst">WarningLevel</span>: <span class="STpe">u8</span>
{
    <span class="SCst">Enable</span>      <span class="SCmt">// Enable the given warning</span>
    <span class="SCst">Disable</span>     <span class="SCmt">// Disable the given warning</span>
    <span class="SCst">Error</span>       <span class="SCmt">// Force the given warning to be raised as an error</span>
}

<span class="SCmt">// Change the behavior of a given warning or list of warnings.</span>
<span class="SCmt">// For example:</span>
<span class="SCmt">// ```swag</span>
<span class="SCmt">// #[Swag.Warning("Wrn0006", Swag.WarningLevel.Error)</span>
<span class="SCmt">// #[Swag.Warning("Wrn0002|Wrn0006", Swag.WarningLevel.Disable)</span>
<span class="SCmt">// #global #[Swag.Warning("Wrn0005", Swag.WarningLevel.Enable)]</span>
<span class="SCmt">// ```</span>
<span class="SCmt">// You can also change the warning behaviors for the whole module in your [[BuildCfg]]</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.All | AttributeUsage.File), AttrMulti]</span>
<span class="SKwd">attr</span> <span class="SFct">Warning</span>(what: <span class="STpe">string</span>, level: <span class="SCst">WarningLevel</span>)

<span class="SAtr">#[AttrUsage(AttributeUsage.All)]</span>
<span class="SKwd">attr</span> <span class="SFct">Match</span>(what: <span class="STpe">string</span>, value: <span class="STpe">bool</span>)

<span class="SKwd">attr</span> <span class="SFct">Strict</span>()
<span class="SKwd">attr</span> <span class="SFct">Global</span>()
<span class="SKwd">attr</span> <span class="SFct">Align</span>(value: <span class="STpe">u8</span>)</span></div>

<h2 id="_011_000_scoping_swg">Scoping</h2>
<h3 id="_011_000_scoping_swg__011_001_namespace_swg">Namespace</h3><h4 id="_011_000_scoping_swg__011_001_namespace_swg">Namespaces in Swag </h4>
<p>Namespaces in Swag provide a mechanism to organize and encapsulate symbols such as functions, variables, and types within a specific scope. By grouping related symbols together under a namespace, you can avoid naming conflicts and make your codebase more modular and maintainable. Symbols within a namespace are accessible only through the namespace unless explicitly made available outside of it. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Define a simple namespace 'A'</span>
<span class="SKwd">namespace</span> <span class="SCst">A</span>
{
    <span class="SCmt">// Function 'a' is defined within the namespace 'A'.</span>
    <span class="SKwd">func</span> <span class="SFct">a</span>() =&gt; <span class="SNum">1</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_001_namespace_swg">Nested Namespaces </h4>
<p>Swag allows you to create nested namespaces, enabling hierarchical organization of symbols. In the following example, namespace <span class="code-inline">C</span> is nested inside <span class="code-inline">B</span>, which is itself nested inside <span class="code-inline">A</span>. This structure facilitates even finer control and organization, particularly useful in large projects. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Define a nested namespace 'A.B.C'</span>
<span class="SKwd">namespace</span> <span class="SCst">A</span>.<span class="SCst">B</span>.<span class="SCst">C</span>
{
    <span class="SCmt">// Function 'a' is defined within the nested namespace 'A.B.C'.</span>
    <span class="SKwd">func</span> <span class="SFct">a</span>() =&gt; <span class="SNum">2</span>
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Accessing functions using their fully qualified namespace paths.</span>
    <span class="SItr">@assert</span>(<span class="SCst">A</span>.<span class="SFct">a</span>() == <span class="SNum">1</span>)          <span class="SCmt">// Calls the 'a' function from namespace 'A'</span>
    <span class="SItr">@assert</span>(<span class="SCst">A</span>.<span class="SCst">B</span>.<span class="SCst">C</span>.<span class="SFct">a</span>() == <span class="SNum">2</span>)      <span class="SCmt">// Calls the 'a' function from nested namespace 'A.B.C'</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_001_namespace_swg">Using <span class="code-inline">using</span> with Namespaces </h4>
<p>The <span class="code-inline">using</span> keyword allows you to import symbols from a namespace into the current scope, eliminating the need to fully qualify those symbols with the namespace name. This makes the code more concise and improves readability, particularly when working with deeply nested namespaces. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SKwd">namespace</span> <span class="SCst">Private</span>
{
    <span class="SKwd">const</span> <span class="SCst">FileSymbol</span> = <span class="SNum">0</span>         <span class="SCmt">// A constant defined within the 'Private' namespace</span>
}

<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCst">Private</span>.<span class="SCst">FileSymbol</span>     <span class="SCmt">// Accessing 'FileSymbol' with the full namespace path</span>
<span class="SKwd">const</span> <span class="SCst">C</span> = <span class="SCst">FileSymbol</span>             <span class="SCmt">// Direct access to 'FileSymbol' thanks to the 'using' directive</span></span></div>
<h4 id="_011_000_scoping_swg__011_001_namespace_swg">Private Scopes with <span class="code-inline">private</span> </h4>
<p>In addition to named namespaces, Swag allows you to define a private scope using the <span class="code-inline">private</span> keyword. A private scope creates a unique, unnamed namespace that restricts access to the enclosed symbols to the current file, effectively making them private. This is particularly useful for isolating symbols that should not be accessible outside the file. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">private</span>
{
    <span class="SKwd">const</span> <span class="SCst">OtherSymbol</span> = <span class="SNum">0</span>        <span class="SCmt">// A constant defined within an unnamed private scope</span>
}

<span class="SKwd">const</span> <span class="SCst">D</span> = <span class="SCst">OtherSymbol</span>            <span class="SCmt">// Direct access to 'OtherSymbol' as it is private to the file</span></span></div>
<h4 id="_011_000_scoping_swg__011_001_namespace_swg">Exporting Symbols </h4>
<p>By default, all symbols defined in a Swag source file are exported and can be accessed by other files within the same module. However, using <span class="code-inline">private</span> scopes or explicit namespaces provides a layer of protection against unintentional name conflicts, particularly in larger projects where different files may define symbols with similar or identical names. </p>

<h3 id="_011_000_scoping_swg__011_002_defer_swg">Defer</h3><h4 id="_011_000_scoping_swg__011_002_defer_swg"><span class="code-inline">defer</span> Statement </h4>
<p>The <span class="code-inline">defer</span> statement allows you to specify an expression that will be automatically executed when the  current scope is exited. Since <span class="code-inline">defer</span> operates purely at compile time, the deferred expression is not  evaluated until the block of code in which it is defined is left. This feature is useful for managing  resources, ensuring cleanup operations, and maintaining code clarity. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v = <span class="SNum">0</span>
    <span class="SLgc">defer</span> <span class="SItr">@assert</span>(v == <span class="SNum">1</span>)   <span class="SCmt">// Ensures that v equals 1 when leaving the scope.</span>
    v += <span class="SNum">1</span>                  <span class="SCmt">// Increment v by 1.</span>

    <span class="SCmt">// When the scope is exited, the deferred expression will be executed here, verifying that v is 1.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">Defer in a Block </h4>
<p>The <span class="code-inline">defer</span> statement can also encapsulate multiple expressions within a block. This allows you to  group together operations that should all be executed upon exiting the scope, maintaining the integrity  of your logic and ensuring that all necessary actions are performed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v = <span class="SNum">0</span>
    <span class="SLgc">defer</span>
    {
        v += <span class="SNum">10</span>            <span class="SCmt">// Increment v by 10.</span>
        <span class="SItr">@assert</span>(v == <span class="SNum">15</span>)   <span class="SCmt">// Ensure v equals 15 after the block execution.</span>
    }

    v += <span class="SNum">5</span>                <span class="SCmt">// Increment v by 5.</span>

    <span class="SCmt">// Upon scope exit, the defer block is executed, adding 10 to v and ensuring the final value is 15.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">Defer with Control Flow </h4>
<p>The <span class="code-inline">defer</span> expression is executed whenever the scope is exited, including in the presence of control  flow statements like <span class="code-inline">return</span>, <span class="code-inline">break</span>, or <span class="code-inline">continue</span>. This behavior makes <span class="code-inline">defer</span> particularly  advantageous for scenarios that require guaranteed execution of specific operations, such as resource  cleanup or ensuring that certain conditions are met, regardless of how the code block is terminated. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        <span class="SLgc">defer</span> <span class="SCst">G</span> += <span class="SNum">1</span>   <span class="SCmt">// Ensure G is incremented each loop iteration, even if the loop is exited early.</span>

        <span class="SLgc">if</span> <span class="SCst">G</span> == <span class="SNum">2</span>:
            <span class="SLgc">break</span>      <span class="SCmt">// Exit the loop when G equals 2. Defer will execute before breaking out.</span>

        <span class="SCmt">// The defer expression is executed at the end of each iteration.</span>
    }

    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">3</span>)    <span class="SCmt">// Check that G has been correctly incremented, even after the loop is broken.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">Defer Execution Order </h4>
<p>When multiple <span class="code-inline">defer</span> statements are declared, they are executed in the reverse order of their  declaration. This ensures that the most recently deferred operation occurs first upon scope exit,  providing a predictable and manageable flow of operations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>
    <span class="SLgc">defer</span> <span class="SItr">@assert</span>(x == <span class="SNum">2</span>)   <span class="SCmt">// Executed second, after x is multiplied by 2.</span>
    <span class="SLgc">defer</span> x *= <span class="SNum">2</span>            <span class="SCmt">// Executed first, doubling the value of x.</span>

    <span class="SCmt">// The deferred statements execute in reverse, ensuring logical and predictable order.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">Example: Defer for Resource Management </h4>
<p>A common use case for <span class="code-inline">defer</span> is in resource management, such as the creation and subsequent release  of resources. By placing the release logic immediately after the creation logic, the code becomes  more readable and ensures that resources are always properly managed, even in the event of an error or  early exit. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">createResource</span>()                 =&gt; <span class="SKwd">true</span>
    <span class="SKwd">func</span> <span class="SFct">releaseResource</span>(resource: *<span class="STpe">bool</span>) = <span class="SKwd">dref</span> resource = <span class="SKwd">false</span>
    <span class="SKwd">func</span> <span class="SFct">isResourceCreated</span>(b: <span class="STpe">bool</span>)       =&gt; b

    <span class="SKwd">var</span> resource = <span class="SKwd">false</span>
    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        resource = <span class="SFct">createResource</span>()
        <span class="SLgc">defer</span>
        {
            <span class="SItr">@assert</span>(resource.<span class="SFct">isResourceCreated</span>())   <span class="SCmt">// Validate that the resource was created.</span>
            <span class="SFct">releaseResource</span>(&resource)              <span class="SCmt">// Release the resource when exiting the loop.</span>
        }

        <span class="SLgc">if</span> <span class="SItr">#index</span> == <span class="SNum">2</span>:
            <span class="SLgc">break</span>      <span class="SCmt">// Exit for early, defer block still ensures resource release.</span>
    }

    <span class="SItr">@assert</span>(!resource.<span class="SFct">isResourceCreated</span>())   <span class="SCmt">// Ensure the resource is no longer created post-loop.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">Example: Defer in Error Handling </h4>
<p>In more complex functions, <span class="code-inline">defer</span> proves invaluable for ensuring that resources are cleaned up  reliably, even in the presence of errors or early returns. This pattern is essential for writing  robust, error-resilient code that gracefully handles failure scenarios while ensuring that all necessary  cleanup is performed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">createResource</span>()                 =&gt; <span class="SKwd">true</span>
    <span class="SKwd">func</span> <span class="SFct">releaseResource</span>(resource: *<span class="STpe">bool</span>) = <span class="SKwd">dref</span> resource = <span class="SKwd">false</span>
    <span class="SKwd">func</span> <span class="SFct">isResourceCreated</span>(b: <span class="STpe">bool</span>)       =&gt; b

    <span class="SKwd">func</span> <span class="SFct">performTask</span>() -&gt; <span class="STpe">bool</span>
    {
        <span class="SKwd">var</span> resource = <span class="SFct">createResource</span>()
        <span class="SLgc">defer</span> <span class="SFct">releaseResource</span>(&resource)   <span class="SCmt">// Guarantee resource release on function exit.</span>

        <span class="SLgc">if</span> !resource.<span class="SFct">isResourceCreated</span>()
        {
            <span class="SCmt">// Handle error: resource wasn't created. Defer block still ensures cleanup.</span>
            <span class="SLgc">return</span> <span class="SKwd">false</span>
        }

        <span class="SCmt">// Perform other tasks here...</span>
        <span class="SCmt">// If an error occurs, the defer block will release the resource.</span>
        <span class="SLgc">return</span> <span class="SKwd">true</span>
    }

    <span class="SKwd">let</span> success = <span class="SFct">performTask</span>()
    <span class="SItr">@assert</span>(success)   <span class="SCmt">// Ensure that the task was successful and resources were managed correctly.</span>
    <span class="SCmt">// The resource is released correctly regardless of the function's outcome.</span>
}</span></div>

<h3 id="_011_000_scoping_swg__011_003_using_swg">Using</h3><h4 id="_011_000_scoping_swg__011_003_using_swg"><span class="code-inline">using</span> with Enums and Namespaces </h4>
<p>The <span class="code-inline">using</span> statement allows you to bring the scope of a namespace, struct, or enum into the current  scope. This makes it possible to reference members directly without the need for full qualification.  For example, when working with enums, this can simplify the code by removing the need to constantly  prefix enum values with the enum type name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span> == <span class="SNum">0</span>)   <span class="SCmt">// Accessing the enum member with full qualification.</span>

    <span class="SKwd">using</span> <span class="SCst">RGB</span>             <span class="SCmt">// Bringing the enum members into the current scope.</span>
    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">1</span>)       <span class="SCmt">// 'G' is now directly accessible without the 'RGB.' prefix.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_003_using_swg"><span class="code-inline">using</span> with Variables </h4>
<p>The <span class="code-inline">using</span> statement can also be applied to variables, particularly those of struct types. This allows  you to access the fields of a struct directly within the current scope, eliminating the need to  reference the variable name each time you access a field. This is particularly useful for reducing  code verbosity and improving readability. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> }

    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>         <span class="SCmt">// Declaring a variable of struct type 'Point.'</span>

    <span class="SKwd">using</span> pt              <span class="SCmt">// Bringing the fields of 'pt' into the current scope.</span>
    x = <span class="SNum">1</span>                 <span class="SCmt">// Direct access to 'x' without needing 'pt.x'.</span>
    y = <span class="SNum">2</span>                 <span class="SCmt">// Direct access to 'y' without needing 'pt.y'.</span>

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)    <span class="SCmt">// Verifying that 'x' was set correctly.</span>
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)    <span class="SCmt">// Verifying that 'y' was set correctly.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_003_using_swg">Declaring Variables with <span class="code-inline">using</span> </h4>
<p>You can declare a variable with the <span class="code-inline">using</span> keyword, which immediately brings the variable’s fields  into the current scope. This approach can streamline your code by allowing direct access to struct  fields without the need to prefix them with the variable name, making the code cleaner and more  concise. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> }
    <span class="SKwd">using</span> <span class="SKwd">var</span> pt: <span class="SCst">Point</span>   <span class="SCmt">// Declare 'pt' and bring its fields into the current scope.</span>
    x = <span class="SNum">1</span>                 <span class="SCmt">// Direct access to 'x' without specifying 'pt'.</span>
    y = <span class="SNum">2</span>                 <span class="SCmt">// Direct access to 'y' without specifying 'pt'.</span>

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)    <span class="SCmt">// Ensure that 'x' was correctly set.</span>
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)    <span class="SCmt">// Ensure that 'y' was correctly set.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_003_using_swg"><span class="code-inline">using</span> in Function Parameters </h4>
<p>When applied to function parameters, <span class="code-inline">using</span> allows fields of a struct to be accessed directly within  the function, similar to how a <span class="code-inline">this</span> pointer works in C++. This can simplify function code by  eliminating the need to repeatedly dereference a pointer or reference a parameter name, making the  function logic clearer and easier to follow. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> }

    <span class="SKwd">func</span> <span class="SFct">setOne</span>(<span class="SKwd">using</span> point: *<span class="SCst">Point</span>)
    {
        <span class="SCmt">// Access the fields of 'point' directly without prefixing with 'point-&gt;'.</span>
        x, y = <span class="SNum">1</span>
    }

    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    <span class="SFct">setOne</span>(&pt)           <span class="SCmt">// Call 'setOne' and modify 'pt' directly.</span>
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)    <span class="SCmt">// Validate that 'x' was set correctly.</span>
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">1</span>)    <span class="SCmt">// Validate that 'y' was set correctly.</span>

    <span class="SCmt">// UFCS (Uniform Function Call Syntax) allows calling the function as if it were a method.</span>
    pt.<span class="SFct">setOne</span>()           <span class="SCmt">// Equivalent to 'setOne(&pt)'.</span>
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)    <span class="SCmt">// Ensure 'x' remains correct.</span>
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">1</span>)    <span class="SCmt">// Ensure 'y' remains correct.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_003_using_swg"><span class="code-inline">using</span> with Struct Fields </h4>
<p>The <span class="code-inline">using</span> statement can also be applied to a field within a struct. This allows the fields of a  nested struct to be accessed as if they were part of the containing struct. This feature is especially  useful when working with inheritance or composition, enabling cleaner and more intuitive code by  removing unnecessary layers of field access. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point2</span>
    {
        x, y: <span class="STpe">s32</span>        <span class="SCmt">// Define two fields, 'x' and 'y'.</span>
    }

    <span class="SKwd">struct</span> <span class="SCst">Point3</span>
    {
        <span class="SKwd">using</span> base: <span class="SCst">Point2</span>  <span class="SCmt">// Bring 'Point2' fields into 'Point3' scope.</span>
        z: <span class="STpe">s32</span>              <span class="SCmt">// Define an additional field 'z'.</span>
    }

    <span class="SCmt">// The 'base' fields can now be referenced directly through 'Point3'.</span>
    <span class="SKwd">var</span> value: <span class="SCst">Point3</span>
    value.x = <span class="SNum">0</span>           <span class="SCmt">// Direct access to 'x', equivalent to 'value.base.x = 0'.</span>
    value.y = <span class="SNum">0</span>           <span class="SCmt">// Direct access to 'y', equivalent to 'value.base.y = 0'.</span>
    value.z = <span class="SNum">0</span>           <span class="SCmt">// Access 'z' directly, as it is part of 'Point3'.</span>
    <span class="SItr">@assert</span>(&value.x == &value.base.x)  <span class="SCmt">// Validate that 'x' refers to the correct memory location.</span>
    <span class="SItr">@assert</span>(&value.y == &value.base.y)  <span class="SCmt">// Validate that 'y' refers to the correct memory location.</span>

    <span class="SCmt">// The compiler can automatically cast 'Point3' to 'Point2' due to the `using` statement.</span>
    <span class="SKwd">func</span> <span class="SFct">set1</span>(<span class="SKwd">using</span> ptr: *<span class="SCst">Point2</span>)
    {
        x, y = <span class="SNum">1</span>          <span class="SCmt">// Direct access to 'x' and 'y' fields.</span>
    }

    <span class="SFct">set1</span>(&value)          <span class="SCmt">// Automatic cast to 'Point2' and modify 'value'.</span>
    <span class="SItr">@assert</span>(value.x == <span class="SNum">1</span>) <span class="SCmt">// Confirm 'x' was correctly set.</span>
    <span class="SItr">@assert</span>(value.y == <span class="SNum">1</span>) <span class="SCmt">// Confirm 'y' was correctly set.</span>
    <span class="SItr">@assert</span>(value.base.x == <span class="SNum">1</span>)  <span class="SCmt">// Ensure 'base.x' was updated.</span>
    <span class="SItr">@assert</span>(value.base.y == <span class="SNum">1</span>)  <span class="SCmt">// Ensure 'base.y' was updated.</span>
}</span></div>

<h3 id="_011_000_scoping_swg__011_004_with_swg">With</h3><h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> Statement </h4>
<p>The <span class="code-inline">with</span> statement is designed to reduce repetition by allowing you to access the fields and methods  of a variable or object within a specified scope. Inside a <span class="code-inline">with</span> block, you can use the <span class="code-inline">.</span> prefix to  refer to the fields or methods of the specified object, making the code more concise and easier to read. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Point</span> { x, y: <span class="STpe">s32</span> }

<span class="SKwd">impl</span> <span class="SCst">Point</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">setOne</span>()
    {
        x, y = <span class="SNum">1</span>   <span class="SCmt">// Set both x and y to 1 within the Point instance.</span>
    }
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> on a Variable </h4>
<p>The <span class="code-inline">with</span> statement can be used with a variable to streamline access to its fields and methods,  eliminating the need to repeatedly reference the variable name. This makes the code cleaner and reduces  clutter, especially when working with objects that have multiple fields or methods. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>           <span class="SCmt">// Declare a variable of type Point.</span>
    <span class="SKwd">with</span> pt
    {
        .x = <span class="SNum">1</span>             <span class="SCmt">// Equivalent to pt.x = 1, sets the x field.</span>
        .y = <span class="SNum">2</span>             <span class="SCmt">// Equivalent to pt.y = 2, sets the y field.</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)      <span class="SCmt">// Verify that x was set correctly.</span>
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)      <span class="SCmt">// Verify that y was set correctly.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with Function Calls </h4>
<p>The <span class="code-inline">with</span> statement also simplifies function calls on an object or struct by allowing direct  invocation of methods and access to fields within the <span class="code-inline">with</span> block. This approach helps maintain  cleaner and more intuitive code by reducing the repetition of the object or variable name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>           <span class="SCmt">// Declare a variable of type Point.</span>
    <span class="SKwd">with</span> pt
    {
        .<span class="SFct">setOne</span>()           <span class="SCmt">// Equivalent to pt.setOne(), sets both x and y to 1.</span>
        .y = <span class="SNum">2</span>              <span class="SCmt">// Modify the y field directly within the block.</span>
        <span class="SItr">@assert</span>(.x == <span class="SNum">1</span>)    <span class="SCmt">// Equivalent to pt.x == 1, verifies that x is set to 1.</span>
        <span class="SItr">@assert</span>(.y == <span class="SNum">2</span>)    <span class="SCmt">// Equivalent to pt.y == 2, verifies that y is set to 2.</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)      <span class="SCmt">// Confirm that x remains correct after the with block.</span>
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)      <span class="SCmt">// Confirm that y remains correct after the with block.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with a Namespace </h4>
<p>The <span class="code-inline">with</span> statement can also be applied to a namespace, allowing you to call functions or access  constants within that namespace without needing to fully qualify the names. This is particularly useful  when working with large namespaces or when multiple calls to namespace members are required. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SCst">NameSpace</span>
    {
        .<span class="SFct">inside0</span>()          <span class="SCmt">// Equivalent to NameSpace.inside0(), calls the inside0 function.</span>
        .<span class="SFct">inside1</span>()          <span class="SCmt">// Equivalent to NameSpace.inside1(), calls the inside1 function.</span>
    }
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with Variable Declaration </h4>
<p>In addition to existing variables, the <span class="code-inline">with</span> statement can be used directly with variable declarations.  This allows you to immediately work with the fields of the newly declared variable within the scope of  the <span class="code-inline">with</span> block, streamlining initialization and setup tasks. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SKwd">var</span> pt = <span class="SCst">Point</span>{<span class="SNum">1</span>, <span class="SNum">2</span>}  <span class="SCmt">// Declare and initialize 'pt' with x=1, y=2.</span>
    {
        .x = <span class="SNum">10</span>             <span class="SCmt">// Modify x within the block.</span>
        .y = <span class="SNum">20</span>             <span class="SCmt">// Modify y within the block.</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)  <span class="SCmt">// Ensure both fields are correctly updated.</span>
}

<span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SKwd">var</span> pt: <span class="SCst">Point</span>      <span class="SCmt">// Declare 'pt' without initialization.</span>
    {
        .x = <span class="SNum">10</span>             <span class="SCmt">// Set x to 10 within the block.</span>
        .y = <span class="SNum">20</span>             <span class="SCmt">// Set y to 20 within the block.</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)  <span class="SCmt">// Ensure fields are set as expected.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with an Assignment Statement </h4>
<p>The <span class="code-inline">with</span> statement can also be used with an assignment, allowing you to immediately access and modify  the fields of the newly assigned value. This can be particularly helpful in scenarios where you want  to initialize or adjust an object’s fields immediately after creation or assignment. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>           <span class="SCmt">// Declare a variable of type Point.</span>
    <span class="SKwd">with</span> pt = <span class="SCst">Point</span>{<span class="SNum">1</span>, <span class="SNum">2</span>}   <span class="SCmt">// Assign a new Point instance to 'pt'.</span>
    {
        .x = <span class="SNum">10</span>             <span class="SCmt">// Modify x within the block.</span>
        .y = <span class="SNum">20</span>             <span class="SCmt">// Modify y within the block.</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)  <span class="SCmt">// Ensure fields are updated correctly.</span>
}

<span class="SKwd">namespace</span> <span class="SCst">NameSpace</span>
{
    <span class="SKwd">func</span> <span class="SFct">inside0</span>() {}        <span class="SCmt">// Define a function inside the namespace.</span>
    <span class="SKwd">func</span> <span class="SFct">inside1</span>() {}        <span class="SCmt">// Define another function inside the namespace.</span>
}</span></div>

<h2 id="_012_000_type_reflection_swg">Type reflection</h2><h3 id="_012_000_type_reflection_swg">Types as Values in Swag </h3>
<p>In Swag, <b>types are treated as first-class values</b> that can be inspected and manipulated  at both compile-time and runtime. This powerful feature enables advanced metaprogramming  capabilities, allowing developers to write more flexible and reusable code. The primary  intrinsics for interacting with types are <span class="code-inline">#typeof</span> and <span class="code-inline">@kindof</span>, which provide the ability  to introspect and work with types dynamically. </p>
<h3 id="_012_000_type_reflection_swg">Using <span class="code-inline">#typeof</span> to Inspect Types </h3>
<p>The <span class="code-inline">#typeof</span> intrinsic allows you to retrieve the type information of an expression.  When an expression explicitly represents a type, you can also directly use the type  itself. This is particularly useful for type inspection and validation at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Using #typeof to retrieve the type information of the basic type 's8'</span>
    <span class="SKwd">let</span> ptr1 = <span class="SItr">#typeof</span>(<span class="STpe">s8</span>)
    <span class="SItr">@assert</span>(ptr1.name == <span class="SStr">"s8"</span>) <span class="SCmt">// Verifies that the name of the type is 's8'</span>
    <span class="SItr">@assert</span>(ptr1 == <span class="STpe">s8</span>)        <span class="SCmt">// Confirms that the retrieved type matches 's8'</span>

    <span class="SCmt">// Retrieving the type of another basic type 's16' using #typeof</span>
    <span class="SKwd">let</span> ptr2 = <span class="SItr">#typeof</span>(<span class="STpe">s16</span>)
    <span class="SItr">@assert</span>(ptr2.name == <span class="SStr">"s16"</span>)
    <span class="SItr">@assert</span>(ptr2 == <span class="STpe">s16</span>)

    <span class="SCmt">// Directly using the type 's32' without #typeof</span>
    <span class="SKwd">let</span> ptr3 = <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(ptr3.name == <span class="SStr">"s32"</span>)
    <span class="SItr">@assert</span>(ptr3 == <span class="SItr">#typeof</span>(<span class="STpe">s32</span>))

    <span class="SCmt">// Another example of direct type usage with 's64'</span>
    <span class="SKwd">let</span> ptr4 = <span class="STpe">s64</span>
    <span class="SItr">@assert</span>(ptr4.name == <span class="SStr">"s64"</span>)
    <span class="SItr">@assert</span>(ptr4 == <span class="STpe">s64</span>)
}</span></div>
<h3 id="_012_000_type_reflection_swg">Understanding the Result of <span class="code-inline">#typeof</span> </h3>
<p>The result of the <span class="code-inline">#typeof</span> intrinsic is a constant pointer to a <span class="code-inline">Swag.TypeInfo</span> structure.  This structure serves as a type descriptor, providing detailed information about the type  it describes. The <span class="code-inline">Swag.TypeInfo</span> is an alias for the <span class="code-inline">typeinfo</span> type, and each type in Swag  corresponds to a specific <span class="code-inline">TypeInfo</span> structure found in the <span class="code-inline">Swag</span> namespace, which is  part of the compiler runtime. </p>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> You can explore all available type descriptors in the runtime documentation on the Swag website. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Using #typeof on a bool type, which is a native type</span>
    <span class="SKwd">let</span> ptr = <span class="STpe">bool</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr) == <span class="SItr">#typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoNative</span>)) 

    <span class="SCmt">// The `#type` keyword is used when the expression might be ambiguous, such as with arrays.</span>
    <span class="SCmt">// This ensures that the compiler understands the expression as a type.</span>
    <span class="SKwd">let</span> ptr1 = <span class="SItr">#type</span> [<span class="SNum">2</span>] <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr1) == <span class="SItr">#typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoArray</span>)) 
    <span class="SItr">@assert</span>(ptr1.name == <span class="SStr">"[2] s32"</span>)

    <span class="SCmt">// Using #typeof on an array literal</span>
    <span class="SKwd">let</span> ptr2 = <span class="SItr">#typeof</span>([<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>])
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr2) == <span class="SItr">#typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoArray</span>))
    <span class="SItr">@assert</span>(ptr2.name == <span class="SStr">"const [3] s32"</span>)
}</span></div>
<h3 id="_012_000_type_reflection_swg">Working with <span class="code-inline">TypeInfo</span> Structures </h3>
<p>The <span class="code-inline">TypeInfo</span> structure includes a <span class="code-inline">kind</span> field that identifies the specific category  of the type, such as native type, pointer, array, or struct. This <span class="code-inline">kind</span> field is crucial  when dealing with types in a more abstract or generic manner, as it allows you to differentiate  between various kinds of types and handle them appropriately. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Checking the 'kind' field of the typeinfo for 'f64', which should be a native type</span>
    <span class="SKwd">let</span> typeOf = <span class="STpe">f64</span>
    <span class="SItr">@assert</span>(typeOf.kind == <span class="SCst">Swag</span>.<span class="SCst">TypeInfoKind</span>.<span class="SCst">Native</span>)

    <span class="SCmt">// Evaluating these type checks at compile time</span>
    <span class="SKwd">using</span> <span class="SCst">Swag</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(*<span class="STpe">u8</span>).kind == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Pointer</span>  <span class="SCmt">// Ensures the type is recognized as a pointer</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>([<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>]).kind == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Array</span>  <span class="SCmt">// Ensures the type is recognized as an array</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>({<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>}).kind == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Struct</span>  <span class="SCmt">// Ensures the type is recognized as a struct</span>
}</span></div>
<h3 id="_012_000_type_reflection_swg"><span class="code-inline">#decltype</span> </h3>
<p>The <span class="code-inline">#decltype</span> intrinsic performs the reverse operation of <span class="code-inline">#typeof</span> or <span class="code-inline">@kindof</span>.  It converts a <span class="code-inline">typeinfo</span> structure back into an actual compiler type. This is useful  when you need to dynamically determine the type of a variable based on compile-time  information and then use that type within your code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Using #decltype to declare a variable of type s32 based on its typeinfo</span>
    <span class="SKwd">var</span> x: <span class="SItr">#decltype</span>(<span class="SItr">#typeof</span>(<span class="STpe">s32</span>))
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(x) == <span class="STpe">s32</span>  <span class="SCmt">// Confirms that the variable 'x' is indeed of type 's32'</span>
}</span></div>
<h3 id="_012_000_type_reflection_swg">Using <span class="code-inline">#decltype</span> with Compile-Time Expressions </h3>
<p><span class="code-inline">#decltype</span> can evaluate a compile-time constant expression (<i>constexpr</i>) that returns  a <span class="code-inline">typeinfo</span> to determine the actual type. This is particularly powerful when the type  depends on compile-time logic, allowing for dynamic yet type-safe programming patterns. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// A function that returns a typeinfo based on a compile-time condition</span>
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">getType</span>(needAString: <span class="STpe">bool</span>) -&gt; <span class="STpe">typeinfo</span>
    {
        <span class="SLgc">if</span> needAString:
            <span class="SLgc">return</span> <span class="STpe">string</span>
        <span class="SLgc">else</span>:
            <span class="SLgc">return</span> <span class="STpe">s32</span>
    }

    <span class="SCmt">// Using #decltype to determine the type of 'x' based on the compile-time condition</span>
    <span class="SKwd">var</span> x: <span class="SItr">#decltype</span>(<span class="SFct">getType</span>(needAString: <span class="SKwd">false</span>))
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(x) == <span class="STpe">s32</span>  <span class="SCmt">// Confirms that 'x' is of type s32</span>
    x = <span class="SNum">0</span>

    <span class="SCmt">// Another example with the condition evaluating to true</span>
    <span class="SKwd">var</span> x1: <span class="SItr">#decltype</span>(<span class="SFct">getType</span>(needAString: <span class="SKwd">true</span>))
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(x1) == <span class="STpe">string</span>  <span class="SCmt">// Confirms that 'x1' is of type string</span>
    x1 = <span class="SStr">"0"</span>
}</span></div>

<h2 id="_013_000_error_management_and_safety_swg">Error management and safety</h2>
<h3 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Error management</h3><p>A function marked with <span class="code-inline">throw</span> indicates that it can return an error by invoking the <span class="code-inline">throw</span> keyword, followed by an error value. The error value is a struct, which encapsulates the error details. If an error occurs, the caller has the option to either halt execution and propagate the error using <span class="code-inline">try</span>, or handle the error explicitly using the <span class="code-inline">@err()</span> intrinsic. </p>
<div class="blockquote blockquote-default">
<p> It's crucial to understand that these are <b>not</b> exceptions in the traditional sense. Consider <span class="code-inline">throw</span> as a specialized form of <span class="code-inline">return</span> that carries an error value. </p>
</div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Using <span class="code-inline">throw</span> with Custom Errors </h4>
<p>A function that has the potential to return an error must be annotated with the <span class="code-inline">throw</span> keyword. This annotation signals that the function can raise an error using the <span class="code-inline">throw</span> statement. When an error is thrown, it is represented as a structured value, typically using a custom-defined struct to encapsulate the error information. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Here, we define a custom error type named `MyError`. This custom error extends a default runtime base error provided by the language.</span>
<span class="SKwd">struct</span> <span class="SCst">MyError</span>
{
    <span class="SCmt">// The custom error inherits from the base error type `Swag.BaseError`.</span>
    <span class="SCmt">// The base error type includes common fields such as an error 'message', which can be useful for debugging or error reporting.</span>
    <span class="SKwd">using</span> base: <span class="SCst">Swag</span>.<span class="SCst">BaseError</span>
}</span></div>
<p>When a function encounters an error and exits early, the actual return value is not what the function was originally intended to return. Instead, the function returns the <b>default value</b> for its return type. For example, if the return type is an integer, the default value would typically be 0. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The function 'count()' is defined to take a string parameter named 'name' and return an unsigned 64-bit integer (u64).</span>
<span class="SCmt">// The 'throw' keyword at the end of the function's signature indicates that this function can potentially raise an error.</span>
<span class="SKwd">func</span> <span class="SFct">count</span>(name: <span class="STpe">string</span>) -&gt; <span class="STpe">u64</span> <span class="SKwd">throw</span>
{
    <span class="SCmt">// Inside the function, we first check if the input parameter 'name' is null (i.e., it has no value assigned to it).</span>
    <span class="SLgc">if</span> name == <span class="SKwd">null</span>
    {
        <span class="SCmt">// If 'name' is null, we raise (throw) an error of type `MyError`.</span>
        <span class="SCmt">// The error is initialized with a string message "null pointer" to describe the problem.</span>
        <span class="SCmt">// When an error is thrown, the function will not proceed to return the intended value.</span>
        <span class="SCmt">// Instead, it will return 0, which is the default value for the u64 type.</span>
        <span class="SKwd">throw</span> <span class="SCst">MyError</span>{<span class="SStr">"null pointer"</span>}  <span class="SCmt">// Error is thrown with the message: "null pointer"</span>
    }

    <span class="SCmt">// If 'name' is not null, the function proceeds to count the number of characters in the string.</span>
    <span class="SCmt">// The '@countof(name)' function is used to determine this count, and the result is returned.</span>
    <span class="SLgc">return</span> <span class="SItr">@countof</span>(name)  <span class="SCmt">// Return the count of characters in the string</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Handling Errors with <span class="code-inline">catch</span> and <span class="code-inline">@err()</span> </h4>
<p>When calling a function that can throw an error, it's essential to handle the error appropriately. This is where the <span class="code-inline">catch</span> keyword comes into play. The error can be <span class="code-inline">caught</span> using <span class="code-inline">catch</span>, and its value can be tested (or ignored) using the <span class="code-inline">@err()</span> intrinsic. If an error is caught, it is dismissed, allowing the program to continue execution from the point where the error was handled. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc</span>()
{
    <span class="SCmt">// Attempt to call the `count()` function. If `count()` throws an error,</span>
    <span class="SCmt">// `catch` will intercept it. The function will then return the default value </span>
    <span class="SCmt">// of the return type (in this case, 0) and assign it to `cpt`.</span>
    <span class="SKwd">let</span> cpt = <span class="SKwd">catch</span> <span class="SFct">count</span>(<span class="SStr">"fileName"</span>)

    <span class="SCmt">// Immediately after catching the error, use `@err()` to check if an error occurred.</span>
    <span class="SLgc">if</span> <span class="SItr">@err</span>() != <span class="SKwd">null</span>
    {
        <span class="SCmt">// `@err()` returns an 'any' type, representing the caught error.</span>
        <span class="SCmt">// Here, we assert that the error is of type `MyError` to ensure correct error handling.</span>
        <span class="SItr">@assert</span>(<span class="SItr">@err</span>() == <span class="SCst">MyError</span>)  <span class="SCmt">// Validate that the error is indeed a `MyError`.</span>

        <span class="SCmt">// Also, assert that the value returned by `count()` is the default value (0 in this case),</span>
        <span class="SCmt">// which happens when an error is thrown.</span>
        <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span>)

        <span class="SCmt">// Inform the user that an error was encountered during the execution.</span>
        <span class="SItr">@print</span>(<span class="SStr">"An error was raised"</span>)
        <span class="SLgc">return</span>  <span class="SCmt">// Exit the function early since an error was handled.</span>
    }

    <span class="SCmt">// If no error was caught, the function would proceed normally from this point.</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Error Handling with <span class="code-inline">trycatch</span> </h4>
<p>The <span class="code-inline">trycatch</span> construct provides an alternative way to handle errors. It allows the function to dismiss the error and exit gracefully, returning the default value if necessary. This approach ensures that no error is propagated to the caller, effectively containing the error within the current function. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myOtherFunc</span>()
{
    <span class="SCmt">// Attempt to call the `count()` function. If it throws an error, </span>
    <span class="SCmt">// `trycatch` catches the error, assigns the default value to `cpt1`, </span>
    <span class="SCmt">// and the function continues without propagating the error.</span>
    <span class="SKwd">var</span> cpt1 = <span class="SKwd">trycatch</span> <span class="SFct">count</span>(<span class="SStr">"fileName"</span>)

    <span class="SCmt">// The above `trycatch` block is equivalent to using `catch` followed by an error check:</span>
    <span class="SKwd">var</span> cpt2 = <span class="SKwd">catch</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
    <span class="SLgc">if</span> <span class="SItr">@err</span>() != <span class="SKwd">null</span>:
        <span class="SLgc">return</span>  <span class="SCmt">// If an error is caught, exit the function silently</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Propagating Errors with <span class="code-inline">try</span> </h4>
<p>The <span class="code-inline">try</span> keyword allows a function to halt its execution and propagate any encountered errors to its caller. The function using <span class="code-inline">try</span> must be annotated with <span class="code-inline">throw</span>, indicating that it can pass errors up the call stack. </p>
<p>In this example, if the function <span class="code-inline">myFunc1</span> encounters an error, it will propagate that error to its caller, requiring the caller to handle it. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc1</span>() <span class="SKwd">throw</span>
{
    <span class="SCmt">// Attempt to call the `count()` function. If it raises an error,</span>
    <span class="SCmt">// `try` will automatically propagate the error to the caller of `myFunc1`.</span>
    <span class="SKwd">var</span> cpt = <span class="SKwd">try</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>)  <span class="SCmt">// Propagate the error if one occurs</span>
}</span></div>
<p>This behavior is equivalent to the following code, which uses <span class="code-inline">catch</span> to catch the error and then explicitly re-throws it. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc2</span>() <span class="SKwd">throw</span>
{
    <span class="SCmt">// Call `count()` and catch any error that might be raised.</span>
    <span class="SKwd">var</span> cpt = <span class="SKwd">catch</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
    <span class="SLgc">if</span> <span class="SItr">@err</span>() != <span class="SKwd">null</span>
    {
        <span class="SCmt">// If an error is caught, re-throw the same error, propagating it to the caller.</span>
        <span class="SKwd">throw</span> <span class="SItr">@err</span>()  <span class="SCmt">// Re-throw the caught error</span>
    }
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Forcing Panic with <span class="code-inline">assume</span> </h4>
<p>The <span class="code-inline">assume</span> keyword allows the caller to force a panic if an error occurs, rather than handling or propagating the error. This is useful in scenarios where you expect the code to run without errors, and any error should result in an immediate halt. </p>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> In <span class="code-inline">release</span> builds, the <span class="code-inline">assume</span> behavior can be disabled, which may lead to undefined behavior if an error occurs. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc3</span>()
{
    <span class="SCmt">// If the `count()` function throws an error, the program will panic and terminate,</span>
    <span class="SCmt">// displaying an error message. The error is not propagated or handled.</span>
    <span class="SKwd">var</span> cpt = <span class="SKwd">assume</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>)  <span class="SCmt">// Panic on error</span>
}</span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> If an error is not caught, Swag will <b>panic</b> at runtime. This is because the top-level caller always assumes safe execution, ensuring that unhandled errors result in a program halt. </p>
</div>
<h5 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Implicit <span class="code-inline">assume</span> </h5>
<p>Instead of using <span class="code-inline">throw</span>, you can annotate the entire function with <span class="code-inline">assume</span>. This treats the entire function as if every error is critical, causing an automatic panic if any error occurs. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc3A</span>() <span class="SKwd">assume</span>
{
    <span class="SCmt">// Since the function is annotated with `assume`, any error thrown by `count()` will</span>
    <span class="SCmt">// cause an immediate panic, without the need for explicit `assume` statements.</span>
    <span class="SKwd">var</span> cpt = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)  <span class="SCmt">// Implicit `assume`</span>

    <span class="SCmt">// Additional calls to `count()` are also covered by the implicit `assume`.</span>
    <span class="SKwd">var</span> cpt1 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)  <span class="SCmt">// Implicit `assume`</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Blocks in Error Handling </h4>
<p>Blocks can be used in place of a single statement to group multiple operations together in error-handling constructs like <span class="code-inline">try</span>, <span class="code-inline">assume</span>, <span class="code-inline">catch</span>, and <span class="code-inline">trycatch</span>. These blocks do not create a new scope but allow you to execute several related operations under a single error-handling strategy. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc4</span>() <span class="SKwd">throw</span>
{
    <span class="SCmt">// Using 'try' with a block to propagate errors from multiple operations.</span>
    <span class="SKwd">try</span>
    {
        <span class="SKwd">var</span> cpt0 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt1 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SCmt">// Using 'assume' with a block to enforce a panic on any error occurring in the block.</span>
    <span class="SKwd">assume</span>
    {
        <span class="SKwd">var</span> cpt2 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt3 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SCmt">// Using 'catch' with a block to catch and dismiss errors, proceeding with execution without handling or propagating the error.</span>
    <span class="SCmt">// In this context, checking '@err()' is irrelevant as the errors are dismissed.</span>
    <span class="SKwd">catch</span>
    {
        <span class="SKwd">var</span> cpt4 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt5 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SCmt">// Using 'trycatch' with a block to catch errors and exit immediately, without propagating or handling the error message.</span>
    <span class="SKwd">trycatch</span>
    {
        <span class="SKwd">var</span> cpt6 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt7 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Implicit <span class="code-inline">try</span> </h4>
<p>When a function is annotated with <span class="code-inline">throw</span>, any function calls within it that can raise errors will implicitly use <span class="code-inline">try</span> unless explicitly overridden. This implicit behavior reduces verbosity in scenarios where specific error handling is not required. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Define a function 'mySubFunc2' that throws an error.</span>
    <span class="SKwd">func</span> <span class="SFct">mySubFunc2</span>() <span class="SKwd">throw</span>
    {
        <span class="SKwd">throw</span> <span class="SCst">MyError</span>{<span class="SStr">"error from mySubFunc2"</span>}  <span class="SCmt">// Raise a custom error</span>
    }

    <span class="SCmt">// Define another function 'mySubFunc3' that also throws an error.</span>
    <span class="SKwd">func</span> <span class="SFct">mySubFunc3</span>() <span class="SKwd">throw</span>
    {
        <span class="SKwd">throw</span> <span class="SCst">MyError</span>{<span class="SStr">"error from mySubFunc3"</span>}  <span class="SCmt">// Raise a custom error</span>
    }

    <span class="SCmt">// Define 'mySubFunc1', which is marked with 'throw' indicating it can propagate errors.</span>
    <span class="SKwd">func</span> <span class="SFct">mySubFunc1</span>() <span class="SKwd">throw</span>
    {
        <span class="SCmt">// When calling 'mySubFunc2()', there's no need for an explicit 'try' since 'mySubFunc1'</span>
        <span class="SCmt">// is marked with 'throw'. The 'try' is implicit, reducing the need for additional syntax.</span>
        <span class="SFct">mySubFunc2</span>()  <span class="SCmt">// Implicit 'try'</span>

        <span class="SCmt">// However, you can still use an explicit 'try' if specific error handling is desired.</span>
        <span class="SKwd">try</span> <span class="SFct">mySubFunc3</span>()  <span class="SCmt">// Explicit 'try'</span>
    }

    <span class="SCmt">// Catch the error raised by 'mySubFunc1' and confirm that it is of type 'MyError'.</span>
    <span class="SKwd">catch</span> <span class="SFct">mySubFunc1</span>()
    <span class="SItr">@assert</span>(<span class="SItr">@err</span>() == <span class="SCst">MyError</span>)  <span class="SCmt">// Ensure the error is of type 'MyError'</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">The error struct </h4>
<p>As discussed, the error value is a struct. This allows you to add specific error parameters, such as line and column numbers for syntax errors. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">SyntaxError</span>
{
    <span class="SKwd">using</span> base:     <span class="SCst">Swag</span>.<span class="SCst">BaseError</span>
    line, col:      <span class="STpe">u32</span>
}</span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> Ensure that references to external values (e.g., <span class="code-inline">string</span>, <span class="code-inline">any</span>) remain valid throughout the error's lifecycle. The runtime will manage complex types, so it's recommended to store such values in the heap or a dedicated allocator within the current context. </p>
</div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Using <span class="code-inline">defer</span> for Controlled Cleanup </h4>
<p>The <span class="code-inline">defer</span> statement schedules a block of code to be executed when the function exits, whether it's through a normal return or due to an error being thrown. Since throwing an error is functionally similar to returning, <span class="code-inline">defer</span> behaves consistently in both cases. </p>
<p><span class="code-inline">defer</span> can be customized with specific modes (<span class="code-inline">#err</span> or <span class="code-inline">#noerr</span>) to control its execution based on the function's exit state: </p>
<table class="table-markdown">
<tr><td> <span class="code-inline">defer&lt;err&gt;</span>   </td><td> Executes only when an error is raised via <span class="code-inline">throw</span>.</td></tr>
<tr><td> <span class="code-inline">defer&lt;noerr&gt;</span> </td><td> Executes only when the function returns normally without errors.</td></tr>
<tr><td> <span class="code-inline">defer</span>        </td><td> Executes regardless of how the function exits (either by returning normally or by throwing an error).</td></tr>
</table>
<div class="code-block"><span class="SCde"><span class="SKwd">var</span> g_Defer = <span class="SNum">0</span>  <span class="SCmt">// A global variable to track the execution of defer statements</span>

<span class="SCmt">// A function that raises an error based on the provided input</span>
<span class="SKwd">func</span> <span class="SFct">raiseError</span>() <span class="SKwd">throw</span>
{
    <span class="SKwd">throw</span> <span class="SCst">MyError</span>{<span class="SStr">"error"</span>}  <span class="SCmt">// Raise a custom error</span>
}

<span class="SCmt">// A function that demonstrates the use of defer with different modes</span>
<span class="SKwd">func</span> <span class="SFct">testDefer</span>(err: <span class="STpe">bool</span>) <span class="SKwd">throw</span>
{
    <span class="SCmt">// Schedules this block to execute only if an error is raised.</span>
    <span class="SLgc">defer</span>&lt;err&gt; g_Defer += <span class="SNum">1</span>  <span class="SCmt">// Increment if an error occurs</span>

    <span class="SCmt">// Schedules this block to execute only if the function exits without an error.</span>
    <span class="SLgc">defer</span>&lt;noerr&gt; g_Defer += <span class="SNum">2</span>  <span class="SCmt">// Increment if no error occurs</span>

    <span class="SCmt">// Schedules this block to execute regardless of whether an error occurs.</span>
    <span class="SLgc">defer</span> g_Defer += <span class="SNum">3</span>  <span class="SCmt">// Increment regardless of error state</span>

    <span class="SLgc">if</span> err:
        <span class="SFct">raiseError</span>()  <span class="SCmt">// If 'err' is true, raise an error</span>
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Test case where an error is raised</span>
    g_Defer = <span class="SNum">0</span>
    <span class="SKwd">catch</span> <span class="SFct">testDefer</span>(<span class="SKwd">true</span>)  <span class="SCmt">// Execute the function with error condition</span>
    <span class="SItr">@assert</span>(g_Defer == <span class="SNum">4</span>)  <span class="SCmt">// Expect g_Defer to be 4 (1 + 3) since only 'defer&lt;err&gt;' and the general 'defer' executed</span>

    <span class="SCmt">// Test case where no error is raised</span>
    g_Defer = <span class="SNum">0</span>
    <span class="SKwd">catch</span> <span class="SFct">testDefer</span>(<span class="SKwd">false</span>)  <span class="SCmt">// Execute the function without error condition</span>
    <span class="SItr">@assert</span>(g_Defer == <span class="SNum">5</span>)   <span class="SCmt">// Expect g_Defer to be 5 (2 + 3) since only 'defer&lt;noerr&gt;' and the general 'defer' executed</span>
}</span></div>

<h3 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety</h3><h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety Checks in Swag </h4>
<p>Swag provides various safety checks that can be enabled at different granularity levels—module,  function, or even individual instruction—using the <span class="code-inline">#[Swag.Safety]</span> attribute. </p>
<p>These safety checks are designed to prevent common programming errors by triggering panics during  unsafe operations, such as overflows, invalid math operations, or out-of-bounds access. </p>
<p>You can also configure safety checks globally based on the build configuration using  <span class="code-inline">buildCfg.safetyGuards</span>. </p>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> Swag offers four predefined build configurations: <span class="code-inline">debug</span>, <span class="code-inline">fast-debug</span>, <span class="code-inline">fast-compile</span>, and <span class="code-inline">release</span>. Safety checks are enabled by default in <span class="code-inline">debug</span> and <span class="code-inline">fast-debug</span>, but they are disabled in <span class="code-inline">fast-compile</span> and <span class="code-inline">release</span> for performance reasons. </p>
</div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Overflow Safety </h4>
<div class="code-block"><span class="SAtr">#[Swag.Safety("overflow", true)]</span></div>
<p>When overflow safety is enabled, Swag will panic if arithmetic operations overflow or if bits  are lost during an integer conversion. </p>
<p>Operators that can cause overflows include: <span class="code-inline">+ - * &lt;&lt; &gt;&gt;</span> and their compound assignments <span class="code-inline">+= -= *= </code> &lt;&lt;= &gt;&gt;=<span class="code-inline">.</code> </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>                                <span class="SCmt">// Initialize x with the maximum value for u8</span>
    <span class="SCmt">// x += 1                                      // Uncommenting this will cause a panic due to overflow</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Disabling Overflow Safety with <span class="code-inline">#over</span> </h5>
<p>If an overflow is expected and should not cause a panic, the <span class="code-inline">#over</span> modifier can be used with the  operation to bypass the safety check. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>                                <span class="SCmt">// Initialize x with the maximum value for u8</span>
    x += <span class="SCmp">#over</span> <span class="SNum">1</span>                                  <span class="SCmt">// This will wrap around without causing a panic</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)                               <span class="SCmt">// Assert that x has wrapped around to 0</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Global Overflow Safety Control </h5>
<p>To disable overflow safety checks globally within a scope, use <span class="code-inline">#[Swag.AllowOverflow(true)]</span>. This  prevents overflows from causing panics for all operations in the scope. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.AllowOverflow(true)]</span>
<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>                                <span class="SCmt">// Initialize x with the maximum value for u8</span>
    x += <span class="SNum">1</span>                                        <span class="SCmt">// Overflow occurs, but no panic due to global setting</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)                               <span class="SCmt">// Assert that x has wrapped around to 0</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Promoting Operations to Prevent Overflow </h5>
<p>For operations involving 8-bit or 16-bit integers, you can use the <span class="code-inline">#prom</span> modifier to promote the  operation to 32-bit, thereby avoiding overflow by widening the operand types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span> + <span class="SCmp">#prom</span> <span class="SNum">1</span>                      <span class="SCmt">// Promote the addition to 32-bit to avoid overflow</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">256</span>)                             <span class="SCmt">// Assert that the result is 256</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(x) == <span class="STpe">u32</span>)                    <span class="SCmt">// Assert that the type of x is u32</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Information Loss During Casting </h4>
<p>Swag checks for potential information loss during type casting operations, such as when converting  between different integer types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x1 = <span class="SNum">255</span>'<span class="STpe">u8</span>                               <span class="SCmt">// Initialize x1 with the maximum value for u8</span>

    <span class="SCmt">// var y0 = cast(s8) x1                       // This would cause a panic because 255 cannot be </span>
                                                  <span class="SCmt">// represented as s8</span>

    <span class="SKwd">let</span> y1 = <span class="SKwd">cast</span>&lt;overflow&gt;(<span class="STpe">s8</span>) x1                    <span class="SCmt">// Use #over to bypass safety checks and allow this </span>
                                                  <span class="SCmt">// cast</span>
    <span class="SItr">@assert</span>(y1 == -<span class="SNum">1</span>)                             <span class="SCmt">// Assert that y1 is -1 after wrapping</span>

    <span class="SKwd">let</span> x2 = -<span class="SNum">1</span>'<span class="STpe">s8</span>                                <span class="SCmt">// Initialize x2 with the minimum value for s8</span>
    <span class="SCmt">// var y2 = cast(u8) x2                       // This would cause a panic because x2 is negative</span>
    <span class="SKwd">let</span> y2 = <span class="SKwd">cast</span>&lt;overflow&gt;(<span class="STpe">u8</span>) x2                    <span class="SCmt">// Use #over to bypass safety checks</span>
    <span class="SItr">@assert</span>(y2 == <span class="SNum">255</span>)                            <span class="SCmt">// Assert that y2 is 255 after wrapping</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Disabling Overflow Safety Globally </h5>
<p>Safety checks for overflow can be globally disabled, allowing operations that would typically  panic due to overflow to proceed normally. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.AllowOverflow(true)]</span>
<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>                                <span class="SCmt">// Initialize x with the maximum value for u8</span>
    x += <span class="SNum">255</span>                                      <span class="SCmt">// x becomes 254 after wrapping</span>
    x += <span class="SNum">1</span>                                        <span class="SCmt">// x becomes 255</span>
    x &gt;&gt;= <span class="SNum">1</span>                                       <span class="SCmt">// x becomes 127 after right shift</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">127</span>)                             <span class="SCmt">// Assert that x is 127</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Dynamic Cast Type Safety </h4>
<div class="code-block"><span class="SAtr">#[Swag.Safety("dyncast", true)]</span></div>
<p>Swag will panic if a cast from the <span class="code-inline">any</span> type to another type is invalid, ensuring type safety  when working with dynamic types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"1"</span>                              <span class="SCmt">// Initialize x with a string</span>
    <span class="SKwd">let</span> y  = <span class="SKwd">cast</span>(<span class="STpe">string</span>) x                       <span class="SCmt">// This is valid because the underlying type is correct</span>
    <span class="SCmt">// var z = cast(s32) x                        // This is invalid and will cause a panic</span>
    <span class="SCmt">// @assert(z == 0)</span>
}</span></div>
<p>Swag will also panic if casting from an interface to a pointer to struct that cannot be performed. </p>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Array Bounds Checking </h4>
<div class="code-block"><span class="SAtr">#[Swag.Safety("boundcheck", true)]</span></div>
<p>Swag will panic if an index is out of range when dereferencing a sized value such as an array, a  slice, or a string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x   = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]                           <span class="SCmt">// Initialize an array</span>
    <span class="SKwd">var</span> idx = <span class="SNum">10</span>                                  <span class="SCmt">// Set an out-of-bounds index</span>
    <span class="SCmt">// @assert(x[idx] == 1)                       // This will cause a panic due to out-of-bounds access</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety When Indexing a Slice </h5>
<p>Swag ensures that indexing operations on slices are within bounds to prevent runtime errors. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="SKwd">const</span> [..] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]             <span class="SCmt">// Initialize a slice</span>
    <span class="SKwd">var</span> idx = <span class="SNum">1</span>                                   <span class="SCmt">// Set a valid index</span>
    <span class="SItr">@assert</span>(x[idx] == <span class="SNum">1</span>)                          <span class="SCmt">// Assert that x[1] is 1</span>
    idx += <span class="SNum">9</span>                                      <span class="SCmt">// Move the index out of bounds</span>
    <span class="SCmt">// @assert(x[idx] == 1)                       // This will cause a panic due to out-of-bounds access</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety When Slicing a Sized Value </h5>
<p>Swag will panic if a slice operation goes out of bounds, ensuring safe slicing of arrays or strings. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="SKwd">const</span> [..] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]             <span class="SCmt">// Initialize a slice</span>
    <span class="SCmt">// var slice = x[1..4]                        // This will cause a panic due to out-of-bounds access</span>
    <span class="SCmt">// @assert(slice[0] == 1)</span>
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x   = <span class="SStr">"string"</span>                            <span class="SCmt">// Initialize a string</span>
    <span class="SKwd">var</span> idx = <span class="SNum">10</span>                                  <span class="SCmt">// Set an out-of-bounds index for slicing</span>
    <span class="SCmt">// var slice = x[0..idx]                      // This will cause a panic due to out-of-bounds slicing</span>
    <span class="SCmt">// @assert(slice[0] == 's')</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Math Safety </h4>
<div class="code-block"><span class="SAtr">#[Swag.Safety("math", true)]</span></div>
<p>Swag will panic if certain math operations are invalid, such as division by zero or invalid  arguments to math functions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>'<span class="STpe">f32</span>                                 <span class="SCmt">// Initialize x with a float value</span>
    <span class="SKwd">var</span> y = <span class="SNum">0</span>'<span class="STpe">f32</span>                                 <span class="SCmt">// Initialize y with zero</span>
    <span class="SCmt">// var z = x / y                              // Division by zero will cause a panic</span>
    <span class="SCmt">// @print(z)</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Checking Invalid Math Intrinsic Arguments </h5>
<p>Swag also checks for invalid arguments passed to certain math intrinsics, causing a panic if the  arguments are unsupported or invalid. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// The following operations will panic if the arguments are invalid:</span>

    <span class="SCmt">// @abs(-128)                                 // Invalid argument for abs</span>
    <span class="SCmt">// @log(-2'f32)                               // Logarithm of a negative number is invalid</span>
    <span class="SCmt">// @log2(-2'f32)                              // Logarithm base 2 of a negative number is invalid</span>
    <span class="SCmt">// @log10(2'f64)                              // Logarithm base 10 of a negative number is invalid</span>
    <span class="SCmt">// @sqrt(-2'f32)                              // Square root of a negative number is invalid</span>
    <span class="SCmt">// @asin(-2'f32)                              // Arc sine out of valid range is invalid</span>
    <span class="SCmt">// @acos(2'f32)                               // Arc cosine out of valid range is invalid</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Switch Safety </h4>
<div class="code-block"><span class="SAtr">#[Swag.Safety("switch", true)]</span></div>
<p>Swag will panic if a switch statement marked with <span class="code-inline">#[Swag.Complete]</span> does not cover all possible  cases, ensuring exhaustive pattern matching. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Color</span> { <span class="SCst">Red</span>, <span class="SCst">Green</span>, <span class="SCst">Blue</span> }               <span class="SCmt">// Define an enum with three values</span>

    <span class="SKwd">func</span> <span class="SFct">colorToString</span>(color: <span class="SCst">Color</span>) -&gt; <span class="STpe">string</span>
    {
        <span class="SCmt">// #[Swag.Complete]                       // Mark the switch as complete</span>
        <span class="SLgc">switch</span> color
        {
            <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Red</span>: <span class="SLgc">return</span> <span class="SStr">"Red"</span>          <span class="SCmt">// Handle Red</span>
            <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Green</span>: <span class="SLgc">return</span> <span class="SStr">"Green"</span>      <span class="SCmt">// Handle Green</span>
            <span class="SCmt">// If `Color.Blue` is not covered, this will cause a panic due to missing case</span>
        }

        <span class="SLgc">return</span> <span class="SStr">""</span>                                 <span class="SCmt">// Return an empty string as a fallback</span>
    }
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Boolean Safety </h4>
<div class="code-block"><span class="SAtr">#[Swag.Safety("bool", true)]</span></div>
<p>Swag will panic if a boolean value is not either <span class="code-inline">true</span> (1) or <span class="code-inline">false</span> (0), enforcing strict  boolean type safety. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> b: <span class="STpe">u8</span> = <span class="SNum">2</span>                                 <span class="SCmt">// Initialize b with an invalid boolean value</span>
    <span class="SCmt">// if b { ... }                               // This will panic because b is not a valid boolean</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">NaN Safety </h4>
<div class="code-block"><span class="SAtr">#[Swag.Safety("nan", true)]</span></div>
<p>Swag will panic if a floating-point <span class="code-inline">NaN</span> (Not a Number) is used in an operation, ensuring that  NaNs do not propagate through calculations. </p>

<h2 id="_014_000_compile-time_evaluation_swg">Compile-time evaluation</h2><p>One of the most powerful features of Swag is its ability to execute <b>everything</b> at compile-time.  This capability allows Swag to function not only as a compiled language but also as a scripting  language, where the compiler effectively acts as an interpreter. This flexibility enables developers  to leverage compile-time execution for tasks that traditionally require runtime evaluation,  resulting in more efficient and versatile code. </p>

<h3 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Constexpr</h3><h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Compile-Time Function Evaluation with <span class="code-inline">#[Swag.ConstExpr]</span> </h4>
<p>The <span class="code-inline">#[Swag.ConstExpr]</span> attribute marks a function as capable of being evaluated during compile time.  This enables the compiler to resolve the function's result at compile time, provided that all inputs  are also known at compile time. This approach significantly optimizes the code by precomputing values  and eliminating the need for these calculations at runtime.  </p>
<p>Functions marked with <span class="code-inline">#[Swag.ConstExpr]</span> are ideal for returning constant values or performing operations  that are determined before runtime, thereby improving efficiency. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The function 'isThisDebug' is annotated with 'Swag.ConstExpr', indicating that </span>
<span class="SCmt">// it can be evaluated during the compilation phase. Given that this function </span>
<span class="SCmt">// consistently returns `true`, the result is established at compile time.</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">isThisDebug</span>() =&gt; <span class="SKwd">true</span>

<span class="SCmt">// This conditional block demonstrates how 'isThisDebug' can be utilized in a </span>
<span class="SCmt">// compile-time context. Since 'isThisDebug' invariably returns `true`, the </span>
<span class="SCmt">// condition `isThisDebug() == false` evaluates to `false`, and thus the compiler </span>
<span class="SCmt">// will exclude the code inside the block from the final compilation.</span>
<span class="SCmp">#if</span> <span class="SFct">isThisDebug</span>() == <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span> <span class="SStr">"this should not be called!"</span>
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Recursive Compile-Time Evaluation </h4>
<p>The <span class="code-inline">#[Swag.ConstExpr]</span> attribute can also be applied to more complex functions,  including those that perform recursion. This allows such recursive functions to  be entirely evaluated at compile time, effectively reducing runtime overhead  and improving overall performance. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This function 'factorial' calculates the factorial of a given number recursively. </span>
<span class="SCmt">// By marking it with 'Swag.ConstExpr', the factorial is computed during compilation, </span>
<span class="SCmt">// avoiding the need for runtime computation.</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">factorial</span>(x: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>
{
    <span class="SCmt">// Base case: return 1 when x equals 1</span>
    <span class="SLgc">if</span> x == <span class="SNum">1</span>:
        <span class="SLgc">return</span> <span class="SNum">1</span>
    
    <span class="SCmt">// Recursive case: multiply x by the factorial of (x - 1)</span>
    <span class="SLgc">return</span> x * <span class="SFct">factorial</span>(x - <span class="SNum">1</span>)
}

<span class="SCmt">// The `#assert` directive ensures that 'factorial(4)' equals 24. As 'factorial' </span>
<span class="SCmt">// is evaluated at compile time, this assertion is verified before execution begins.</span>
<span class="SCmp">#assert</span> <span class="SFct">factorial</span>(<span class="SNum">4</span>) == <span class="SNum">24</span> <span class="SCmt">// Evaluated at compile time</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Compile-Time Constant Expressions </h4>
<p>In this section, <span class="code-inline">#[Swag.ConstExpr]</span> is utilized to define a straightforward constant  expression. The function returns a fixed value that the compiler resolves during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The 'getMagicNumber' function returns a constant value of 42. </span>
<span class="SCmt">// Since it's a compile-time constant expression, this value is resolved at compile time.</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">getMagicNumber</span>() -&gt; <span class="STpe">s32</span>
{
    <span class="SLgc">return</span> <span class="SNum">42</span>
}

<span class="SCmt">// The assertion checks that 'getMagicNumber()' equals 42, verified at compile time.</span>
<span class="SCmp">#assert</span> <span class="SFct">getMagicNumber</span>() == <span class="SNum">42</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Compile-Time Conditional Logic </h4>
<p>This example illustrates how the function <span class="code-inline">isEven</span> determines if a number is even.  By marking it with <span class="code-inline">#[Swag.ConstExpr]</span>, the compiler can perform this logic during  the compilation phase. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The 'isEven' function checks whether a number is even. </span>
<span class="SCmt">// With the 'Swag.ConstExpr' annotation, this check occurs at compile time.</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">isEven</span>(x: <span class="STpe">s32</span>) -&gt; <span class="STpe">bool</span>
{
    <span class="SLgc">return</span> x % <span class="SNum">2</span> == <span class="SNum">0</span>
}

<span class="SCmt">// This block only compiles if the number 4 is even. Since 4 is indeed even, </span>
<span class="SCmt">// the error is not triggered, and the code compiles successfully.</span>
<span class="SCmp">#if</span> <span class="SFct">isEven</span>(<span class="SNum">4</span>) == <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span> <span class="SStr">"4 should be even!"</span>
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Compile-Time Slice Operations </h4>
<p>In this example, <span class="code-inline">#[Swag.ConstExpr]</span> is used to calculate the sum of elements within an array.  The summation is performed during the compilation, optimizing runtime performance. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The 'arraySum' function calculates the sum of all elements in an array. </span>
<span class="SCmt">// Since it is a compile-time function, the sum is computed during the compilation phase.</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">arraySum</span>(arr: <span class="SKwd">const</span> [..] <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>
{
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> val <span class="SLgc">in</span> arr:
        sum += val
    <span class="SLgc">return</span> sum
}

<span class="SCmt">// The assertion verifies that the sum of the array [1, 2, 3, 4, 5] equals 15. </span>
<span class="SCmt">// This is checked and confirmed at compile time.</span>
<span class="SCmp">#assert</span> <span class="SFct">arraySum</span>([<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>, <span class="SNum">5</span>]) == <span class="SNum">15</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Compile-Time Fibonacci Sequence </h4>
<p>This example showcases how <span class="code-inline">#[Swag.ConstExpr]</span> enables a recursive function to  compute the Fibonacci sequence at compile time, optimizing the execution. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The 'fibonacci' function calculates the nth Fibonacci number recursively. </span>
<span class="SCmt">// The result is computed during the compilation when marked with 'Swag.ConstExpr'.</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">fibonacci</span>(n: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>
{
    <span class="SLgc">if</span> n &lt;= <span class="SNum">1</span>:
        <span class="SLgc">return</span> n
    <span class="SLgc">return</span> <span class="SFct">fibonacci</span>(n - <span class="SNum">1</span>) + <span class="SFct">fibonacci</span>(n - <span class="SNum">2</span>)
}

<span class="SCmt">// The 5th Fibonacci number, which is 5, is calculated during compilation and asserted here.</span>
<span class="SCmp">#assert</span> <span class="SFct">fibonacci</span>(<span class="SNum">5</span>) == <span class="SNum">5</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Compile-Time Bitwise Operations </h4>
<p>Bitwise operations can also be evaluated at compile time using <span class="code-inline">#[Swag.ConstExpr]</span>.  This example demonstrates how to check if a specific bit is set within a number. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The 'isBitSet' function checks whether a particular bit is set in a number. </span>
<span class="SCmt">// With 'Swag.ConstExpr', this operation is performed at compile time.</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">isBitSet</span>(num: <span class="STpe">s32</span>, bit: <span class="STpe">s32</span>) -&gt; <span class="STpe">bool</span>
{
    <span class="SLgc">return</span> (num & (<span class="SNum">1</span> &lt;&lt; bit)) != <span class="SNum">0</span>
}

<span class="SCmt">// The assertion verifies that the 3rd bit (0-indexed) of the number 8 is set. </span>
<span class="SCmt">// Since 8 in binary is 1000, the check is resolved during compilation.</span>
<span class="SCmp">#assert</span> <span class="SFct">isBitSet</span>(<span class="SNum">8</span>, <span class="SNum">3</span>) == <span class="SKwd">true</span></span></div>

<h3 id="_014_000_compile-time_evaluation_swg__014_002_run_swg">Run</h3><h4 id="_014_000_compile-time_evaluation_swg__014_002_run_swg">Force Compile-Time Execution with <span class="code-inline">#run</span> </h4>
<p>The <span class="code-inline">#run</span> directive allows you to invoke a function at compile time, even if that function  is not marked with the <span class="code-inline">#[Swag.ConstExpr]</span> attribute. This powerful feature enables  compile-time execution of any function, regardless of its original design or intent,  whether it comes from external modules, system libraries, or is defined within your code. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The function 'isThisRelease' is not marked with 'Swag.ConstExpr', which means</span>
<span class="SCmt">// it is not specifically prepared for compile-time evaluation.</span>
<span class="SKwd">func</span> <span class="SFct">isThisRelease</span>() =&gt; <span class="SKwd">true</span>

<span class="SCmt">// However, by using the `#run` directive, we force the function to be executed </span>
<span class="SCmt">// at compile time. In this example, since 'isThisRelease()' returns `true`, the </span>
<span class="SCmt">// condition `isThisRelease() == false` evaluates to `false`, and the code block </span>
<span class="SCmt">// is excluded from the compilation process.</span>
<span class="SCmp">#if</span> <span class="SFct">#run</span> <span class="SFct">isThisRelease</span>() == <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span> <span class="SStr">"this should not be called!"</span>
}</span></div>
<p>This capability allows you to execute any function at compile time, whether it  is a system function, a function from an external module, or a user-defined function. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The function 'sum' is a regular function that sums a variable number of integers.</span>
<span class="SCmt">// It is not explicitly marked for compile-time evaluation, as it lacks the </span>
<span class="SCmt">// 'Swag.ConstExpr' attribute.</span>
<span class="SKwd">func</span> <span class="SFct">sum</span>(values: <span class="STpe">s32</span>...) -&gt; <span class="STpe">s32</span>
{
    <span class="SKwd">var</span> result = <span class="SNum">0</span>'<span class="STpe">s32</span>
    <span class="SLgc">foreach</span> v <span class="SLgc">in</span> values:
        result += v
    <span class="SLgc">return</span> result
}

<span class="SCmt">// Despite the absence of 'Swag.ConstExpr', we can still execute 'sum' at compile time </span>
<span class="SCmt">// using the `#run` directive. The expression `#run sum(1, 2, 3, 4) + 10` is evaluated </span>
<span class="SCmt">// during compilation, and the result is assigned to 'SumValue'.</span>
<span class="SKwd">const</span> <span class="SCst">SumValue</span> = <span class="SFct">#run</span> <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>) + <span class="SNum">10</span>
<span class="SCmp">#assert</span> <span class="SCst">SumValue</span> == <span class="SNum">20</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_002_run_swg"><span class="code-inline">#run</span> Block </h4>
<p>The <span class="code-inline">#run</span> directive can also be used in a block format. When placed inside a block,  <span class="code-inline">#run</span> enables you to execute complex logic or initialize global variables at compile time.  Multiple <span class="code-inline">#run</span> blocks can exist in a program, but the execution order is undefined,  so care must be taken when relying on the order of these blocks. </p>
<p>An example of using <span class="code-inline">#run</span> to precompute global values at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// A global array 'G' that we intend to initialize using a more complex logic.</span>
<span class="SKwd">var</span> <span class="SCst">G</span>: [<span class="SNum">5</span>] <span class="STpe">f32</span> = <span class="SKwd">undefined</span></span></div>
<p>The <span class="code-inline">#run</span> block below initializes the global array <span class="code-inline">G</span> with the values <span class="code-inline">[1, 2, 4, 8, 16]</span>  at compile time, ensuring that the array is fully prepared before runtime. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
{
    <span class="SKwd">var</span> value = <span class="SNum">1</span>'<span class="STpe">f32</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SItr">@countof</span>(<span class="SCst">G</span>)
    {
        <span class="SCst">G</span>[i] = value
        value *= <span class="SNum">2</span>
    }
}</span></div>
<p><span class="code-inline">#test</span> blocks are executed after <span class="code-inline">#run</span> blocks, even when run at compile time  (during testing). This allows you to validate the correctness of compile-time  calculations, as demonstrated below by verifying the contents of <span class="code-inline">G</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">2</span>] == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">3</span>] == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">4</span>] == <span class="SNum">16</span>)
}</span></div>
<p>The flexibility of Swag allows it to function as a scripting language.  In fact, if your project only contains <span class="code-inline">#run</span> blocks, you are effectively  writing a script that runs during compilation. </p>
<h4 id="_014_000_compile-time_evaluation_swg__014_002_run_swg"><span class="code-inline">#run</span> Expression </h4>
<p>The <span class="code-inline">#run</span> directive can also be used as an expression block. The return type  of the block is inferred from the <span class="code-inline">return</span> statement within it. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">Value</span> = <span class="SFct">#run</span>
    {
        <span class="SKwd">var</span> result: <span class="STpe">f32</span>
        <span class="SLgc">for</span> <span class="SNum">10</span>:
            result += <span class="SNum">1</span>
        <span class="SLgc">return</span> result <span class="SCmt">// The inferred type of 'Value' will be 'f32'.</span>
    }
    <span class="SCmp">#assert</span> <span class="SCst">Value</span> == <span class="SNum">10.0</span>
}</span></div>
<p>This technique can also be utilized to initialize a static array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">N</span> = <span class="SNum">4</span>
    <span class="SKwd">const</span> <span class="SCst">PowerOfTwo</span>: [<span class="SCst">N</span>] <span class="STpe">s32</span> = <span class="SFct">#run</span>
    {
        <span class="SKwd">var</span> arr: [<span class="SCst">N</span>] <span class="STpe">s32</span>
        <span class="SLgc">for</span> i <span class="SLgc">in</span> arr:
            arr[i] = <span class="SNum">1</span> &lt;&lt; <span class="SKwd">cast</span>(<span class="STpe">u32</span>) i
        <span class="SLgc">return</span> arr
    }

    <span class="SCmp">#assert</span> <span class="SCst">PowerOfTwo</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SCst">PowerOfTwo</span>[<span class="SNum">1</span>] == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SCst">PowerOfTwo</span>[<span class="SNum">2</span>] == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SCst">PowerOfTwo</span>[<span class="SNum">3</span>] == <span class="SNum">8</span>
}</span></div>
<p>String initialization is another use case for <span class="code-inline">#run</span> blocks. The block  below demonstrates how to construct a string at compile time. This is safe  because the <span class="code-inline">#run</span> block creates a copy of the string, ensuring it persists  beyond the block's execution. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">MyString</span>: <span class="STpe">string</span> = <span class="SFct">#run</span>
    {
        <span class="SKwd">var</span> str: [<span class="SNum">3</span>] <span class="STpe">u8</span>
        str[<span class="SNum">0</span>] = <span class="SStr">`a`</span>
        str[<span class="SNum">1</span>] = <span class="SStr">`b`</span>
        str[<span class="SNum">2</span>] = str[<span class="SNum">1</span>] + <span class="SNum">1</span>
        <span class="SLgc">return</span> <span class="SKwd">cast</span>(<span class="STpe">string</span>) str
    }
    <span class="SCmp">#assert</span> <span class="SCst">MyString</span> == <span class="SStr">"abc"</span>
}</span></div>
<p><span class="code-inline">#run</span> blocks can also initialize plain old data (POD) structs. If necessary,  you can enforce POD status on a struct by tagging it with <span class="code-inline">#[Swag.ConstExpr]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r, g, b: <span class="STpe">u8</span> }
    <span class="SKwd">const</span> <span class="SCst">White</span>: <span class="SCst">RGB</span> = <span class="SFct">#run</span>
    {
        <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span> = <span class="SKwd">undefined</span>
        rgb.r = <span class="SNum">255</span>
        rgb.g = rgb.r
        rgb.b = rgb.r
        <span class="SLgc">return</span> rgb
    }
    <span class="SCmp">#assert</span> <span class="SCst">White</span>.r == <span class="SNum">255</span> <span class="SLgc">and</span> <span class="SCst">White</span>.g == <span class="SNum">255</span> <span class="SLgc">and</span> <span class="SCst">White</span>.b == <span class="SNum">255</span>
}</span></div>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> It is possible to convert a complex struct (e.g., one that uses the heap) into  a static array, provided the struct implements the <span class="code-inline">opCount</span> and <span class="code-inline">opSlice</span> methods.  In this case, the resulting type will be a static array. The compiler will invoke  <span class="code-inline">opCount</span> to determine the array size and <span class="code-inline">opSlice</span> to initialize its content.  If the struct also implements <span class="code-inline">opDrop</span>, it will be called after the array  conversion is complete. </p>
</div>

<h3 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg">Compiler instructions</h3><h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#assert</span> </h4>
<p>The <span class="code-inline">#assert</span> directive is used to perform a static assertion during the compilation process.  It ensures that a particular condition is true at compile time. If the condition evaluates to <span class="code-inline">false</span>,  compilation will fail, providing an error message. This is particularly useful for enforcing  compile-time invariants and validating assumptions within your code. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span> <span class="SKwd">true</span> <span class="SCmt">// This assertion always passes, so no error is triggered.</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#defined(SYMBOL)</span> </h4>
<p>The <span class="code-inline">#defined(SYMBOL)</span> intrinsic checks if a given symbol exists within the current context  at compile time. It returns <span class="code-inline">true</span> if the symbol is defined, and <span class="code-inline">false</span> otherwise. This is  useful for conditional compilation, allowing you to verify the existence of variables,  constants, or functions before using them. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span> !<span class="SItr">#defined</span>(<span class="SCst">DOES_NOT_EXISTS</span>) <span class="SCmt">// Ensures that the symbol 'DOES_NOT_EXISTS' is not defined.</span>
<span class="SCmp">#assert</span> <span class="SItr">#defined</span>(<span class="SCst">Global</span>)            <span class="SCmt">// Confirms that the symbol 'Global' is defined.</span>
<span class="SKwd">var</span> <span class="SCst">Global</span> = <span class="SNum">0</span>                      <span class="SCmt">// Define a global variable 'Global'.</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#if</span>/<span class="code-inline">#elif</span>/<span class="code-inline">#else</span> </h4>
<p>The <span class="code-inline">#if</span>/<span class="code-inline">#elif</span>/<span class="code-inline">#else</span> directives are used for static conditional compilation.  They evaluate expressions at compile time and include or exclude code based on the result.  This mechanism allows you to compile different sections of code based on predefined constants  or compile-time conditions. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">DEBUG</span>   = <span class="SNum">1</span>
<span class="SKwd">const</span> <span class="SCst">RELEASE</span> = <span class="SNum">0</span>

<span class="SCmp">#if</span> <span class="SCst">DEBUG</span>
{
    <span class="SCmt">// This block is compiled because DEBUG is set to 1.</span>
}
<span class="SCmp">#elif</span> <span class="SCst">RELEASE</span>
{
    <span class="SCmt">// This block would be compiled if RELEASE were true and DEBUG were false.</span>
}
<span class="SCmp">#else</span>
{
    <span class="SCmt">// This block is compiled if neither DEBUG nor RELEASE is true.</span>
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#error</span>/<span class="code-inline">#warning</span> </h4>
<p>The <span class="code-inline">#error</span> and <span class="code-inline">#warning</span> directives allow you to raise compile-time errors and warnings,  respectively. <span class="code-inline">#error</span> will cause the compilation to fail with a custom error message,  while <span class="code-inline">#warning</span> will produce a warning message during compilation but will not stop the process.  These directives are useful for enforcing compile-time checks and providing informative messages  during the build process. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#if</span> <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span> <span class="SStr">"this is an error"</span>       <span class="SCmt">// Raises a compile-time error if this block is reached.</span>
    <span class="SCmp">#warning</span> <span class="SStr">"this is a warning"</span>    <span class="SCmt">// Raises a compile-time warning if this block is reached.</span>
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#global</span> </h4>
<p>The <span class="code-inline">#global</span> directive can be placed at the top of a source file to apply global settings  or attributes across the entire file. These directives control various aspects of the  compilation and symbol visibility for the entire file. </p>
<p>Examples: </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Skip the content of the file (but it must be a valid Swag file).</span>
<span class="SCmp">#global</span> skip

<span class="SCmt">// All symbols in the file will be public (accessible from other modules).</span>
<span class="SCmp">#global</span> <span class="SKwd">public</span>

<span class="SCmt">// All symbols in the file will be internal (accessible only within the same module).</span>
<span class="SCmp">#global</span> <span class="SKwd">internal</span>

<span class="SCmt">// All symbols in the file will be placed within the namespace 'Toto'.</span>
<span class="SCmp">#global</span> <span class="SKwd">namespace</span> <span class="SCst">Toto</span>

<span class="SCmt">// Conditional compilation for the entire file.</span>
<span class="SCmp">#global</span> <span class="SCmp">#if</span> <span class="SCst">DEBUG</span> == <span class="SKwd">true</span>

<span class="SCmt">// Apply attributes to all declarations in the file.</span>
<span class="SCmp">#global</span> <span class="SAtr">#[Swag.Safety("", true)]</span>

<span class="SCmt">// Export the entire file for external usage.</span>
<span class="SCmt">// This is similar to making everything public, but the file will also be copied </span>
<span class="SCmt">// in its entirety to the public folder.</span>
<span class="SCmp">#global</span> export</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#foreignlib</span> </h4>
<p>The <span class="code-inline">#foreignlib</span> directive is used to link with an external library during the compilation  process. This allows your program to utilize functions, variables, and resources defined  in the external library. The library name should be provided as a string. </p>
<p>Example: </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#foreignlib</span> <span class="SStr">"windows.lib"</span></span></div>
<p>This example links the program with the "windows.lib" library, allowing the use of Windows  API functions and resources defined within that library. </p>

<h3 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Code inspection</h3><h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg"><span class="code-inline">#message</span> Function </h4>
<p>The <span class="code-inline">#message</span> function in Swag is a special hook that gets invoked by the compiler  when specific events occur during the build process. This function allows you to  intercept certain stages of compilation and execute custom actions or checks.  The parameter of <span class="code-inline">#message</span> is a mask that specifies the compilation stage or  event that should trigger the function. By utilizing these hooks, developers  can gain deeper insights into the compilation process and perform additional  processing when necessary. </p>
<h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Function Message Mask </h4>
<p>For instance, when you use the <span class="code-inline">Swag.CompilerMsgMask.SemFunctions</span> flag, the <span class="code-inline">#message</span>  function will be called each time a function within the module has been successfully  typed. This means the function has been fully analyzed and its type information is  available. Within the <span class="code-inline">@compiler()</span> interface, you can use the <span class="code-inline">getMessage()</span> method  to retrieve details about the event that triggered the call, such as the function's name  and type information. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemFunctions</span>)
{
    <span class="SCmt">// Obtain the compiler interface to interact with the compilation process</span>
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()

    <span class="SCmt">// Retrieve the current compilation message</span>
    <span class="SKwd">let</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// Given that the mask is `Swag.CompilerMsgMask.SemFunctions`, the message </span>
    <span class="SCmt">// pertains to a function, allowing us to safely cast the type information.</span>
    <span class="SKwd">let</span> typeFunc = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoFunc</span>) msg.type

    <span class="SCmt">// The message name, in this case, corresponds to the function's name being compiled.</span>
    <span class="SKwd">let</span> nameFunc = msg.name

    <span class="SCmt">// Example: Count functions whose names start with "XX"</span>
    <span class="SLgc">if</span> <span class="SItr">@countof</span>(nameFunc) &gt; <span class="SNum">2</span> <span class="SLgc">and</span> nameFunc[<span class="SNum">0</span>] == <span class="SStr">`X`</span> <span class="SLgc">and</span> nameFunc[<span class="SNum">1</span>] == <span class="SStr">`X`</span>:
        <span class="SCst">G</span> += <span class="SNum">1</span>
}

<span class="SCmt">// Global variable to count the number of functions starting with "XX"</span>
<span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span>

<span class="SCmt">// Example functions to demonstrate the functionality of the `#message` hook</span>
<span class="SKwd">func</span> <span class="SFct">XXTestFunc1</span>() {}
<span class="SKwd">func</span> <span class="SFct">XXTestFunc2</span>() {}
<span class="SKwd">func</span> <span class="SFct">XXTestFunc3</span>() {}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Semantic Pass Completion </h4>
<p>The compiler will invoke the following <span class="code-inline">#message</span> function after the semantic pass  has completed. The semantic pass occurs after all functions within the module have  been parsed and typed. This stage is ideal for performing final checks or actions  that need to consider the entire module's content. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">PassAfterSemantic</span>)
{
    <span class="SCmt">// Verify that exactly 3 functions starting with "XX" were found during the compilation</span>
    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">3</span>)
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Global Variables Message Mask </h4>
<p>The <span class="code-inline">#message</span> function can also be triggered for each global variable in the module  by using the <span class="code-inline">Swag.CompilerMsgMask.SemGlobals</span> flag. This allows you to process or  validate each global variable as it is encountered by the compiler during the  semantic analysis phase. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemGlobals</span>)
{
    <span class="SCmt">// Retrieve the compiler interface</span>
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()

    <span class="SCmt">// Get the current message, which contains details about the global variable</span>
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// Process the message as needed, for example, by analyzing the global variable's properties</span>
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Global Types Message Mask </h4>
<p>Similarly, the <span class="code-inline">Swag.CompilerMsgMask.SemTypes</span> flag triggers the <span class="code-inline">#message</span> function  for each global type in the module, such as structs, enums, and interfaces.  This allows you to inspect, analyze, or modify global types during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemTypes</span>)
{
    <span class="SCmt">// Access the compiler interface</span>
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()

    <span class="SCmt">// Retrieve the current message, which contains information about the global type</span>
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// Process the message as required, which could include analyzing type attributes or properties</span>
}</span></div>

<h2 id="_017_000_meta_programming_swg">Meta programming</h2><p>Swag provides the ability to construct and inject source code at compile time.  This powerful feature allows you to dynamically generate code based on compile-time  conditions or inputs, and have that code seamlessly integrated into the final program.  The source code is supplied as a <b>string</b>, and it must be a valid Swag program. </p>
<p>This technique opens up possibilities for advanced metaprogramming, where code can  be generated, modified, or extended during the compilation process, reducing redundancy  and enabling more flexible, adaptive programs. </p>

<h3 id="_017_000_meta_programming_swg__017_001_ast_swg">Ast</h3><h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> Block </h4>
<p>The <span class="code-inline">#ast</span> block is one of the simplest methods to generate Swag code dynamically at compile time. It allows you to write code that, when executed during compilation, produces a string. This string is then compiled <b>in place</b> as if it were written directly in the source code. </p>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg">Basic <span class="code-inline">#ast</span> Usage </h4>
<p>A <span class="code-inline">#ast</span> block can be as straightforward as a single expression that returns the string to be compiled. This feature is highly useful for injecting dynamically generated code during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SFct">#ast</span> <span class="SStr">"var x = 666"</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">666</span>)          <span class="SCmt">// The variable 'x' is generated by the `#ast` block and initialized with the value 666.</span>
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> Block with <span class="code-inline">return</span> </h4>
<p>The <span class="code-inline">#ast</span> block can contain more complex logic, including multiple statements and an explicit <span class="code-inline">return</span>. The returned string will be compiled at the location of the <span class="code-inline">#ast</span> block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">2</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">const</span> <span class="SCst">INC</span> = <span class="SNum">5</span>
        <span class="SLgc">return</span> <span class="SStr">"cpt += "</span> ++ <span class="SCst">INC</span> <span class="SCmt">// Generates the code 'cpt += 5', incrementing 'cpt' by the value of 'INC'.</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">7</span>)          <span class="SCmt">// The variable 'cpt' is incremented by 5 as generated by the `#ast` block.</span>
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> for Structs and Enums </h4>
<p>The <span class="code-inline">#ast</span> block can be used to dynamically generate the content of complex types like <span class="code-inline">structs</span> or <span class="code-inline">enums</span>. This approach is particularly valuable for creating code structures based on compile-time conditions or parameters. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SLgc">return</span> <span class="SStr">"x, y: s32 = 666"</span> <span class="SCmt">// Generates two fields 'x' and 'y', both initialized to 666.</span>
        }
    }

    <span class="SKwd">var</span> v: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">666</span>)         <span class="SCmt">// Asserts that the generated field 'x' is correctly initialized to 666.</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)         <span class="SCmt">// Asserts that the generated field 'y' is correctly initialized to 666.</span>
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> with Generics </h4>
<p>The <span class="code-inline">#ast</span> block can be effectively used with generics, allowing for flexible and reusable code generation patterns. This can be particularly powerful when combined with static declarations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">MyStruct</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SLgc">return</span> <span class="SStr">"x, y: "</span> ++ <span class="SItr">#typeof</span>(<span class="SCst">T</span>).name <span class="SCmt">// Generates fields 'x' and 'y' with the type of the generic parameter 'T'.</span>
        }

        z: <span class="STpe">string</span>          <span class="SCmt">// Additional static declaration that adds a field 'z' of type string.</span>
    }

    <span class="SKwd">var</span> v: <span class="SFct">MyStruct</span>'<span class="STpe">bool</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(v.x) == <span class="STpe">bool</span>     <span class="SCmt">// Asserts that the generated field 'x' is of type 'bool'.</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(v.y) == <span class="STpe">bool</span>     <span class="SCmt">// Asserts that the generated field 'y' is of type 'bool'.</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(v.z) == <span class="STpe">string</span>   <span class="SCmt">// Asserts that the static field 'z' is of type 'string'.</span>

    <span class="SKwd">var</span> v1: <span class="SFct">MyStruct</span>'<span class="STpe">f64</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(v1.x) == <span class="STpe">f64</span>     <span class="SCmt">// Asserts that the generated field 'x' is of type 'f64'.</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(v1.y) == <span class="STpe">f64</span>     <span class="SCmt">// Asserts that the generated field 'y' is of type 'f64'.</span>
    <span class="SCmp">#assert</span> <span class="SItr">#typeof</span>(v1.z) == <span class="STpe">string</span>  <span class="SCmt">// Asserts that the static field 'z' is of type 'string'.</span>
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg">Constructing Strings in <span class="code-inline">#ast</span> </h4>
<p>The <span class="code-inline">#ast</span> block requires a <i>string-like</i> value to be returned, which can be dynamically constructed. In this example, the string is manually built, although a more sophisticated method like <span class="code-inline">Core.String</span> is typically recommended. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Compiler]</span>
    <span class="SKwd">func</span> <span class="SFct">append</span>(buf: ^<span class="STpe">u8</span>, val: <span class="STpe">string</span>)
    {
        <span class="SKwd">var</span> len = <span class="SNum">0</span>
        <span class="SLgc">while</span> buf[len]:
            len += <span class="SNum">1</span>
        <span class="SItr">@memcpy</span>(buf + len, <span class="SItr">@dataof</span>(val), <span class="SKwd">cast</span>(<span class="STpe">u64</span>) <span class="SItr">@countof</span>(val) + <span class="SNum">1</span>)
    }

    <span class="SKwd">struct</span> <span class="SCst">Vector3</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SCmt">// Construct the code to compile in this local array</span>
            <span class="SKwd">var</span> buf: [<span class="SNum">256</span>] <span class="STpe">u8</span>
            <span class="SFct">append</span>(buf, <span class="SStr">"x: f32 = 1\n"</span>)
            <span class="SFct">append</span>(buf, <span class="SStr">"y: f32 = 2\n"</span>)
            <span class="SFct">append</span>(buf, <span class="SStr">"z: f32 = 3\n"</span>)

            <span class="SCmt">// Return the constructed code to the compiler</span>
            <span class="SLgc">return</span> <span class="SKwd">cast</span>(<span class="STpe">string</span>) buf
        }
    }

    <span class="SKwd">var</span> v: <span class="SCst">Vector3</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">1</span>)           <span class="SCmt">// Asserts that the generated field 'x' is initialized to 1.</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">2</span>)           <span class="SCmt">// Asserts that the generated field 'y' is initialized to 2.</span>
    <span class="SItr">@assert</span>(v.z == <span class="SNum">3</span>)           <span class="SCmt">// Asserts that the generated field 'z' is initialized to 3.</span>
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg">Real-World Example </h4>
<p>The following is a practical example from the <span class="code-inline">Std.Core</span> module. It demonstrates how an <span class="code-inline">#ast</span> block can generate a structure where all the fields of another structure have their types converted to <span class="code-inline">bool</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">IsSet</span>
{
    <span class="SFct">#ast</span>
    {
        <span class="SCmt">// A `StringBuilder` is used to manipulate dynamic strings.</span>
        <span class="SKwd">var</span> str = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}

        <span class="SCmt">// We get the type of the generic parameter 'T'</span>
        <span class="SKwd">let</span> typeof = <span class="SItr">#typeof</span>(<span class="SCst">T</span>)

        <span class="SCmt">// Then we foreach all the fields, assuming the type is a struct (or this will not compile).</span>
        <span class="SCmt">// For each original field, we create one with the same name, but with a `bool` type.</span>
        <span class="SLgc">foreach</span> f <span class="SLgc">in</span> typeof.fields:
            str.<span class="SFct">appendFormat</span>(<span class="SStr">"%: bool\n"</span>, f.name)

        <span class="SCmt">// Then we return the constructed source code.</span>
        <span class="SCmt">// It will be used by the compiler to generate the content of the `IsSet` struct.</span>
        <span class="SLgc">return</span> str.<span class="SFct">toString</span>()
    }
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> at Global Scope </h4>
<p>The <span class="code-inline">#ast</span> block can also be employed at the global scope to dynamically generate global variables, constants, or other declarations. This feature allows for a high degree of flexibility in defining global entities. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#ast</span>
{
    <span class="SKwd">const</span> value = <span class="SNum">666</span>
    <span class="SLgc">return</span> <span class="SStr">"const myGeneratedConst = "</span> ++ value <span class="SCmt">// Generates a global constant 'myGeneratedConst' with the value 666.</span>
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#placeholder</span> Usage </h4>
<p>When generating global symbols that may be referenced elsewhere in the code, it is necessary to use <span class="code-inline">#placeholder</span>. This directive informs Swag that the symbol will be generated later, preventing compilation errors when the symbol is referenced before it exists. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#placeholder</span> myGeneratedConst <span class="SCmt">// Declares that the symbol `myGeneratedConst` will be generated.</span></span></div>
<p>Here, thanks to the <span class="code-inline">#placeholder</span>, the <span class="code-inline">#assert</span> will wait for the symbol <span class="code-inline">myGeneratedConst</span> to be replaced with its actual value before performing the assertion. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span> myGeneratedConst == <span class="SNum">666</span> <span class="SCmt">// Asserts that the generated constant 'myGeneratedConst' equals 666.</span></span></div>

<h3 id="_017_000_meta_programming_swg__017_002_compiler_interface_swg">Compiler interface</h3><p>The <span class="code-inline">compileString()</span> function within the <span class="code-inline">@compiler()</span> interface is another method to compile  generated code. This function should be invoked at compile time, typically within a <span class="code-inline">#message</span>  call. </p>
<p>Below is an example from the <span class="code-inline">Std.Ogl</span> module (an OpenGL wrapper), which utilizes <span class="code-inline">#message</span> to  identify functions annotated with a specific user attribute, <span class="code-inline">Ogl.Extension</span>, and subsequently  generates code for each identified function. </p>
<p>First, we define a new attribute that can be associated with functions. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Extension</span>()</span></div>
<p>Example of applying the custom attribute to OpenGL functions. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Extension]</span>
{
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix2x3fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix2x4fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix3x2fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix3x4fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix4x2fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix4x3fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
}</span></div>
<p>The following will be used to track the functions with that specific attribute. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">OneFunc</span>
{
    type: <span class="STpe">typeinfo</span>
    name: <span class="STpe">string</span>
}

<span class="SAtr">#[Compiler]</span>
<span class="SKwd">var</span> g_Functions: <span class="SFct">Array</span>'<span class="SCst">OneFunc</span></span></div>
<p>This <span class="code-inline">#message</span> will be called for each function of the <span class="code-inline">Ogl</span> module. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemFunctions</span>)
{
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// If the function does not have our attribute, ignore it</span>
    <span class="SLgc">if</span> !<span class="SCst">Reflection</span>.<span class="SFct">hasAttribute</span>(msg.type, <span class="SCst">Extension</span>)
        <span class="SLgc">return</span>

    <span class="SCmt">// Track all functions with the specified attribute</span>
    g_Functions.<span class="SFct">add</span>({msg.type, msg.name})
}</span></div>
<p>We will generate a <span class="code-inline">glInitExtensions</span> global function, so we register it as a placeholder. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#placeholder</span> glInitExtensions</span></div>
<p>This code is called once all functions of the module have been typed, and it handles the main  code generation process. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">CompilerMsgMask</span>.<span class="SCst">PassAfterSemantic</span>)
{
    <span class="SKwd">var</span> builderVars: <span class="SCst">StringBuilder</span>
    <span class="SKwd">var</span> builderInit: <span class="SCst">StringBuilder</span>

    <span class="SCmt">// Generate the `glInitExtensions` function</span>
    builderInit.<span class="SFct">appendString</span>(<span class="SStr">"public func glInitExtensions()\n{\n"</span>);

    <span class="SCmt">// Visit all functions we have registered, i.e., all functions with the `Ogl.Extension` attribute.</span>
    <span class="SLgc">foreach</span> e <span class="SLgc">in</span> g_Functions
    {
        <span class="SKwd">let</span> typeFunc = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="SCst">TypeInfoFunc</span>) e.type

        <span class="SCmt">// Declare a lambda variable for that extension</span>
        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"var ext_%: %\n"</span>, e.name, typeFunc.name)

        <span class="SCmt">// Make a wrapper function</span>
        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"public func %("</span>, e.name)
        <span class="SLgc">foreach</span> p, i <span class="SLgc">in</span> typeFunc.parameters
        {
            <span class="SLgc">if</span> i != <span class="SNum">0</span> builderVars.<span class="SFct">appendString</span>(<span class="SStr">", "</span>)
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"p%: %"</span>, i, p.pointedType.name)
        }

        <span class="SLgc">if</span> typeFunc.returnType == <span class="STpe">void</span>
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">")\n{\n"</span>)
        <span class="SLgc">else</span>
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">")-&gt;%\n{\n"</span>, typeFunc.returnType.name)
        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"\treturn ext_%("</span>, e.name)
        <span class="SLgc">foreach</span> p, i <span class="SLgc">in</span> typeFunc.parameters
        {
            <span class="SLgc">if</span> i != <span class="SNum">0</span> builderVars.<span class="SFct">appendString</span>(<span class="SStr">", "</span>)
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"p%"</span>, i)
        }

        builderVars.<span class="SFct">appendString</span>(<span class="SStr">");\n}\n\n"</span>)

        <span class="SCmt">// Initialize the variable with the getExtensionAddress</span>
        builderInit.<span class="SFct">appendFormat</span>(<span class="SStr">"\text_% = cast(%) getExtensionAddress(@dataof(\"%\"))\n"</span>, 
                                 e.name, typeFunc.name, e.name);
    }

    <span class="SCmt">// Compile !!</span>
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
    <span class="SKwd">var</span> str = builderVars.<span class="SFct">toString</span>()
    itf.<span class="SFct">compileString</span>(str.<span class="SFct">toString</span>())

    builderInit.<span class="SFct">appendString</span>(<span class="SStr">"}\n"</span>);
    str = builderInit.<span class="SFct">toString</span>()
    itf.<span class="SFct">compileString</span>(str.<span class="SFct">toString</span>())
}</span></div>

<h2 id="_018_000_documentation_md">Documentation</h2><p>The Swag compiler is capable of generating comprehensive documentation for all modules within a specified workspace. </p>
<p>To generate documentation for your workspace, use the following command: </p>
<div class="code-block"><span class="SCde">swag doc -w:myWorkspaceFolder</span></div>
<p>Swag supports various documentation generation modes, which should be specified in the module.swg file within the <a href="swag.runtime.php#Swag_BuildCfg">Swag.BuildCfg</a> structure. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#dependencies</span>
{
    <span class="SCmp">#import</span> <span class="SStr">"pixel"</span>

    <span class="SFct">#run</span>
    {
        <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
        <span class="SKwd">let</span> cfg = itf.<span class="SFct">getBuildCfg</span>()
        cfg.genDoc.kind = .<span class="SCst">Api</span> <span class="SCmt">// Specify the documentation generation mode</span>
    }
}</span></div>
<table class="table-markdown">
<tr><th style="text-align: left;">Kind</th><th style="text-align: left;">Purpose</th></tr><tr><td style="text-align: left;"> Swag.DocKind.Api      </td><td style="text-align: left;"> Generates an api documentation (all public symbols)</td></tr>
<tr><td style="text-align: left;"> Swag.DocKind.Examples </td><td style="text-align: left;"> Generates a documentation like this one</td></tr>
<tr><td style="text-align: left;"> Swag.DocKind.Pages    </td><td style="text-align: left;"> Generates different pages, where each file is a page (a variation of  <span class="code-inline">Examples</span>)</td></tr>
</table>
<h3 id="_018_000_documentation_md">Markdown files </h3>
<p>If the module contains <b>markdown</b> files with the <span class="code-inline">.md</span> extension, they will be processed as if they were Swag comments. </p>
<h3 id="_018_000_documentation_md">Format of comments </h3>
<h4 id="_018_000_documentation_md">Paragraphs </h4>
<div class="code-block"><span class="SCde"><span class="SCmt">// Everything between empty lines is considered to be a simple paragraph. Which</span>
<span class="SCmt">// means that if you put several comments on several lines like this, they all</span>
<span class="SCmt">// will be part of the same paragraph.</span>
<span class="SCmt">//</span>
<span class="SCmt">// This is another paragraph because there's an empty line before.</span>
<span class="SCmt">//</span>
<span class="SCmt">// This is yet another paragraph.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> Everything between empty lines is considered to be a simple paragraph. Which  means that if you put several comments on several lines like this, they all  will be part of the same paragraph. </p>
<p> This is another paragraph because there's an empty line before. </p>
<p> This is yet another paragraph. </p>
</div>
<p>Inside a paragraph, you can end of line with <span class="code-inline">\</span> to force a break without creating a new paragraph. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// First line.</span>
<span class="SCmt">// Second line is on first line.\</span>
<span class="SCmt">// But third line has a break before.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> First line.  Second line is on first line.<br/>  But third line has a break before. </p>
</div>
<p>A paragraph that starts with <span class="code-inline">---</span> is a <b>verbatim</b> paragraph where every blanks and end of lines are respected. The paragraph will be generated <b>as is</b> without any markdown change. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// ---</span>
<span class="SCmt">// Even...</span>
<span class="SCmt">//</span>
<span class="SCmt">// ...empty lines are preserved.</span>
<span class="SCmt">//</span>
<span class="SCmt">// You end that kind of paragraph with another '---' alone on its line.</span>
<span class="SCmt">// Note that **everything** is not bold, put printed 'as it is'.</span>
<span class="SCmt">// ---</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p style="white-space: break-spaces"> Even...

 ...empty lines are preserved.

 You end that kind of paragraph with another '---' alone on its line.
 Note that **everything** is not bold, put printed 'as it is'.</p>
</div>
<h4 id="_018_000_documentation_md">Lists </h4>
<p>You can create a <b>list</b> of bullet points with <span class="code-inline">*</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// * This is a bullet point</span>
<span class="SCmt">// * This is a bullet point</span>
<span class="SCmt">// * This is a bullet point</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><ul>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
</ul>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// - This is a bullet point</span>
<span class="SCmt">// - This is a bullet point</span>
<span class="SCmt">// - This is a bullet point</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><ul>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
</ul>
</div>
<p>You can create an <b>ordered</b> list by starting the line with a digit followed by a <span class="code-inline">.</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// 1. This is an ordered list</span>
<span class="SCmt">// 1. The digit itself does not matter, real numbers will be computed</span>
<span class="SCmt">// 0. This is another one</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><ol>
<li>This is an ordered list</li>
<li>The digit itself does not matter, real numbers will be computed</li>
<li>This is another one</li>
</ol>
</div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> Swag only supports single line list items. You cannot have complex paragraphs (or sub lists). </p>
</div>
<h4 id="_018_000_documentation_md">Definition Lists </h4>
<p>You can add a definition title with the <span class="code-inline">+</span> character followed by a blank, and then the title. The description paragraph should come just after the title, with at least 4 blanks or one tabulation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Title</span>
<span class="SCmt">//     This is the description.</span>
<span class="SCmt">// + Other title</span>
<span class="SCmt">//     This is the other description.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Title</p></div>
<div class="description-list-block">
<p> This is the description. </p>
</div>
<div class="description-list-title"><p>Other title</p></div>
<div class="description-list-block">
<p> This is the other description. </p>
</div>
</div>
<p>A description can contain complex paragraphs. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Title</span>
<span class="SCmt">//     This is an embedded list.</span>
<span class="SCmt">//     * Item1</span>
<span class="SCmt">//     * Item2</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Title</p></div>
<div class="description-list-block">
<p> This is an embedded list. </p>
<ul>
<li>Item1</li>
<li>Item2</li>
</ul>
</div>
</div>
<p>The description paragraph can contain some empty lines. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Other title</span>
<span class="SCmt">//</span>
<span class="SCmt">//     This is the other description</span>
<span class="SCmt">//     on more than one line.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Other title</p></div>
<div class="description-list-block">
<p> This is the other description  on more than one line. </p>
</div>
</div>
<h4 id="_018_000_documentation_md">Quotes </h4>
<p>You can create a <b>quote</b> with <span class="code-inline">&gt;</span> </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; This is a block quote on multiple</span>
<span class="SCmt">// &gt; lines.</span>
<span class="SCmt">// &gt;</span>
<span class="SCmt">// &gt; End of the quote.</span></span></div>
<div class="blockquote blockquote-default">
<p> This is a block quote on multiple  lines. </p>
<p> End of the quote. </p>
</div>
<p>You can create a special quote by adding a title on the first line. There must be exactly one blank between <span class="code-inline">&gt;</span> and the title, and the title case should be respected. </p>
<ul>
<li><span class="code-inline">NOTE:</span></li>
<li><span class="code-inline">TIP:</span></li>
<li><span class="code-inline">WARNING:</span></li>
<li><span class="code-inline">ATTENTION:</span></li>
<li><span class="code-inline">EXAMPLE:</span></li>
</ul>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; NOTE:</span>
<span class="SCmt">// &gt; This is the note content</span></span></div>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> This is the note content </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; TIP:</span>
<span class="SCmt">// &gt; This is a tip.</span></span></div>
<div class="blockquote blockquote-tip">
<div class="blockquote-title-block"><i class="fa fa-lightbulb-o"></i>  <span class="blockquote-title">Tip</span></div><p> This is a tip. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; WARNING:</span>
<span class="SCmt">// &gt; This is the warning content</span>
<span class="SCmt">// &gt;</span>
<span class="SCmt">// &gt; Another paragraph</span></span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> This is the warning content </p>
<p> Another paragraph </p>
</div>
<div class="code-block"><span class="SCmt">// &gt; ATTENTION: The content of the quote can be written on the same line as the title</span></div>
<div class="blockquote blockquote-attention">
<div class="blockquote-title-block"><i class="fa fa-ban"></i>  <span class="blockquote-title">Attention</span></div><p> The content of the quote can be written on the same line as the title </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; EXAMPLE:</span>
<span class="SCmt">// &gt; In the 'module.swg' file, we have changed the 'example' title to be `"Result"` instead of `"Example"`.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> In the <span class="code-inline">module.swg</span> file, we have changed the <span class="code-inline">example</span> title to be <span class="code-inline">"Result"</span> instead of <span class="code-inline">"Example"</span>. </p>
</div>
<h4 id="_018_000_documentation_md">Tables </h4>
<p>You can create a <b>table</b> by starting a line with <span class="code-inline">|</span>. Each column must then be separated with <span class="code-inline">|</span>. The last column can end with <span class="code-inline">|</span>, but this is not mandatory. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// A table with 4 lines of 2 columns:</span>
<span class="SCmt">// | boundcheck   | Check out of bound access</span>
<span class="SCmt">// | overflow     | Check type conversion lost of bits or precision</span>
<span class="SCmt">// | math         | Various math checks (like a negative '@sqrt')        |</span>
<span class="SCmt">// | switch       | Check an invalid case in a '#[Swag.Complete]' switch |</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><td> boundcheck   </td><td> Check out of bound access</td></tr>
<tr><td> overflow     </td><td> Check type conversion lost of bits or precision</td></tr>
<tr><td> math         </td><td> Various math checks (like a negative <span class="code-inline">@sqrt</span>)        </td></tr>
<tr><td> switch       </td><td> Check an invalid case in a <span class="code-inline">#[Swag.Complete]</span> switch </td></tr>
</table>
</div>
<p>You can define a header to the table if you separate the first line from the second one with a separator like <span class="code-inline">---</span>. A valid separator must have a length of at least 3 characters, and must only contain <span class="code-inline">-</span> or <span class="code-inline">:</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// | Title1 | Title2</span>
<span class="SCmt">// | ------ | ------</span>
<span class="SCmt">// | Item1  | Item2</span>
<span class="SCmt">// | Item1  | Item2</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><th style="text-align: left;">Title1</th><th style="text-align: left;">Title2</th></tr><tr><td style="text-align: left;"> Item1  </td><td style="text-align: left;"> Item2</td></tr>
<tr><td style="text-align: left;"> Item1  </td><td style="text-align: left;"> Item2</td></tr>
</table>
</div>
<p>You can define the <b>column alignment</b> by adding <span class="code-inline">:</span> at the start and/or at the end of a separator. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// | Title1     | Title2       | Title3</span>
<span class="SCmt">// | :-----     | :----:       | -----:</span>
<span class="SCmt">// | Align left | Align center | Align right</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><th style="text-align: left;">Title1</th><th style="text-align: center;">Title2</th><th style="text-align: right;">Title3</th></tr><tr><td style="text-align: left;"> Align left </td><td style="text-align: center;"> Align center </td><td style="text-align: right;"> Align right</td></tr>
</table>
</div>
<h4 id="_018_000_documentation_md">Code </h4>
<p>You can create a simple <b>code paragraph</b> with three backticks before and after the code. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// ```</span>
<span class="SCmt">// if a == true</span>
<span class="SCmt">//   @print("true")</span>
<span class="SCmt">// ```</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="code-block"><span class="SCde">if a == true
   @print("true")</span></div>
</div>
<p>You can also create that kind of paragraph by simply indenting the code with four blanks or one tabulation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">//    if a == false</span>
<span class="SCmt">//        @print("false")</span></span></div>
<p>And if you want <b>syntax coloration</b>, add <span class="code-inline">swag</span> after the three backticks. Only Swag syntax is supported right now. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// ```swag</span>
<span class="SCmt">// if a == true</span>
<span class="SCmt">//   @print("true")</span>
<span class="SCmt">// ```</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="code-block"><span class="SCde"><span class="SLgc">if</span> a == <span class="SKwd">true</span>
   <span class="SItr">@print</span>(<span class="SStr">"true"</span>)</span></div>
</div>
<h4 id="_018_000_documentation_md">Titles </h4>
<p>You can define <b>titles</b> with <span class="code-inline">#</span>, <span class="code-inline">##</span> ... followed by a blank, and then the text. The real level of the title will depend on the context and the generated documentation kind. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// # Title 1</span>
<span class="SCmt">// ## Title 2</span>
<span class="SCmt">// ### Title 3</span>
<span class="SCmt">// #### Title 4</span>
<span class="SCmt">// ##### Title 5</span>
<span class="SCmt">// ###### Title 6</span></span></div>
<h4 id="_018_000_documentation_md">References </h4>
<p>You can create an external <b>reference</b> with <span class="code-inline">[name](link)</span>. </p>
<div class="code-block"><span class="SCmt">// This is a [reference](https://github.com/swag-lang/swag) to the Swag repository on GitHub.</span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> This is a <a href="https://github.com/swag-lang/swag">reference</a> to the Swag repository on GitHub. </p>
</div>
<h4 id="_018_000_documentation_md">Images </h4>
<p>You can insert an external <b>image</b> with <span class="code-inline">![name](link)</span>. </p>
<div class="code-block"><span class="SCmt">// This is an image ![image](https://swag-lang/imgs/swag_icon.png).</span></div>
<h4 id="_018_000_documentation_md">Markdown </h4>
<p>Some other markers are also supported inside texts. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is `inline code` with back ticks.\</span>
<span class="SCmt">// This is inline 'code' with normal ticks, but just for a single word (no blanks).\</span>
<span class="SCmt">// This is **bold**.\</span>
<span class="SCmt">// This is *italic*.\</span>
<span class="SCmt">// This is ***bold and italic***.\</span>
<span class="SCmt">// This is ~~strikethrough~~.\</span>
<span class="SCmt">// This character \n is escaped, and 'n' will be output as is.\</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> This is <span class="code-inline">inline code</span> with back ticks.<br/>  This is inline <span class="code-inline">code</span> with normal ticks, but just for a single word (no blanks).<br/>  This is <b>bold</b>.<br/>  This is <i>italic</i>.<br/>  This is <b><i>bold and italic</i></b>.<br/>  This is <span class="strikethrough-text">strikethrough</span>.<br/>  This character n is escaped, and <span class="code-inline">n</span> will be output as is.<br/> </p>
</div>

<h3 id="_018_000_documentation_md__018_001_api_swg">Api</h3><p>In <span class="code-inline">Swag.DocKind.Api</span> mode, swag will collect all <b>public definitions</b> to generate the documentation. <a href="std.core.php">Std.Core</a> is an example of documentation generated in that mode. </p>
<p>The main module documentation should be placed at the top of the corresponding <span class="code-inline">module.swg</span> file. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is the main module documentation.</span>
<span class="SCmp">#dependencies</span>
{
}</span></div>
<p>Other comments need to be placed just before a function, struct or enum. </p>
<p>The first paragraph is considered to be the <b>short description</b> which can appear on specific parts of the documentation. So make it... short. </p>
<p>If the first line ends with a dot <span class="code-inline">.</span>, then this marks the end of the paragraph, i.e. the end of the short description. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This first paragraph is the short description of function 'test1'</span>
<span class="SCmt">//</span>
<span class="SCmt">// This second paragraph should be the long description.</span>
<span class="SKwd">func</span> <span class="SFct">test1</span>() {}

<span class="SCmt">// This is the short description of 'test'.</span>
<span class="SCmt">// As the previous first line ends with '.', this is another paragraph, so this should be</span>
<span class="SCmt">// the long description. No need for an empty line before.</span>
<span class="SKwd">func</span> <span class="SFct">test</span>() {}</span></div>
<p>For constants or enum values, the document comment is the one declared at the end of the line. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SNum">0</span> <span class="SCmt">// This is the documentation comment of constant 'A'</span>

<span class="SKwd">enum</span> <span class="SCst">Color</span>
{
    <span class="SCst">Red</span>      <span class="SCmt">// This is the documentation comment of enum value 'Red'</span>
    <span class="SCst">Blue</span>     <span class="SCmt">// This is the documentation comment of enum value 'Blue'</span>
}</span></div>
<h4 id="_018_000_documentation_md__018_001_api_swg">References </h4>
<p>You can create a <b>reference</b> to something in the current module with <span class="code-inline">[[name]]</span> or <span class="code-inline">[[name1.name2 etc.]]</span> </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is a function with a 'value' parameter.</span>
<span class="SKwd">func</span> <span class="SFct">one</span>(value: <span class="STpe">s32</span>) {}

<span class="SCmt">// This is a reference to [[one]]</span>
<span class="SKwd">func</span> <span class="SFct">two</span>() {}</span></div>
<h4 id="_018_000_documentation_md__018_001_api_swg">NoDoc </h4>
<p>You can use the <span class="code-inline">#[Swag.NoDoc]</span> attribute to prevent a certain element from showing up in the documentation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The function 'three' will be ignored when generating the documentation.</span>
<span class="SAtr">#[Swag.NoDoc]</span>
<span class="SKwd">func</span> <span class="SFct">three</span>() {}</span></div>

<h3 id="_018_000_documentation_md__018_002_examples_md">Examples</h3><p>In <span class="code-inline">Swag.DocKind.Examples</span> mode, documentation is generated systematically, with each file representing a chapter or subchapter. The following guidelines outline the structure and formatting required for effective documentation creation. </p>
<h4 id="_018_000_documentation_md__018_002_examples_md">File Naming Convention </h4>
<p>File names must adhere to the format <span class="code-inline">DDD_DDD_name</span>, where each <span class="code-inline">D</span> represents a digit. This naming convention facilitates the hierarchical organization of the documentation. </p>
<div class="description-list-title"><p>Main Titles</p></div>
<div class="description-list-block">
<p>Files with names formatted as <span class="code-inline">100_000_my_title.swg</span> will generate a main heading (<span class="code-inline">&lt;h1&gt;My Title&lt;/h1&gt;</span>). </p>
</div>
<div class="description-list-title"><p>Subtitles</p></div>
<div class="description-list-block">
<p>Files named <span class="code-inline">101_001_my_sub_title.swg</span> or <span class="code-inline">102_002_my_sub_title.swg</span> will generate subheadings (<span class="code-inline">&lt;h2&gt;My Sub Title&lt;/h2&gt;</span>) under the corresponding main title. </p>
</div>
<div class="description-list-title"><p>Multiple Main Titles</p></div>
<div class="description-list-block">
<p>For separate sections, such as <span class="code-inline">110_000_my_other_title.swg</span>, another main heading (<span class="code-inline">&lt;h1&gt;My Other Title&lt;/h1&gt;</span>) will be generated. </p>
</div>
<div class="description-list-title"><p>File Type Flexibility</p></div>
<div class="description-list-block">
<p>You can mix <span class="code-inline">.swg</span> files with <span class="code-inline">.md</span> files. For example, <span class="code-inline">111_000_my_other_title.md</span> will seamlessly integrate Markdown files into the documentation structure. </p>
</div>
<h4 id="_018_000_documentation_md__018_002_examples_md">Comment Format for Documentation </h4>
<p>To include comments in your code that should be interpreted as part of the documentation (as opposed to standard Swag comments), use the following syntax: </p>
<div class="code-block"><span class="SCde">/**
 This is a valid documentation comment.
 The comment must start with /** and end with */, each on a separate line.
 */</span></div>
<p>These comments will be processed and included in the generated documentation, ensuring that inline comments are properly formatted and contribute to the final output. </p>
<h4 id="_018_000_documentation_md__018_002_examples_md">Source of Documentation </h4>
<p>The documentation you are reading is generated from the <a href="https://github.com/swag-lang/swag/tree/master/bin/reference/tests/language">std/reference/language</a> module. This directory contains examples and files structured according to these guidelines, showcasing how to effectively create and manage documentation in <span class="code-inline">Swag.DocKind.Examples</span> mode. </p>

<h3 id="_018_000_documentation_md__018_003_pages_md">Pages</h3><p>In <span class="code-inline">Swag.DocKind.Pages</span> mode, each file generates an individual webpage, with the page name matching the file name. Aside from this distinction, the behavior is consistent with that of <span class="code-inline">Swag.DocKind.Examples</span> mode. </p>
<h4 id="_018_000_documentation_md__018_003_pages_md">File Naming and Page Generation </h4>
<p>Each file in this mode generates a separate webpage. The page name will directly correspond to the file name. </p>
<h4 id="_018_000_documentation_md__018_003_pages_md">Use Case </h4>
<p><span class="code-inline">Swag.DocKind.Pages</span> mode is particularly useful for generating individual web pages, as demonstrated in the <a href="https://github.com/swag-lang/swag/tree/master/bin/reference/tests/web">example directory</a>. This mode is ideal for creating standalone pages that can be linked together or accessed independently, making it a versatile option for web-based documentation projects. </p>
<div class="swag-watermark">
Generated on 02-09-2024 with <a href="https://swag-lang.org/index.php">swag</a> 0.39.0</div>
</div>
</div>
</div>

    <script> 
		function getOffsetTop(element, parent) {
			let offsetTop = 0;
			while (element && element != parent) {
				offsetTop += element.offsetTop;
				element = element.offsetParent;
			}
			return offsetTop;
		}	
		document.addEventListener("DOMContentLoaded", function() {
			let hash = window.location.hash;
			if (hash)
			{
				let parentScrollable = document.querySelector('.right');
				if (parentScrollable)
				{
					let targetElement = parentScrollable.querySelector(hash);
					if (targetElement)
					{
						parentScrollable.scrollTop = getOffsetTop(targetElement, parentScrollable);
					}
				}
			}
        });
    </script>
</body>
</html>
