<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<?php include('common/start-head.php'); ?><title>Swag Language Reference</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script src="https://kit.fontawesome.com/f76be2b3ee.js" crossorigin="anonymous"></script>
<style>

    .container  { display: flex; flex-wrap: nowrap; flex-direction: row; margin: 0px auto; padding: 0px; }
    .left       { display: block; overflow-y: scroll; width: 500px; }
    .left-page  { margin: 10px; }
    .right      { display: block; width: 100%; }
    .right-page { max-width: 1024px; margin: 10px auto; }
    
    @media(min-width: 640px)  { .container { max-width: 640px; }}
    @media(min-width: 768px)  { .container { max-width: 768px; }}
    @media(min-width: 1024px) { .container { max-width: 1024px; }}
    @media(min-width: 1280px) { .container { max-width: 1280px; }}
    @media(min-width: 1536px) { .container { max-width: 1536px; }}
    
    @media screen and (max-width: 600px) {
        .left       { display: none; }
        .right-page { margin:  10px; }
    }

            .container { height: 100vh; }
            .right     { overflow-y: scroll; }
        
    html { font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
    body { margin: 0px; line-height: 1.3em; }     

    .container a        { color: DoggerBlue; }
    .container a:hover  { text-decoration: underline; }
    .container img      { margin: 0 auto; }
   
    .left a     { text-decoration: none; }
    .left ul    { list-style-type: none; margin-left: -20px; }
    .left h3    { background-color: Black; color: White; padding: 6px; }
    .right h1   { margin-top: 50px; margin-bottom: 50px; }
    .right h2   { margin-top: 35px; }

    .right hr   { margin-top: 50px; margin-bottom: 50px; }

    .right h1 { font-size: 2em; }
    .right h2 { font-size: 1.75em; }
    .right h3 { font-size: 1.5em; }

    .right ol li { margin-bottom: 10px; }

    .strikethrough-text { text-decoration: line-through; }
    .swag-watermark     { text-align:right; font-size: 80%; margin-top: 30px; }
    .swag-watermark a   { text-decoration: none; color: inherit; }

    .blockquote               { border-radius: 5px; border: 1px solid; margin: 20px; padding: 10px; }
    .blockquote-default       { border-color: Orange; border-left: 6px solid Orange; background-color: LightYellow; }
    .blockquote-note          { border-color: #ADCEDD; background-color: #CDEEFD; }
    .blockquote-tip           { border-color: #BCCFBC; background-color: #DCEFDC; }
    .blockquote-warning       { border-color: #DFBDB3; background-color: #FFDDD3; }
    .blockquote-attention     { border-color: #DDBAB8; background-color: #FDDAD8; }
    .blockquote-example       { border: 2px solid LightGrey; }
    .blockquote-title-block   { margin-bottom: 10px; }
    .blockquote-title         { font-weight: bold; }
    .blockquote-default       p:first-child { margin-top: 0px; }
    .blockquote-default       p:last-child  { margin-bottom: 0px; }
    .blockquote               p:last-child  { margin-bottom: 0px; }

    .description-list-title   { font-weight: bold; font-style: italic; }
    .description-list-block   { margin-left: 30px; }

    .container table          { border: 1px solid LightGrey; border-collapse: collapse; font-size: 90%; margin-left: 20px; margin-right: 20px; }
    .container td             { border: 1px solid LightGrey; border-collapse: collapse; padding: 6px; min-width: 100px; }
    .container th             { border: 1px solid LightGrey; border-collapse: collapse; padding: 6px; min-width: 100px; background-color: #eeeeee; }

    table.api-item            { border-collapse: separate; background-color: Black; color: White; width: 100%; margin-top: 70px; margin-right: 0px; font-size: 110%; }
    .api-item td              { font-size: revert; border: 0; }
    .api-item td:first-child  { width: 33%; white-space: nowrap; }
    .api-item-title-src-ref   { text-align:  right; }
    .api-item-title-src-ref a { color:       inherit; }
    .api-item-title-kind      { font-weight: normal; font-size: 80%; }
    .api-item-title-light     { font-weight: normal; }
    .api-item-title-strong    { font-weight: bold; font-size: 100%; }
    .api-additional-infos     { font-size: 90%; white-space: break-spaces; overflow-wrap: break-word; }

    table.table-enumeration           { width: calc(100% - 40px); }
    .table-enumeration td:first-child { background-color: #f8f8f8; white-space: nowrap; }
    .table-enumeration td:last-child  { width: 100%; }
    .table-enumeration td.code-type   { background-color: #eeeeee; }
    .table-enumeration a              { text-decoration: none; color: inherit; }

    .code-inline  { background-color: #eeeeee; border-radius: 5px; border: 1px dotted #cccccc; padding: 0px 8px; font-size: 110%; font-family: monospace; display: inline-block; }
    .code-block   { background-color: #eeeeee; border-radius: 5px; border: 1px solid LightGrey; padding: 10px; margin: 20px; white-space: pre; overflow-x: auto; }
    .code-block   { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .code-block a { color: inherit; }

    .blockquote-default     .code-inline    { background-color: #FFE89C; }
    .blockquote-note        .code-inline    { border-color: #9DBECD; background-color: #BDDEED; }
    .blockquote-tip         .code-inline    { border-color: #ACBFAC; background-color: #CCDFCC; }
    .blockquote-warning     .code-inline    { border-color: #CFADA3; background-color: #EFCDC3; }
    .blockquote-attention   .code-inline    { border-color: #CDAAA8; background-color: #EDCAC8; }
    .SCde { color: #222222; }
    .SCmt { color: #71a35b; }
    .SCmp { color: #7f7f7f; }
    .SFct { color: #ff6a00; }
    .SCst { color: #3bc3a7; }
    .SItr { color: #b4b44a; }
    .STpe { color: #ed9a11; }
    .SKwd { color: #3186cd; }
    .SLgc { color: #b040be; }
    .SNum { color: #74a35b; }
    .SStr { color: #bb6643; }
    .SAtr { color: #7f7f7f; }
    .SBcR { color: #b5af49; }
    .SInv { color: #ff0000; }
</style>
<?php include('common/end-head.php'); ?>
</head>
<body>
<?php include('common/start-body.php'); ?>
<div class="container">
<div class="left">
<div class="left-page">
<h2>Table of Contents</h2>
<ul>
<li><a href="#_001_000_introduction_swg">Introduction </a></li>
<ul>
<li><a href="#_001_000_introduction_swg__001_001_the_test_module_swg">The Test Module </a></li>
<li><a href="#_001_000_introduction_swg__001_002_the_basics_swg">The Basics </a></li>
<li><a href="#_001_000_introduction_swg__001_003_hello_mad_world_swg">Hello Mad World </a></li>
</ul>
<li><a href="#_002_000_code_structure_swg">Code Structure </a></li>
<ul>
<li><a href="#_002_000_code_structure_swg__002_002_source_code_organization_swg">Source Code Organization </a></li>
<li><a href="#_002_000_code_structure_swg__002_003_global_declaration_order_swg">Global Declaration Order </a></li>
<li><a href="#_002_000_code_structure_swg__002_004_comments_swg">Comments </a></li>
<li><a href="#_002_000_code_structure_swg__002_005_semicolons_swg">Semicolons </a></li>
<li><a href="#_002_000_code_structure_swg__002_006_identifiers_swg">Identifiers </a></li>
<li><a href="#_002_000_code_structure_swg__002_007_keywords_swg">Keywords </a></li>
</ul>
<li><a href="#_003_000_fundamentals_swg">Fundamentals </a></li>
<ul>
<li><a href="#_003_000_fundamentals_swg__003_001_basic_types_swg">Basic Types </a></li>
<li><a href="#_003_000_fundamentals_swg__003_002_number_literals_swg">Number Literals </a></li>
<li><a href="#_003_000_fundamentals_swg__003_003_string_swg">String </a></li>
<li><a href="#_003_000_fundamentals_swg__003_004_constants_swg">Constants </a></li>
<li><a href="#_003_000_fundamentals_swg__003_005_variables_swg">Variables </a></li>
<li><a href="#_003_000_fundamentals_swg__003_006_operators_swg">Operators </a></li>
<li><a href="#_003_000_fundamentals_swg__003_007_cast_swg">Cast </a></li>
<li><a href="#_003_000_fundamentals_swg__003_008_alias_swg">Alias </a></li>
</ul>
<li><a href="#_004_000_data_structures_swg">Data Structures </a></li>
<ul>
<li><a href="#_004_000_data_structures_swg__004_001_array_swg">Array </a></li>
<li><a href="#_004_000_data_structures_swg__004_002_slice_swg">Slice </a></li>
<li><a href="#_004_000_data_structures_swg__004_003_tuple_swg">Tuple </a></li>
<li><a href="#_004_000_data_structures_swg__004_004_enum_swg">Enum </a></li>
<li><a href="#_004_000_data_structures_swg__004_005_impl_swg">Impl </a></li>
<li><a href="#_004_000_data_structures_swg__004_006_union_swg">Union </a></li>
<li><a href="#_004_000_data_structures_swg__004_007_pointers_swg">Pointers </a></li>
<li><a href="#_004_000_data_structures_swg__004_008_references_swg">References </a></li>
<li><a href="#_004_000_data_structures_swg__004_009_any_swg">Any </a></li>
</ul>
<li><a href="#_005_000_control_flow_swg">Control Flow </a></li>
<ul>
<li><a href="#_005_000_control_flow_swg__005_001_if_swg">If </a></li>
<li><a href="#_005_000_control_flow_swg__005_002_for_swg">For </a></li>
<li><a href="#_005_000_control_flow_swg__005_003_foreach_swg">Foreach </a></li>
<li><a href="#_005_000_control_flow_swg__005_004_while_swg">While </a></li>
<li><a href="#_005_000_control_flow_swg__005_005_switch_swg">Switch </a></li>
<li><a href="#_005_000_control_flow_swg__005_006_break_swg">Break </a></li>
</ul>
<li><a href="#_006_000_structs_swg">Structs </a></li>
<ul>
<li><a href="#_006_000_structs_swg__006_001_declaration_swg">Declaration </a></li>
<li><a href="#_006_000_structs_swg__006_002_impl_swg">Impl </a></li>
<li><a href="#_006_000_structs_swg__006_003_offset_swg">Offset </a></li>
<li><a href="#_006_000_structs_swg__006_004_packing_swg">Packing </a></li>
<li><a href="#_006_000_structs_swg__006_005_special_functions_swg">Special Functions </a></li>
<li><a href="#_006_000_structs_swg__006_006_custom_assignment_swg">Custom Assignment </a></li>
<li><a href="#_006_000_structs_swg__006_007_custom_loop_swg">Custom Loop </a></li>
<li><a href="#_006_000_structs_swg__006_008_custom_iteration_swg">Custom Iteration </a></li>
<li><a href="#_006_000_structs_swg__006_009_custom_copy_and_move_swg">Custom Copy and Move </a></li>
<li><a href="#_006_000_structs_swg__006_010_custom_literals_swg">Custom Literals </a></li>
<li><a href="#_006_000_structs_swg__006_011_interface_swg">Interface </a></li>
</ul>
<li><a href="#_007_000_functions_swg">Functions </a></li>
<ul>
<li><a href="#_007_000_functions_swg__007_001_declaration_swg">Declaration </a></li>
<li><a href="#_007_000_functions_swg__007_002_lambda_swg">Lambda </a></li>
<li><a href="#_007_000_functions_swg__007_003_closure_swg">Closure </a></li>
<li><a href="#_007_000_functions_swg__007_004_mixin_swg">Mixin </a></li>
<li><a href="#_007_000_functions_swg__007_005_macro_swg">Macro </a></li>
<li><a href="#_007_000_functions_swg__007_006_variadic_parameters_swg">Variadic Parameters </a></li>
<li><a href="#_007_000_functions_swg__007_007_ufcs_swg">Ufcs </a></li>
<li><a href="#_007_000_functions_swg__007_008_constexpr_swg">Constexpr </a></li>
<li><a href="#_007_000_functions_swg__007_009_function_overloading_swg">Function Overloading </a></li>
<li><a href="#_007_000_functions_swg__007_010_discard_swg">Discard </a></li>
<li><a href="#_007_000_functions_swg__007_011_retval_swg">Retval </a></li>
<li><a href="#_007_000_functions_swg__007_012_foreign_swg">Foreign </a></li>
<li><a href="#_007_000_functions_swg__007_013_special_functions_swg">Special Functions </a></li>
</ul>
<li><a href="#_008_000_intrinsics_swg">Intrinsics </a></li>
<ul>
<li><a href="#_008_000_intrinsics_swg__008_001_init_swg">Init </a></li>
<li><a href="#_008_000_intrinsics_swg__008_002_drop_swg">Drop </a></li>
</ul>
<li><a href="#_009_000_generics_swg">Generics </a></li>
<ul>
<li><a href="#_009_000_generics_swg__009_001_functions_swg">Functions </a></li>
<li><a href="#_009_000_generics_swg__009_002_structs_swg">Structs </a></li>
<li><a href="#_009_000_generics_swg__009_003_where_constraints_swg">Where Constraints </a></li>
</ul>
<li><a href="#_010_000_attributes_swg">Attributes </a></li>
<ul>
<li><a href="#_010_000_attributes_swg__010_001_user_attributes_swg">User Attributes </a></li>
<li><a href="#_010_000_attributes_swg__010_002_predefined_attributes_swg">Predefined Attributes </a></li>
</ul>
<li><a href="#_011_000_scoping_swg">Scoping </a></li>
<ul>
<li><a href="#_011_000_scoping_swg__011_001_namespace_swg">Namespace </a></li>
<li><a href="#_011_000_scoping_swg__011_002_defer_swg">Defer </a></li>
<li><a href="#_011_000_scoping_swg__011_003_using_swg">Using </a></li>
<li><a href="#_011_000_scoping_swg__011_004_with_swg">With </a></li>
</ul>
<li><a href="#_012_000_type_reflection_swg">Type Reflection </a></li>
<li><a href="#_013_000_error_management_and_safety_swg">Error Management and Safety </a></li>
<ul>
<li><a href="#_013_000_error_management_and_safety_swg__013_001_error_management_swg">Error Management </a></li>
<li><a href="#_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety </a></li>
</ul>
<li><a href="#_014_000_compile-time_evaluation_swg">Compile-time Evaluation </a></li>
<ul>
<li><a href="#_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Constexpr </a></li>
<li><a href="#_014_000_compile-time_evaluation_swg__014_002_run_swg">Run </a></li>
<li><a href="#_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg">Compiler Instructions </a></li>
<li><a href="#_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Code Inspection </a></li>
</ul>
<li><a href="#_017_000_meta_programming_swg">Meta Programming </a></li>
<ul>
<li><a href="#_017_000_meta_programming_swg__017_001_ast_swg">Ast </a></li>
<li><a href="#_017_000_meta_programming_swg__017_002_compiler_interface_swg">Compiler Interface </a></li>
</ul>
<li><a href="#_018_000_documentation_md">Documentation </a></li>
<ul>
<li><a href="#_018_000_documentation_md__018_001_api_swg">Api </a></li>
<li><a href="#_018_000_documentation_md__018_002_examples_md">Examples </a></li>
<li><a href="#_018_000_documentation_md__018_003_pages_md">Pages </a></li>
</ul>
</div>
</div>
<div class="right">
<div class="right-page">
<h1>Swag Language Reference</h1>

<h2 id="_001_000_introduction_swg">Introduction </h2>
<h3 id="_001_000_introduction_swg__001_001_the_test_module_swg">The Test Module </h3><p>The <span class="code-inline">swag-lang/swag/bin/reference/language</span> module provides a foundational introduction to the syntax and essential features of the Swag programming language. It is designed to offer insight into core language elements, separate from the more extensive <a href="std.php">Swag standard modules</a> (<span class="code-inline">Std</span>). </p>
<h4 id="_001_000_introduction_swg__001_001_the_test_module_swg">Scope </h4>
<p>This documentation is auto-generated directly from the module’s source code and serves as a basic guide to Swag’s syntax and functionality. Advanced topics such as dynamic arrays, dynamic strings, and hash maps are covered in the <a href="std.core.php">Std.Core</a> module documentation, which you should reference for more sophisticated implementations beyond the examples covered here. </p>
<h4 id="_001_000_introduction_swg__001_001_the_test_module_swg">Running the Test Module </h4>
<p>The <span class="code-inline">reference/language</span> module is implemented as a test module to demonstrate the language’s core features in action. You can run the module by executing the following commands from the terminal: </p>
<div class="code-block"><span class="SCde">swag test --workspace:c:/swag-lang/swag/bin/reference
swag test -w:c:/swag-lang/swag/bin/reference</span></div>
<p>These commands execute all test modules within the specified workspace, including <span class="code-inline">reference/language</span>. If you are already working within the workspace directory, the <span class="code-inline">--workspace</span> flag (or shorthand <span class="code-inline">-w</span>) can be omitted. </p>
<h4 id="_001_000_introduction_swg__001_001_the_test_module_swg">Compiling and Running a Specific Test Module </h4>
<p>To compile and execute a specific test module, such as <span class="code-inline">test_language</span>, use the <span class="code-inline">--module</span> (or <span class="code-inline">-m</span>) flag in conjunction with the <span class="code-inline">swag test</span> command: </p>
<div class="code-block"><span class="SCde">swag test -w:c:/swag-lang/swag/bin/reference -m:test_language</span></div>
<p>This will target and run only the specified module, enabling you to focus on individual components for testing and development purposes. </p>
<p style="white-space: break-spaces"><hr>
</p>
<h4 id="_001_000_introduction_swg__001_001_the_test_module_swg">Key Features of the <span class="code-inline">reference/language</span> Module: </h4>
<ol>
<li><b>Core Syntax</b>: Covers the fundamental elements of the Swag programming language, including variables, control structures, functions, and basic data types.</li>
<li><b>Test-Driven</b>: All examples and modules are designed to be executable as tests, allowing developers to verify their understanding of core Swag concepts in real time.</li>
<li><b>Auto-Generated Documentation</b>: This guide is generated directly from the source code, ensuring accuracy and up-to-date information on Swag's core functionality.</li>
</ol>
<p>For further exploration of Swag’s advanced features, such as memory management or concurrency, consult the <a href="std.core.php">Std.Core</a> documentation. </p>

<h3 id="_001_000_introduction_swg__001_002_the_basics_swg">The Basics </h3><h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Swag Language Overview </h4>
<p>Swag is a modern and flexible programming language designed for ease of use, combining a strong type system with an intuitive syntax. This section introduces the fundamental concepts of Swag through concise examples, covering variables, functions, control flow, and more. </p>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Constants and Variables </h4>
<p>Use <span class="code-inline">const</span> to define constants, <span class="code-inline">var</span> for mutable variables, and <span class="code-inline">let</span> for immutable variables (single-assignment, set once at runtime). </p>
<ul>
<li><span class="code-inline">const</span> values are immutable and must be initialized at declaration.</li>
<li><span class="code-inline">var</span> values can be reassigned.</li>
<li><span class="code-inline">let</span> values are immutable after initialization.</li>
</ul>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">Pi</span>   = <span class="SNum">3.14159</span>     <span class="SCmt">// Constant value, cannot be changed</span>
    <span class="SKwd">var</span> radius = <span class="SNum">10</span>          <span class="SCmt">// Mutable variable</span>
    <span class="SKwd">let</span> height = <span class="SNum">100</span>         <span class="SCmt">// Immutable variable (single assignment)</span>
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Mutability and Reassignment </h4>
<p>Variables declared with <span class="code-inline">var</span> can be reassigned as needed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> counter = <span class="SNum">0</span>
    counter = <span class="SNum">5</span> <span class="SCmt">// Reassigning the value of 'counter'</span>
}</span></div>
<p>Constants (<span class="code-inline">const</span>) and immutable variables (<span class="code-inline">let</span>) cannot be reassigned. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">MaxCount</span> = <span class="SNum">10</span>
    <span class="SCmt">// MaxCount = 12  // Error: Cannot assign to constant</span>

    <span class="SKwd">let</span> width = <span class="SNum">50</span>
    <span class="SCmt">// width = 60     // Error: Cannot reassign an immutable variable</span>
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Type Inference </h4>
<p>Swag infers types automatically if they can be deduced from assigned values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> greeting = <span class="SStr">"Hello, Swag!"</span>     <span class="SCmt">// Inferred as 'string'</span>
    <span class="SKwd">var</span> age      = <span class="SNum">25</span>                 <span class="SCmt">// Inferred as 's32'</span>
}</span></div>
<p>You can also explicitly declare a type when desired. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> name:  <span class="STpe">string</span> = <span class="SStr">"Alice"</span>
    <span class="SKwd">var</span> score: <span class="STpe">s32</span> = <span class="SNum">100</span>
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Constants and Immutability </h4>
<p><span class="code-inline">let</span> and <span class="code-inline">const</span> emphasize immutability. <span class="code-inline">let</span> allows runtime initialization, while <span class="code-inline">const</span> is typically resolved at compile-time. </p>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Printing Values </h4>
<p>Use the <span class="code-inline">@print</span> intrinsic to display output in the console. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">CanPrint</span> = <span class="SKwd">false</span> <span class="SCmt">// Must be 'true' to show '@print' results</span>

<span class="SKwd">func</span> <span class="SFct">print</span>(x: ...)
{
    <span class="SLgc">if</span> <span class="SCst">CanPrint</span> <span class="SLgc">do</span>
        <span class="SItr">@print</span>(x)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">let</span> name = <span class="SStr">"Swag"</span>
    <span class="SFct">print</span>(<span class="SStr">"Welcome to "</span>, name, <span class="SStr">" language!\n"</span>)
}</span></div>
<p>This prints: 'Welcome to Swag language!' </p>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Comments </h4>
<p>Swag supports both single-line and multi-line comments. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// This is a single-line comment</span>

    <span class="SCmt">/*
    This is a multi-line comment
    that spans multiple lines.
    */</span>
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Semicolons </h4>
<p>Semicolons are optional at the end of statements. They’re only needed when placing multiple statements on the same line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">5</span>
    <span class="SKwd">let</span> b = <span class="SNum">10</span>
    <span class="SFct">print</span>(a + b, <span class="SStr">"\n"</span>) <span class="SCmt">// Outputs 15</span>
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Integers and Floating-Point Numbers </h4>
<p>Swag supports both integer and floating-point numeric types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> maxHeight: <span class="STpe">u32</span> = <span class="SNum">500</span>        <span class="SCmt">// Unsigned 32-bit integer</span>
    <span class="SKwd">let</span> distance:  <span class="STpe">f64</span> = <span class="SNum">42.195</span>     <span class="SCmt">// Double-precision float</span>

    <span class="SKwd">let</span> result = maxHeight + <span class="SNum">50</span>
    <span class="SFct">print</span>(<span class="SStr">"New height: "</span>, result, <span class="SStr">"\n"</span>)
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Strings </h4>
<p>Strings are UTF-8 encoded and handle international text naturally. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> message = <span class="SStr">"Hello, 世界!"</span>
    <span class="SFct">print</span>(message, <span class="SStr">"\n"</span>)
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Tuples </h4>
<p>Tuples group multiple values of possibly different types. They are useful for returning multiple values or bundling related data. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> person = {<span class="SStr">"Alice"</span>, <span class="SNum">30</span>, <span class="SKwd">true</span>}
    <span class="SKwd">let</span> (name, age, isActive) = person

    <span class="SFct">print</span>(name, <span class="SStr">" is "</span>, age, <span class="SStr">" years old. Active: "</span>, isActive, <span class="SStr">"\n"</span>)

    <span class="SCmt">// Access tuple elements by index:</span>
    <span class="SFct">print</span>(person.item0, <span class="SStr">" is "</span>, person.item1, <span class="SStr">" years old.\n"</span>)
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Control Flow </h4>
<p>Swag uses <span class="code-inline">if</span>, <span class="code-inline">for</span>, and <span class="code-inline">switch</span> for flow control. Curly braces <span class="code-inline">{}</span> are optional; you may use <span class="code-inline">do</span> blocks instead. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> temperature = <span class="SNum">30</span>
    <span class="SLgc">if</span> temperature &gt; <span class="SNum">25</span> <span class="SLgc">do</span>
        <span class="SFct">print</span>(<span class="SStr">"It's hot!\n"</span>)
    <span class="SLgc">else</span> <span class="SLgc">do</span>
        <span class="SFct">print</span>(<span class="SStr">"It's cool!\n"</span>)
}</span></div>
<p>You can also use braces for control blocks. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> temperature = <span class="SNum">30</span>
    <span class="SLgc">if</span> temperature &gt; <span class="SNum">25</span>
    {
        <span class="SFct">print</span>(<span class="SStr">"It's hot!\n"</span>)
    }
    <span class="SLgc">else</span>
    {
        <span class="SFct">print</span>(<span class="SStr">"It's cool!\n"</span>)
    }
}</span></div>
<p>Swag supports both <span class="code-inline">for</span> and <span class="code-inline">while</span> loops. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Iterate 10 times</span>
    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        <span class="SFct">print</span>(<span class="SStr">"Iteration: "</span>, <span class="SItr">@index</span>, <span class="SStr">"\n"</span>)
    }

    <span class="SLgc">for</span> <span class="SKwd">var</span> i: <span class="STpe">u32</span> = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">2</span>
    {
        <span class="SFct">print</span>(<span class="SStr">"Iteration: "</span>, i, <span class="SStr">"\n"</span>)
    }

    <span class="SKwd">var</span> countdown: <span class="STpe">u32</span> = <span class="SNum">5</span>
    <span class="SLgc">while</span> countdown &gt; <span class="SNum">0</span>
    {
        <span class="SFct">print</span>(<span class="SStr">"T-minus "</span>, countdown, <span class="SStr">"\n"</span>)
        countdown -= <span class="SNum">1</span>
    }
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg"><span class="code-inline">foreach</span> Loop </h4>
<p><span class="code-inline">foreach</span> iterates over collections such as arrays. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> numbers = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>, <span class="SNum">5</span>]
    <span class="SLgc">foreach</span> num <span class="SLgc">in</span> numbers
    {
        <span class="SFct">print</span>(<span class="SStr">"Number: "</span>, num, <span class="SStr">"\n"</span>)
    }
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Functions </h4>
<p>Functions encapsulate reusable blocks of logic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">add</span>(a: <span class="STpe">s32</span>, b: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    {
        <span class="SLgc">return</span> a + b
    }

    <span class="SKwd">let</span> result = <span class="SFct">add</span>(<span class="SNum">10</span>, <span class="SNum">5</span>)
    <span class="SFct">print</span>(<span class="SStr">"Result: "</span>, result, <span class="SStr">"\n"</span>) <span class="SCmt">// Outputs 15</span>
}</span></div>
<p>Functions can also return multiple values via tuples. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">splitName</span>()-&gt;{ x: <span class="STpe">string</span>, y: <span class="STpe">string</span> }
    {
        <span class="SLgc">return</span> {<span class="SStr">"a"</span>, <span class="SStr">"b"</span>}
    }

    <span class="SKwd">let</span> (firstName, lastName) = <span class="SFct">splitName</span>()
    <span class="SItr">@assert</span>(firstName == <span class="SStr">"a"</span>)
    <span class="SItr">@assert</span>(lastName == <span class="SStr">"b"</span>)
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Error Handling </h4>
<p>Swag uses <span class="code-inline">throw</span>, <span class="code-inline">try</span>, and <span class="code-inline">catch</span> for robust error management. Errors are treated as values, not exceptions. </p>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Propagating Errors with <span class="code-inline">throw</span> and <span class="code-inline">try</span> </h4>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">divide</span>(a: <span class="STpe">s32</span>, b: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> <span class="SKwd">throw</span>
{
    <span class="SLgc">if</span> b == <span class="SNum">0</span>
    {
        <span class="SKwd">throw</span> <span class="SCst">Swag</span>.<span class="SCst">BaseError</span>{<span class="SStr">"Division by zero!"</span>}
    }
    <span class="SLgc">return</span> a / b
}

<span class="SFct">#test</span>
{
    <span class="SKwd">let</span> result = <span class="SKwd">try</span> <span class="SFct">divide</span>(<span class="SNum">10</span>, <span class="SNum">2</span>)
    <span class="SFct">print</span>(<span class="SStr">"Result: "</span>, result, <span class="SStr">"\n"</span>) <span class="SCmt">// Outputs 5</span>
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Handling Errors with <span class="code-inline">catch</span> </h4>
<p>Use <span class="code-inline">catch</span> to handle errors locally. The intrinsic <span class="code-inline">@err</span> holds the error value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> result = <span class="SKwd">catch</span> <span class="SFct">divide</span>(<span class="SNum">10</span>, <span class="SNum">0</span>)
    <span class="SLgc">if</span> <span class="SItr">@err</span> != <span class="SKwd">null</span>
    {
        <span class="SFct">print</span>(<span class="SStr">"Error: "</span>, <span class="SItr">@err</span>, <span class="SStr">"\n"</span>)
    }
    <span class="SLgc">else</span>
    {
        <span class="SFct">print</span>(<span class="SStr">"Result: "</span>, result, <span class="SStr">"\n"</span>)
    }
}</span></div>
<h4 id="_001_000_introduction_swg__001_002_the_basics_swg">Dismissing Errors with <span class="code-inline">trycatch</span> </h4>
<p><span class="code-inline">trycatch</span> dismisses errors and continues execution, assigning a default value to the target variable. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">safeDivide</span>(a: <span class="STpe">s32</span>, b: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">return</span> <span class="SKwd">trycatch</span> <span class="SFct">divide</span>(a, b)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">let</span> result = <span class="SFct">safeDivide</span>(<span class="SNum">10</span>, <span class="SNum">0</span>)
    <span class="SFct">print</span>(<span class="SStr">"Result: "</span>, result, <span class="SStr">"\n"</span>) <span class="SCmt">// Outputs 0 (default value)</span>
}</span></div>

<h3 id="_001_000_introduction_swg__001_003_hello_mad_world_swg">Hello Mad World </h3><h4 id="_001_000_introduction_swg__001_003_hello_mad_world_swg">'Hello World' Examples </h4>
<p>Let's dig deeper into the classic 'hello world' example. The simplest version requires no external dependencies, such as the <a href="std.php">Swag standard modules</a>. </p>
<p><span class="code-inline">#main</span> is the <b>program entry point</b>, a special compiler function (its name starts with <span class="code-inline">#</span>). It must be defined only once in a native executable. </p>
<p><span class="code-inline">@print</span> is an <b>intrinsic</b>, a built-in function (its name starts with <span class="code-inline">@</span>). All intrinsics are part of the <a href="std/swag.runtime.php">compiler runtime</a>, which is bundled with the compiler. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SItr">@print</span>(<span class="SStr">"Hello mad world!\n"</span>)
}</span></div>
<p>Next, a version using the <span class="code-inline">Core.Console.print</span> function from the <a href="std.core.html">Std.Core</a> module. The <span class="code-inline">Std.Core</span> module must be imported before use, but this example keeps things simple. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world!"</span>, <span class="SStr">"\n"</span>)
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">printf</span>(<span class="SStr">"%\n"</span>, <span class="SStr">"Hello mad world again!"</span>)
}</span></div>
<p>A <span class="code-inline">#run</span> block executes <b>at compile time</b>, allowing Swag to behave like a <b>scripting language</b>. In the following example, the famous message is printed by the compiler during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
{
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SStr">"Hello mad world!\n"</span>   <span class="SCmt">// Creates a compiler constant of type 'string'</span>
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)            <span class="SCmt">// Calls 'Console.print' at compile time</span>
}</span></div>
<p>A version that calls a <b>nested function</b> at compile time to initialize the string constant to print. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Brings the 'Core' namespace into scope to avoid repetition</span>
<span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">nestedFunc</span>() =&gt; <span class="SStr">"Hello mad world!\n"</span>   <span class="SCmt">// Short function syntax</span>

    <span class="SCmt">// 'nestedFunc()' can be called at compile time because it is marked with</span>
    <span class="SCmt">// the 'Swag.ConstExpr' attribute.</span>
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SFct">nestedFunc</span>()
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)
}</span></div>
<p>A version that generates code dynamically using <b>meta programming</b>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SStr">"Hello mad world!\n"</span>

    <span class="SCmt">// The result of a '#ast' block is a string compiled in place.</span>
    <span class="SCmt">// This is equivalent to calling 'Console.print(Msg)' directly.</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">var</span> sb = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}
        sb.<span class="SFct">appendString</span>(<span class="SStr">"Console.print(Msg)"</span>)
        <span class="SLgc">return</span> sb.<span class="SFct">toString</span>()
    }
}</span></div>
<p>Finally, an even more elaborate example combining compile-time execution and meta programming. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SCmt">// '#run' forces the call to 'mySillyFunction()' at compile time</span>
    <span class="SCmt">// even though it is not marked with '#[Swag.ConstExpr]'</span>
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SFct">#run</span> <span class="SFct">mySillyFunction</span>()
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)
}

<span class="SCmt">// The attribute '#[Swag.Compiler]' tells Swag that this function is for</span>
<span class="SCmt">// compile-time only, and will not be exported to the final executable or module.</span>
<span class="SAtr">#[Swag.Compiler]</span>
<span class="SKwd">func</span> <span class="SFct">mySillyFunction</span>()-&gt;<span class="STpe">string</span>
{
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world at compile time!\n"</span>)

    <span class="SCmt">// This creates a constant named 'MyConst'</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">var</span> sb = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}
        sb.<span class="SFct">appendString</span>(<span class="SStr">"const MyConst = \"Hello "</span>)
        sb.<span class="SFct">appendString</span>(<span class="SStr">"mad world "</span>)
        sb.<span class="SFct">appendString</span>(<span class="SStr">"at runtime!\""</span>)
        <span class="SLgc">return</span> sb.<span class="SFct">toString</span>()
    }

    <span class="SCmt">// Use and return the constant created above</span>
    <span class="SLgc">return</span> <span class="SCst">MyConst</span>
}</span></div>
<p>This entire sequence of meta-programming and compile-time evaluation ultimately produces the following equivalent runtime code: </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world at runtime!"</span>)
}</span></div>

<h2 id="_002_000_code_structure_swg">Code Structure </h2>
<h3 id="_002_000_code_structure_swg__002_002_source_code_organization_swg">Source Code Organization </h3><h4 id="_002_000_code_structure_swg__002_002_source_code_organization_swg">Source Files and Workspaces </h4>
<p>In Swag, all source files must use the <span class="code-inline">.swg</span> extension, except for simple script files, which use the <span class="code-inline">.swgs</span> extension. All files must be encoded in <b>UTF-8</b> to ensure proper handling of text and symbols. </p>
<p>Swag does not compile individual source files (except for <span class="code-inline">.swgs</span> scripts). Instead, source code is organized within a <b>workspace</b> that contains one or more <b>modules</b>. This modular approach promotes clean structure and efficient management of complex projects. </p>
<p>For example, <span class="code-inline">Std</span> is a workspace that includes all the standard modules provided by Swag. </p>
<p>A module can either produce a <span class="code-inline">dll</span> (on Windows) or an executable. A single workspace may include multiple modules, typically comprising both the modules you develop (such as your main executable) and any external dependencies. </p>
<p>Generally, the entire workspace is compiled together, ensuring that all modules and dependencies are properly built, up to date, and fully integrated. </p>

<h3 id="_002_000_code_structure_swg__002_003_global_declaration_order_swg">Global Declaration Order </h3><h4 id="_002_000_code_structure_swg__002_003_global_declaration_order_swg">Top-Level Declaration Order </h4>
<p>The order of all <b>top-level</b> declarations in Swag does not matter. This means you can reference constants, variables, or functions before they are defined — either within the same file or across multiple files. </p>
<p>This flexibility is especially useful in large codebases, where logical flow or readability may benefit from organizing code independently of declaration order. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// In this example, we declare a constant 'A' and initialize it with 'B',</span>
<span class="SCmt">// even though 'B' has not yet been declared or defined.</span>
<span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SCst">B</span>

<span class="SCmt">// Next, we declare a constant 'B' and initialize it with 'C',</span>
<span class="SCmt">// which is also not yet declared or defined.</span>
<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCst">C</span>

<span class="SCmt">// Finally, we declare and define 'C' as a constant of type 'u64'</span>
<span class="SCmt">// (an unsigned 64-bit integer) with a value of 1.</span>
<span class="SCmt">// This retroactively assigns values to both 'A' and 'B'</span>
<span class="SCmt">// based on the earlier assignments.</span>
<span class="SKwd">const</span> <span class="SCst">C</span>: <span class="STpe">u64</span> = <span class="SNum">1</span></span></div>
<p>In this example, we demonstrate Swag's flexibility by calling the function <span class="code-inline">functionDeclaredLater</span> before it is defined. This behavior illustrates that Swag does not impose order restrictions on function declarations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
{
    <span class="SCmt">// Call the function 'functionDeclaredLater' before it is declared.</span>
    <span class="SCmt">// Swag allows this because top-level declarations are order-independent.</span>
    <span class="SFct">functionDeclaredLater</span>()
}

<span class="SCmt">// The function is declared here, after it has already been called.</span>
<span class="SKwd">func</span> <span class="SFct">functionDeclaredLater</span>() {}</span></div>
<p>This flexibility also applies across multiple files. For example, you can call a function in one file and define it in another. Swag's global declaration model is intentionally non-restrictive, allowing you to structure your code in the way that best supports clarity and maintainability. </p>

<h3 id="_002_000_code_structure_swg__002_004_comments_swg">Comments </h3><h4 id="_002_000_code_structure_swg__002_004_comments_swg">Comments </h4>
<p>Swag supports both single-line and multi-line comments, providing flexibility for inline documentation and explanations within your code. This helps maintain clarity and readability, especially in larger or more complex codebases. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Example of a single-line comment</span>
<span class="SCmt">// Single-line comments are typically used for brief explanations or notes.</span>

<span class="SCmt">/*
    Example of a multi-line comment
    that spans several lines.

    Multi-line comments are useful when more detailed explanations are required.
    These comments can describe the overall purpose of a function, document complex
    logic, or provide additional context to developers.
*/</span>

<span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SNum">0</span>        <span class="SCmt">// A constant named 'A' assigned the value '0'.</span>
<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCmt">/* false */</span><span class="SKwd">true</span> <span class="SCmt">// A constant named 'B' assigned the value 'true', with an inline</span>
<span class="SCmt">// comment noting that 'false' was an alternative value considered.</span></span></div>
<h4 id="_002_000_code_structure_swg__002_004_comments_swg">Nested Comments </h4>
<p>Swag also supports nested comments within multi-line comments. This can be particularly useful when temporarily disabling a block of code or when adding notes inside an existing comment block. </p>
<div class="code-block"><span class="SCmt">/*
    */ Example of a nested multi-line comment */
    The nested comment above is encapsulated within another multi-line comment.
    This demonstrates Swag's ability to handle complex comment structures without
    causing errors or ambiguity.
*/</span></div>

<h3 id="_002_000_code_structure_swg__002_005_semicolons_swg">Semicolons </h3><h4 id="_002_000_code_structure_swg__002_005_semicolons_swg">Statement Termination in Swag </h4>
<p>Unlike languages such as C or C++, there is no strict requirement to end statements with a semicolon (<span class="code-inline">;</span>). In Swag, a statement naturally terminates at the end of a line ('end of line'). This allows for cleaner, more concise syntax and reduces visual clutter, making the code easier to read and maintain. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Declare two variables, 'x' and 'y', both of type 's32' (signed 32-bit integer),</span>
    <span class="SCmt">// and initialize them with the value '1'.</span>
    <span class="SKwd">var</span> x, y: <span class="STpe">s32</span> = <span class="SNum">1</span>

    <span class="SCmt">// Increment the value of both 'x' and 'y' by 1.</span>
    x += <span class="SNum">1</span>
    y += <span class="SNum">1</span>

    <span class="SCmt">// Use the '@assert' intrinsic to verify the correctness of the logic.</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">2</span>) <span class="SCmt">// Confirms that 'x' equals 2. Raises an error if it fails.</span>
    <span class="SItr">@assert</span>(y == x) <span class="SCmt">// Confirms that 'y' equals 'x', which should also be 2.</span>
}</span></div>
<h4 id="_002_000_code_structure_swg__002_005_semicolons_swg">Optional Semicolons </h4>
<p>While semicolons are optional, they can still be used if desired. In some cases, using semicolons may enhance code clarity or readability, particularly in more complex statements or when writing multiple statements on a single line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Here, type inference is used, so the types of 'x' and 'y' are not explicitly defined.</span>
    <span class="SKwd">var</span> x, y = <span class="SNum">0</span>
    <span class="SCmt">// Both 'x' and 'y' are initialized to 0, with types inferred automatically.</span>

    <span class="SCmt">// Increment both variables by 1.</span>
    x, y += <span class="SNum">1</span>
    <span class="SCmt">// Both 'x' and 'y' now have the value 1.</span>
}</span></div>
<h4 id="_002_000_code_structure_swg__002_005_semicolons_swg">Multiple Statements on a Single Line </h4>
<p>Semicolons are especially useful when writing multiple statements on a single line. Although this can make code more compact, it is generally recommended to use it sparingly, as it may reduce readability in complex code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Two variable declarations and initializations on a single line.</span>
    <span class="SKwd">var</span> x = <span class="SNum">0</span>
    <span class="SKwd">var</span> y = <span class="SNum">0</span>

    <span class="SCmt">// Increment both 'x' and 'y' on the same line.</span>
    x += <span class="SNum">1</span>; y += <span class="SNum">1</span>

    <span class="SCmt">// Assert correctness of both variables.</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)
}</span></div>

<h3 id="_002_000_code_structure_swg__002_006_identifiers_swg">Identifiers </h3><h4 id="_002_000_code_structure_swg__002_006_identifiers_swg">Naming </h4>
<p>User-defined identifiers, such as variables, constants, and function names, must begin with either an underscore (<span class="code-inline">_</span>) or an ASCII letter. Identifiers may then include underscores, ASCII letters, and digits. </p>
<p>Examples: </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> thisIsAValidIdentifier0   = <span class="SNum">0</span>
<span class="SKwd">const</span> this_is_also_valid        = <span class="SNum">0</span>
<span class="SKwd">const</span> this_1_is_2_also__3_valid = <span class="SNum">0</span></span></div>
<p>However, identifiers cannot start with two underscores, as this prefix is reserved by the compiler. </p>
<div class="code-block"><span class="SCmt">// const __this_is_invalid = 0</span></div>
<h4 id="_002_000_code_structure_swg__002_006_identifiers_swg">Compiler Instructions </h4>
<p>Some identifiers may begin with <span class="code-inline">#</span>, indicating a compiler directive or special function. These instructions have specific roles within the Swag environment and are evaluated at compile time. </p>
<p>Examples of compiler instructions: </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span>
<span class="SFct">#run</span>
<span class="SFct">#main</span></span></div>
<h4 id="_002_000_code_structure_swg__002_006_identifiers_swg">Intrinsics </h4>
<p>Identifiers that start with <span class="code-inline">@</span> represent intrinsic functions. These functions are provided by the compiler and are available at both compile time and runtime. </p>
<p>Examples of intrinsic functions: </p>
<div class="code-block"><span class="SCde"><span class="SItr">@min</span>()
<span class="SItr">@max</span>()
<span class="SItr">@sqrt</span>()
<span class="SItr">@print</span>()</span></div>

<h3 id="_002_000_code_structure_swg__002_007_keywords_swg">Keywords </h3><h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Special Keywords </h4>
<p>Special keywords are predefined, reserved identifiers that have specific meanings within the Swag compiler. These cannot be used as identifiers in your code, as they are integral to the language's structure. </p>
<div class="code-block"><span class="SCde"><span class="SLgc">if</span>
<span class="SLgc">else</span>
<span class="SLgc">elif</span>
<span class="SLgc">while</span>
<span class="SLgc">switch</span>
<span class="SLgc">defer</span>
<span class="SLgc">for</span>
<span class="SLgc">foreach</span>
<span class="SLgc">break</span>
<span class="SLgc">fallthrough</span>
<span class="SLgc">return</span>
<span class="SLgc">case</span>
<span class="SLgc">continue</span>
<span class="SLgc">default</span>
<span class="SLgc">and</span>
<span class="SLgc">or</span>
<span class="SLgc">orelse</span>
<span class="SLgc">unreachable</span>
<span class="SLgc">to</span>
<span class="SLgc">until</span>
<span class="SLgc">where</span>
<span class="SLgc">in</span>
<span class="SLgc">as</span>

<span class="SKwd">true</span>
<span class="SKwd">false</span>
<span class="SKwd">null</span>
<span class="SKwd">undefined</span>

<span class="SKwd">using</span>
<span class="SKwd">with</span>
<span class="SKwd">cast</span>
<span class="SKwd">dref</span>
<span class="SKwd">retval</span>
<span class="SKwd">try</span>
<span class="SKwd">trycatch</span>
<span class="SKwd">catch</span>
<span class="SKwd">assume</span>
<span class="SKwd">throw</span>
<span class="SKwd">discard</span>

<span class="SKwd">public</span>
<span class="SKwd">internal</span>
<span class="SKwd">private</span>

<span class="SKwd">enum</span>
<span class="SKwd">struct</span>
<span class="SKwd">union</span>
<span class="SKwd">impl</span>
<span class="SKwd">interface</span>
<span class="SKwd">func</span>
<span class="SKwd">mtd</span>
<span class="SKwd">namespace</span>
<span class="SKwd">alias</span>
<span class="SKwd">attr</span>
<span class="SKwd">var</span>
<span class="SKwd">let</span>
<span class="SKwd">const</span>
<span class="SKwd">moveref</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Reserved Keywords </h4>
<p>These keywords are reserved by the language and cannot be used by developers, even though they may not currently serve an active role in the syntax. They are reserved for potential future use or to prevent conflicts with language features. </p>
<div class="code-block"><span class="SCde"><span class="SLgc">is</span>
<span class="SInv">not</span>
<span class="SLgc">do</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Basic Types </h4>
<p>These are the fundamental data types provided by the language. They are reserved keywords and form the core building blocks for variables, constants, and function return types. </p>
<div class="code-block"><span class="SCde"><span class="STpe">s8</span>
<span class="STpe">s16</span>
<span class="STpe">s32</span>
<span class="STpe">s64</span>
<span class="STpe">u8</span>
<span class="STpe">u16</span>
<span class="STpe">u32</span>
<span class="STpe">u64</span>
<span class="STpe">f32</span>
<span class="STpe">f64</span>
<span class="STpe">bool</span>
<span class="STpe">string</span>
<span class="STpe">rune</span>
<span class="STpe">any</span>
<span class="STpe">typeinfo</span>
<span class="STpe">void</span>
code
<span class="STpe">cstring</span>
<span class="STpe">cvarargs</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Compiler Instructions </h4>
<p>Compiler instructions are prefixed with <span class="code-inline">#</span>. They are reserved for specific operations within the Swag compiler and control various aspects of compilation and code generation. User-defined identifiers cannot start with <span class="code-inline">#</span>, ensuring there are no naming conflicts. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
<span class="SFct">#ast</span>
<span class="SFct">#test</span>
<span class="SFct">#init</span>
<span class="SFct">#drop</span>
<span class="SFct">#main</span>
<span class="SFct">#premain</span>
<span class="SFct">#message</span>
<span class="SFct">#dependencies</span>

<span class="SCmp">#global</span>
<span class="SCmp">#load</span>
<span class="SCmp">#foreignlib</span>
<span class="SCmp">#assert</span>
<span class="SCmp">#print</span>
<span class="SCmp">#error</span>
<span class="SCmp">#warning</span>
<span class="SCmp">#import</span>
<span class="SCmp">#if</span>
<span class="SCmp">#else</span>
<span class="SCmp">#elif</span>
<span class="SCmp">#inject</span>
<span class="SCmp">#macro</span>
<span class="SCmp">#scope</span>

<span class="SItr">#defined</span>
<span class="SItr">#offsetof</span>
<span class="SItr">#alignof</span>
<span class="SItr">#sizeof</span>
<span class="SItr">#typeof</span>
<span class="SItr">#stringof</span>
<span class="SItr">#nameof</span>
<span class="SItr">#isconstexpr</span>
<span class="SItr">#location</span>
<span class="SItr">#decltype</span>
<span class="SItr">#gettag</span>
<span class="SItr">#hastag</span>
<span class="SItr">#runes</span>
<span class="SItr">#safety</span>
<span class="SItr">#include</span>

<span class="SCmp">#cfg</span>
<span class="SCmp">#os</span>
<span class="SCmp">#arch</span>
<span class="SCmp">#cpu</span>
<span class="SCmp">#backend</span>
<span class="SCmp">#module</span>
<span class="SCmp">#file</span>
<span class="SCmp">#line</span>
<span class="SCmp">#me</span>
<span class="SCmp">#curlocation</span>
<span class="SCmp">#callerlocation</span>
<span class="SCmp">#callerfunction</span>
<span class="SCmp">#swagversion</span>
<span class="SCmp">#swagrevision</span>
<span class="SCmp">#swagbuildnum</span>
<span class="SCmp">#swagos</span>

<span class="SItr">#code</span>
<span class="SItr">#type</span>
<span class="SItr">#up</span>

<span class="SItr">#alias0</span>
<span class="SItr">#alias1</span>
<span class="SItr">#alias2</span> <span class="SCmt">// and more generally #aliasN</span>
<span class="SItr">#uniq0</span>
<span class="SItr">#uniq1</span>
<span class="SItr">#uniq2</span> <span class="SCmt">// and more generally #mixinN</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Intrinsic Values </h4>
<p>Intrinsic values begin with <span class="code-inline">@</span> and are provided by the compiler for introspection or internal state access. </p>
<div class="code-block"><span class="SCde"><span class="SItr">@err</span>
<span class="SItr">@index</span>
<span class="SItr">@args</span>
<span class="SItr">@pinfos</span>
<span class="SItr">@bytecode</span>
<span class="SItr">@compiler</span>
<span class="SItr">@modules</span>
<span class="SItr">@gvtd</span>
<span class="SItr">@rtflags</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Miscellaneous Intrinsics </h4>
<p>Intrinsic functions are prefixed with <span class="code-inline">@</span> and provide low-level operations directly supported by the compiler or hardware. They can be used at both compile time and runtime. </p>
<div class="code-block"><span class="SCde"><span class="SItr">@kindof</span>
<span class="SItr">@countof</span>
<span class="SItr">@dataof</span>
<span class="SItr">@mkslice</span>
<span class="SItr">@mkstring</span>
<span class="SItr">@mkcallback</span>
<span class="SItr">@mkany</span>
<span class="SItr">@mkinterface</span>
<span class="SItr">@dbgalloc</span>
<span class="SItr">@sysalloc</span>
<span class="SItr">@stringcmp</span>
<span class="SItr">@typecmp</span>
<span class="SItr">@is</span>
<span class="SItr">@as</span>
<span class="SItr">@getcontext</span>
<span class="SItr">@tableof</span>

<span class="SItr">@assert</span>
<span class="SItr">@breakpoint</span>
<span class="SItr">@init</span>
<span class="SItr">@drop</span>
<span class="SItr">@postcopy</span>
<span class="SItr">@postmove</span>
<span class="SItr">@compilererror</span>
<span class="SItr">@compilerwarning</span>
<span class="SItr">@panic</span>
<span class="SItr">@print</span>
<span class="SItr">@setcontext</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Intrinsics from <span class="code-inline">libc</span> </h4>
<p>These intrinsic functions expose standard <span class="code-inline">libc</span> functionalities, allowing developers to perform common mathematical, memory, and string operations. They are also prefixed with <span class="code-inline">@</span> to prevent conflicts with user-defined identifiers. </p>
<div class="code-block"><span class="SCde"><span class="SItr">@abs</span>
<span class="SItr">@acos</span>
<span class="SItr">@asin</span>
<span class="SItr">@atan</span>
<span class="SItr">@atan2</span>
<span class="SItr">@alloc</span>
<span class="SItr">@atomadd</span>
<span class="SItr">@atomand</span>
<span class="SItr">@atomcmpxchg</span>
<span class="SItr">@atomor</span>
<span class="SItr">@atomxchg</span>
<span class="SItr">@atomxor</span>
<span class="SItr">@bitcountlz</span>
<span class="SItr">@bitcountnz</span>
<span class="SItr">@bitcounttz</span>
<span class="SItr">@byteswap</span>
<span class="SItr">@cvaarg</span>
<span class="SItr">@cvaend</span>
<span class="SItr">@cvastart</span>
<span class="SItr">@ceil</span>
<span class="SItr">@cos</span>
<span class="SItr">@cosh</span>
<span class="SItr">@exp</span>
<span class="SItr">@exp2</span>
<span class="SItr">@floor</span>
<span class="SItr">@free</span>
<span class="SItr">@log</span>
<span class="SItr">@log10</span>
<span class="SItr">@log2</span>
<span class="SItr">@max</span>
<span class="SItr">@memcmp</span>
<span class="SItr">@memcpy</span>
<span class="SItr">@memmove</span>
<span class="SItr">@memset</span>
<span class="SItr">@min</span>
<span class="SItr">@muladd</span>
<span class="SItr">@pow</span>
<span class="SItr">@realloc</span>
<span class="SItr">@rol</span>
<span class="SItr">@ror</span>
<span class="SItr">@round</span>
<span class="SItr">@sin</span>
<span class="SItr">@sinh</span>
<span class="SItr">@sqrt</span>
<span class="SItr">@strcmp</span>
<span class="SItr">@strlen</span>
<span class="SItr">@tan</span>
<span class="SItr">@tanh</span>
<span class="SItr">@trunc</span></span></div>
<h4 id="_002_000_code_structure_swg__002_007_keywords_swg">Modifiers </h4>
<p>Modifiers can be applied to specific keywords or operators to adjust their behavior. They give developers finer control over how code is interpreted or executed. </p>
<div class="code-block"><span class="SCde"><span class="SItr">#prom</span>
<span class="SItr">#wrap</span>
<span class="SItr">#nodrop</span>
<span class="SItr">#move</span>
<span class="SItr">#moveraw</span>
<span class="SItr">#reverse</span>
<span class="SItr">#ref</span>
<span class="SItr">#constref</span>
<span class="SItr">#err</span>
<span class="SItr">#noerr</span>
<span class="SItr">#null</span></span></div>

<h2 id="_003_000_fundamentals_swg">Fundamentals </h2>
<h3 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Basic Types </h3><h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Signed Integers </h4>
<p>Swag provides various signed integer types: <span class="code-inline">s8</span>, <span class="code-inline">s16</span>, <span class="code-inline">s32</span>, and <span class="code-inline">s64</span>. These types represent signed integers with different bit widths, allowing both positive and negative values within their respective ranges. Each type is designed for efficient integer operations at varying levels of precision. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">s8</span> = -<span class="SNum">1</span>      <span class="SCmt">// 8-bit signed integer, range: -128 to 127</span>
    <span class="SKwd">let</span> b: <span class="STpe">s16</span> = -<span class="SNum">2</span>     <span class="SCmt">// 16-bit signed integer, range: -32,768 to 32,767</span>
    <span class="SKwd">let</span> c: <span class="STpe">s32</span> = -<span class="SNum">3</span>     <span class="SCmt">// 32-bit signed integer, range: -2^31 to 2^31-1</span>
    <span class="SKwd">let</span> d: <span class="STpe">s64</span> = -<span class="SNum">4</span>     <span class="SCmt">// 64-bit signed integer, range: -2^63 to 2^63-1</span>

    <span class="SItr">@assert</span>(a == -<span class="SNum">1</span>)
    <span class="SItr">@assert</span>(b == -<span class="SNum">2</span>)
    <span class="SItr">@assert</span>(c == -<span class="SNum">3</span>)
    <span class="SItr">@assert</span>(d == -<span class="SNum">4</span>)

    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">1</span>) <span class="SCmt">// 'a' is an 's8' → 1 byte</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(b) == <span class="SNum">2</span>) <span class="SCmt">// 'b' is an 's16' → 2 bytes</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(c) == <span class="SNum">4</span>) <span class="SCmt">// 'c' is an 's32' → 4 bytes</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(d) == <span class="SNum">8</span>) <span class="SCmt">// 'd' is an 's64' → 8 bytes</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Unsigned Integers </h4>
<p>Swag also supports unsigned integer types: <span class="code-inline">u8</span>, <span class="code-inline">u16</span>, <span class="code-inline">u32</span>, and <span class="code-inline">u64</span>. These types can only represent non-negative values, making them ideal for counting, indexing, and other operations where negative numbers are not applicable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">u8</span> = <span class="SNum">1</span>      <span class="SCmt">// 8-bit unsigned integer, range: 0 to 255</span>
    <span class="SKwd">let</span> b: <span class="STpe">u16</span> = <span class="SNum">2</span>     <span class="SCmt">// 16-bit unsigned integer, range: 0 to 65,535</span>
    <span class="SKwd">let</span> c: <span class="STpe">u32</span> = <span class="SNum">3</span>     <span class="SCmt">// 32-bit unsigned integer, range: 0 to 2^32-1</span>
    <span class="SKwd">let</span> d: <span class="STpe">u64</span> = <span class="SNum">4</span>     <span class="SCmt">// 64-bit unsigned integer, range: 0 to 2^64-1</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(c == <span class="SNum">3</span>)
    <span class="SItr">@assert</span>(d == <span class="SNum">4</span>)

    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">1</span>) <span class="SCmt">// 'a' is a 'u8' → 1 byte</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(b) == <span class="SNum">2</span>) <span class="SCmt">// 'b' is a 'u16' → 2 bytes</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(c) == <span class="SNum">4</span>) <span class="SCmt">// 'c' is a 'u32' → 4 bytes</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(d) == <span class="SNum">8</span>) <span class="SCmt">// 'd' is a 'u64' → 8 bytes</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Floating-Point Types </h4>
<p>Swag supports floating-point types <span class="code-inline">f32</span> and <span class="code-inline">f64</span>. These represent single- and double-precision floating-point numbers, suitable for calculations requiring fractional values or higher precision. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">f32</span> = <span class="SNum">3.14</span>        <span class="SCmt">// 32-bit float (single precision)</span>
    <span class="SKwd">let</span> b: <span class="STpe">f64</span> = <span class="SNum">3.14159</span>     <span class="SCmt">// 64-bit float (double precision)</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">3.14</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">3.14159</span>)

    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">4</span>) <span class="SCmt">// 'a' is an 'f32' → 4 bytes</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(b) == <span class="SNum">8</span>) <span class="SCmt">// 'b' is an 'f64' → 8 bytes</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Boolean Type </h4>
<p>The boolean type <span class="code-inline">bool</span> represents logical true or false values. In Swag, a boolean occupies 1 byte of memory. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">bool</span> = <span class="SKwd">true</span>
    <span class="SKwd">let</span> b: <span class="STpe">bool</span> = <span class="SKwd">false</span>

    <span class="SItr">@assert</span>(a == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(b == <span class="SKwd">false</span>)

    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">1</span>) <span class="SCmt">// 'bool' → 1 byte</span>
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(b) == <span class="SNum">1</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">String Type </h4>
<p>The <span class="code-inline">string</span> type represents text. Strings in Swag are UTF-8 encoded and stored as two 64-bit values: one for the data pointer and one for the length in bytes. This structure ensures efficient text manipulation and full Unicode compatibility. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">string</span> = <span class="SStr">"string 是"</span> <span class="SCmt">// UTF-8 encoded string</span>

    <span class="SItr">@assert</span>(a == <span class="SStr">"string 是"</span>)
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">2</span> * <span class="SItr">#sizeof</span>(*<span class="STpe">void</span>)) <span class="SCmt">// Pointer + length</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Rune Type </h4>
<p>The <span class="code-inline">rune</span> type represents a 32-bit Unicode code point. It stores a single Unicode character and is ideal for per-character text operations across languages. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">rune</span> = '是' <span class="SCmt">// Single Unicode code point</span>

    <span class="SItr">@assert</span>(a == '是')
    <span class="SItr">@assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SNum">4</span>) <span class="SCmt">// 'rune' → 4 bytes (32 bits)</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Type Reflection </h4>
<p>Swag supports <b>type reflection</b> at both <b>compile time</b> and <b>runtime</b>. This allows inspection and manipulation of types dynamically, enabling powerful and introspective programming techniques. </p>
<p>Further details about type reflection are explored in later sections. </p>
<h4 id="_003_000_fundamentals_swg__003_001_basic_types_swg">Type Creation with <span class="code-inline">#decltype</span> </h4>
<p>You can use <span class="code-inline">#decltype</span> to create a type based on an existing expression. This is useful for inferring or mirroring the type of another variable dynamically, improving reusability and reducing redundancy. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a  = <span class="SNum">0</span>                  <span class="SCmt">// Type of 'a' inferred as 's32'</span>
    <span class="SKwd">let</span> b: <span class="SItr">#decltype</span>(a) = <span class="SNum">1</span>     <span class="SCmt">// 'b' declared with same type as 'a'</span>

    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(a) == <span class="SItr">#typeof</span>(b))
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">s32</span>)

    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="SItr">#typeof</span>(b))
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">s32</span>)
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Number Literals </h3><h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Number Representations </h4>
<p>Integers can be written in multiple formats: <i>decimal</i>, <i>hexadecimal</i>, or <i>binary</i>. These representations allow you to express numbers in the format that best fits your use case or domain requirements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">u32</span> = <span class="SNum">123456</span>         <span class="SCmt">// Decimal format</span>
    <span class="SKwd">const</span> b: <span class="STpe">u32</span> = <span class="SNum">0xFFFF</span>         <span class="SCmt">// Hexadecimal, prefixed with '0x' (represents 65535)</span>
    <span class="SKwd">const</span> c: <span class="STpe">u32</span> = <span class="SNum">0b00001111</span>     <span class="SCmt">// Binary, prefixed with '0b' (represents 15)</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">123456</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">65535</span>)
    <span class="SItr">@assert</span>(c == <span class="SNum">15</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Digit Separators </h4>
<p>Numeric literals can use the underscore (<span class="code-inline">_</span>) as a digit separator for better readability. Separators do not affect the numeric value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">u32</span> = <span class="SNum">123_456</span>         <span class="SCmt">// Decimal with separators</span>
    <span class="SKwd">const</span> b: <span class="STpe">u32</span> = <span class="SNum">0xF_F_F_F</span>       <span class="SCmt">// Hexadecimal with separators</span>
    <span class="SKwd">const</span> c: <span class="STpe">u32</span> = <span class="SNum">0b0000_1111</span>     <span class="SCmt">// Binary with separators</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">123456</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">65535</span>)
    <span class="SItr">@assert</span>(c == <span class="SNum">15</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Default Integer Types </h4>
<p>In Swag, hexadecimal or binary literals default to type <span class="code-inline">u32</span> if the value fits within 32 bits. If the literal exceeds 32 bits, it is automatically inferred as <span class="code-inline">u64</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SNum">0xFF</span> <span class="SCmt">// Fits in 32 bits → inferred as 'u32'</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">u32</span>)

    <span class="SKwd">const</span> b = <span class="SNum">0xF_FFFFF_FFFFFF</span> <span class="SCmt">// Exceeds 32 bits → inferred as 'u64'</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(b) == <span class="STpe">u64</span>)

    <span class="SKwd">const</span> c = <span class="SNum">0b00000001</span> <span class="SCmt">// Within 32 bits → inferred as 'u32'</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(c) == <span class="STpe">u32</span>)

    <span class="SKwd">const</span> d = <span class="SNum">0b00000001_00000001_00000001_00000001_00000001</span> <span class="SCmt">// Exceeds 32 bits → 'u64'</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(d) == <span class="STpe">u64</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Booleans </h4>
<p>A <span class="code-inline">bool</span> type can hold either <span class="code-inline">true</span> or <span class="code-inline">false</span>. Since constants are known at compile time, you can use <span class="code-inline">#assert</span> to verify their values during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SKwd">true</span>
    <span class="SCmp">#assert</span>(a == <span class="SKwd">true</span>)

    <span class="SKwd">const</span> b, c = <span class="SKwd">false</span>
    <span class="SCmp">#assert</span>(b == <span class="SKwd">false</span>)
    <span class="SCmp">#assert</span>(c == <span class="SKwd">false</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Floating-Point Values </h4>
<p>Floating-point literals use standard C-style notation. This makes them familiar and easy to read for developers coming from C or C++ backgrounds. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">f32</span>) <span class="SCmt">// Default float type is 'f32'</span>

    <span class="SKwd">let</span> b = <span class="SNum">0.11</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">0.11</span>)

    <span class="SKwd">let</span> c = <span class="SNum">15e2</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">15e2</span>) <span class="SCmt">// Equivalent to 1500</span>

    <span class="SKwd">let</span> d = <span class="SNum">15e+2</span>
    <span class="SItr">@assert</span>(d == <span class="SNum">15e2</span>)

    <span class="SKwd">let</span> e = -<span class="SNum">1E-1</span>
    <span class="SItr">@assert</span>(e == -<span class="SNum">0.1</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Default Floating-Point Type </h4>
<p>By default, floating-point literals are of type <span class="code-inline">f32</span>. This differs from C and C++, where floating-point literals default to <span class="code-inline">double</span> (<span class="code-inline">f64</span>). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">f32</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) != <span class="STpe">f64</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_002_number_literals_swg">Literal Suffix </h4>
<p>You can specify the type of a literal explicitly by adding a <b>suffix</b> to it. This is useful when a specific type is required, such as <span class="code-inline">f64</span> or <span class="code-inline">u8</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>'<span class="STpe">f64</span> <span class="SCmt">// Explicitly declare 'a' as 'f64'</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>'<span class="STpe">f64</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">f64</span>)

    <span class="SKwd">let</span> b = <span class="SNum">10</span>'<span class="STpe">u8</span> <span class="SCmt">// Declare 'b' as 'u8'</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">10</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(b) == <span class="STpe">u8</span>)

    <span class="SKwd">let</span> c = <span class="SNum">1</span>'<span class="STpe">u32</span> <span class="SCmt">// Explicitly typed as 'u32'</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(c) == <span class="STpe">u32</span>)
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_003_string_swg">String </h3><h4 id="_003_000_fundamentals_swg__003_003_string_swg">UTF-8 Encoding </h4>
<p>Swag uses UTF-8 encoding for strings, allowing representation of characters from virtually all languages and symbol sets. </p>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">String Comparison </h4>
<p>Strings can be compared directly for equality using the <span class="code-inline">==</span> operator. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is a Chinese character: 是"</span>
    <span class="SCmp">#assert</span>(a == <span class="SStr">"this is a Chinese character: 是"</span>)

    <span class="SKwd">const</span> b = <span class="SStr">"these are some Cyrillic characters: ӜИ"</span>
    <span class="SCmp">#assert</span>(b == <span class="SStr">"these are some Cyrillic characters: ӜИ"</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">The <span class="code-inline">rune</span> Type </h4>
<p>A <span class="code-inline">rune</span> represents a Unicode code point and is stored as a 32-bit value, ensuring it can accommodate any Unicode character. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">rune</span> = '是'
    <span class="SCmp">#assert</span>(a == '是')
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SItr">#sizeof</span>(<span class="STpe">u32</span>))
}</span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> Direct indexing of a string to retrieve a <span class="code-inline">rune</span> is not supported, except for  ASCII strings. Swag avoids the runtime overhead of UTF-8 decoding.  The <span class="code-inline">Std.Core</span> module provides utilities for working with UTF-8 strings. </p>
</div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">String Indexing </h4>
<p>When indexing a string, Swag returns a byte (<span class="code-inline">u8</span>), not a <span class="code-inline">rune</span>. This reflects the underlying UTF-8 encoding. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is a Chinese character: 是"</span>

    <span class="SCmt">// Retrieve the first byte ('t')</span>
    <span class="SKwd">const</span> b = a[<span class="SNum">0</span>]
    <span class="SCmp">#assert</span>(b == <span class="SStr">'t'</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(b) == <span class="SItr">#typeof</span>(<span class="STpe">u8</span>))

    <span class="SCmt">// Multibyte UTF-8 affects indexing</span>
    <span class="SKwd">const</span> c = <span class="SStr">"是X是"</span>
    <span class="SCmp">#assert</span>(c[<span class="SNum">1</span>] != <span class="SStr">'X'</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">String Concatenation </h4>
<p>Swag allows compile-time concatenation of strings and other values using the <span class="code-inline">++</span> operator. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"the devil's number is "</span> ++ <span class="SNum">666</span>
    <span class="SCmp">#assert</span>(a == <span class="SStr">"the devil's number is 666"</span>)

    <span class="SKwd">const</span> b = <span class="SNum">666</span>
    <span class="SKwd">let</span> c   = <span class="SStr">"the devil's number is not "</span> ++ (b + <span class="SNum">1</span>) ++ <span class="SStr">"!"</span>
    <span class="SItr">@assert</span>(c == <span class="SStr">"the devil's number is not 667!"</span>)

    <span class="SKwd">let</span> d = <span class="SStr">"there are "</span> ++ <span class="SNum">4</span> ++ <span class="SStr">" apples in "</span> ++ (<span class="SNum">2</span> * <span class="SNum">2</span>) ++ <span class="SStr">" baskets"</span>
    <span class="SItr">@assert</span>(d == <span class="SStr">"there are 4 apples in 4 baskets"</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Null Strings </h4>
<p>A string can be <span class="code-inline">null</span> if it has not been initialized. This allows checking whether a string has been assigned a value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">string</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">null</span>)
    a = <span class="SStr">"not null"</span>
    <span class="SItr">@assert</span>(a != <span class="SKwd">null</span>)
    a = <span class="SKwd">null</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">null</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Character Literals </h4>
<p>Character literals are enclosed in quotes and can represent any Unicode character, not just ASCII. </p>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> A character literal's quote must follow a symbol or space to avoid confusion  with a type suffix. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> char0 = <span class="SStr">'a'</span>
    <span class="SKwd">let</span> char1 = '我'
    <span class="SKwd">let</span> value = <span class="SNum">5</span>'<span class="STpe">s32</span>     <span class="SCmt">// Type suffix example</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Default Type of Character Literals </h4>
<p>A character literal is a 32-bit integer by default. It can be assigned to any integer type or a <span class="code-inline">rune</span> if the value fits within the target type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> a: <span class="STpe">u8</span> = <span class="SStr">'a'</span>
        <span class="SKwd">let</span> b: <span class="STpe">u16</span> = <span class="SStr">'a'</span>
        <span class="SKwd">let</span> c: <span class="STpe">u32</span> = '我'
        <span class="SKwd">let</span> d: <span class="STpe">u64</span> = '我'
        <span class="SKwd">let</span> e: <span class="STpe">rune</span> = '我'
    }

    {
        <span class="SKwd">let</span> a: <span class="STpe">s8</span> = <span class="SStr">'a'</span>
        <span class="SKwd">let</span> b: <span class="STpe">s16</span> = <span class="SStr">'a'</span>
        <span class="SKwd">let</span> c: <span class="STpe">s32</span> = '我'
        <span class="SKwd">let</span> d: <span class="STpe">s64</span> = '我'
    }
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Specifying Character Literal Types </h4>
<p>You can specify a character literal’s type using a suffix to control its storage size. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SStr">'0'</span>'<span class="STpe">u8</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">48</span>)
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">u8</span>)

    <span class="SKwd">let</span> b = <span class="SStr">'1'</span>'<span class="STpe">u16</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">49</span>)
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(b) == <span class="STpe">u16</span>)

    <span class="SKwd">let</span> c = <span class="SStr">'2'</span>'<span class="STpe">u32</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">50</span>)
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(c) == <span class="STpe">u32</span>)

    <span class="SKwd">let</span> d = <span class="SStr">'3'</span>'<span class="STpe">u64</span>
    <span class="SItr">@assert</span>(d == <span class="SNum">51</span>)
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(d) == <span class="STpe">u64</span>)

    <span class="SKwd">let</span> e = <span class="SStr">'4'</span>'<span class="STpe">rune</span>
    <span class="SItr">@assert</span>(e == <span class="SNum">52</span>)
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(e) == <span class="STpe">rune</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Escape Sequences </h4>
<p>Swag supports escape sequences in strings and character literals to represent special characters. </p>
<p>An escape sequence starts with a backslash (<span class="code-inline">') followed by a specific character.</code> </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is ASCII code 0x00:   \0"</span>
    <span class="SKwd">const</span> b = <span class="SStr">"this is ASCII code 0x07:   \a"</span>
    <span class="SKwd">const</span> c = <span class="SStr">"this is ASCII code 0x08:   \b"</span>
    <span class="SKwd">const</span> d = <span class="SStr">"this is ASCII code 0x09:   \t"</span>
    <span class="SKwd">const</span> e = <span class="SStr">"this is ASCII code 0x0A:   \n"</span>
    <span class="SKwd">const</span> f = <span class="SStr">"this is ASCII code 0x0B:   \v"</span>
    <span class="SKwd">const</span> g = <span class="SStr">"this is ASCII code 0x0C:   \f"</span>
    <span class="SKwd">const</span> h = <span class="SStr">"this is ASCII code 0x0D:   \r"</span>
    <span class="SKwd">const</span> i = <span class="SStr">"this is ASCII code 0x22:   \""</span>
    <span class="SKwd">const</span> j = <span class="SStr">"this is ASCII code 0x27:   \'"</span>
    <span class="SKwd">const</span> k = <span class="SStr">"this is ASCII code 0x5C:   \\"</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">ASCII and Unicode Escape Sequences </h4>
<p>Escape sequences can represent characters via their ASCII or Unicode values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">const</span> a = <span class="SStr">"\x26"</span>
        <span class="SKwd">const</span> b = <span class="SStr">"\u2626"</span>
        <span class="SKwd">const</span> c = <span class="SStr">"\U00101234"</span>
    }

    {
        <span class="SKwd">const</span> d = <span class="SStr">"\u2F46\u2F46"</span>
        <span class="SCmp">#assert</span>(d == <span class="SStr">"⽆⽆"</span>)

        <span class="SKwd">const</span> e = '\<span class="SFct">u2F46</span>'
        <span class="SCmp">#assert</span>(e == '⽆')
    }
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Raw Strings </h4>
<p>A raw string is one where escape sequences and special characters are not processed. This is useful when working with many backslashes or special symbols. </p>
<p>A raw string is enclosed within <span class="code-inline">#</span> characters. Its content is taken literally. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">#"\u2F46"#</span> <span class="SCmt">// Raw string containing a Unicode escape</span>
    <span class="SCmp">#assert</span>(a != <span class="SStr">"⽆"</span>)
    <span class="SCmp">#assert</span>(a == <span class="SStr">#"\u2F46"#</span>)
}</span></div>
<p>Equivalent strings can be written using escape sequences or raw notation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"\\hello \\world"</span>
    <span class="SKwd">const</span> b = <span class="SStr">#"\hello \world"#</span>
    <span class="SCmp">#assert</span>(a == b)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Multiline Raw Strings </h4>
<p>Raw strings can span multiple lines. All leading spaces before the closing <span class="code-inline">"#</span> are removed from each line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">#"this is
                a
                string
                "#</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg">Multiline Strings </h4>
<p>Multiline strings start and end with <span class="code-inline">"""</span>. Unlike raw strings, escape sequences are still processed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">""</span><span class="SStr">"this is
                 a
                 string
                 "</span><span class="SStr">""</span>
}</span></div>
<p>In multiline or raw strings, ending a line with <span class="code-inline">' prevents the following</code> end-of-line from being included. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">""</span><span class="SStr">"\
              this is
              a
              string
              "</span><span class="SStr">""</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_003_string_swg"><span class="code-inline">#stringof</span> and <span class="code-inline">#nameof</span> Intrinsics </h4>
<p>The <span class="code-inline">#stringof</span> intrinsic returns the string representation of a constant expression at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">X</span> = <span class="SNum">1</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#stringof</span>(<span class="SCst">X</span>) == <span class="SStr">"1"</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#stringof</span>(<span class="SCst">X</span> + <span class="SNum">10</span>) == <span class="SStr">"11"</span>)
}</span></div>
<p>The <span class="code-inline">#nameof</span> intrinsic returns the name of a variable, function, etc., as a string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">X</span> = <span class="SNum">1</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#nameof</span>(<span class="SCst">X</span>) == <span class="SStr">"X"</span>)
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_004_constants_swg">Constants </h3><h4 id="_003_000_fundamentals_swg__003_004_constants_swg">Constants with <span class="code-inline">const</span> </h4>
<p>Using <span class="code-inline">const</span> means the value must be <b>known by the compiler</b> at compile time. The compiler embeds the constant’s value directly into the compiled code, removing any runtime memory usage for simple types like integers or strings. </p>
<p>In other words, the compiler replaces every occurrence of a constant with its literal value, leading to optimized and efficient code execution. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Immutable compile-time constants</span>
    <span class="SKwd">const</span> a = <span class="SNum">666</span>
    <span class="SCmp">#assert</span>(a == <span class="SNum">666</span>)

    <span class="SKwd">const</span> b: <span class="STpe">string</span> = <span class="SStr">"string"</span>
    <span class="SCmp">#assert</span>(b == <span class="SStr">"string"</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_004_constants_swg">Constants with Complex Types </h4>
<p>Swag also supports constants with complex data types, such as arrays and structures. When declared, the data is stored in the program's data segment, which occupies memory. The memory address of such constants can be accessed at runtime, allowing indirect manipulation through pointers. </p>
<h5 id="_003_000_fundamentals_swg__003_004_constants_swg">Static Arrays </h5>
<p>A static array has a fixed size. In this example, the constant array <span class="code-inline">a</span> contains three elements of type <span class="code-inline">s32</span> (signed 32-bit integers). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: [<span class="SNum">3</span>] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]

    <span class="SKwd">let</span> ptr = &a[<span class="SNum">0</span>]
    <span class="SItr">@assert</span>(ptr[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(ptr[<span class="SNum">2</span>] == <span class="SNum">2</span>)

    <span class="SCmt">// Compile-time verification of array contents</span>
    <span class="SCmp">#assert</span>(a[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SCmp">#assert</span>(a[<span class="SNum">1</span>] == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(a[<span class="SNum">2</span>] == <span class="SNum">2</span>)
}</span></div>
<h5 id="_003_000_fundamentals_swg__003_004_constants_swg">Multidimensional Arrays </h5>
<p>This example demonstrates a constant 4×4 matrix of 32-bit floating-point values (<span class="code-inline">f32</span>). Arrays will be explored in more detail later in this documentation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">M4x4</span>: [<span class="SNum">4</span>, <span class="SNum">4</span>] <span class="STpe">f32</span> = [
        [<span class="SNum">1</span>, <span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">0</span>],
        [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">0</span>, <span class="SNum">0</span>],
        [<span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">0</span>],
        [<span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">1</span>]]
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_004_constants_swg">Key Difference Between <span class="code-inline">let</span> and <span class="code-inline">const</span> </h4>
<p>The key distinction between <span class="code-inline">let</span> and <span class="code-inline">const</span> lies in <b>when</b> their values are determined: </p>
<ul>
<li>A <span class="code-inline">const</span> value is fixed and known <b>at compile time</b>.</li>
<li>A <span class="code-inline">let</span> value can be assigned <b>at runtime</b>, allowing computation before assignment.</li>
</ul>
<p>Despite this difference, both <span class="code-inline">let</span> and <span class="code-inline">const</span> enforce immutability — once a value is assigned, it cannot be changed. </p>

<h3 id="_003_000_fundamentals_swg__003_005_variables_swg">Variables </h3><h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Variable Declaration </h4>
<p>Variables are declared using the <span class="code-inline">let</span> or <span class="code-inline">var</span> keyword, followed by a <span class="code-inline">:</span> and the variable’s type. </p>
<ul>
<li><b><span class="code-inline">let</span></b> — Declares an immutable variable. Once assigned, its value cannot change.</li>
<li><b><span class="code-inline">var</span></b> — Declares a mutable variable. Its value can be modified after initialization.</li>
</ul>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">u32</span> = <span class="SNum">1</span> <span class="SCmt">// Immutable variable</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)

    <span class="SKwd">let</span> b: <span class="STpe">string</span> = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(b == <span class="SStr">"string"</span>)

    <span class="SKwd">var</span> c: <span class="STpe">s32</span> = <span class="SNum">42</span> <span class="SCmt">// Mutable variable</span>
    c += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">43</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Multiple Variable Declarations </h4>
<p>Swag allows declaring multiple variables of the same type on a single line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a, b: <span class="STpe">u32</span> = <span class="SNum">123</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">123</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">123</span>)
}</span></div>
<p>Multiple variables of different types can also be declared on one line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">u32</span> = <span class="SNum">12</span>, b: <span class="STpe">f32</span> = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">12</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">1.5</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Default Initialization </h4>
<p>If a variable is declared without an explicit value, it is automatically initialized with a default value. Variables in Swag are <b>always initialized</b> and never left undefined. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">bool</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">false</span>)

    <span class="SKwd">var</span> b: <span class="STpe">string</span>
    <span class="SItr">@assert</span>(b == <span class="SKwd">null</span>)

    <span class="SKwd">var</span> c: <span class="STpe">f64</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">0</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Uninitialized Variables </h4>
<p>To skip default initialization, you can assign <span class="code-inline">undefined</span>. This prevents automatic initialization but leaves the variable in an undefined state, which should be used cautiously. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">bool</span> = <span class="SKwd">undefined</span>
    <span class="SKwd">var</span> b: <span class="STpe">string</span> = <span class="SKwd">undefined</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Type Inference </h4>
<p>Swag supports <b>type inference</b>, automatically determining a variable’s type based on its assigned value. This often eliminates the need for explicit type annotations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">f32</span>)

    <span class="SKwd">let</span> b = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(b == <span class="SStr">"string"</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(b) == <span class="STpe">string</span>)

    <span class="SKwd">let</span> c = <span class="SNum">1.5</span>'<span class="STpe">f64</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(c) == <span class="STpe">f64</span>)
}</span></div>
<p>Type inference also applies when declaring multiple variables simultaneously. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a, b = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(b == <span class="SKwd">true</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="SItr">#typeof</span>(<span class="SKwd">true</span>))
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(b) == <span class="SItr">#typeof</span>(a))

    <span class="SKwd">let</span> c = <span class="SNum">1.5</span>, d = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">1.5</span>)
    <span class="SItr">@assert</span>(d == <span class="SStr">"string"</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(c) == <span class="STpe">f32</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(d) == <span class="STpe">string</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_005_variables_swg">Special Variables </h4>
<p>Swag provides attributes that modify how variables are stored or accessed. </p>
<h5 id="_003_000_fundamentals_swg__003_005_variables_swg">Thread-Local Storage </h5>
<p>Global variables marked with <span class="code-inline">#[Swag.Tls]</span> are stored in thread-local storage. Each thread has its own copy of the variable. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Tls]</span>
<span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span> <span class="SCmt">// Thread-local global variable</span></span></div>
<h5 id="_003_000_fundamentals_swg__003_005_variables_swg">Global Variables </h5>
<p>A local variable can be marked with <span class="code-inline">#[Swag.Global]</span> to make it global within its function’s scope. It behaves similarly to <span class="code-inline">static</span> variables in C/C++, retaining its value between function calls. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>()-&gt;<span class="STpe">s32</span>
    {
        <span class="SAtr">#[Swag.Global]</span>
        <span class="SKwd">var</span> <span class="SCst">G1</span> = <span class="SNum">0</span>
        <span class="SCst">G1</span> += <span class="SNum">1</span>
        <span class="SLgc">return</span> <span class="SCst">G1</span>
    }

    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">3</span>)
}</span></div>
<h5 id="_003_000_fundamentals_swg__003_005_variables_swg">Compile-Time Variables </h5>
<p>Global variables marked with <span class="code-inline">#[Swag.Compiler]</span> exist only during compile time and are excluded from the final runtime code. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Compiler]</span>
<span class="SKwd">var</span> <span class="SCst">G2</span> = <span class="SNum">0</span>

<span class="SFct">#run</span>
{
    <span class="SCst">G2</span> += <span class="SNum">5</span> <span class="SCmt">// Executes at compile time</span>
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_006_operators_swg">Operators </h3><h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Arithmetic Operators </h4>
<p>Arithmetic operators perform basic mathematical operations such as addition, subtraction, multiplication, division, and modulus (remainder). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    <span class="SCmt">// Addition</span>
    x = x + <span class="SNum">1</span>

    <span class="SCmt">// Subtraction</span>
    x = x - <span class="SNum">1</span>

    <span class="SCmt">// Multiplication</span>
    x = x * <span class="SNum">2</span>

    <span class="SCmt">// Division</span>
    x = x / <span class="SNum">2</span>

    <span class="SCmt">// Modulus</span>
    x = x % <span class="SNum">2</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Bitwise Operators </h4>
<p>Bitwise operators manipulate individual bits of integral types. They include bitwise AND, OR, XOR, and bit shifting. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    x = x ^ <span class="SNum">2</span> <span class="SCmt">// XOR</span>
    x = x & <span class="SNum">0b0000_0001</span>'<span class="STpe">s32</span> <span class="SCmt">// AND</span>
    x = x | <span class="SKwd">cast</span>(<span class="STpe">s32</span>) <span class="SNum">0b0001</span> <span class="SCmt">// OR</span>
    x = x &lt;&lt; <span class="SNum">1</span> <span class="SCmt">// Shift left</span>
    x = x &gt;&gt; <span class="SNum">1</span> <span class="SCmt">// Shift right</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Assignment Operators </h4>
<p>Assignment operators perform an operation and immediately assign the result to the left operand, creating concise expressions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    x += <span class="SNum">1</span>
    x -= <span class="SNum">1</span>
    x *= <span class="SNum">2</span>
    x /= <span class="SNum">2</span>
    x %= <span class="SNum">2</span>
    x ^= <span class="SNum">2</span>
    x |= <span class="SNum">0b0001</span>
    x &= <span class="SNum">0b0001</span>
    x &lt;&lt;= <span class="SNum">1</span>
    x &gt;&gt;= <span class="SNum">1</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Unary Operators </h4>
<p>Unary operators operate on a single operand. These include logical NOT, bitwise NOT, and negation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SKwd">true</span>
    <span class="SKwd">var</span> y = <span class="SNum">0b0000_0001</span>'<span class="STpe">u8</span>
    <span class="SKwd">var</span> z = <span class="SNum">1</span>

    x = !x <span class="SCmt">// Logical NOT</span>
    y = ~y <span class="SCmt">// Bitwise NOT</span>
    z = -z <span class="SCmt">// Negation</span>

    <span class="SItr">@assert</span>(z == -<span class="SNum">1</span>)
    <span class="SItr">@assert</span>(x == <span class="SKwd">false</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">0b1111_1110</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Comparison Operators </h4>
<p>Comparison operators compare two values and return a boolean result. They include equality, inequality, and relational comparisons. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">var</span> a = <span class="SKwd">false</span>
        a = <span class="SNum">1</span> == <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>
        a = <span class="SNum">1</span> != <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>
        a = <span class="SNum">1</span> &lt;= <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>
        a = <span class="SNum">1</span> &gt;= <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>
        a = <span class="SNum">1</span> &lt; <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>
        a = <span class="SNum">1</span> &gt; <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>
    }

    {
        <span class="SKwd">let</span> x = <span class="SNum">5</span>
        <span class="SKwd">let</span> y = <span class="SNum">10</span>
        <span class="SItr">@assert</span>(x == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x != <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(x &lt;= <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x &lt; <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(x &gt;= <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x &gt; <span class="SNum">0</span>)
    }
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Logical Operators </h4>
<p>Logical operators evaluate expressions and return a boolean result. Swag uses <span class="code-inline">and</span> and <span class="code-inline">or</span> instead of <span class="code-inline">&&</span> and <span class="code-inline">||</span> from C/C++. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SKwd">false</span>
    a = (<span class="SNum">1</span> &gt; <span class="SNum">10</span>) <span class="SLgc">and</span> (<span class="SNum">10</span> &lt; <span class="SNum">1</span>)
    a = (<span class="SNum">1</span> &gt; <span class="SNum">10</span>) <span class="SLgc">or</span> (<span class="SNum">10</span> &lt; <span class="SNum">1</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Ternary Operator </h4>
<p>The ternary operator tests an expression and returns one of two values depending on whether the condition is true or false. </p>
<p>Syntax: <span class="code-inline">A = Condition ? B : C</span> </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SKwd">true</span> ? <span class="SNum">1</span> : <span class="SNum">666</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>)

    <span class="SKwd">let</span> y = (x == <span class="SNum">52</span>) ? <span class="SNum">1</span> : <span class="SNum">666</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">666</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Spaceship Operator </h4>
<p>The <span class="code-inline">&lt;=&gt;</span> operator returns -1, 0, or 1 depending on whether the left operand is less than, equal to, or greater than the right operand. The result type is <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> == -<span class="SNum">1</span> <span class="SLgc">if</span> <span class="SCst">A</span> &lt; <span class="SCst">B</span>
<span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> ==  <span class="SNum">0</span> <span class="SLgc">if</span> <span class="SCst">A</span> == <span class="SCst">B</span>
<span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> ==  <span class="SNum">1</span> <span class="SLgc">if</span> <span class="SCst">A</span> &gt; <span class="SCst">B</span></span></div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> a = -<span class="SNum">1.5</span> &lt;=&gt; <span class="SNum">2.31</span>
        <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">s32</span>)
        <span class="SItr">@assert</span>(a == -<span class="SNum">1</span>)

        <span class="SItr">@assert</span>(-<span class="SNum">10</span> &lt;=&gt; <span class="SNum">10</span> == -<span class="SNum">1</span>)
        <span class="SItr">@assert</span>(<span class="SNum">10</span> &lt;=&gt; -<span class="SNum">10</span> == <span class="SNum">1</span>)
        <span class="SItr">@assert</span>(<span class="SNum">10</span> &lt;=&gt; <span class="SNum">10</span> == <span class="SNum">0</span>)
    }

    {
        <span class="SKwd">let</span> x1 = <span class="SNum">10</span> &lt;=&gt; <span class="SNum">20</span>
        <span class="SItr">@assert</span>(x1 == -<span class="SNum">1</span>)

        <span class="SKwd">let</span> x2 = <span class="SNum">20</span> &lt;=&gt; <span class="SNum">10</span>
        <span class="SItr">@assert</span>(x2 == <span class="SNum">1</span>)

        <span class="SKwd">let</span> x3 = <span class="SNum">20</span> &lt;=&gt; <span class="SNum">20</span>
        <span class="SItr">@assert</span>(x3 == <span class="SNum">0</span>)
    }
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Null-Coalescing Operator </h4>
<p>The <span class="code-inline">orelse</span> operator returns the left-hand expression if it is not null; otherwise, it returns the right-hand expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SStr">"string1"</span>
    <span class="SKwd">let</span> b = <span class="SStr">"string2"</span>

    <span class="SKwd">var</span> c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == <span class="SStr">"string1"</span>)

    a = <span class="SKwd">null</span>
    c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == <span class="SStr">"string2"</span>)
}</span></div>
<p>The <span class="code-inline">orelse</span> operator also works with numeric and basic types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">0</span>
    <span class="SKwd">let</span> b = <span class="SNum">1</span>
    <span class="SKwd">let</span> c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == b)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Type Promotion </h4>
<p>Unlike C, Swag does not automatically promote small integer types (8-bit or 16-bit) to 32 bits. However, when operands differ in type, promotion occurs to match the larger or signed type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u8</span>) == <span class="STpe">u8</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u16</span>) == <span class="STpe">u16</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u32</span>) == <span class="STpe">u32</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u64</span>) == <span class="STpe">u64</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s8</span>) == <span class="STpe">s8</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s16</span>) == <span class="STpe">s16</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s32</span>) == <span class="STpe">s32</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s64</span>) == <span class="STpe">s64</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">f32</span>) == <span class="STpe">f32</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">f64</span>) == <span class="STpe">f64</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">0</span>'<span class="STpe">s8</span> + <span class="SNum">1</span>'<span class="STpe">u16</span>) == <span class="STpe">u16</span>)
}</span></div>
<p>To prevent overflow during small integer operations, you can apply the <span class="code-inline">#prom</span> modifier to promote operands to at least 32 bits before the operation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SNum">255</span>'<span class="STpe">u8</span> + <span class="SItr">#prom</span> <span class="SNum">1</span>'<span class="STpe">u8</span>) == <span class="STpe">u32</span>)
    <span class="SCmp">#assert</span>(<span class="SNum">255</span>'<span class="STpe">u8</span> + <span class="SItr">#prom</span> <span class="SNum">1</span>'<span class="STpe">u8</span> == <span class="SNum">256</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_006_operators_swg">Operator Precedence </h4>
<div class="code-block"><span class="SCde">~
* / %
+ -
&gt;&gt; &lt;&lt;
&
|
^
&lt;=&gt;
== !=
&lt; &lt;= &gt; &gt;=
<span class="SLgc">and</span>
<span class="SLgc">or</span></span></div>
<p>When two operators share the same precedence level, expressions are evaluated from left to right. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SNum">10</span> + <span class="SNum">2</span> * <span class="SNum">3</span> == <span class="SNum">16</span>)
    <span class="SItr">@assert</span>((<span class="SNum">10</span> + <span class="SNum">2</span>) * <span class="SNum">3</span> == <span class="SNum">36</span>)
    <span class="SItr">@assert</span>((<span class="SNum">5</span> + <span class="SNum">3</span> &lt; <span class="SNum">10</span> - <span class="SNum">2</span>) == <span class="SKwd">false</span>)
    <span class="SItr">@assert</span>((<span class="SKwd">false</span> <span class="SLgc">and</span> <span class="SKwd">false</span> <span class="SLgc">or</span> <span class="SKwd">true</span>) == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>((<span class="SNum">10</span> & <span class="SNum">2</span> &lt;&lt; <span class="SNum">1</span>) == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(((<span class="SNum">10</span> & <span class="SNum">2</span>) &lt;&lt; <span class="SNum">1</span>) == <span class="SNum">4</span>)
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_007_cast_swg">Cast </h3><h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Explicit Cast with <span class="code-inline">cast</span> </h4>
<p>Explicit casting converts a value from one type to another using the syntax 'cast(type) value'. This transformation changes the type of <span class="code-inline">value</span> to the specified <span class="code-inline">type</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">1.0</span> <span class="SCmt">// Defaults to 'f32'</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(x) == <span class="STpe">f32</span>)

    <span class="SKwd">let</span> y = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) x <span class="SCmt">// Explicit cast to 's32'</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(y) == <span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Automatic Cast with <span class="code-inline">cast()</span> </h4>
<p>A <span class="code-inline">cast()</span> without a type performs an <b>automatic cast</b>, allowing the compiler to infer the target type based on the left-hand side of the assignment. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">f32</span> = <span class="SNum">1.0</span>
    <span class="SKwd">let</span> y: <span class="STpe">s32</span> = <span class="SKwd">cast</span>() x
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(y) == <span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)
}</span></div>
<p>Automatic casts can also be applied when passing function arguments. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">testAutoCast</span>(x: <span class="STpe">s32</span>)
{
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>)
}

<span class="SFct">#test</span>
{
    <span class="SFct">testAutoCast</span>(<span class="SKwd">cast</span>() <span class="SNum">1.4</span>) <span class="SCmt">// Automatically cast to 's32'</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Bit Cast </h4>
<p>The <span class="code-inline">#bit</span> cast mode performs a <b>bit-level reinterpretation</b> of a value’s type without altering its underlying bit pattern. Source and destination types must have the same size. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">f32</span> = <span class="SNum">1.0</span>
    <span class="SKwd">let</span> y: <span class="STpe">u32</span> = <span class="SKwd">cast</span> <span class="SItr">#bit</span> (<span class="STpe">u32</span>) x
    <span class="SItr">@assert</span>(y == <span class="SNum">0x3f800000</span>) <span class="SCmt">// 1.0 in IEEE 754 format</span>

    <span class="SCmp">#assert</span>(<span class="SKwd">cast</span> <span class="SItr">#bit</span> (<span class="STpe">u32</span>) <span class="SNum">1.0</span> == <span class="SNum">0x3f800000</span>)
    <span class="SCmp">#assert</span>(<span class="SKwd">cast</span> <span class="SItr">#bit</span> (<span class="STpe">f32</span>) <span class="SNum">0x3f800000</span> == <span class="SNum">1.0</span>)
}</span></div>
<p>Bitcasting also allows reinterpreting an integer’s bit pattern as a floating-point value, or vice versa. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> rawBits: <span class="STpe">u32</span> = <span class="SNum">0x40490FDB</span>
    <span class="SKwd">let</span> pi:      <span class="STpe">f32</span> = <span class="SKwd">cast</span> <span class="SItr">#bit</span> (<span class="STpe">f32</span>) rawBits
    <span class="SItr">@assert</span>(pi == <span class="SNum">3.1415927</span>)

    <span class="SKwd">let</span> backToBits: <span class="STpe">u32</span> = <span class="SKwd">cast</span> <span class="SItr">#bit</span> (<span class="STpe">u32</span>) pi
    <span class="SItr">@assert</span>(backToBits == <span class="SNum">0x40490FDB</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Implicit Casts </h4>
<p>Swag supports <b>implicit casts</b>, automatically converting between compatible types when no data loss or precision loss can occur. These conversions happen without requiring an explicit <span class="code-inline">cast</span> statement. </p>
<h5 id="_003_000_fundamentals_swg__003_007_cast_swg">Implicit Cast Rules </h5>
<ol>
<li><b>Widening conversions</b> — Allowed when converting from smaller to larger</li>
</ol>
<p>   types, such as <span class="code-inline">s8</span> → <span class="code-inline">s16</span> or <span class="code-inline">f32</span> → <span class="code-inline">f64</span>. 2. <b>Sign preservation</b> — Implicit signed/unsigned conversions occur only if    the value fits in the destination type. 3. <b>No narrowing conversions</b> — Conversions that could lose precision or range    require an explicit cast. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">s16</span> = <span class="SNum">1</span>'<span class="STpe">s8</span>
    <span class="SKwd">let</span> y: <span class="STpe">s32</span> = <span class="SNum">1</span>'<span class="STpe">s16</span>
    <span class="SKwd">let</span> z: <span class="STpe">s64</span> = <span class="SNum">1</span>'<span class="STpe">s32</span>

    <span class="SKwd">let</span> a: <span class="STpe">u16</span> = <span class="SNum">255</span>'<span class="STpe">u8</span>
    <span class="SKwd">let</span> b: <span class="STpe">u32</span> = <span class="SNum">65535</span>'<span class="STpe">u16</span>
    <span class="SKwd">let</span> c: <span class="STpe">u64</span> = <span class="SNum">4294967295</span>'<span class="STpe">u32</span>

    <span class="SKwd">let</span> d: <span class="STpe">f64</span> = <span class="SNum">1.23</span>'<span class="STpe">f32</span>
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_007_cast_swg">Disallowed Implicit Casts </h4>
<p>Swag forbids implicit casts that may lose data or precision. In such cases, an explicit cast is required. The <span class="code-inline">#wrap</span> or <span class="code-inline">#unsafe</span> cast modes can be used to acknowledge potential data loss. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Explicit cast from 's16' to 's8' required</span>
    <span class="SKwd">let</span> z0: <span class="STpe">s16</span> = <span class="SNum">256</span>
    <span class="SKwd">let</span> z1: <span class="STpe">s8</span> = <span class="SKwd">cast</span> <span class="SItr">#wrap</span> (<span class="STpe">s8</span>) z0
    <span class="SItr">@assert</span>(z1 == <span class="SNum">0</span>)

    <span class="SCmt">// Explicit cast from 'u16' to 's16' required</span>
    <span class="SKwd">let</span> u_val: <span class="STpe">u16</span> = <span class="SNum">65535</span>
    <span class="SKwd">let</span> s_val: <span class="STpe">s16</span> = <span class="SKwd">cast</span> <span class="SItr">#wrap</span> (<span class="STpe">s16</span>) u_val
    <span class="SItr">@assert</span>(s_val == -<span class="SNum">1</span>)

    <span class="SCmt">// Explicit cast from 'f64' to 'f32' required</span>
    <span class="SKwd">let</span> large_float:   <span class="STpe">f64</span> = <span class="SNum">1.23456789012345611111</span>
    <span class="SKwd">let</span> smaller_float: <span class="STpe">f32</span> = <span class="SKwd">cast</span>(<span class="STpe">f32</span>) large_float
}</span></div>

<h3 id="_003_000_fundamentals_swg__003_008_alias_swg">Alias </h3><h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Type Alias </h4>
<p>An <span class="code-inline">alias</span> creates a shorthand or alternative name for an existing type. This can improve readability, reduce repetition, and simplify the use of complex types. A type alias does not create a new type — it simply provides a new name for an existing one. </p>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Basic Type Alias </h4>
<p>Using <span class="code-inline">alias</span>, you can define a shorthand for any existing type. The alias can be used interchangeably with the original type throughout your code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span> == <span class="SNum">0</span>)

    <span class="SKwd">alias</span> <span class="SCst">Color</span> = <span class="SCst">RGB</span>
    <span class="SItr">@assert</span>(<span class="SCst">Color</span>.<span class="SCst">G</span> == <span class="SNum">1</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Aliasing Primitive Types </h4>
<p>Aliases can be created for primitive types to make your code more expressive or domain-specific, improving clarity when a type has a specific contextual meaning. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">alias</span> <span class="SCst">Float32</span> = <span class="STpe">f32</span>
    <span class="SKwd">alias</span> <span class="SCst">Float64</span> = <span class="STpe">f64</span>

    <span class="SKwd">var</span> x: <span class="SCst">Float32</span> = <span class="SNum">1.0</span>
    <span class="SKwd">var</span> y: <span class="SCst">Float64</span> = <span class="SNum">1.0</span>

    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SCst">Float32</span>) == <span class="STpe">f32</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SCst">Float64</span>) == <span class="STpe">f64</span>)
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Strict Type Alias </h4>
<p>When you need stronger type safety, you can use the <span class="code-inline">#[Swag.Strict]</span> attribute. This makes the alias a <b>distinct type</b>, disallowing implicit conversions between the alias and its base type. Explicit casting is still permitted. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Strict]</span>
    <span class="SKwd">alias</span> <span class="SCst">MyType</span> = <span class="STpe">s32</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SCst">MyType</span>) != <span class="STpe">s32</span>)

    <span class="SKwd">let</span> x: <span class="SCst">MyType</span> = <span class="SKwd">cast</span>(<span class="SCst">MyType</span>) <span class="SNum">0</span>
    <span class="SKwd">let</span> y: <span class="STpe">s32</span> = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) x
}</span></div>
<h4 id="_003_000_fundamentals_swg__003_008_alias_swg">Name Alias </h4>
<p>The <span class="code-inline">alias</span> keyword can also create shortcuts for functions, variables, or namespaces. This helps simplify long names and improve code readability. </p>
<h5 id="_003_000_fundamentals_swg__003_008_alias_swg">Function Name Alias </h5>
<p>A function can be aliased to a shorter or more convenient name, which is especially useful for lengthy or descriptive function names. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">thisIsABigFunctionName</span>(x: <span class="STpe">s32</span>) =&gt; x * x

    <span class="SKwd">alias</span> myFunc = thisIsABigFunctionName
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">4</span>) == <span class="SNum">16</span>)
}</span></div>
<h5 id="_003_000_fundamentals_swg__003_008_alias_swg">Variable and Namespace Alias </h5>
<p>You can alias variables or namespaces to shorter names for easier access, especially in large codebases with long identifiers. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myLongVariableName: <span class="STpe">s32</span> = <span class="SNum">0</span>
    <span class="SKwd">alias</span> short = myLongVariableName

    short += <span class="SNum">2</span>
    <span class="SItr">@assert</span>(myLongVariableName == <span class="SNum">2</span>)
}</span></div>

<h2 id="_004_000_data_structures_swg">Data Structures </h2>
<h3 id="_004_000_data_structures_swg__004_001_array_swg">Array </h3><h4 id="_004_000_data_structures_swg__004_001_array_swg">Static Arrays in Swag </h4>
<p>Static arrays are fixed-size arrays where the size is known at compile time. Unlike dynamic arrays from the <span class="code-inline">Std.Core</span> module, they cannot grow or shrink during execution. Static arrays are ideal when size and memory usage are deterministic. </p>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Declaring a Static Array </h4>
<p>A static array is declared using the syntax '[N] type', where <span class="code-inline">N</span> is the number of elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>
    array[<span class="SNum">0</span>] = <span class="SNum">1</span>
    array[<span class="SNum">1</span>] = <span class="SNum">2</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Array Size and Memory </h4>
<p>The <span class="code-inline">@countof</span> intrinsic returns the number of elements in an array, while <span class="code-inline">#sizeof</span> returns the total memory size in bytes. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>

    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(array).count == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(array) == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(array) == <span class="SNum">2</span> * <span class="SItr">#sizeof</span>(<span class="STpe">s32</span>))
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Obtaining the Address of an Array </h4>
<p>The <span class="code-inline">@dataof</span> intrinsic retrieves the address of the first element in an array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>
    <span class="SKwd">var</span> ptr0   = <span class="SItr">@dataof</span>(array)
    ptr0[<span class="SNum">0</span>] = <span class="SNum">1</span>

    <span class="SKwd">var</span> ptr1 = &array[<span class="SNum">0</span>]
    ptr1[<span class="SNum">1</span>] = <span class="SNum">2</span>

    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Array Literals </h4>
<p>An array literal is a list of elements enclosed in brackets '[A, B, ...]'. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(arr) == <span class="SItr">#type</span> [<span class="SNum">4</span>] <span class="STpe">s32</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Type Deduction in Arrays </h4>
<p>Swag can deduce array size and element type from the initialization expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [?] <span class="STpe">s32</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(array) == <span class="SNum">2</span>)

    <span class="SKwd">var</span> array1 = [<span class="SStr">"10"</span>, <span class="SStr">"20"</span>, <span class="SStr">"30"</span>]
    <span class="SItr">@assert</span>(array1[<span class="SNum">0</span>] == <span class="SStr">"10"</span>)
    <span class="SItr">@assert</span>(array1[<span class="SNum">1</span>] == <span class="SStr">"20"</span>)
    <span class="SItr">@assert</span>(array1[<span class="SNum">2</span>] == <span class="SStr">"30"</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(array1) == <span class="SNum">3</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Default Initialization </h4>
<p>Static arrays are automatically initialized with zero values (0 for numbers, <span class="code-inline">null</span> for strings, <span class="code-inline">false</span> for booleans, etc.) unless specified otherwise. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">0</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Preventing Default Initialization </h4>
<p>You can skip default initialization by using <span class="code-inline">undefined</span>, which improves performance when the array will be manually initialized later. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">100</span>] <span class="STpe">s32</span> = <span class="SKwd">undefined</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Constant Arrays </h4>
<p>Arrays initialized with compile-time values can be declared as <span class="code-inline">const</span>, making them immutable after declaration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> array = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SCmp">#assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(array[<span class="SNum">3</span>] == <span class="SNum">4</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Type Inference from Array Literals </h4>
<p>If no explicit type is specified, Swag infers the array’s type from the first element. All other elements are promoted to match that type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>'<span class="STpe">f64</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(arr) == <span class="SItr">#type</span> [<span class="SNum">4</span>] <span class="STpe">f64</span>)
    <span class="SItr">@assert</span>(arr[<span class="SNum">3</span>] == <span class="SNum">4.0</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Multi-Dimensional Arrays </h4>
<p>Swag supports multi-dimensional arrays using the syntax '[X, Y, Z...]', where each number represents a dimension. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span>
    array[<span class="SNum">0</span>, <span class="SNum">0</span>] = <span class="SNum">1</span>
    array[<span class="SNum">0</span>, <span class="SNum">1</span>] = <span class="SNum">2</span>
    array[<span class="SNum">1</span>, <span class="SNum">0</span>] = <span class="SNum">3</span>
    array[<span class="SNum">1</span>, <span class="SNum">1</span>] = <span class="SNum">4</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">C/C++ Style Multi-Dimensional Arrays </h4>
<p>You can also declare multi-dimensional arrays using nested array syntax, similar to C/C++. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] [<span class="SNum">2</span>] <span class="STpe">s32</span>
    array[<span class="SNum">0</span>, <span class="SNum">0</span>] = <span class="SNum">1</span>
    array[<span class="SNum">0</span>, <span class="SNum">1</span>] = <span class="SNum">2</span>
    array[<span class="SNum">1</span>, <span class="SNum">0</span>] = <span class="SNum">3</span>
    array[<span class="SNum">1</span>, <span class="SNum">1</span>] = <span class="SNum">4</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Array Size Deduction </h4>
<p>Swag can infer the dimensions of arrays — including multi-dimensional ones — directly from the initialization expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array  = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SKwd">var</span> array1 = [[<span class="SNum">1</span>, <span class="SNum">2</span>], [<span class="SNum">3</span>, <span class="SNum">4</span>]]

    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(array) == <span class="SNum">4</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(array1) == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_001_array_swg">Single Value Initialization </h4>
<p>An entire array can be initialized with a single value. This feature applies to variables (not constants) and works for basic types such as integers, floats, strings, booleans, and runes. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">bool</span> = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(arr[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(arr[<span class="SNum">1</span>, <span class="SNum">1</span>] == <span class="SKwd">true</span>)

    <span class="SKwd">var</span> arr1: [<span class="SNum">5</span>, <span class="SNum">10</span>] <span class="STpe">string</span> = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(arr1[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SStr">"string"</span>)
    <span class="SItr">@assert</span>(arr1[<span class="SNum">4</span>, <span class="SNum">9</span>] == <span class="SStr">"string"</span>)
}</span></div>

<h3 id="_004_000_data_structures_swg__004_002_slice_swg">Slice </h3><h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slices in Swag </h4>
<p>A slice provides a dynamic view over a contiguous block of memory. Unlike static arrays, slices can point to different memory regions or subsets of existing data at runtime. </p>
<p>A slice consists of a data pointer and a <span class="code-inline">u64</span> count representing the number of elements. This allows efficient access to large datasets without copying memory. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: [..] <span class="STpe">bool</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(a) == <span class="SItr">#sizeof</span>(*<span class="STpe">void</span>) + <span class="SItr">#sizeof</span>(<span class="STpe">u64</span>))
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Initializing Slices </h4>
<p>Slices can be initialized directly with array literals. The slice will reference the array’s elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="SKwd">const</span> [..] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>, <span class="SNum">50</span>]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">0</span>] == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">4</span>] == <span class="SNum">50</span>)

    a = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">1</span>] == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Accessing Slice Data </h4>
<p>The <span class="code-inline">@dataof</span> intrinsic retrieves the slice’s data address, and <span class="code-inline">@countof</span> returns the number of elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a:    <span class="SKwd">const</span> [..] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>, <span class="SNum">50</span>]
    <span class="SKwd">let</span> count = <span class="SItr">@countof</span>(a)
    <span class="SKwd">let</span> addr  = <span class="SItr">@dataof</span>(a)

    <span class="SItr">@assert</span>(count == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(addr[<span class="SNum">0</span>] == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(addr[<span class="SNum">4</span>] == <span class="SNum">50</span>)

    a = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Creating Slices with <span class="code-inline">@mkslice</span> </h4>
<p>The <span class="code-inline">@mkslice</span> intrinsic creates a slice from a pointer and an element count. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">4</span>] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]

    <span class="SKwd">let</span> slice: [..] <span class="STpe">u32</span> = <span class="SItr">@mkslice</span>(&array[<span class="SNum">0</span>] + <span class="SNum">2</span>, <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)

    slice[<span class="SNum">0</span>] = <span class="SNum">314</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">2</span>] == <span class="SNum">314</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing Strings </h4>
<p>Strings can be sliced, but the result must be declared as <span class="code-inline">const</span> since strings are immutable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str       = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> strSlice: <span class="SKwd">const</span> [..] <span class="STpe">u8</span> = <span class="SItr">@mkslice</span>(<span class="SItr">@dataof</span>(str), <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(strSlice[<span class="SNum">0</span>] == <span class="SStr">'s'</span>)
    <span class="SItr">@assert</span>(strSlice[<span class="SNum">1</span>] == <span class="SStr">'t'</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing with the <span class="code-inline">..</span> Operator </h4>
<p>The <span class="code-inline">..</span> operator can be used to create slices directly. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str   = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice == <span class="SStr">"tri"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Inclusive and Exclusive Slicing </h4>
<p>By default, the upper bound in a slice is inclusive. To exclude it, use <span class="code-inline">until</span> instead of <span class="code-inline">to</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str   = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">1</span> <span class="SLgc">until</span> <span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice == <span class="SStr">"tr"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing to the End </h4>
<p>Omitting the upper bound creates a slice extending to the end of the sequence. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str   = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">2</span> <span class="SLgc">to</span> ]
    <span class="SItr">@assert</span>(slice == <span class="SStr">"ring"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing from the Start </h4>
<p>Omitting the lower bound starts the slice from index 0. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>

    <span class="SKwd">let</span> slice = str[ <span class="SLgc">to</span> <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(slice == <span class="SStr">"str"</span>)

    <span class="SKwd">let</span> slice1 = str[ <span class="SLgc">until</span> <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(slice1 == <span class="SStr">"st"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing Arrays </h4>
<p>Arrays can be sliced the same way as strings. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> arr   = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> slice = arr[<span class="SNum">2</span> <span class="SLgc">to</span> <span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)

    <span class="SKwd">let</span> slice1 = arr[ <span class="SLgc">to</span> ]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice1) == <span class="SItr">@countof</span>(arr))
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Slicing a Slice </h4>
<p>A slice can be further sliced to produce another slice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> arr    = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> slice1 = arr[<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice1[<span class="SNum">0</span>] == <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(slice1[<span class="SNum">1</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice1[<span class="SNum">2</span>] == <span class="SNum">40</span>)

    <span class="SKwd">let</span> slice2 = slice1[<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(slice2[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice2[<span class="SNum">1</span>] == <span class="SNum">40</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_002_slice_swg">Transforming a Pointer into a Slice </h4>
<p>A pointer can be transformed into a slice by specifying a range. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr   = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> ptr   = &arr[<span class="SNum">2</span>]
    <span class="SKwd">let</span> slice = ptr[<span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">1</span>]
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)
}</span></div>

<h3 id="_004_000_data_structures_swg__004_003_tuple_swg">Tuple </h3><h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Tuples in Swag </h4>
<p>A tuple represents an anonymous structure (a <i>struct literal</i>) that can group multiple values of different types together without defining a named structure. Tuples are enclosed in curly braces <span class="code-inline">{}</span> and can mix any combination of data types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple1 = {<span class="SNum">2</span>, <span class="SNum">2</span>}
    <span class="SKwd">let</span> tuple2 = {<span class="SStr">"string"</span>, <span class="SNum">2</span>, <span class="SKwd">true</span>}
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Accessing Tuple Values </h4>
<p>Tuple fields are automatically named <span class="code-inline">itemX</span>, where <span class="code-inline">X</span> is the zero-based index of the field. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple = {<span class="SStr">"string"</span>, <span class="SNum">2</span>, <span class="SKwd">true</span>}
    <span class="SItr">@assert</span>(tuple.item0 == <span class="SStr">"string"</span>)
    <span class="SItr">@assert</span>(tuple.item1 == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(tuple.item2 == <span class="SKwd">true</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Named Fields in Tuples </h4>
<p>Tuple fields can have explicit names. Named fields improve readability but can still be accessed using their default <span class="code-inline">itemX</span> identifiers. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}
    <span class="SItr">@assert</span>(tuple.x == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(tuple.item0 == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(tuple.y == <span class="SNum">2.0</span>)
    <span class="SItr">@assert</span>(tuple.item1 == <span class="SNum">2.0</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Automatic Field Naming </h4>
<p>When creating a tuple from variables, Swag automatically uses the variable names as field names unless overridden. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">555</span>
    <span class="SKwd">let</span> y = <span class="SNum">666</span>
    <span class="SKwd">let</span> t = {x, y}
    <span class="SItr">@assert</span>(t.x == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(t.item0 == t.x)
    <span class="SItr">@assert</span>(t.y == <span class="SNum">666</span>)
    <span class="SItr">@assert</span>(t.item1 == t.y)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Tuple Assignment and Compatibility </h4>
<p>Tuples can be assigned to each other if their field types match, even if field names differ. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x:
    {
        a: <span class="STpe">s32</span>, b: <span class="STpe">s32</span>
    }
    <span class="SKwd">var</span> y:
    {
        c: <span class="STpe">s32</span>, d: <span class="STpe">s32</span>
    }

    y = {<span class="SNum">1</span>, <span class="SNum">2</span>}
    x = y

    <span class="SItr">@assert</span>(x.a == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(x.b == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(x) != <span class="SItr">#typeof</span>(y))
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Tuple Unpacking </h4>
<p>Tuples can be unpacked into separate variables, allowing easy extraction of values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple1 = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}
    <span class="SKwd">let</span> (value0, value1) = tuple1
    <span class="SItr">@assert</span>(value0 == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(value1 == <span class="SNum">2.0</span>)

    <span class="SKwd">let</span> tuple2 = {<span class="SStr">"name"</span>, <span class="SKwd">true</span>}
    <span class="SKwd">let</span> (name, value) = tuple2
    <span class="SItr">@assert</span>(name == <span class="SStr">"name"</span>)
    <span class="SItr">@assert</span>(value == <span class="SKwd">true</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_003_tuple_swg">Ignoring Fields During Unpacking </h4>
<p>Use <span class="code-inline">?</span> as a placeholder to ignore specific tuple fields when unpacking. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple1 = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}
    <span class="SKwd">let</span> (x, ?) = tuple1
    <span class="SItr">@assert</span>(x == <span class="SNum">1.0</span>)

    <span class="SKwd">let</span> (?, y) = tuple1
    <span class="SItr">@assert</span>(y == <span class="SNum">2.0</span>)
}</span></div>

<h3 id="_004_000_data_structures_swg__004_004_enum_swg">Enum </h3><h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enums in Swag </h4>
<p>Enums define a set of named constant values. Unlike C/C++, Swag allows enum values to end with <span class="code-inline">;</span>, <span class="code-inline">,</span>, or simply a new line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values0</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">enum</span> <span class="SCst">Values1</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">enum</span> <span class="SCst">Values2</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">enum</span> <span class="SCst">Values3</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enum Underlying Type </h4>
<p>By default, enums use the <span class="code-inline">s32</span> type for storage. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">let</span> type = <span class="SItr">#typeof</span>(<span class="SCst">Values</span>)

    <span class="SItr">@assert</span>(type.rawType == <span class="STpe">s32</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SCst">Values</span>) == <span class="SCst">Values</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Custom Enum Underlying Type </h4>
<p>A custom base type can be specified after the enum name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values1</span>: <span class="STpe">s64</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
        <span class="SCst">C</span>
    }

    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SCst">Values1</span>).rawType == <span class="STpe">s64</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(<span class="SCst">Values1</span>.<span class="SCst">A</span>) == <span class="SCst">Values1</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Default and Custom Enum Values </h4>
<p>Without explicit values, enums start at 0 and increment by 1. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">s64</span> { <span class="SCst">A</span>, <span class="SCst">B</span>, <span class="SCst">C</span> }
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">0</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">2</span>)
}</span></div>
<p>Custom values can be assigned manually. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">s64</span> { <span class="SCst">A</span> = <span class="SNum">10</span>, <span class="SCst">B</span> = <span class="SNum">20</span>, <span class="SCst">C</span> = <span class="SNum">30</span> }
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">10</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">20</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">30</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Incremental Enum Values </h4>
<p>After a custom value, following values auto-increment. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">u32</span>
    {
        <span class="SCst">A</span> = <span class="SNum">10</span>
        <span class="SCst">B</span>
        <span class="SCst">C</span>
    }

    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">10</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">11</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">12</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Non-Integer Enum Values </h4>
<p>Non-integer enums require explicit assignments. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value1</span>: <span class="STpe">string</span> { <span class="SCst">A</span> = <span class="SStr">"string 1"</span>, <span class="SCst">B</span> = <span class="SStr">"string 2"</span>, <span class="SCst">C</span> = <span class="SStr">"string 3"</span> }
    <span class="SCmp">#assert</span>(<span class="SCst">Value1</span>.<span class="SCst">A</span> == <span class="SStr">"string 1"</span>)

    <span class="SKwd">enum</span> <span class="SCst">Value2</span>: <span class="STpe">f32</span>
    {
        <span class="SCst">A</span> = <span class="SNum">1.0</span>
        <span class="SCst">B</span> = <span class="SNum">3.14</span>
        <span class="SCst">C</span> = <span class="SNum">6.0</span>
    }

    <span class="SCmp">#assert</span>(<span class="SCst">Value2</span>.<span class="SCst">B</span> == <span class="SNum">3.14</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Counting Enum Values </h4>
<p><span class="code-inline">@countof</span> returns the number of enum members. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">string</span>
    {
        <span class="SCst">A</span> = <span class="SStr">"1"</span>
        <span class="SCst">B</span> = <span class="SStr">"2"</span>
        <span class="SCst">C</span> = <span class="SStr">"3"</span>
    }

    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(<span class="SCst">Value</span>) == <span class="SNum">3</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Using <span class="code-inline">using</span> with Enums </h4>
<p><span class="code-inline">using</span> allows direct access to enum values without prefixing with the enum name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span> { <span class="SCst">A</span>, <span class="SCst">B</span>, <span class="SCst">C</span> }
    <span class="SKwd">using</span> <span class="SCst">Value</span>

    <span class="SItr">@assert</span>(<span class="SCst">A</span> == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(<span class="SCst">B</span> == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enums as Flags </h4>
<p>With <span class="code-inline">#[Swag.EnumFlags]</span>, enum values represent bit flags. They should use unsigned integer types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumFlags]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyFlags</span>: <span class="STpe">u8</span> { <span class="SCst">A</span>, <span class="SCst">B</span>, <span class="SCst">C</span>, <span class="SCst">D</span> }

    <span class="SCmp">#assert</span>(<span class="SCst">MyFlags</span>.<span class="SCst">A</span> == <span class="SNum">0b00000001</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">MyFlags</span>.<span class="SCst">B</span> == <span class="SNum">0b00000010</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">MyFlags</span>.<span class="SCst">C</span> == <span class="SNum">0b00000100</span>)

    <span class="SKwd">let</span> value = <span class="SCst">MyFlags</span>.<span class="SCst">B</span> | <span class="SCst">MyFlags</span>.<span class="SCst">C</span>
    <span class="SItr">@assert</span>(value == <span class="SNum">0b00000110</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enums with Arrays </h4>
<p>Enums can store array constants. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="SKwd">const</span> [<span class="SNum">2</span>] <span class="STpe">s32</span> { <span class="SCst">A</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>], <span class="SCst">B</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>] }
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">A</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span>.<span class="SCst">B</span>[<span class="SNum">1</span>] == <span class="SNum">20</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enums with Slices </h4>
<p>Enums can also store slices. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="SKwd">const</span> [..] <span class="STpe">s32</span> { <span class="SCst">A</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>], <span class="SCst">B</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>] }
    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(<span class="SCst">Value</span>.<span class="SCst">A</span>) == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SCst">Value</span>.<span class="SCst">B</span>[<span class="SNum">2</span>] == <span class="SNum">30</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Nested Enums </h4>
<p>Enums can include other enums using <span class="code-inline">using</span>. Both must share the same base type. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">enum</span> <span class="SCst">BasicErrors</span> { <span class="SCst">FailedToLoad</span>, <span class="SCst">FailedToSave</span> }

<span class="SKwd">enum</span> <span class="SCst">MyErrors</span>
{
    <span class="SKwd">using</span> <span class="SCst">BasicErrors</span>
    <span class="SCst">NotFound</span> = <span class="SNum">100</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Accessing Nested Enums </h4>
<p>Access nested values with their scoped names. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">MyError0</span> = <span class="SCst">MyErrors</span>.<span class="SCst">BasicErrors</span>.<span class="SCst">FailedToSave</span></span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Automatic Cast with Nested Enums </h4>
<p>Nested enums can be automatically cast to their parent enum type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">E0</span>: <span class="SCst">MyErrors</span> = <span class="SCst">MyErrors</span>.<span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>
    <span class="SKwd">const</span> <span class="SCst">E1</span>: <span class="SCst">BasicErrors</span> = <span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>

    <span class="SKwd">func</span> <span class="SFct">toto</span>(err: <span class="SCst">MyErrors</span>)
    {
        <span class="SItr">@assert</span>(err == <span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>)
    }

    <span class="SFct">toto</span>(<span class="SCst">E0</span>)
    <span class="SFct">toto</span>(<span class="SCst">E1</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Specific Enum Attributes </h4>
<p><span class="code-inline">#[Swag.EnumIndex]</span> allows direct indexing with enum values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumIndex]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyIndex</span> { <span class="SCst">First</span>, <span class="SCst">Second</span>, <span class="SCst">Third</span> }

    <span class="SKwd">const</span> <span class="SCst">Array</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SKwd">const</span> <span class="SCst">Valu</span>  = <span class="SCst">Array</span>[<span class="SCst">MyIndex</span>.<span class="SCst">First</span>]
}</span></div>
<p><span class="code-inline">#[Swag.NoDuplicate]</span> prevents duplicate values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.NoDuplicate]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyEnum</span> { <span class="SCst">Val0</span> = <span class="SNum">0</span> }
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Enum Type Inference </h4>
<p>Swag infers enum types automatically in assignments and expressions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">let</span> x: <span class="SCst">Values</span> = <span class="SCst">Values</span>.<span class="SCst">A</span>
    <span class="SKwd">let</span> y: <span class="SCst">Values</span> = <span class="SCst">A</span>
    <span class="SItr">@assert</span>(x == y)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Type Inference in <span class="code-inline">switch</span> </h4>
<p>Enum types are inferred inside <span class="code-inline">switch</span> statements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span>

    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SCst">A</span>:
        <span class="SLgc">break</span>
    <span class="SLgc">case</span> <span class="SCst">B</span>:
        <span class="SLgc">break</span>
    }
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Simplified Enum Syntax </h4>
<p>You can omit the enum name when the type is already known. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span>
    <span class="SItr">@assert</span>(x == .<span class="SCst">A</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Simplified Enum Flags Syntax </h4>
<p>This works with flags too. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumFlags]</span>
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }

    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span> | <span class="SCst">Values</span>.<span class="SCst">B</span>
    <span class="SItr">@assert</span>((x & .<span class="SCst">A</span>) <span class="SLgc">and</span> (x & .<span class="SCst">B</span>))
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Simplified Enum Syntax in Functions </h4>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">func</span> <span class="SFct">toto</span>(v1, v2: <span class="SCst">Values</span>) {}
    <span class="SFct">toto</span>(.<span class="SCst">A</span>, .<span class="SCst">B</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_004_enum_swg">Iterating Over Enum Values </h4>
<p>You can iterate over enums using <span class="code-inline">for</span> or <span class="code-inline">foreach</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }

    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> idx <span class="SLgc">in</span> <span class="SCst">RGB</span> <span class="SLgc">do</span>
        cpt += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>
<p><span class="code-inline">foreach</span> offers a structured way to iterate and handle specific values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }

    <span class="SLgc">foreach</span> val <span class="SLgc">in</span> <span class="SCst">RGB</span>
    {
        <span class="SLgc">switch</span> val
        {
        <span class="SLgc">case</span> <span class="SCst">R</span>:
            <span class="SLgc">break</span>
        <span class="SLgc">case</span> <span class="SCst">G</span>:
            <span class="SLgc">break</span>
        <span class="SLgc">case</span> <span class="SCst">B</span>:
            <span class="SLgc">break</span>
        <span class="SLgc">default</span>:
            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
        }
    }
}</span></div>

<h3 id="_004_000_data_structures_swg__004_005_impl_swg">Impl </h3><h4 id="_004_000_data_structures_swg__004_005_impl_swg">Implementing Methods for Enums in Swag </h4>
<p>Swag allows the use of the <span class="code-inline">impl</span> keyword with enums to define methods directly associated with them. This makes it possible to attach behavior to enum values, enhancing code organization and encapsulation. </p>
<p>Within these methods, the <span class="code-inline">me</span> keyword refers to the current enum instance, similar to <span class="code-inline">this</span> in other languages. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">enum</span> <span class="SCst">RGB</span>
{
    <span class="SCst">R</span>     <span class="SCmt">// Represents Red</span>
    <span class="SCst">G</span>     <span class="SCmt">// Represents Green</span>
    <span class="SCst">B</span>     <span class="SCmt">// Represents Blue</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_005_impl_swg">Defining Enum Methods with <span class="code-inline">impl enum</span> </h4>
<p>The <span class="code-inline">impl enum</span> block defines methods that operate on enum values. This helps group functionality logically with the type it belongs to. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SKwd">enum</span> <span class="SCst">RGB</span>
{
    <span class="SCmt">// Check if the current color is Red</span>
    <span class="SKwd">func</span> <span class="SFct">isRed</span>(<span class="STpe">me</span>) =&gt; <span class="STpe">me</span> == <span class="SCst">R</span>

    <span class="SCmt">// Check if the current color is Red or Blue</span>
    <span class="SKwd">func</span> <span class="SFct">isRedOrBlue</span>(<span class="STpe">me</span>) =&gt; <span class="STpe">me</span> == <span class="SCst">R</span> <span class="SLgc">or</span> <span class="STpe">me</span> == <span class="SCst">B</span>
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Verify if `RGB.R` is recognized as red</span>
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SFct">isRed</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span>))

    <span class="SCmt">// Verify if `RGB.B` is recognized as either red or blue</span>
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SFct">isRedOrBlue</span>(<span class="SCst">RGB</span>.<span class="SCst">B</span>))
}</span></div>
<h4 id="_004_000_data_structures_swg__004_005_impl_swg">Simplifying Calls with <span class="code-inline">using</span> </h4>
<p>The <span class="code-inline">using</span> keyword allows you to call enum methods without qualifying them with the enum name. This makes the code cleaner when the enum type is already in scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">using</span> <span class="SCst">RGB</span>

    <span class="SItr">@assert</span>(<span class="SFct">isRedOrBlue</span>(<span class="SCst">R</span>))
    <span class="SItr">@assert</span>(<span class="SFct">isRedOrBlue</span>(<span class="SCst">B</span>))
}</span></div>
<h4 id="_004_000_data_structures_swg__004_005_impl_swg">Uniform Function Call Syntax (UFCS) </h4>
<p>Swag supports <i>Uniform Function Call Syntax (UFCS)</i>, meaning methods can be called directly on enum values. This provides a natural, object-oriented style of method invocation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">using</span> <span class="SCst">RGB</span>

    <span class="SCmt">// Call `isRedOrBlue` directly on the enum value</span>
    <span class="SItr">@assert</span>(<span class="SCst">R</span>.<span class="SFct">isRedOrBlue</span>())

    <span class="SCmt">// Verify that `G` is not recognized as red or blue</span>
    <span class="SItr">@assert</span>(!<span class="SCst">G</span>.<span class="SFct">isRedOrBlue</span>())
}</span></div>

<h3 id="_004_000_data_structures_swg__004_006_union_swg">Union </h3><h4 id="_004_000_data_structures_swg__004_006_union_swg">The <span class="code-inline">union</span> Type in Swag </h4>
<p>A <span class="code-inline">union</span> is a special kind of struct where all fields share the same memory location. Each field starts at offset <span class="code-inline">0</span>, allowing multiple variables to overlap in memory. </p>
<p>This makes it possible to represent different data types using the same storage space, which is particularly useful for optimizing memory when only one field is used at a time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Define a union with three overlapping f32 fields: x, y, and z</span>
    <span class="SKwd">union</span> <span class="SCst">MyUnion</span> { x, y, z: <span class="STpe">f32</span> }

    <span class="SCmt">// Initialize the union, setting the value of the 'x' field</span>
    <span class="SKwd">let</span> v = <span class="SCst">MyUnion</span>{x: <span class="SNum">666</span>}

    <span class="SCmt">// All fields share the same memory location — updating one affects all</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
    <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_006_union_swg">How Unions Work </h4>
<p>In this example, the <span class="code-inline">MyUnion</span> type defines three fields (<span class="code-inline">x</span>, <span class="code-inline">y</span>, and <span class="code-inline">z</span>) that occupy the same memory space. Writing to one field overwrites the others, since they are all stored at the same offset. </p>
<p>This design is ideal for cases where different data types (or values) are stored alternately in the same memory area. Here, since all fields are of type <span class="code-inline">f32</span>, assigning a value to <span class="code-inline">x</span> automatically updates <span class="code-inline">y</span> and <span class="code-inline">z</span>, demonstrating the shared-memory behavior of unions. </p>

<h3 id="_004_000_data_structures_swg__004_007_pointers_swg">Pointers </h3><h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Single-Value Pointers </h4>
<p>A pointer to a <b>single element</b> is declared using the <span class="code-inline">*</span> symbol. It represents the memory address of one instance of a given type. </p>
<p>Pointers can reference any type of data and are fundamental for efficient memory access and manipulation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr1: *<span class="STpe">u8</span>      <span class="SCmt">// Pointer to a single 'u8' value</span>
    <span class="SKwd">var</span> ptr2: **<span class="STpe">u8</span>     <span class="SCmt">// Pointer to another pointer to 'u8'</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Null Pointers </h4>
<p>In Swag, a pointer can be <span class="code-inline">null</span>, meaning it does not refer to any valid memory location. Null pointers are often used to indicate uninitialized or intentionally empty references. </p>
<p>It is good practice to check for null pointers before dereferencing them to avoid runtime errors. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr1: *<span class="STpe">u8</span>
    <span class="SItr">@assert</span>(ptr1 == <span class="SKwd">null</span>) <span class="SCmt">// Uninitialized pointers are null by default</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Taking the Address of a Variable </h4>
<p>The <span class="code-inline">&</span> operator returns the <b>address</b> of a variable, producing a pointer to it. This allows you to access or modify a variable indirectly via its memory address. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> value = <span class="SNum">1</span>
    <span class="SKwd">let</span> ptr   = &value
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr) == *<span class="STpe">s32</span>) <span class="SCmt">// The pointer type matches the variable's type</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Dereferencing a Pointer </h4>
<p>To access the value stored at a pointer’s address, use the <span class="code-inline">dref</span> intrinsic. Dereferencing retrieves the data located at the memory address referenced by the pointer. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> value = <span class="SNum">42</span>
    <span class="SKwd">let</span> ptr   = &value
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">42</span>) <span class="SCmt">// Access the value stored at the pointer</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Const Pointers </h4>
<p>A <span class="code-inline">const</span> pointer is one whose <b>target address cannot change</b> once assigned. However, the data at that address may still be modified (unless declared const itself). Const pointers help guarantee that a pointer always refers to the same memory location. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str  = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> ptr: <span class="SKwd">const</span> *<span class="STpe">u8</span> = <span class="SItr">@dataof</span>(str)
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SStr">'s'</span>) <span class="SCmt">// Access the first byte of the string</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Combining <span class="code-inline">const</span> with Pointers </h4>
<p>Swag allows fine-grained control over constness in pointer declarations. You can define: - a <b>pointer to const data</b>, - a <b>const pointer</b>, or - a <b>const pointer to const data</b>. </p>
<p>This provides strong control over both pointer immutability and data mutability. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr:  *<span class="SKwd">const</span> *<span class="STpe">u8</span>           <span class="SCmt">// Pointer to a const pointer</span>
    <span class="SKwd">var</span> ptr1: <span class="SKwd">const</span> *<span class="SKwd">const</span> *<span class="STpe">u8</span>     <span class="SCmt">// Const pointer to a const pointer</span>
    <span class="SKwd">var</span> ptr2: <span class="SKwd">const</span> **<span class="STpe">u8</span>           <span class="SCmt">// Const pointer to a mutable pointer</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Multi-Value Pointers </h4>
<p>To enable <b>pointer arithmetic</b> or reference <b>contiguous memory blocks</b>, use <span class="code-inline">[*]</span> instead of <span class="code-inline">*</span>. </p>
<p>This type of pointer behaves like a view over multiple elements, allowing indexed access and pointer movement through memory. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Sanity(false)]</span>
<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr: [*] <span class="STpe">u8</span> <span class="SCmt">// Pointer to a block of 'u8' values</span>
    ptr = ptr - <span class="SNum">1</span> <span class="SCmt">// Move the pointer back by one element</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Pointer Arithmetic and Array Elements </h4>
<p>When taking the address of an array element, the resulting pointer automatically supports pointer arithmetic since it refers to a sequence of elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr: [<span class="SNum">4</span>] <span class="STpe">s32</span>
    <span class="SKwd">var</span> ptr  = &arr[<span class="SNum">1</span>]

    <span class="SCmt">// The pointer is treated as a multi-value pointer</span>
    ptr = ptr - <span class="SNum">1</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(ptr) == [*] <span class="STpe">s32</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_007_pointers_swg">Dereferencing with Indexing </h4>
<p>When pointer arithmetic is available, you can dereference a pointer using indexes, just like accessing elements in an array. </p>
<p>This is particularly useful when traversing arrays or buffers via pointers. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SKwd">let</span> ptr = &arr[<span class="SNum">0</span>]
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr) == [*] <span class="STpe">s32</span>)

    <span class="SKwd">let</span> value1 = ptr[<span class="SNum">0</span>]
    <span class="SItr">@assert</span>(value1 == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(value1) == <span class="STpe">s32</span>)

    <span class="SKwd">let</span> value2 = ptr[<span class="SNum">1</span>]
    <span class="SItr">@assert</span>(value2 == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(value2) == <span class="STpe">s32</span>)

    <span class="SKwd">let</span> value = <span class="SKwd">dref</span> ptr
    <span class="SItr">@assert</span>(value == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(value) == <span class="STpe">s32</span>)
}</span></div>

<h3 id="_004_000_data_structures_swg__004_008_references_swg">References </h3><h4 id="_004_000_data_structures_swg__004_008_references_swg">References in Swag </h4>
<p>Swag supports <b>references</b>, which behave like pointers but act syntactically like values. References offer a safer and more convenient way to work with memory addresses, eliminating the need for explicit pointer dereferencing in most cases. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">42</span>

    <span class="SCmt">// Declare a constant reference to 'x'.</span>
    <span class="SCmt">// Unlike C++, you must explicitly take the address of 'x' to create the reference.</span>
    <span class="SKwd">let</span> myRef: <span class="SKwd">const</span> &<span class="STpe">s32</span> = &x

    <span class="SCmt">// References behave like aliases — no explicit dereferencing is needed.</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">42</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Assigning Through References </h4>
<p>Assigning a value to a reference (after initialization) updates the <b>referenced variable</b>, not the reference itself. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x      = <span class="SNum">42</span>
    <span class="SKwd">var</span> myRef: &<span class="STpe">s32</span> = &x
    <span class="SItr">@assert</span>(myRef == <span class="SNum">42</span>)

    <span class="SCmt">// Change the value of 'x' through the reference</span>
    myRef = <span class="SNum">66</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">66</span>)
    <span class="SItr">@assert</span>(x == <span class="SNum">66</span>) <span class="SCmt">// 'x' is updated as well</span>
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Reassigning References </h4>
<p>Unlike in C++, Swag allows <b>reassigning</b> a reference to point to a different variable. Use the <span class="code-inline">#ref</span> modifier to perform this operation safely. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>
    <span class="SKwd">var</span> y = <span class="SNum">1000</span>

    <span class="SKwd">var</span> myRef: &<span class="STpe">s32</span> = &x
    <span class="SItr">@assert</span>(myRef == <span class="SNum">1</span>)

    <span class="SCmt">// Reassign the reference to point to 'y' instead of 'x'</span>
    myRef = <span class="SItr">#ref</span> &y
    <span class="SItr">@assert</span>(myRef == <span class="SNum">1000</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Passing References to Functions </h4>
<p>Normally, you take the address of a variable to create a reference. However, when passing a <b>const reference</b> to a function, Swag automatically takes the address — even for literals. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Passing a literal directly is allowed for const references</span>
    <span class="SFct">toto</span>(<span class="SNum">4</span>)
}

<span class="SKwd">func</span> <span class="SFct">toto</span>(x: <span class="SKwd">const</span> &<span class="STpe">s32</span>)
{
    <span class="SItr">@assert</span>(x == <span class="SNum">4</span>)

    <span class="SCmt">// A reference is still an address internally</span>
    <span class="SKwd">let</span> ptr = &x
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">4</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Using References with Structs </h4>
<p>References are especially useful when working with structs. They allow you to pass entire structures or tuples directly, including literal expressions. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Our first simple struct</span>
<span class="SKwd">struct</span> <span class="SCst">MyStruct</span> { x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> }

<span class="SFct">#test</span>
{
    <span class="SFct">titi0</span>({<span class="SNum">1</span>, <span class="SNum">2</span>})
    <span class="SFct">titi1</span>({<span class="SNum">3</span>, <span class="SNum">4</span>})
    <span class="SFct">titi2</span>({<span class="SNum">5</span>, <span class="SNum">6</span>})
}

<span class="SKwd">func</span> <span class="SFct">titi0</span>(param: <span class="SKwd">const</span> &{ x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> })
{
    <span class="SCmt">// Tuples can be accessed by item index</span>
    <span class="SItr">@assert</span>(param.item0 == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(param.item1 == <span class="SNum">2</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_008_references_swg">Equivalent Reference Passing </h4>
<p>Declaring a tuple type or a struct type as a function parameter is <b>equivalent</b> to passing a <b>constant reference</b>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">titi1</span>(param: { x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> })
{
    <span class="SItr">@assert</span>(param.x == <span class="SNum">3</span>)
    <span class="SItr">@assert</span>(param.y == <span class="SNum">4</span>)
}

<span class="SKwd">func</span> <span class="SFct">titi2</span>(param: <span class="SCst">MyStruct</span>)
{
    <span class="SItr">@assert</span>(param.x == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(param.y == <span class="SNum">6</span>)
}</span></div>

<h3 id="_004_000_data_structures_swg__004_009_any_swg">Any </h3><h4 id="_004_000_data_structures_swg__004_009_any_swg">The <span class="code-inline">any</span> Type in Swag </h4>
<p><span class="code-inline">any</span> is a dynamically typed reference that can point to a value of any concrete type. </p>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> <span class="code-inline">any</span> is <b>not</b> a variant. It holds a reference to an existing value plus its runtime type info. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">any</span>

    <span class="SCmt">// Store an s32 literal value in the 'any'</span>
    a = <span class="SNum">6</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) a == <span class="SNum">6</span>)

    <span class="SCmt">// Now store a string</span>
    a = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) a == <span class="SStr">"string"</span>)

    <span class="SCmt">// Now store a bool</span>
    a = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) a == <span class="SKwd">true</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Working with <span class="code-inline">any</span> and Pointers </h4>
<p>Use <span class="code-inline">@dataof</span> to access a pointer to the underlying value stored inside <span class="code-inline">any</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a:  <span class="STpe">any</span> = <span class="SNum">6</span>
    <span class="SKwd">let</span> ptr = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="STpe">s32</span>) <span class="SItr">@dataof</span>(a)
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">6</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Type Information and <span class="code-inline">any</span> </h4>
<p><span class="code-inline">#typeof</span> on an <span class="code-inline">any</span> yields <span class="code-inline">any</span> (the reference type). Use <span class="code-inline">@kindof</span> to get the concrete runtime type of the referenced value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">any</span> = <span class="SStr">"string"</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">any</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(a) == <span class="STpe">string</span>)

    a = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(a) == <span class="STpe">bool</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Retrieving Values from <span class="code-inline">any</span> </h4>
<p>You can retrieve the stored value directly or as a constant reference. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">any</span> = <span class="SNum">42</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(a) == <span class="STpe">any</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(a) == <span class="STpe">s32</span>)

    <span class="SKwd">let</span> b = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) a <span class="SCmt">// Get the value itself</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">42</span>)

    <span class="SKwd">let</span> c = <span class="SKwd">cast</span>(<span class="SKwd">const</span> &<span class="STpe">s32</span>) a <span class="SCmt">// Get a constant reference to the value</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">42</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Arrays of <span class="code-inline">any</span> </h4>
<p>You can create heterogeneous arrays where each element holds a different type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [?] <span class="STpe">any</span> = [<span class="SKwd">true</span>, <span class="SNum">2</span>, <span class="SNum">3.0</span>, <span class="SStr">"4"</span>]

    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">0</span>]) == <span class="STpe">bool</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">1</span>]) == <span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">2</span>]) == <span class="STpe">f32</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">3</span>]) == <span class="STpe">string</span>)

    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) array[<span class="SNum">0</span>] == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) array[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">f32</span>) array[<span class="SNum">2</span>] == <span class="SNum">3.0</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) array[<span class="SNum">3</span>] == <span class="SStr">"4"</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Nullability of <span class="code-inline">any</span> </h4>
<p>An <span class="code-inline">any</span> value can be null, similar to pointers and other nullable types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">any</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)

    x = <span class="SNum">6</span>
    <span class="SItr">@assert</span>(x != <span class="SKwd">null</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) x == <span class="SNum">6</span>)

    x = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(x != <span class="SKwd">null</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) x == <span class="SStr">"string"</span>)

    x = <span class="SKwd">null</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)
}</span></div>
<h4 id="_004_000_data_structures_swg__004_009_any_swg">Type Checking with <span class="code-inline">any</span> </h4>
<p>An <span class="code-inline">any</span> can be compared to a type using <span class="code-inline">==</span> or <span class="code-inline">!=</span>. This uses <span class="code-inline">@kindof</span> internally to compare the stored value's type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">any</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)

    x = <span class="SNum">6</span>
    <span class="SItr">@assert</span>(x == <span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(x != <span class="STpe">bool</span>)

    x = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(x != <span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(x == <span class="STpe">string</span>)

    <span class="SKwd">struct</span> <span class="SCst">A</span> {}
    x = <span class="SCst">A</span>{}
    <span class="SItr">@assert</span>(x == <span class="SCst">A</span>)
}</span></div>

<h2 id="_005_000_control_flow_swg">Control Flow </h2>
<h3 id="_005_000_control_flow_swg__005_001_if_swg">If </h3><h4 id="_005_000_control_flow_swg__005_001_if_swg">Basic Usage of <span class="code-inline">if</span> </h4>
<p>A basic test with an <span class="code-inline">if</span> statement. </p>
<p>In Swag, curly braces <span class="code-inline">{}</span> are optional for control structures like <span class="code-inline">if</span>. However, if you omit them, you must use <span class="code-inline">do</span>. This rule also applies to <span class="code-inline">while</span> and <span class="code-inline">for</span> loops. </p>
<p>Unlike in C/C++, the condition in an <span class="code-inline">if</span> statement does not need parentheses. They can be used for clarity or grouping, but they are not required. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SLgc">if</span> a == <span class="SNum">1</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)

    <span class="SLgc">if</span> (a == <span class="SNum">1</span>) <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)

    <span class="SLgc">if</span> a == <span class="SNum">0</span>
    {
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    }

    <span class="SCmt">// The 'else' keyword works as in most languages.</span>
    <span class="SCmt">// When omitting braces, 'do' is mandatory after the condition.</span>
    <span class="SLgc">if</span> a == <span class="SNum">0</span> <span class="SLgc">do</span>
        a += <span class="SNum">1</span>
    <span class="SLgc">else</span> <span class="SLgc">do</span>
        a += <span class="SNum">2</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)

    <span class="SCmt">// 'elif' functions like 'else if' in other languages.</span>
    <span class="SLgc">if</span> a == <span class="SNum">1</span> <span class="SLgc">do</span>
        a += <span class="SNum">1</span>
    <span class="SLgc">else</span> <span class="SLgc">do</span>
        <span class="SLgc">if</span> a == <span class="SNum">2</span> <span class="SLgc">do</span>
            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
        <span class="SLgc">elif</span> a == <span class="SNum">3</span> <span class="SLgc">do</span>
            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
        <span class="SLgc">elif</span> a == <span class="SNum">4</span> <span class="SLgc">do</span>
            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)

    <span class="SCmt">// Logical expressions work as expected with 'and' and 'or'.</span>
    <span class="SLgc">if</span> a == <span class="SNum">0</span> <span class="SLgc">and</span> a == <span class="SNum">1</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">if</span> a == <span class="SNum">0</span> <span class="SLgc">or</span> a == <span class="SNum">1</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">if</span> a == <span class="SNum">1</span> <span class="SLgc">or</span> a == <span class="SNum">2</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_001_if_swg">Variable Declaration in <span class="code-inline">if</span> </h4>
<p>You can declare and test a variable directly in an <span class="code-inline">if</span> statement. When doing so, the use of <span class="code-inline">var</span>, <span class="code-inline">let</span>, or <span class="code-inline">const</span> is mandatory. </p>
<p>The declared variable is converted to a boolean for the condition: non-zero (or non-null) values are considered <span class="code-inline">true</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Declare and test 'a' in the same line.</span>
    <span class="SCmt">// Since 'a' is 0, the condition is false and the block won’t execute.</span>
    <span class="SLgc">if</span> <span class="SKwd">let</span> a = <span class="SNum">0</span>
    {
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SCmt">// Redeclare 'a' as a constant in another scope.</span>
    <span class="SCmt">// Since 'a' is 1, the block will execute.</span>
    <span class="SLgc">if</span> <span class="SKwd">const</span> a = <span class="SNum">1</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)
    <span class="SLgc">else</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)

    <span class="SLgc">if</span> <span class="SKwd">let</span> a = <span class="SNum">1</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)
    <span class="SLgc">else</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_001_if_swg">Adding Conditions with <span class="code-inline">where</span> </h4>
<p>When an <span class="code-inline">if</span> statement includes a variable declaration, you can refine the test with a <span class="code-inline">where</span> clause. The <span class="code-inline">where</span> condition is only evaluated if the variable test passes. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">retSomething</span>()-&gt;<span class="STpe">string</span>     =&gt; <span class="SStr">"string"</span>
    <span class="SKwd">func</span> <span class="SFct">retNothing</span>()-&gt;<span class="SItr">#null</span> <span class="STpe">string</span> =&gt; <span class="SKwd">null</span>

    <span class="SCmt">// The 'where' clause runs only if 'str' is not null.</span>
    <span class="SLgc">if</span> <span class="SKwd">let</span> str = <span class="SFct">retSomething</span>() <span class="SLgc">where</span> str[<span class="SNum">0</span>] == <span class="SStr">'s'</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">else</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)

    <span class="SCmt">// Since 'retNothing()' returns null, the 'where' clause is skipped.</span>
    <span class="SLgc">if</span> <span class="SKwd">let</span> str = <span class="SFct">retNothing</span>() <span class="SLgc">where</span> str[<span class="SNum">0</span>] == <span class="SStr">'s'</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">else</span> <span class="SLgc">do</span>
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
}</span></div>

<h3 id="_005_000_control_flow_swg__005_002_for_swg">For </h3><h4 id="_005_000_control_flow_swg__005_002_for_swg">Introduction to <span class="code-inline">for</span> </h4>
<p>The <span class="code-inline">for</span> construct in Swag enables iteration, allowing a block of code to execute repeatedly. This guide explores its features: basic usage, indexing, naming, reverse loops, early exits, range iteration, and advanced filtering using the <span class="code-inline">where</span> clause. </p>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Basic Usage </h4>
<p>The <span class="code-inline">for</span> expression specifies the number of iterations and is evaluated <b>once</b> before the loop starts. This expression must yield a <b>positive integer</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SNum">10</span> <span class="SLgc">do</span>
        cpt += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Using <span class="code-inline">@index</span> </h4>
<p>Within a <span class="code-inline">for</span>, the compiler provides the built-in <span class="code-inline">@index</span>, representing the current iteration (starting from 0). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>'<span class="STpe">u64</span>
    <span class="SLgc">for</span> <span class="SNum">5</span>
    {
        cpt += <span class="SItr">@index</span>
    }
    <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Naming the Loop Index </h4>
<p>You can assign a custom name to the loop index for clarity, while <span class="code-inline">@index</span> remains accessible. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt  = <span class="SNum">0</span>
    <span class="SKwd">var</span> cpt1 = <span class="SNum">0</span>

    <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SNum">5</span>
    {
        cpt += i
        cpt1 += <span class="SItr">@index</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(cpt1 == cpt)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Looping Over Arrays and Slices </h4>
<p>The <span class="code-inline">for</span> construct can iterate over any type supporting <span class="code-inline">@countof</span>, such as arrays, slices, or strings. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SCmp">#assert</span>(<span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>)

    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> arr <span class="SLgc">do</span>
        cpt += arr[<span class="SItr">@index</span>]
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span> + <span class="SNum">20</span> + <span class="SNum">30</span> + <span class="SNum">40</span>)
}</span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> When iterating over strings, <span class="code-inline">for</span> loops over <b>bytes</b>, not runes.  Use <span class="code-inline">Std.Core</span> for rune-based iteration. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SStr">"⻘"</span> <span class="SLgc">do</span>
        cpt += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Reverse Looping </h4>
<p>To iterate in reverse order, add the <span class="code-inline">#reverse</span> modifier. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SLgc">for</span> <span class="SItr">#reverse</span> <span class="SNum">3</span>
    {
        <span class="SLgc">if</span> cpt == <span class="SNum">0</span> <span class="SLgc">do</span>
            <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">2</span>)
        <span class="SLgc">elif</span> cpt == <span class="SNum">1</span> <span class="SLgc">do</span>
            <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">1</span>)
        <span class="SLgc">elif</span> cpt == <span class="SNum">2</span> <span class="SLgc">do</span>
            <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">0</span>)
        cpt += <span class="SNum">1</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg"><span class="code-inline">break</span> and <span class="code-inline">continue</span> </h4>
<p>The <span class="code-inline">break</span> and <span class="code-inline">continue</span> keywords control loop flow. <span class="code-inline">break</span> exits the loop, while <span class="code-inline">continue</span> skips to the next iteration. </p>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Exiting Early with <span class="code-inline">break</span> </h4>
<p><span class="code-inline">break</span> stops the loop before completing all iterations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> x <span class="SLgc">in</span> <span class="SNum">10</span>
    {
        <span class="SLgc">if</span> x == <span class="SNum">5</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">5</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Skipping Iterations with <span class="code-inline">continue</span> </h4>
<p><span class="code-inline">continue</span> skips the current iteration and proceeds to the next. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> x <span class="SLgc">in</span> <span class="SNum">10</span>
    {
        <span class="SLgc">if</span> x == <span class="SNum">5</span> <span class="SLgc">do</span>
            <span class="SLgc">continue</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">9</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Ranges </h4>
<p>The <span class="code-inline">for</span> loop supports signed integer ranges, offering flexible intervals. </p>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Looping Over a Range with <span class="code-inline">to</span> </h4>
<p><span class="code-inline">to</span> defines an inclusive range loop. </p>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> The start value must be less than or equal to the end value. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> count = <span class="SNum">0</span>
    <span class="SKwd">var</span> sum   = <span class="SNum">0</span>

    <span class="SLgc">for</span> i <span class="SLgc">in</span> -<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">1</span>
    {
        count += <span class="SNum">1</span>
        sum += i
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(count == <span class="SNum">3</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Excluding the Last Value with <span class="code-inline">until</span> </h4>
<p><span class="code-inline">until</span> defines a range that excludes the end value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SNum">1</span> <span class="SLgc">until</span> <span class="SNum">3</span>
    {
        cpt += i
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span> + <span class="SNum">2</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Reverse Range Looping </h4>
<p>Use <span class="code-inline">#reverse</span> to iterate a range in reverse order. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">for</span> <span class="SItr">#reverse</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">5</span>
    {
    }

    <span class="SLgc">for</span> <span class="SItr">#reverse</span> -<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">1</span>
    {
    }

    <span class="SLgc">for</span> <span class="SItr">#reverse</span> -<span class="SNum">2</span> <span class="SLgc">until</span> <span class="SNum">2</span>
    {
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Infinite Loop </h4>
<p>A <span class="code-inline">for</span> without an expression creates an infinite loop, similar to <span class="code-inline">while true {}</span>. Use <span class="code-inline">break</span> to exit. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">for</span>
    {
        <span class="SLgc">if</span> <span class="SItr">@index</span> == <span class="SNum">4</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Using <span class="code-inline">where</span> Clause </h4>
<p>The <span class="code-inline">where</span> clause filters iterations based on conditions. </p>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Basic <span class="code-inline">where</span> Clause </h4>
<p>Attach <span class="code-inline">where</span> to apply a filter to the loop index or element. Only iterations meeting the condition are executed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> result = <span class="SNum">0</span>

    <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SNum">10</span> <span class="SLgc">where</span> i % <span class="SNum">2</span> == <span class="SNum">0</span>
    {
        result += i
    }

    <span class="SItr">@assert</span>(result == <span class="SNum">0</span> + <span class="SNum">2</span> + <span class="SNum">4</span> + <span class="SNum">6</span> + <span class="SNum">8</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg"><span class="code-inline">where</span> with Arrays </h4>
<p>Use <span class="code-inline">where</span> to filter array elements during iteration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr        = [<span class="SNum">10</span>, <span class="SNum">21</span>, <span class="SNum">30</span>, <span class="SNum">41</span>, <span class="SNum">50</span>]
    <span class="SKwd">var</span> sumOfEvens = <span class="SNum">0</span>

    <span class="SLgc">for</span> i <span class="SLgc">in</span> arr <span class="SLgc">where</span> arr[i] % <span class="SNum">2</span> == <span class="SNum">0</span>
    {
        sumOfEvens += arr[i]
    }

    <span class="SItr">@assert</span>(sumOfEvens == <span class="SNum">10</span> + <span class="SNum">30</span> + <span class="SNum">50</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Complex Conditions with <span class="code-inline">where</span> </h4>
<p>The <span class="code-inline">where</span> clause supports multiple logical conditions for advanced filtering. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr         = [<span class="SNum">10</span>, <span class="SNum">15</span>, <span class="SNum">20</span>, <span class="SNum">25</span>, <span class="SNum">30</span>, <span class="SNum">35</span>]
    <span class="SKwd">var</span> filteredSum = <span class="SNum">0</span>

    <span class="SLgc">for</span> i <span class="SLgc">in</span> arr <span class="SLgc">where</span> arr[i] % <span class="SNum">2</span> == <span class="SNum">0</span> <span class="SLgc">and</span> arr[i] &gt; <span class="SNum">15</span>
    {
        filteredSum += arr[i]
    }

    <span class="SItr">@assert</span>(filteredSum == <span class="SNum">20</span> + <span class="SNum">30</span>)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr        = [<span class="SNum">10</span>, <span class="SNum">25</span>, <span class="SNum">30</span>, <span class="SNum">45</span>, <span class="SNum">50</span>, <span class="SNum">65</span>]
    <span class="SKwd">var</span> complexSum = <span class="SNum">0</span>

    <span class="SLgc">for</span> i <span class="SLgc">in</span> arr <span class="SLgc">where</span> arr[i] % <span class="SNum">2</span> == <span class="SNum">0</span> <span class="SLgc">or</span> arr[i] &gt; <span class="SNum">40</span>
    {
        complexSum += arr[i]
    }

    <span class="SItr">@assert</span>(complexSum == <span class="SNum">10</span> + <span class="SNum">30</span> + <span class="SNum">45</span> + <span class="SNum">50</span> + <span class="SNum">65</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg"><span class="code-inline">where</span> with Ranges </h4>
<p>The <span class="code-inline">where</span> clause can also be applied to ranges. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> sumOfPositiveEvens = <span class="SNum">0</span>

    <span class="SLgc">for</span> i <span class="SLgc">in</span> -<span class="SNum">5</span> <span class="SLgc">to</span> <span class="SNum">5</span> <span class="SLgc">where</span> i &gt; <span class="SNum">0</span> <span class="SLgc">and</span> i % <span class="SNum">2</span> == <span class="SNum">0</span>
    {
        sumOfPositiveEvens += i
    }

    <span class="SItr">@assert</span>(sumOfPositiveEvens == <span class="SNum">2</span> + <span class="SNum">4</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Combining <span class="code-inline">#reverse</span> and <span class="code-inline">where</span> </h4>
<p>You can combine <span class="code-inline">#reverse</span> with <span class="code-inline">where</span> for reverse conditional iteration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr         = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>, <span class="SNum">50</span>]
    <span class="SKwd">var</span> reversedSum = <span class="SNum">0</span>

    <span class="SLgc">for</span> <span class="SItr">#reverse</span> i <span class="SLgc">in</span> arr <span class="SLgc">where</span> arr[i] % <span class="SNum">2</span> == <span class="SNum">0</span>
    {
        reversedSum += arr[i]
    }

    <span class="SItr">@assert</span>(reversedSum == <span class="SNum">50</span> + <span class="SNum">40</span> + <span class="SNum">30</span> + <span class="SNum">20</span> + <span class="SNum">10</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">C-like <span class="code-inline">for</span> </h4>
<p>Swag also supports a C-style <span class="code-inline">for</span> loop with initialization, condition, and increment sections. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// Standard syntax</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span> <span class="SLgc">do</span>
        cpt += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)

    <span class="SCmt">// Alternative syntax with newlines</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>
    {
        cpt += <span class="SNum">1</span>
    }
    <span class="SItr">@assert</span>(cpt == <span class="SNum">20</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Accessing Loop Index with <span class="code-inline">@index</span> </h4>
<p>In all <span class="code-inline">for</span> variants, <span class="code-inline">@index</span> provides the current iteration index. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>'<span class="STpe">u64</span>

    <span class="SLgc">for</span> <span class="SKwd">var</span> i: <span class="STpe">u32</span> = <span class="SNum">10</span>; i &lt; <span class="SNum">15</span>; i += <span class="SNum">1</span> <span class="SLgc">do</span>
        cpt += <span class="SItr">@index</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)

    <span class="SKwd">var</span> cpt1 = <span class="SNum">0</span>'<span class="STpe">u64</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">10</span>; i &lt; <span class="SNum">15</span>; i += <span class="SNum">1</span> <span class="SLgc">do</span>
        cpt1 += <span class="SItr">@index</span>
    <span class="SItr">@assert</span>(cpt1 == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Using <span class="code-inline">break</span> and <span class="code-inline">continue</span> in <span class="code-inline">for</span> Loops </h4>
<p><span class="code-inline">break</span> exits the loop early, and <span class="code-inline">continue</span> skips to the next iteration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>

    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>
    {
        <span class="SLgc">if</span> i == <span class="SNum">5</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span>
        sum += i
    }
    <span class="SItr">@assert</span>(sum == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)

    sum = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>
    {
        <span class="SLgc">if</span> i % <span class="SNum">2</span> == <span class="SNum">0</span> <span class="SLgc">do</span>
            <span class="SLgc">continue</span>
        sum += i
    }
    <span class="SItr">@assert</span>(sum == <span class="SNum">1</span> + <span class="SNum">3</span> + <span class="SNum">5</span> + <span class="SNum">7</span> + <span class="SNum">9</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Nested <span class="code-inline">for</span> Loops </h4>
<p>Swag supports nested loops. In nested contexts, <span class="code-inline">@index</span> refers to the current innermost loop. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> result = <span class="SNum">0</span>'<span class="STpe">u64</span>

    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">5</span>; i += <span class="SNum">1</span>
    {
        <span class="SLgc">for</span> <span class="SKwd">var</span> j = <span class="SNum">0</span>; j &lt; <span class="SNum">5</span>; j += <span class="SNum">1</span>
        {
            result += <span class="SItr">@index</span>
        }
    }

    <span class="SItr">@assert</span>(result == <span class="SNum">10</span> * <span class="SNum">5</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_002_for_swg">Iterating Over Arrays with <span class="code-inline">for</span> </h4>
<p>You can also use <span class="code-inline">for</span> to iterate over arrays and collections. (Although <span class="code-inline">foreach</span> is generally preferred.) </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>, <span class="SNum">5</span>]
    <span class="SKwd">var</span> sum   = <span class="SNum">0</span>

    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SItr">@countof</span>(array); i += <span class="SNum">1</span>
    {
        sum += array[i]
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span> + <span class="SNum">5</span>)
}</span></div>

<h3 id="_005_000_control_flow_swg__005_003_foreach_swg">Foreach </h3><h4 id="_005_000_control_flow_swg__005_003_foreach_swg">Introduction to <span class="code-inline">foreach</span> </h4>
<p>The <span class="code-inline">foreach</span> statement iterates over all elements of a collection (arrays, slices, strings, and even structs), providing a streamlined and efficient way to process each item. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">foreach</span> value <span class="SLgc">in</span> <span class="SStr">"ABC"</span>
    {
        <span class="SKwd">let</span> a = <span class="SItr">@index</span>
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'A'</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'B'</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'C'</span>)
        }
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_foreach_swg">Naming the Value and Index </h4>
<p>You can explicitly name both the element <span class="code-inline">value</span> and the loop <span class="code-inline">index</span> to improve readability, especially in nested loops or with complex data structures. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">foreach</span> value, index <span class="SLgc">in</span> <span class="SStr">"ABC"</span>
    {
        <span class="SKwd">let</span> a = index
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'A'</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'B'</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'C'</span>)
        }
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_foreach_swg">Using Default Aliases </h4>
<p>If you do not name the element or index, you can access them with the default aliases: <span class="code-inline">#alias0</span> for the element and <span class="code-inline">#alias1</span> for the index. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">foreach</span> <span class="SStr">"ABC"</span>
    {
        <span class="SKwd">let</span> a = <span class="SItr">#alias1</span>
        <span class="SItr">@assert</span>(a == <span class="SItr">@index</span>)
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SStr">'A'</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SStr">'B'</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SStr">'C'</span>)
        }
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_foreach_swg">Reverse Order with <span class="code-inline">#reverse</span> </h4>
<p>Iterate from the last element to the first by adding the <span class="code-inline">#reverse</span> modifier. <span class="code-inline">@index</span> still reflects the loop index within the original collection. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> <span class="SItr">#reverse</span> value <span class="SLgc">in</span> <span class="SStr">"ABC"</span>
    {
        <span class="SLgc">switch</span> cpt
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'C'</span>)
            <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">2</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'B'</span>)
            <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">1</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>:
            <span class="SItr">@assert</span>(value == <span class="SStr">'A'</span>)
            <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">0</span>)
        }
        cpt += <span class="SNum">1</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_foreach_swg">Visiting Arrays and Slices </h4>
<p>Use <span class="code-inline">foreach</span> to traverse arrays or slices and process each element. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array  = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>]
    <span class="SKwd">var</span> result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> it <span class="SLgc">in</span> array <span class="SLgc">do</span>
        result += it
    <span class="SItr">@assert</span>(result == <span class="SNum">10</span> + <span class="SNum">20</span> + <span class="SNum">30</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_foreach_swg">Multi-dimensional Arrays </h4>
<p><span class="code-inline">foreach</span> works with multi-dimensional arrays and visits each element in row-major order. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span> = [[<span class="SNum">10</span>, <span class="SNum">20</span>], [<span class="SNum">30</span>, <span class="SNum">40</span>]]
    <span class="SKwd">var</span> result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> it <span class="SLgc">in</span> array <span class="SLgc">do</span>
        result += it
    <span class="SItr">@assert</span>(result == <span class="SNum">10</span> + <span class="SNum">20</span> + <span class="SNum">30</span> + <span class="SNum">40</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_foreach_swg">Modifying Elements with <span class="code-inline">&</span> </h4>
<p>Prefix the element name with <span class="code-inline">&</span> to visit elements by address and modify them in place. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span> = [[<span class="SNum">1</span>, <span class="SNum">2</span>], [<span class="SNum">3</span>, <span class="SNum">4</span>]]
    <span class="SKwd">var</span> result = <span class="SNum">0</span>

    <span class="SLgc">foreach</span> &it <span class="SLgc">in</span> array
    {
        result += <span class="SKwd">dref</span> it
        <span class="SKwd">dref</span> it = <span class="SNum">555</span>
    }

    <span class="SItr">@assert</span>(result == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>, <span class="SNum">1</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>, <span class="SNum">0</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>, <span class="SNum">1</span>] == <span class="SNum">555</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_003_foreach_swg">Filtering with <span class="code-inline">where</span> </h4>
<p>Add a <span class="code-inline">where</span> clause to process only elements that satisfy a condition. This avoids explicit branching inside the loop. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [?] <span class="STpe">s32</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SKwd">var</span> result = <span class="SNum">0</span>

    <span class="SLgc">foreach</span> value <span class="SLgc">in</span> array <span class="SLgc">where</span> value & <span class="SNum">1</span> == <span class="SNum">0</span> <span class="SLgc">do</span>
        result += value
    <span class="SItr">@assert</span>(result == <span class="SNum">6</span>)

    <span class="SCmt">// Equivalent with an 'if' guard:</span>
    result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> value <span class="SLgc">in</span> array <span class="SLgc">do</span>
        <span class="SLgc">if</span> value & <span class="SNum">1</span> == <span class="SNum">0</span> <span class="SLgc">do</span>
            result += value
    <span class="SItr">@assert</span>(result == <span class="SNum">6</span>)

    <span class="SCmt">// Equivalent using 'continue' to skip odd values:</span>
    result = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> value <span class="SLgc">in</span> array
    {
        <span class="SLgc">if</span> (value & <span class="SNum">1</span>) != <span class="SNum">0</span> <span class="SLgc">do</span>
            <span class="SLgc">continue</span>
        result += value
    }
    <span class="SItr">@assert</span>(result == <span class="SNum">6</span>)
}</span></div>

<h3 id="_005_000_control_flow_swg__005_004_while_swg">While </h3><h4 id="_005_000_control_flow_swg__005_004_while_swg">Introduction to <span class="code-inline">while</span> Loops </h4>
<p>A <span class="code-inline">while</span> loop repeatedly executes a block of code as long as its condition evaluates to <span class="code-inline">true</span>. Once the condition becomes <span class="code-inline">false</span>, the loop terminates. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> i = <span class="SNum">0</span>
    <span class="SLgc">while</span> i &lt; <span class="SNum">10</span> <span class="SLgc">do</span>
        i += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(i == <span class="SNum">10</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_004_while_swg">Breaking Out of a <span class="code-inline">while</span> Loop </h4>
<p>The <span class="code-inline">break</span> statement allows an early exit from a <span class="code-inline">while</span> loop before the condition becomes <span class="code-inline">false</span>. This is useful when you need to stop the loop based on a specific condition. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> i = <span class="SNum">0</span>
    <span class="SLgc">while</span> i &lt; <span class="SNum">10</span>
    {
        <span class="SLgc">if</span> i == <span class="SNum">5</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span>
        i += <span class="SNum">1</span>
    }
    <span class="SItr">@assert</span>(i == <span class="SNum">5</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_004_while_swg">Skipping Iterations with <span class="code-inline">continue</span> </h4>
<p>The <span class="code-inline">continue</span> statement skips the current iteration and jumps to the next one. It is useful for ignoring specific cases within the loop. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>
    <span class="SKwd">var</span> i   = <span class="SNum">0</span>

    <span class="SLgc">while</span> i &lt; <span class="SNum">10</span>
    {
        i += <span class="SNum">1</span>
        <span class="SLgc">if</span> i % <span class="SNum">2</span> == <span class="SNum">0</span> <span class="SLgc">do</span>
            <span class="SLgc">continue</span>
        sum += i
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">25</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_004_while_swg">Nested <span class="code-inline">while</span> Loops </h4>
<p>A <span class="code-inline">while</span> loop can contain another <span class="code-inline">while</span> loop. <span class="code-inline">break</span> and <span class="code-inline">continue</span> only affect the loop in which they are directly used. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> i     = <span class="SNum">0</span>
    <span class="SKwd">var</span> j     = <span class="SNum">0</span>
    <span class="SKwd">var</span> count = <span class="SNum">0</span>

    <span class="SLgc">while</span> i &lt; <span class="SNum">3</span>
    {
        j = <span class="SNum">0</span>
        <span class="SLgc">while</span> j &lt; <span class="SNum">3</span>
        {
            <span class="SLgc">if</span> j == <span class="SNum">2</span> <span class="SLgc">do</span>
                <span class="SLgc">break</span>
            count += <span class="SNum">1</span>
            j += <span class="SNum">1</span>
        }
        i += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(count == <span class="SNum">6</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_004_while_swg">Using <span class="code-inline">while</span> with Complex Conditions </h4>
<p>The condition in a <span class="code-inline">while</span> loop can include logical operators such as <span class="code-inline">and</span> and <span class="code-inline">or</span> for more complex and controlled iteration logic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a          = <span class="SNum">0</span>
    <span class="SKwd">var</span> b          = <span class="SNum">1</span>
    <span class="SKwd">var</span> iterations = <span class="SNum">0</span>

    <span class="SLgc">while</span> a &lt; <span class="SNum">100</span> <span class="SLgc">and</span> b &lt; <span class="SNum">200</span>
    {
        a += <span class="SNum">10</span>
        b += <span class="SNum">20</span>
        iterations += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">100</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">201</span>)
    <span class="SItr">@assert</span>(iterations == <span class="SNum">10</span>)
}</span></div>

<h3 id="_005_000_control_flow_swg__005_005_switch_swg">Switch </h3><h4 id="_005_000_control_flow_swg__005_005_switch_swg">Introduction to <span class="code-inline">switch</span> in Swag </h4>
<p>The <span class="code-inline">switch</span> statement in Swag behaves similarly to C/C++, with one key difference: Swag <b>does not require <span class="code-inline">break</span></b> at the end of each case. Unintentional fallthroughs are prevented by default, ensuring each <span class="code-inline">case</span> is isolated unless explicitly linked with <span class="code-inline">fallthrough</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">0</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">5</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">6</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SKwd">let</span> ch = <span class="SStr">'A'</span>'<span class="STpe">rune</span>

    <span class="SLgc">switch</span> ch
    {
    <span class="SLgc">case</span> <span class="SStr">'B'</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SStr">'A'</span>:
        <span class="SLgc">break</span>
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Multiple Values in a <span class="code-inline">case</span> </h4>
<p>A <span class="code-inline">case</span> can match multiple values, simplifying logic when several values share the same behavior. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">2</span>, <span class="SNum">4</span>, <span class="SNum">6</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SCmt">// Alternatively, list each value on its own line for clarity.</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">2</span>,
         <span class="SNum">4</span>,
         <span class="SNum">6</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Using <span class="code-inline">switch</span> with Various Types </h4>
<p><span class="code-inline">switch</span> supports any type that implements <span class="code-inline">==</span>, including strings and user-defined comparable types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SStr">"myString"</span>

    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SStr">"myString"</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">case</span> <span class="SStr">"otherString"</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Intentional Fallthrough with <span class="code-inline">fallthrough</span> </h4>
<p>Use <span class="code-inline">fallthrough</span> to intentionally continue execution into the next case. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">6</span>:
        <span class="SLgc">fallthrough</span>
    <span class="SLgc">case</span> <span class="SNum">7</span>:
        <span class="SItr">@assert</span>(value == <span class="SNum">6</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Exiting a <span class="code-inline">case</span> Early with <span class="code-inline">break</span> </h4>
<p>Use <span class="code-inline">break</span> to exit a <span class="code-inline">case</span> early when a certain condition is met. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">6</span>:
        <span class="SLgc">if</span> value == <span class="SNum">6</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Handling Empty Cases with <span class="code-inline">break</span> </h4>
<p>A <span class="code-inline">case</span> cannot be left empty. Use <span class="code-inline">break</span> explicitly when no action is required. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>

    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">5</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">6</span>:
        <span class="SLgc">break</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Variable and Expression Cases </h4>
<p><span class="code-inline">switch</span> cases can use variables and expressions, evaluated dynamically at runtime. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> test = <span class="SNum">2</span>
    <span class="SKwd">let</span> a    = <span class="SNum">0</span>
    <span class="SKwd">let</span> b    = <span class="SNum">1</span>

    <span class="SLgc">switch</span> test
    {
    <span class="SLgc">case</span> a:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> b:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> b + <span class="SNum">1</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">The <span class="code-inline">Swag.Complete</span> Attribute </h4>
<p>Annotate a <span class="code-inline">switch</span> with <span class="code-inline">#[Swag.Complete]</span> when matching enums to enforce exhaustive case handling. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Color</span> { <span class="SCst">Red</span>, <span class="SCst">Green</span>, <span class="SCst">Blue</span> }
    <span class="SKwd">let</span> color = <span class="SCst">Color</span>.<span class="SCst">Red</span>

    <span class="SAtr">#[Swag.Complete]</span>
    <span class="SLgc">switch</span> color
    {
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Red</span>:
        <span class="SLgc">break</span>
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Green</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Blue</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Matching Ranges in a <span class="code-inline">switch</span> Statement </h4>
<p>Swag supports matching a <b>range of values</b> in <span class="code-inline">case</span> conditions for concise range-based logic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> success = <span class="SKwd">false</span>
    <span class="SKwd">let</span> x       = <span class="SNum">6</span>

    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">5</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">to</span> <span class="SNum">15</span>:
        success = <span class="SKwd">true</span>
    }

    <span class="SItr">@assert</span>(success)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Overlapping Ranges </h4>
<p>When ranges overlap, the <b>first matching range</b> is executed; later overlaps are ignored. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> success = <span class="SKwd">false</span>
    <span class="SKwd">let</span> x       = <span class="SNum">6</span>

    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">10</span>:
        success = <span class="SKwd">true</span>
    <span class="SLgc">case</span> <span class="SNum">5</span> <span class="SLgc">until</span> <span class="SNum">15</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SItr">@assert</span>(success)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Using the <span class="code-inline">where</span> Clause in <span class="code-inline">switch</span> </h4>
<p>Add a <span class="code-inline">where</span> clause to a <span class="code-inline">case</span> to refine matching conditions based on additional logic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">6</span>
    <span class="SKwd">let</span> y = <span class="SNum">10</span>

    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">where</span> y == <span class="SNum">9</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">where</span> y == <span class="SNum">10</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Using <span class="code-inline">where</span> with <span class="code-inline">default</span> </h4>
<p>A <span class="code-inline">where</span> clause can also modify the <span class="code-inline">default</span> case for conditional fallbacks. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">7</span>
    <span class="SKwd">let</span> y = <span class="SNum">10</span>

    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">where</span> y == <span class="SNum">10</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">7</span> <span class="SLgc">where</span> y == <span class="SNum">9</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">default</span> <span class="SLgc">where</span> y == <span class="SNum">10</span>:
        <span class="SLgc">break</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Switching on Type with <span class="code-inline">any</span> or <span class="code-inline">interface</span> </h4>
<p>When switching on <span class="code-inline">any</span> or <span class="code-inline">interface</span> types, cases match based on the <b>underlying runtime type</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"value"</span>

    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="STpe">string</span>:
        <span class="SLgc">break</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Switch Statement with Type Guard and Variable Binding </h4>
<p>You can bind a matched type or value to a variable using <span class="code-inline">as</span>, allowing direct access inside the <span class="code-inline">case</span> block. You may also use <span class="code-inline">where</span> for conditional refinement. </p>
<p>Example 1: Simple Type Binding </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"value"</span>

    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="STpe">string</span> <span class="SLgc">as</span> str:
        <span class="SItr">@assert</span>(str == <span class="SStr">"value"</span>)
        <span class="SLgc">break</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<p>Example 2: Type Binding with <span class="code-inline">where</span> Clause </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"value"</span>

    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="STpe">string</span> <span class="SLgc">as</span> str <span class="SLgc">where</span> str == <span class="SStr">"value"</span>:
        <span class="SItr">@assert</span>(str == <span class="SStr">"value"</span>)
        <span class="SLgc">break</span>
    <span class="SLgc">case</span> <span class="STpe">string</span> <span class="SLgc">as</span> str <span class="SLgc">where</span> str == <span class="SStr">"not_a_value"</span>:
        <span class="SItr">@assert</span>(str == <span class="SStr">"not_a_value"</span>)
        <span class="SLgc">break</span>
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_005_switch_swg">Switch Without an Expression </h4>
<p>A <span class="code-inline">switch</span> without an expression behaves like an <span class="code-inline">if</span>/<span class="code-inline">elif</span> chain. Each <span class="code-inline">case</span> is evaluated in order, executing the first one that evaluates to <span class="code-inline">true</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value  = <span class="SNum">6</span>
    <span class="SKwd">let</span> value1 = <span class="SStr">"true"</span>

    <span class="SLgc">switch</span>
    {
    <span class="SLgc">case</span> value == <span class="SNum">6</span> <span class="SLgc">or</span> value &gt; <span class="SNum">10</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
        <span class="SLgc">fallthrough</span>
    <span class="SLgc">case</span> value1 == <span class="SStr">"true"</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>

<h3 id="_005_000_control_flow_swg__005_006_break_swg">Break </h3><h4 id="_005_000_control_flow_swg__005_006_break_swg">Introduction to <span class="code-inline">break</span> in Swag </h4>
<p>The <span class="code-inline">break</span> statement exits the nearest enclosing control structure. It works with <span class="code-inline">for</span>, <span class="code-inline">foreach</span>, <span class="code-inline">while</span>, and <span class="code-inline">switch</span>. Use it to stop a loop early or to leave a switch case. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Immediately exits the loop body</span>
    <span class="SLgc">for</span> <span class="SNum">10</span> <span class="SLgc">do</span>
        <span class="SLgc">break</span>

    <span class="SCmt">// Exits after the first iteration</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span> <span class="SLgc">do</span>
        <span class="SLgc">break</span>

    <span class="SCmt">// Not reached because the condition is false</span>
    <span class="SLgc">while</span> <span class="SKwd">false</span> <span class="SLgc">do</span>
        <span class="SLgc">break</span>
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Default Behavior </h4>
<p>By default, <span class="code-inline">break</span> exits only the innermost loop or control structure. Outer structures continue to run. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        <span class="SLgc">for</span> <span class="SNum">10</span>
        {
            <span class="SCmt">// Exits only the inner loop</span>
            <span class="SLgc">break</span>
        }
        <span class="SCmt">// Outer loop continues</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Named Scopes with <span class="code-inline">#scope</span> </h4>
<p>Define a named scope with <span class="code-inline">#scope(Name)</span>. 'break to Name' exits that scope from anywhere inside it. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmp">#scope</span>(<span class="SCst">BigScope</span>)
    {
        <span class="SLgc">for</span> <span class="SNum">10</span>
        {
            cpt += <span class="SNum">1</span>
            <span class="SLgc">break</span> <span class="SLgc">to</span> <span class="SCst">BigScope</span> <span class="SCmt">// Leave the whole 'BigScope'</span>
        }

        <span class="SItr">@assert</span>(<span class="SKwd">false</span>) <span class="SCmt">// Unreachable</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Using <span class="code-inline">continue</span> with Named Scopes </h4>
<p>Within a scope, <span class="code-inline">continue</span> restarts execution from the beginning of that scope. Combine a terminating condition with a plain <span class="code-inline">break</span> to end the scope loop. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmp">#scope</span>(<span class="SCst">Loop</span>)
    {
        cpt += <span class="SNum">1</span>
        <span class="SLgc">if</span> cpt == <span class="SNum">5</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span> <span class="SCmt">// End the 'Loop' scope</span>
        <span class="SLgc">continue</span> <span class="SCmt">// Jump back to the start of 'Loop'</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">5</span>)
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Unnamed Scopes </h4>
<p>Scopes can be unnamed. <span class="code-inline">break</span> exits the current (unnamed) scope immediately. This can simplify multi-branch flows. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> cpt = <span class="SNum">0</span>

    <span class="SCmp">#scope</span>
    {
        <span class="SLgc">if</span> cpt == <span class="SNum">1</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span>)
            <span class="SLgc">break</span>
        }

        <span class="SLgc">if</span> cpt == <span class="SNum">2</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">2</span>)
            <span class="SLgc">break</span>
        }

        <span class="SLgc">if</span> cpt == <span class="SNum">3</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
            <span class="SLgc">break</span>
        }
    }
}</span></div>
<h4 id="_005_000_control_flow_swg__005_006_break_swg">Scopes with Simple Statements </h4>
<p>A scope label can precede a simple statement. 'break to Label' exits to just after that labeled statement. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#scope</span>(<span class="SCst">Up</span>)
    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        <span class="SLgc">for</span> <span class="SNum">10</span>
        {
            <span class="SLgc">if</span> <span class="SItr">@index</span> == <span class="SNum">5</span> <span class="SLgc">do</span>
                <span class="SLgc">break</span> <span class="SLgc">to</span> <span class="SCst">Up</span> <span class="SCmt">// Exit to after the labeled 'for'</span>
        }

        <span class="SItr">@assert</span>(<span class="SKwd">false</span>) <span class="SCmt">// Unreachable</span>
    }
}</span></div>

<h2 id="_006_000_structs_swg">Structs </h2>
<h3 id="_006_000_structs_swg__006_001_declaration_swg">Declaration </h3><h4 id="_006_000_structs_swg__006_001_declaration_swg">Basic Struct Declaration </h4>
<p>This section illustrates a basic <span class="code-inline">struct</span> declaration in Swag. Notice that the <span class="code-inline">var</span> keyword is not required when declaring fields within the struct. Each field is defined with a specific type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        name: <span class="STpe">string</span> <span class="SCmt">// Field 'name' of type 'string'</span>
    }

    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:        <span class="STpe">s32</span>          <span class="SCmt">// Field 'x' of type 's32'</span>
        y, z:     <span class="STpe">s32</span>          <span class="SCmt">// Fields 'y' and 'z' of type 's32', declared together</span>
        val:      <span class="STpe">bool</span>         <span class="SCmt">// Field 'val' of type 'bool'</span>
        myS:      <span class="SCst">MyStruct</span>     <span class="SCmt">// Field 'myS' of type 'MyStruct', demonstrating a nested struct</span>
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Field Separators </h4>
<p>Fields within a struct can be separated by either a comma <span class="code-inline">,</span> or a semicolon <span class="code-inline">;</span>. The trailing separator is optional and can be omitted. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Fields separated by commas</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        name: <span class="STpe">string</span>, val1: <span class="STpe">bool</span>
    }

    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span> { x: <span class="STpe">s32</span>, y, z: <span class="STpe">s32</span>, val: <span class="STpe">bool</span>, myS: <span class="SCst">MyStruct</span> }
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Anonymous Structs </h4>
<p>Structs can be declared anonymously when used as variable types. This is particularly useful for lightweight, temporary groupings of data. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> tuple: <span class="SKwd">struct</span>
    {
        x:     <span class="STpe">f32</span>     <span class="SCmt">// Field 'x' of type 'f32'</span>
        y:     <span class="STpe">f32</span>     <span class="SCmt">// Field 'y' of type 'f32'</span>
    }

    <span class="SKwd">var</span> tuple1: <span class="SKwd">struct</span>
    {
        x, y: <span class="STpe">f32</span> <span class="SCmt">// Anonymous struct with fields 'x' and 'y' of type 'f32'</span>
    }

    tuple.x = <span class="SNum">1.0</span>
    tuple.y = <span class="SNum">2.0</span>
    <span class="SItr">@assert</span>(tuple.x == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(tuple.y == <span class="SNum">2.0</span>)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        rgb: <span class="SKwd">struct</span>
        {
            x, y, z: <span class="STpe">f32</span> <span class="SCmt">// Nested anonymous struct for RGB values</span>
        }

        hsl: <span class="SKwd">struct</span>
        {
            h, s, l: <span class="STpe">f32</span> <span class="SCmt">// Nested anonymous struct for HSL values</span>
        }
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Default Field Values </h4>
<p>Fields within a struct can be initialized with default values, providing a convenient way to ensure fields are set to a known state. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x:     <span class="STpe">s32</span> = <span class="SNum">666</span>          <span class="SCmt">// Field 'x' initialized with default value 666</span>
        y:     <span class="STpe">string</span> = <span class="SStr">"454"</span>     <span class="SCmt">// Field 'y' initialized with default value '454'</span>
    }

    <span class="SKwd">let</span> v = <span class="SCst">MyStruct</span>{} <span class="SCmt">// Initializing struct with default values</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">666</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SStr">"454"</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Struct Initialization </h4>
<p>Struct variables can be initialized in multiple ways, providing flexibility in how you set up your structs. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x, y: <span class="STpe">s32</span> = <span class="SNum">1</span> <span class="SCmt">// Both 'x' and 'y' initialized to 1</span>
    }

    <span class="SCmt">// Default initialization</span>
    <span class="SKwd">let</span> v0: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(v0.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(v0.y == <span class="SNum">1</span>)

    <span class="SCmt">// Positional initialization</span>
    <span class="SKwd">let</span> v1: <span class="SCst">MyStruct</span>{<span class="SNum">10</span>, <span class="SNum">20</span>}
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">20</span>)

    <span class="SCmt">// Named initialization</span>
    <span class="SKwd">let</span> v2 = <span class="SCst">MyStruct</span>{y: <span class="SNum">20</span>}
    <span class="SItr">@assert</span>(v2.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(v2.y == <span class="SNum">20</span>)

    <span class="SCmt">// Tuple initialization</span>
    <span class="SKwd">let</span> v3: <span class="SCst">MyStruct</span> = {<span class="SNum">10</span>, <span class="SNum">20</span>}
    <span class="SItr">@assert</span>(v3.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(v3.y == <span class="SNum">20</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Const Structs </h4>
<p>A struct can be defined as a constant, provided its values can be evaluated at compile time. This ensures immutability throughout program execution. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x:     <span class="STpe">s32</span> = <span class="SNum">666</span>
        y:     <span class="STpe">string</span> = <span class="SStr">"454"</span>
    }

    <span class="SKwd">const</span> <span class="SCst">X</span>: <span class="SCst">MyStruct</span>{<span class="SNum">50</span>, <span class="SStr">"value"</span>}

    <span class="SCmp">#assert</span>(<span class="SCst">X</span>.x == <span class="SNum">50</span>) <span class="SCmt">// Compile-time assertion</span>
    <span class="SCmp">#assert</span>(<span class="SCst">X</span>.y == <span class="SStr">"value"</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_001_declaration_swg">Structs as Function Arguments </h4>
<p>Functions can take a struct as an argument. This is done by reference, with no copy made — equivalent to passing a const reference in C++. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct3</span> { x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span> }

<span class="SKwd">func</span> <span class="SFct">toto</span>(v: <span class="SCst">Struct3</span>)
{
    <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)
}

<span class="SKwd">func</span> <span class="SFct">titi</span>(v: <span class="SCst">Struct3</span>)
{
    <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Calling with explicit values</span>
    <span class="SFct">toto</span>(<span class="SCst">Struct3</span>{<span class="SNum">5</span>, <span class="SNum">5</span>, <span class="SNum">666</span>})

    <span class="SCmt">// Type inferred from arguments</span>
    <span class="SFct">toto</span>({<span class="SNum">5</span>, <span class="SNum">5</span>, <span class="SNum">666</span>})

    <span class="SCmt">// Partial initialization</span>
    <span class="SFct">titi</span>({<span class="SNum">5</span>})
    <span class="SFct">titi</span>({<span class="SNum">5</span>, <span class="SNum">666</span>})

    <span class="SCmt">// Named field initialization</span>
    <span class="SFct">titi</span>({x: <span class="SNum">5</span>, z: <span class="SNum">5</span>})
}</span></div>

<h3 id="_006_000_structs_swg__006_002_impl_swg">Impl </h3><h4 id="_006_000_structs_swg__006_002_impl_swg">Struct Methods and Constants </h4>
<p>In Swag, structs can encapsulate methods and constants within them using the <span class="code-inline">impl</span> block. This keeps related functionality close to the data it operates on. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ExportType("methods")]</span> <span class="SCmt">// Enable method reflection for this struct type</span>
<span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
{
    x:     <span class="STpe">s32</span> = <span class="SNum">5</span>      <span class="SCmt">// Default 5</span>
    y:     <span class="STpe">s32</span> = <span class="SNum">10</span>     <span class="SCmt">// Default 10</span>
    z:     <span class="STpe">s32</span> = <span class="SNum">20</span>     <span class="SCmt">// Default 20</span>
}

<span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SKwd">const</span> <span class="SCst">MyConst</span> = <span class="SKwd">true</span> <span class="SCmt">// Constant in the struct's namespace</span>

    <span class="SKwd">func</span> <span class="SFct">returnTrue</span>() =&gt; <span class="SKwd">true</span>
}</span></div>
<p>To access the constant or the function, use the <span class="code-inline">MyStruct</span> namespace. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SCst">MyStruct</span>.<span class="SCst">MyConst</span>)
    <span class="SItr">@assert</span>(<span class="SCst">MyStruct</span>.<span class="SFct">returnTrue</span>())
}</span></div>
<h4 id="_006_000_structs_swg__006_002_impl_swg">Multiple <span class="code-inline">impl</span> Blocks </h4>
<p>Swag allows multiple <span class="code-inline">impl</span> blocks for the same struct. Inside methods, <span class="code-inline">me</span> refers to the current instance. You can also name the receiver explicitly. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SCmt">// 'me' is implicitly 'var me: MyStruct'</span>
    <span class="SKwd">func</span> <span class="SFct">returnX</span>(<span class="STpe">me</span>) =&gt; <span class="STpe">me</span>.x
    <span class="SKwd">func</span> <span class="SFct">returnY</span>(<span class="STpe">me</span>) =&gt; <span class="STpe">me</span>.y

    <span class="SCmt">// Explicit receiver name and type</span>
    <span class="SKwd">func</span> <span class="SFct">returnZ</span>(self: <span class="SCst">MyStruct</span>) =&gt; self.z
}</span></div>
<h4 id="_006_000_structs_swg__006_002_impl_swg">Method Syntax Sugar </h4>
<p>Using <span class="code-inline">mtd</span> makes the first parameter implicitly <span class="code-inline">me</span>. Using 'mtd const' makes it 'const me'. This simplifies common patterns. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">methodReturnX</span>()  =&gt; <span class="STpe">me</span>.x <span class="SCmt">// Equivalent to 'func methodReturnX(me) =&gt; me.x'</span>
    <span class="SKwd">func</span> <span class="SFct">funcReturnX</span>(<span class="STpe">me</span>) =&gt; <span class="STpe">me</span>.x
    <span class="SKwd">func</span> <span class="SFct">funcReturnY</span>(<span class="STpe">me</span>) =&gt; .x <span class="SCmt">// 'me' can be omitted</span>
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> c: <span class="SCst">MyStruct</span>

    <span class="SItr">@assert</span>(c.<span class="SFct">returnX</span>() == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(c.<span class="SFct">methodReturnX</span>() == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(c.<span class="SFct">funcReturnX</span>() == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(c.<span class="SFct">returnY</span>() == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(c.<span class="SFct">returnZ</span>() == <span class="SNum">20</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_002_impl_swg">Method Reflection </h4>
<p>To enable reflection on methods in an <span class="code-inline">impl</span> block, annotate the struct with <span class="code-inline">#[Swag.ExportType("methods")]</span>. The <span class="code-inline">typeinfo</span> for the struct then exposes a <span class="code-inline">methods</span> array that you can traverse to retrieve function pointers. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Type alias for a function pointer taking 'MyStruct' and returning 's32'</span>
    <span class="SKwd">alias</span> <span class="SCst">Lambda</span> = <span class="SKwd">func</span>(<span class="SCst">MyStruct</span>)-&gt;<span class="STpe">s32</span>

    <span class="SKwd">var</span> fnX: <span class="SCst">Lambda</span>
    <span class="SKwd">var</span> fnY: <span class="SCst">Lambda</span>
    <span class="SKwd">var</span> fnZ: <span class="SCst">Lambda</span>

    <span class="SKwd">let</span> t = <span class="SCst">MyStruct</span>
    <span class="SLgc">foreach</span> p <span class="SLgc">in</span> t.methods
    {
        <span class="SCmt">// 'p.value' is the function pointer; cast it to the expected type</span>
        <span class="SLgc">switch</span> p.name
        {
        <span class="SLgc">case</span> <span class="SStr">"returnX"</span>:
            fnX = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value
        <span class="SLgc">case</span> <span class="SStr">"returnY"</span>:
            fnY = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value
        <span class="SLgc">case</span> <span class="SStr">"returnZ"</span>:
            fnZ = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value
        }
    }

    <span class="SKwd">let</span> v: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(<span class="SFct">fnX</span>(v) == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(<span class="SFct">fnY</span>(v) == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(<span class="SFct">fnZ</span>(v) == <span class="SNum">20</span>)
}</span></div>

<h3 id="_006_000_structs_swg__006_003_offset_swg">Offset </h3><h4 id="_006_000_structs_swg__006_003_offset_swg">Custom Field Layout with <span class="code-inline">Swag.Offset</span> </h4>
<p>You can force the layout of a field within a struct using the <span class="code-inline">Swag.Offset</span> attribute. This lets you manually specify the memory offset of a field — useful for custom memory layouts, such as overlapping fields or sharing memory space between fields. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x:   <span class="STpe">s32</span>

        <span class="SCmt">// 'y' is located at the same offset as 'x', so they share the same memory.</span>
        <span class="SCmt">// Changing one reflects in the other (overlay behavior).</span>
        <span class="SAtr">#[Swag.Offset("x")]</span>
        y:   <span class="STpe">s32</span>
    }

    <span class="SCmt">// Even with two fields, they overlap, so the struct uses only 4 bytes.</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct</span>) == <span class="SNum">4</span>)

    <span class="SKwd">var</span> v = <span class="SCst">MyStruct</span>{}
    v.x = <span class="SNum">666</span>

    <span class="SCmt">// Since 'x' and 'y' share memory, updating 'x' updates 'y'.</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_003_offset_swg">Using <span class="code-inline">Swag.Offset</span> for Indexed Field Access </h4>
<p>Here, <span class="code-inline">Swag.Offset</span> is used so an indexed array aliases multiple fields, enabling indexed access to those fields via a single view. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x, y, z: <span class="STpe">f32</span>

        <span class="SCmt">// 'idx' aliases the same memory as 'x', 'y', and 'z'.</span>
        <span class="SCmt">// Access 'x', 'y', and 'z' through indexed reads/writes on 'idx'.</span>
        <span class="SAtr">#[Swag.Offset("x")]</span>
        idx: [<span class="SNum">3</span>] <span class="STpe">f32</span>
    }

    <span class="SKwd">var</span> v: <span class="SCst">MyStruct</span>
    v.x = <span class="SNum">10</span>; v.y = <span class="SNum">20</span>; v.z = <span class="SNum">30</span>

    <span class="SCmt">// Each index in 'idx' maps directly to x/y/z.</span>
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">0</span>] == v.x)
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">1</span>] == v.y)
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">2</span>] == v.z)
}</span></div>

<h3 id="_006_000_structs_swg__006_004_packing_swg">Packing </h3><h4 id="_006_000_structs_swg__006_004_packing_swg">Default Struct Packing </h4>
<p>By default, Swag aligns struct fields similarly to the C programming language. Each field is aligned based on the size of its type, ensuring optimal memory access. This default behavior can be explicitly specified using <span class="code-inline">#[Swag.Pack(0)]</span>, meaning no additional packing adjustments are applied. Below is an example illustrating this default alignment strategy. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x:     <span class="STpe">bool</span>     <span class="SCmt">// offset 0: aligned to 1 byte (no padding needed)</span>
        y:     <span class="STpe">s32</span>      <span class="SCmt">// offset 4: aligned to 4 bytes (3 bytes of padding before y)</span>
        z:     <span class="STpe">s64</span>      <span class="SCmt">// offset 8: aligned to 8 bytes (no padding needed)</span>
    }

    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct</span>.x) == <span class="SNum">0</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct</span>.y) == <span class="SNum">4</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct</span>.z) == <span class="SNum">8</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct</span>) == <span class="SNum">16</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_004_packing_swg">Reducing Packing </h4>
<p>Swag allows reducing the packing of struct fields using the <span class="code-inline">#[Swag.Pack]</span> attribute. This attribute specifies the alignment value applied to each field, enabling more compact struct representations. Below are examples demonstrating different levels of packing. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Pack(1)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:     <span class="STpe">bool</span>     <span class="SCmt">// offset 0: 1 byte (no padding)</span>
        y:     <span class="STpe">s32</span>      <span class="SCmt">// offset 1: 4 bytes (no padding)</span>
    }
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct1</span>.x) == <span class="SNum">0</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct1</span>.y) == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">5</span>)

    <span class="SAtr">#[Swag.Pack(2)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x:     <span class="STpe">bool</span>     <span class="SCmt">// offset 0: 1 byte</span>
        y:     <span class="STpe">s32</span>      <span class="SCmt">// offset 2: 4 bytes (1 byte of padding before y)</span>
    }
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct2</span>.x) == <span class="SNum">0</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct2</span>.y) == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct2</span>) == <span class="SNum">6</span>)

    <span class="SAtr">#[Swag.Pack(4)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct3</span>
    {
        x:     <span class="STpe">bool</span>     <span class="SCmt">// offset 0: 1 byte</span>
        y:     <span class="STpe">s64</span>      <span class="SCmt">// offset 4: 8 bytes (3 bytes of padding before y)</span>
    }
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct3</span>.x) == <span class="SNum">0</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct3</span>.y) == <span class="SNum">4</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct3</span>) == <span class="SNum">12</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_004_packing_swg">Struct Size and Alignment </h4>
<p>The total size of a struct in Swag is always a multiple of the largest alignment value among its fields. This ensures correct alignment when used within larger data structures or arrays. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:     <span class="STpe">s32</span>      <span class="SCmt">// 4 bytes</span>
        y:     <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
        <span class="SCmt">// 3 bytes of padding to align to s32 size</span>
    }

    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">8</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_004_packing_swg">Enforcing Alignment with <span class="code-inline">Swag.Align</span> </h4>
<p>Swag provides the <span class="code-inline">#[Swag.Align]</span> attribute to enforce specific alignment constraints on an entire struct. Use it to meet hardware or performance requirements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:     <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
        y:     <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
    }
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct1</span>.x) == <span class="SNum">0</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct1</span>.y) == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">2</span>)

    <span class="SAtr">#[Swag.Align(8)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x:     <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
        y:     <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
        <span class="SCmt">// 6 bytes of padding to align struct size to 8</span>
    }
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct2</span>.x) == <span class="SNum">0</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#offsetof</span>(<span class="SCst">MyStruct2</span>.y) == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct2</span>) == <span class="SNum">8</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_004_packing_swg">Field-Specific Alignment </h4>
<p>Set specific alignment values for individual fields using the <span class="code-inline">#[Swag.Align]</span> attribute. This provides fine-grained control over memory layout for low-level optimizations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:   <span class="STpe">bool</span> <span class="SCmt">// offset 0: 1 byte</span>
        <span class="SAtr">#[Swag.Align(8)]</span>
        y:   <span class="STpe">bool</span> <span class="SCmt">// offset 8: aligned to 8 bytes (7 bytes of padding before y)</span>
    }
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">9</span>)

    <span class="SAtr">#[Swag.Align(8)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x:   <span class="STpe">bool</span> <span class="SCmt">// offset 0: 1 byte</span>
        <span class="SAtr">#[Swag.Align(4)]</span>
        y:   <span class="STpe">bool</span> <span class="SCmt">// offset 4: aligned to 4 bytes (3 bytes of padding before y)</span>
        <span class="SCmt">// 3 bytes of padding to align struct size to 8</span>
    }
    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(<span class="SCst">MyStruct2</span>) == <span class="SNum">8</span>)
}</span></div>

<h3 id="_006_000_structs_swg__006_005_special_functions_swg">Special Functions </h3><p>A struct in Swag can define special operations within the <span class="code-inline">impl</span> block. These operations are predefined and recognized by the compiler. This enables the ability to overload operators and customize behavior when interacting with the struct. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct</span>
{
    x, y: <span class="STpe">s32</span> <span class="SCmt">// Two properties, x and y, of type s32 (signed 32-bit integer)</span>
}

<span class="SCmt">// Type aliases used in the examples below</span>
<span class="SKwd">alias</span> <span class="SCst">OneType</span>      = <span class="STpe">bool</span> <span class="SCmt">// Alias for boolean type</span>
<span class="SKwd">alias</span> <span class="SCst">AnotherType</span>  = <span class="STpe">s32</span> <span class="SCmt">// Alias for signed 32-bit integer type</span>
<span class="SKwd">alias</span> <span class="SCst">WhateverType</span> = <span class="STpe">bool</span> <span class="SCmt">// Another alias for boolean type</span>

<span class="SCmt">// Implementation: lifecycle, accessors, conversions, comparisons, assignments,</span>
<span class="SCmt">// indexing, operators, and iteration hooks</span>
<span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SCmt">// -------------------------------------------------------------------------</span>
    <span class="SCmt">// Lifecycle hooks</span>
    <span class="SCmt">// -------------------------------------------------------------------------</span>

    <span class="SCmt">// Called whenever a variable of this struct is about to be destroyed (C++ destructor-like)</span>
    <span class="SKwd">func</span> <span class="SFct">opDrop</span>(<span class="STpe">me</span>) {}

    <span class="SCmt">// Invoked after a raw copy operation has been performed from one value to another</span>
    <span class="SKwd">func</span> <span class="SFct">opPostCopy</span>(<span class="STpe">me</span>) {}

    <span class="SCmt">// Called after a move semantic operation has been executed from one value to another</span>
    <span class="SKwd">func</span> <span class="SFct">opPostMove</span>(<span class="STpe">me</span>) {}

    <span class="SCmt">// -------------------------------------------------------------------------</span>
    <span class="SCmt">// Element & slice access</span>
    <span class="SCmt">// -------------------------------------------------------------------------</span>

    <span class="SCmt">// Access a value by slicing with the [low..up] notation. Returns a string or a slice.</span>
    <span class="SKwd">func</span> <span class="SFct">opSlice</span>(<span class="STpe">me</span>, low, up: <span class="STpe">u64</span>)-&gt;<span class="STpe">string</span> { <span class="SLgc">return</span> <span class="SStr">"true"</span>; }

    <span class="SCmt">// Access a value by its index. The index is of type OneType, and it returns a WhateverType.</span>
    <span class="SKwd">func</span> <span class="SFct">opIndex</span>(<span class="STpe">me</span>, index: <span class="SCst">OneType</span>)-&gt;<span class="SCst">WhateverType</span> { <span class="SLgc">return</span> <span class="SKwd">true</span>; }

    <span class="SCmt">// Called when @countof is used (typically in a 'for' block) to return the count of elements</span>
    <span class="SKwd">func</span> <span class="SFct">opCount</span>(<span class="STpe">me</span>)-&gt;<span class="STpe">u64</span> { <span class="SLgc">return</span> <span class="SNum">0</span>; }

    <span class="SCmt">// Called when @dataof is used; returns a pointer to the underlying data of type WhateverType</span>
    <span class="SKwd">func</span> <span class="SFct">opData</span>(<span class="STpe">me</span>)-&gt;<span class="SItr">#null</span> *<span class="SCst">WhateverType</span> { <span class="SLgc">return</span> <span class="SKwd">null</span>; }

    <span class="SCmt">// -------------------------------------------------------------------------</span>
    <span class="SCmt">// Conversions (cast)</span>
    <span class="SCmt">// -------------------------------------------------------------------------</span>

    <span class="SCmt">// Custom casting between the struct and another type; can be overloaded with different return types</span>
    <span class="SCmt">// Example: var x = cast(OneType) v</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opCast</span>(<span class="STpe">me</span>)-&gt;<span class="SCst">OneType</span> { <span class="SLgc">return</span> <span class="SKwd">true</span>; }
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opCast</span>(<span class="STpe">me</span>)-&gt;<span class="SCst">AnotherType</span> { <span class="SLgc">return</span> <span class="SNum">0</span>; }

    <span class="SCmt">// -------------------------------------------------------------------------</span>
    <span class="SCmt">// Equality & ordering</span>
    <span class="SCmt">// -------------------------------------------------------------------------</span>

    <span class="SCmt">// Compare the struct value with another; used in '==' and '!=' operations</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opEquals</span>(<span class="STpe">me</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="STpe">bool</span> { <span class="SLgc">return</span> <span class="SKwd">false</span>; }
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opEquals</span>(<span class="STpe">me</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="STpe">bool</span> { <span class="SLgc">return</span> <span class="SKwd">false</span>; }

    <span class="SCmt">// Three-way comparison; returns -1, 0, or 1 (used for '&lt;', '&gt;', '&lt;=', '&gt;=', '&lt;=&gt;')</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opCmp</span>(<span class="STpe">me</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="STpe">s32</span> { <span class="SLgc">return</span> <span class="SNum">0</span>; }
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opCmp</span>(<span class="STpe">me</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="STpe">s32</span> { <span class="SLgc">return</span> <span class="SNum">0</span>; }

    <span class="SCmt">// -------------------------------------------------------------------------</span>
    <span class="SCmt">// Assignment</span>
    <span class="SCmt">// -------------------------------------------------------------------------</span>

    <span class="SCmt">// Direct assignment via '='</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opAffect</span>(<span class="STpe">me</span>, other: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opAffect</span>(<span class="STpe">me</span>, other: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Assign a literal value with a specific suffix to the struct (generic)</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(suffix: <span class="STpe">string</span>) <span class="SFct">opAffectLiteral</span>(<span class="STpe">me</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(suffix: <span class="STpe">string</span>) <span class="SFct">opAffectLiteral</span>(<span class="STpe">me</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Assign to an indexed position via '[?] ='</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opIndexAffect</span>(<span class="STpe">me</span>, index: <span class="SCst">OneType</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">opIndexAffect</span>(<span class="STpe">me</span>, index: <span class="SCst">OneType</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// -------------------------------------------------------------------------</span>
    <span class="SCmt">// Operators (binary, unary, compound assignment)</span>
    <span class="SCmt">// -------------------------------------------------------------------------</span>

    <span class="SCmt">// Binary operation with 'op' representing the operator as a string</span>
    <span class="SCmt">// Examples: '+', '-', '*', '/', '%', '|', '&', '^', '&lt;&lt;', '&gt;&gt;'</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opBinary</span>(<span class="STpe">me</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="SCst">Struct</span> { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opBinary</span>(<span class="STpe">me</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="SCst">Struct</span> { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }

    <span class="SCmt">// Unary operation with 'op' representing the operator as a string</span>
    <span class="SCmt">// Examples: '!', '-', '~'</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opUnary</span>(<span class="STpe">me</span>)-&gt;<span class="SCst">Struct</span> { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }

    <span class="SCmt">// Assignment with operator 'op' (compound assignments)</span>
    <span class="SCmt">// Examples: '+=', '-=', '*=', '/=', '%=', '|=', '&=', '^=', '&lt;&lt;=', '&gt;&gt;='</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opAssign</span>(<span class="STpe">me</span>, other: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opAssign</span>(<span class="STpe">me</span>, other: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Indexed assignment with operator 'op'</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opIndexAssign</span>(<span class="STpe">me</span>, index: <span class="SCst">OneType</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opIndexAssign</span>(<span class="STpe">me</span>, index: <span class="SCst">OneType</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// -------------------------------------------------------------------------</span>
    <span class="SCmt">// Iteration (foreach support)</span>
    <span class="SCmt">// -------------------------------------------------------------------------</span>

    <span class="SCmt">// Called in a 'foreach' block to iterate over the struct's elements.</span>
    <span class="SCmt">// Multiple versions can be defined by adding a name after 'opVisit'.</span>
    <span class="SAtr">#[Swag.Macro]</span>
    {
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisit</span>(<span class="STpe">me</span>, stmt: <span class="SItr">#code</span> <span class="STpe">void</span>) {}
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitWhatever</span>(<span class="STpe">me</span>, stmt: <span class="SItr">#code</span> <span class="STpe">void</span>) {}
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitAnother</span>(<span class="STpe">me</span>, stmt: <span class="SItr">#code</span> <span class="STpe">void</span>) {}
    }
}</span></div>

<h3 id="_006_000_structs_swg__006_006_custom_assignment_swg">Custom Assignment </h3><h4 id="_006_000_structs_swg__006_006_custom_assignment_swg">Custom Assignment Behavior with <span class="code-inline">opAffect</span> </h4>
<p>The <span class="code-inline">opAffect</span> method in Swag allows you to define custom assignment behaviors for your struct using the <span class="code-inline">=</span> operator. By overloading <span class="code-inline">opAffect</span>, you can handle assignments of different types and control how your struct responds. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct</span>
{
    x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span> <span class="SCmt">// Fields with default value 666</span>
}

<span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SCmt">// Overload for 's32'</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">s32</span>)
    {
        <span class="STpe">me</span>.x, <span class="STpe">me</span>.y = value
    }

    <span class="SCmt">// Overload for 'bool'</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">bool</span>)
    {
        <span class="STpe">me</span>.x, <span class="STpe">me</span>.y = value ? <span class="SNum">1</span> : <span class="SNum">0</span>
    }
}

<span class="SFct">#test</span>
{
    <span class="SKwd">let</span> v: <span class="SCst">Struct</span> = <span class="SNum">4</span>'<span class="STpe">s32</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)

    <span class="SKwd">var</span> v1: <span class="SCst">Struct</span> = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">1</span>)

    v1 = <span class="SKwd">false</span>
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">0</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_006_custom_assignment_swg">Optimizing Initialization with <span class="code-inline">Swag.Complete</span> </h4>
<p>When <span class="code-inline">opAffect</span> completely initializes the struct, mark it with <span class="code-inline">#[Swag.Complete]</span>. This avoids default initialization before assignment for better performance. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SAtr">#[Swag.Complete, Swag.Overload]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">u64</span>)
    {
        <span class="STpe">me</span>.x, <span class="STpe">me</span>.y, <span class="STpe">me</span>.z = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) value
    }

    <span class="SAtr">#[Swag.Implicit, Swag.Overload]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">u16</span>)
    {
        <span class="STpe">me</span>.x, <span class="STpe">me</span>.y = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) value
    }
}

<span class="SFct">#test</span>
{
    <span class="SKwd">let</span> v: <span class="SCst">Struct</span> = <span class="SNum">2</span>'<span class="STpe">u64</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(v.z == <span class="SNum">2</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_006_custom_assignment_swg">Handling Function Arguments and Automatic Conversion </h4>
<p>Function arguments are not automatically converted through <span class="code-inline">opAffect</span> unless <span class="code-inline">Swag.Implicit</span> is used. Otherwise, an explicit cast is required. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>(v: <span class="SCst">Struct</span>)
    {
        <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(v.y == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)
    }

    <span class="SKwd">func</span> <span class="SFct">titi</span>(v: <span class="SCst">Struct</span>)
    {
        <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
    }

    <span class="SCmt">// Explicit cast triggers 'opAffect(s32)'</span>
    <span class="SFct">toto</span>(<span class="SKwd">cast</span>(<span class="SCst">Struct</span>) <span class="SNum">5</span>'<span class="STpe">s32</span>)

    <span class="SCmt">// Implicit conversion via 'opAffect(u16)'</span>
    <span class="SFct">toto</span>(<span class="SNum">5</span>'<span class="STpe">u16</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_006_custom_assignment_swg">Using <span class="code-inline">opAffect</span> in Constant Expressions </h4>
<p>To allow compile-time initialization through <span class="code-inline">opAffect</span>, mark it with <span class="code-inline">#[Swag.ConstExpr]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Vector2</span> { x, y: <span class="STpe">f32</span> }

<span class="SKwd">impl</span> <span class="SCst">Vector2</span>
{
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(one: <span class="STpe">f32</span>)
    {
        <span class="STpe">me</span>.x, <span class="STpe">me</span>.y = one
    }
}

<span class="SKwd">const</span> <span class="SCst">One</span>: <span class="SCst">Vector2</span> = <span class="SNum">1.0</span>
<span class="SCmp">#assert</span>(<span class="SCst">One</span>.x == <span class="SNum">1.0</span>)
<span class="SCmp">#assert</span>(<span class="SCst">One</span>.y == <span class="SNum">1.0</span>)</span></div>

<h3 id="_006_000_structs_swg__006_007_custom_loop_swg">Custom Loop </h3><div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">MyStruct</span> {}</span></div>
<h4 id="_006_000_structs_swg__006_007_custom_loop_swg">Implementing <span class="code-inline">opCount</span> for Iteration </h4>
<p>The <span class="code-inline">opCount</span> method in Swag specifies how many iterations a loop performs when looping over a struct instance. By defining it, you make the struct act like an iterable object with a controlled length. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SCmt">// Return the number of iterations for loops using this struct</span>
    <span class="SKwd">mtd</span> <span class="SFct">opCount</span>() =&gt; <span class="SNum">4</span>'<span class="STpe">u64</span>
}</span></div>
<p>With <span class="code-inline">opCount</span> defined, an instance of <span class="code-inline">MyStruct</span> can be used in loops just like arrays or other iterable types. The loop executes the number of times returned by <span class="code-inline">opCount</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> v = <span class="SCst">MyStruct</span>{}

    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(v) == <span class="SNum">4</span>)

    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> v <span class="SLgc">do</span>
        cpt += <span class="SNum">1</span>

    <span class="SItr">@assert</span>(cpt == <span class="SNum">4</span>)
}</span></div>

<h3 id="_006_000_structs_swg__006_008_custom_iteration_swg">Custom Iteration </h3><div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
{
    x: <span class="STpe">s32</span> = <span class="SNum">10</span>
    y: <span class="STpe">s32</span> = <span class="SNum">20</span>
    z: <span class="STpe">s32</span> = <span class="SNum">30</span>
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Introduction to <span class="code-inline">opVisit</span> </h4>
<p><span class="code-inline">opVisit</span> is a flexible macro for iterating over elements of a struct or any data it owns (dynamic arrays, buffers, object graphs). The <span class="code-inline">#[Swag.Macro]</span> attribute is mandatory. </p>
<p><span class="code-inline">opVisit</span> is generic over two compile-time booleans: - <span class="code-inline">ptr</span>: if true, elements are visited by pointer (address). - <span class="code-inline">back</span>: if true, elements are visited in reverse order. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisit</span>(<span class="STpe">me</span>, stmt: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SCmp">#if</span> ptr <span class="SLgc">do</span>
            <span class="SCmp">#error</span>(<span class="SStr">"Visiting by pointer is not supported in this example."</span>)

        <span class="SCmp">#if</span> back <span class="SLgc">do</span>
            <span class="SCmp">#error</span>(<span class="SStr">"Reverse visiting is not supported in this example."</span>)

        <span class="SCmt">// Visit fields x, y, z in declaration order</span>
        <span class="SLgc">for</span> idx <span class="SLgc">in</span> <span class="SNum">3</span>
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SKwd">var</span> <span class="SItr">#alias0</span>: <span class="STpe">s32</span> = <span class="SKwd">undefined</span>

                <span class="SLgc">switch</span> <span class="SItr">#up</span> idx
                {
                <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">me</span>.x
                <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">me</span>.y
                <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">me</span>.z
                }

                <span class="SKwd">var</span> <span class="SItr">#alias1</span> = <span class="SItr">@index</span>
                <span class="SCmp">#inject</span>(<span class="SItr">#up</span> stmt)
            }
        }
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Iterating Over Struct Fields </h4>
<p>Example usage of <span class="code-inline">opVisit</span> to traverse fields of a struct. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myStruct = <span class="SCst">MyStruct</span>{}
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SLgc">foreach</span> v, i <span class="SLgc">in</span> myStruct
    {
        <span class="SLgc">switch</span> i
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@assert</span>(v == <span class="SNum">10</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@assert</span>(v == <span class="SNum">20</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@assert</span>(v == <span class="SNum">30</span>)
        }
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Extending <span class="code-inline">opVisit</span>: Reverse Order Iteration </h4>
<p>An alternative macro that visits fields in reverse order. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">mtd</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitReverse</span>(stmt: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SLgc">for</span> idx <span class="SLgc">in</span> <span class="SNum">3</span>
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SKwd">var</span> <span class="SItr">#alias0</span>: <span class="STpe">s32</span> = <span class="SKwd">undefined</span>
                <span class="SLgc">switch</span> <span class="SItr">#up</span> idx
                {
                <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">me</span>.z
                <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">me</span>.y
                <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">me</span>.x
                }

                <span class="SKwd">var</span> <span class="SItr">#alias1</span> = <span class="SItr">@index</span>
                <span class="SCmp">#inject</span>(<span class="SItr">#up</span> stmt)
            }
        }
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Reverse Order Iteration </h4>
<p>Using <span class="code-inline">opVisitReverse</span> to iterate fields from last to first. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myStruct = <span class="SCst">MyStruct</span>{}
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SLgc">foreach</span> <span class="SCmp">#Reverse</span> v, i <span class="SLgc">in</span> myStruct
    {
        <span class="SLgc">switch</span> i
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@assert</span>(v == <span class="SNum">30</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@assert</span>(v == <span class="SNum">20</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@assert</span>(v == <span class="SNum">10</span>)
        }
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Visiting Elements in Dynamic Arrays </h4>
<p>Beyond fields, <span class="code-inline">opVisit</span> can target owned collections such as dynamic arrays. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">SliceStruct</span>
{
    buffer: [?] <span class="STpe">s32</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>, <span class="SNum">5</span>]
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Custom <span class="code-inline">opVisit</span> for Dynamic Arrays </h4>
<p>Iterate over <span class="code-inline">buffer</span> elements instead of struct fields. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">SliceStruct</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisit</span>(<span class="STpe">me</span>, stmt: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SLgc">for</span> idx <span class="SLgc">in</span> <span class="SItr">@countof</span>(<span class="STpe">me</span>.buffer)
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SKwd">var</span> <span class="SItr">#alias0</span> = <span class="SItr">#up</span> <span class="STpe">me</span>.buffer[<span class="SItr">#up</span> idx]
                <span class="SKwd">var</span> <span class="SItr">#alias1</span> = <span class="SItr">@index</span>
                <span class="SCmp">#inject</span>(<span class="SItr">#up</span> stmt)
            }
        }
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_008_custom_iteration_swg">Iterating Over a Dynamic Array </h4>
<p>Sum elements of a slice via <span class="code-inline">opVisit</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arrStruct = <span class="SCst">SliceStruct</span>{}
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>

    <span class="SLgc">foreach</span> v, i <span class="SLgc">in</span> arrStruct <span class="SLgc">do</span>
        sum += v

    <span class="SItr">@assert</span>(sum == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span> + <span class="SNum">5</span>)
}</span></div>

<h3 id="_006_000_structs_swg__006_009_custom_copy_and_move_swg">Custom Copy and Move </h3><p>Swag supports both copy and move semantics for structures. In this example, we demonstrate these concepts using a <span class="code-inline">Vector3</span> struct. Although a <span class="code-inline">Vector3</span> typically wouldn't require move semantics (no heap allocation), this illustrates how these features can be implemented and used in Swag. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Vector3</span> { x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span> }

<span class="SKwd">impl</span> <span class="SCst">Vector3</span>
{
    <span class="SCmt">// Called after a copy; customize post-copy behavior here.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opPostCopy</span>()
    {
        .x, .y, .z += <span class="SNum">1</span>
    }

    <span class="SCmt">// Called after a move; customize post-move behavior here.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opPostMove</span>()
    {
        .x, .y, .z += <span class="SNum">2</span>
    }

    <span class="SCmt">// Called before destruction; place cleanup here if needed.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opDrop</span>() {}
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SCst">Vector3</span>{}                  <span class="SCmt">// Default init.</span>
    <span class="SKwd">var</span> b = <span class="SCst">Vector3</span>{<span class="SNum">100</span>, <span class="SNum">200</span>, <span class="SNum">300</span>}     <span class="SCmt">// Custom init.</span>

    <span class="SCmt">// Copy semantics: drop 'a' (if needed), copy 'b' to 'a', then call 'opPostCopy' on 'a'.</span>
    a = b
    <span class="SItr">@assert</span>(a.x == <span class="SNum">101</span>)
    <span class="SItr">@assert</span>(a.y == <span class="SNum">201</span>)
    <span class="SItr">@assert</span>(a.z == <span class="SNum">301</span>)

    <span class="SCmt">// Move semantics with '#move': drop 'a' (if needed), move 'b' to 'a', then call 'opPostMove' on 'a'.</span>
    <span class="SCmt">// With 'opDrop' present, 'b' is reinitialized to defaults (666).</span>
    a = <span class="SItr">#move</span> b
    <span class="SItr">@assert</span>(a.x == <span class="SNum">102</span>)
    <span class="SItr">@assert</span>(a.y == <span class="SNum">202</span>)
    <span class="SItr">@assert</span>(a.z == <span class="SNum">302</span>)
    <span class="SItr">@assert</span>(b.x == <span class="SNum">666</span>)

    <span class="SCmt">// '#nodrop' skips the initial drop of 'a'.</span>
    a = <span class="SItr">#nodrop</span> b <span class="SCmt">// Copy without dropping 'a' first.</span>
    a = <span class="SItr">#nodrop</span> <span class="SItr">#move</span> b <span class="SCmt">// Move without dropping 'a' first.</span>

    <span class="SCmt">// '#moveraw' prevents reinitialization of the source after move. Use with care.</span>
    a = <span class="SItr">#moveraw</span> b
    a = <span class="SItr">#nodrop</span> <span class="SItr">#moveraw</span> b
}</span></div>
<h4 id="_006_000_structs_swg__006_009_custom_copy_and_move_swg">Move Semantics in Functions </h4>
<p>Move semantics can be expressed in function parameters using <span class="code-inline">&&</span> instead of <span class="code-inline">&</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Move overload: takes ownership of 'from' and moves into 'assignTo'.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">assign</span>(assignTo: &<span class="SCst">Vector3</span>, from: &&<span class="SCst">Vector3</span>)
    {
        assignTo = <span class="SItr">#move</span> from
    }

    <span class="SCmt">// Copy overload: copies 'from' into 'assignTo'.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">assign</span>(assignTo: &<span class="SCst">Vector3</span>, from: <span class="SCst">Vector3</span>)
    {
        assignTo = from
    }

    <span class="SKwd">var</span> a  = <span class="SCst">Vector3</span>{<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>}
    <span class="SKwd">var</span> b: <span class="SCst">Vector3</span>

    <span class="SCmt">// Copy path.</span>
    <span class="SFct">assign</span>(&b, a)
    <span class="SItr">@assert</span>(b.x == <span class="SNum">2</span> <span class="SLgc">and</span> b.y == <span class="SNum">3</span> <span class="SLgc">and</span> b.z == <span class="SNum">4</span>) <span class="SCmt">// +1 via 'opPostCopy'.</span>
    <span class="SItr">@assert</span>(a.x == <span class="SNum">1</span> <span class="SLgc">and</span> a.y == <span class="SNum">2</span> <span class="SLgc">and</span> a.z == <span class="SNum">3</span>) <span class="SCmt">// 'a' unchanged.</span>

    <span class="SCmt">// Move path using 'moveref'.</span>
    <span class="SFct">assign</span>(&b, <span class="SKwd">moveref</span> &a)
    <span class="SItr">@assert</span>(b.x == <span class="SNum">3</span> <span class="SLgc">and</span> b.y == <span class="SNum">4</span> <span class="SLgc">and</span> b.z == <span class="SNum">5</span>) <span class="SCmt">// +2 via 'opPostMove'.</span>
    <span class="SItr">@assert</span>(a.x == <span class="SNum">666</span> <span class="SLgc">and</span> a.y == <span class="SNum">666</span> <span class="SLgc">and</span> a.z == <span class="SNum">666</span>) <span class="SCmt">// 'a' reset to defaults after move.</span>
}</span></div>

<h3 id="_006_000_structs_swg__006_010_custom_literals_swg">Custom Literals </h3><h4 id="_006_000_structs_swg__006_010_custom_literals_swg">User-Defined Literals </h4>
<p>User-defined literals extend literal meaning so custom types can be initialized directly with unit-like suffixes (e.g., <span class="code-inline">4</span>ms'). This example defines a <span class="code-inline">Duration</span> type that stores seconds and accepts seconds, milliseconds, minutes, and hours. </p>
<h4 id="_006_000_structs_swg__006_010_custom_literals_swg">Literal Suffixes </h4>
<p>A literal suffix immediately follows a numeric literal to indicate a unit or type, e.g., <span class="code-inline">4'ms</span> means 4 milliseconds. </p>
<p>To support user-defined literals, provide: 1) a type (e.g., <span class="code-inline">Duration</span>), and 2) methods to convert the numeric value according to the suffix. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Represents a delay, expressed in seconds.</span>
<span class="SKwd">struct</span> <span class="SCst">Duration</span>
{
    timeInSeconds: <span class="STpe">f32</span>
}

<span class="SKwd">impl</span> <span class="SCst">Duration</span>
{
    <span class="SCmt">// Initialize from milliseconds without a suffix (implicit path)</span>
    <span class="SAtr">#[Swag.ConstExpr, Swag.Implicit, Swag.Inline]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(valueMs: <span class="STpe">s32</span>)
    {
        <span class="STpe">me</span>.timeInSeconds = valueMs / <span class="SNum">1000.0</span>
    }
}</span></div>
<p>Use the special function <span class="code-inline">opAffectLiteral</span> to convert a value plus suffix. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">Duration</span>
{
    <span class="SCmt">// Handle literals like '5's', '500'ms', '2'min', '1'h'</span>
    <span class="SAtr">#[Swag.ConstExpr, Swag.Implicit, Swag.Inline]</span>
    <span class="SKwd">mtd</span>(suffix: <span class="STpe">string</span>) <span class="SFct">opAffectLiteral</span>(value: <span class="STpe">s32</span>)
    {
        <span class="SCmp">#if</span> suffix == <span class="SStr">"s"</span> <span class="SLgc">do</span>
            <span class="STpe">me</span>.timeInSeconds = value
        <span class="SCmp">#elif</span> suffix == <span class="SStr">"ms"</span> <span class="SLgc">do</span>
            <span class="STpe">me</span>.timeInSeconds = value / <span class="SNum">1000.0</span>
        <span class="SCmp">#elif</span> suffix == <span class="SStr">"min"</span> <span class="SLgc">do</span>
            <span class="STpe">me</span>.timeInSeconds = value * <span class="SNum">60.0</span>
        <span class="SCmp">#elif</span> suffix == <span class="SStr">"h"</span> <span class="SLgc">do</span>
            <span class="STpe">me</span>.timeInSeconds = value * <span class="SNum">3600.0</span>
        <span class="SCmp">#else</span> <span class="SLgc">do</span>
            <span class="SCmp">#error</span>(<span class="SStr">"invalid duration literal suffix '"</span> ++ suffix ++ <span class="SStr">"'"</span>)
    }
}</span></div>
<p>You can then place the suffix right after the numeric literal when the type is <span class="code-inline">Duration</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">toto</span>(x: <span class="SCst">Duration</span>) {}

<span class="SFct">#test</span>
{
    <span class="SKwd">let</span> delay1: <span class="SCst">Duration</span> = <span class="SNum">5</span>'s
    <span class="SKwd">let</span> delay2: <span class="SCst">Duration</span> = <span class="SNum">500</span>'ms
    <span class="SKwd">let</span> delay3: <span class="SCst">Duration</span> = <span class="SNum">2</span>'min
    <span class="SKwd">let</span> delay4: <span class="SCst">Duration</span> = <span class="SNum">1</span>'h

    <span class="SCmt">// Use the 'Duration' type in functions</span>
    <span class="SFct">toto</span>(<span class="SNum">5</span>'ms)
    <span class="SFct">toto</span>(<span class="SNum">100</span>'h)
}</span></div>

<h3 id="_006_000_structs_swg__006_011_interface_swg">Interface </h3><p>Interfaces in Swag are virtual tables (lists of function pointers) that can be associated with a struct. </p>
<p>Unlike C++, the virtual table is not embedded in the struct; it is a separate object. This lets you implement an interface for a struct without changing the struct. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Point2</span> { x, y: <span class="STpe">f32</span> }

<span class="SKwd">struct</span> <span class="SCst">Point3</span> { x, y, z: <span class="STpe">f32</span> }</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Interface Declaration </h4>
<p>Declare interface <span class="code-inline">IReset</span> with two functions <span class="code-inline">set</span> and <span class="code-inline">reset</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">interface</span> <span class="SCst">IReset</span>
{
    <span class="SCmt">// First parameter must be 'me' when using 'func'</span>
    <span class="SKwd">func</span> <span class="SFct">set</span>(<span class="STpe">me</span>, val: <span class="STpe">f32</span>);

    <span class="SCmt">// 'mtd' avoids specifying 'me'</span>
    <span class="SKwd">mtd</span> <span class="SFct">reset</span>();
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Implementing an Interface </h4>
<p>Implement interface <span class="code-inline">IReset</span> for <span class="code-inline">Point2</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">IReset</span> <span class="SLgc">for</span> <span class="SCst">Point2</span>
{
    <span class="SCmt">// Mark with 'impl' to implement an interface function</span>
    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">set</span>(val: <span class="STpe">f32</span>)
    {
        <span class="STpe">me</span>.x = val
        <span class="STpe">me</span>.y = val + <span class="SNum">1</span>
    }

    <span class="SCmt">// 'mtd' is sugar; 'func' also works</span>
    <span class="SKwd">func</span> <span class="SKwd">impl</span> <span class="SFct">reset</span>(<span class="STpe">me</span>)
    {
        <span class="STpe">me</span>.x, <span class="STpe">me</span>.y = <span class="SNum">0</span>
    }

    <span class="SCmt">// Regular methods may also appear in this 'impl'</span>
    <span class="SKwd">mtd</span> <span class="SFct">myOtherMethod</span>() {}
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Implementing the Interface for Another Struct </h4>
<p>Implement <span class="code-inline">IReset</span> for <span class="code-inline">Point3</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">IReset</span> <span class="SLgc">for</span> <span class="SCst">Point3</span>
{
    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">set</span>(val: <span class="STpe">f32</span>)
    {
        <span class="STpe">me</span>.x = val
        <span class="STpe">me</span>.y = val + <span class="SNum">1</span>
        <span class="STpe">me</span>.z = val + <span class="SNum">2</span>
    }

    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">reset</span>()
    {
        <span class="STpe">me</span>.x, <span class="STpe">me</span>.y, <span class="STpe">me</span>.z = <span class="SNum">0</span>
    }
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Using the Interface </h4>
<p>Cast to the interface and call its methods. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>

    <span class="SKwd">var</span> itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    itf.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt2.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt2.y == <span class="SNum">11</span>)

    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    itf.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt3.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt3.y == <span class="SNum">11</span>)
    <span class="SItr">@assert</span>(pt3.z == <span class="SNum">12</span>)
    itf.<span class="SFct">reset</span>()
    <span class="SItr">@assert</span>(pt3.x == <span class="SNum">0</span> <span class="SLgc">and</span> pt3.y == <span class="SNum">0</span> <span class="SLgc">and</span> pt3.z == <span class="SNum">0</span>)
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Accessing Interface Methods Directly </h4>
<p>Implementation functions live under a scope named after the interface. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>

    pt2.<span class="SCst">IReset</span>.<span class="SFct">set</span>(<span class="SNum">10</span>)
    pt2.<span class="SCst">IReset</span>.<span class="SFct">reset</span>()
    pt3.<span class="SCst">IReset</span>.<span class="SFct">set</span>(<span class="SNum">10</span>)
    pt3.<span class="SCst">IReset</span>.<span class="SFct">reset</span>()
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Interface as a Type </h4>
<p>An interface occupies two pointers: object pointer + virtual table pointer. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>
    <span class="SKwd">var</span> itf  = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2

    <span class="SCmp">#assert</span>(<span class="SItr">#sizeof</span>(itf) == <span class="SNum">2</span> * <span class="SItr">#sizeof</span>(*<span class="STpe">void</span>))

    <span class="SCmt">// Retrieve the concrete type with '@kindof'</span>
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(itf) == <span class="SCst">Point2</span>)
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(itf) == <span class="SCst">Point3</span>)

    <span class="SCmt">// Retrieve the concrete data with '@dataof'</span>
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    <span class="SItr">@assert</span>(<span class="SItr">@dataof</span>(itf) == &pt2)
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    <span class="SItr">@assert</span>(<span class="SItr">@dataof</span>(itf) == &pt3)
}</span></div>
<h4 id="_006_000_structs_swg__006_011_interface_swg">Default Implementation in Interfaces </h4>
<p>Provide default bodies directly in the interface. If a struct does not override, the default is used. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">interface</span> <span class="SCst">ITest</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">isImplemented</span>()-&gt;<span class="STpe">bool</span>
    {
        <span class="SLgc">return</span> <span class="SKwd">false</span>
    }
}</span></div>
<p>Override on <span class="code-inline">Point2</span>; no override on <span class="code-inline">Point3</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">ITest</span> <span class="SLgc">for</span> <span class="SCst">Point2</span>
{
    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">isImplemented</span>()-&gt;<span class="STpe">bool</span>
    {
        <span class="SLgc">return</span> <span class="SKwd">true</span>
    }
}

<span class="SKwd">impl</span> <span class="SCst">ITest</span> <span class="SLgc">for</span> <span class="SCst">Point3</span>
{
}</span></div>
<p>For <span class="code-inline">Point3</span>, <span class="code-inline">isImplemented()</span> returns <span class="code-inline">false</span> (the default). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> v3: <span class="SCst">Point3</span>

    <span class="SKwd">let</span> i2 = <span class="SKwd">cast</span>(<span class="SCst">ITest</span>) v2
    <span class="SItr">@assert</span>(i2.<span class="SFct">isImplemented</span>())

    <span class="SKwd">let</span> i3 = <span class="SKwd">cast</span>(<span class="SCst">ITest</span>) v3
    <span class="SItr">@assert</span>(!i3.<span class="SFct">isImplemented</span>())
}</span></div>

<h2 id="_007_000_functions_swg">Functions </h2>
<h3 id="_007_000_functions_swg__007_001_declaration_swg">Declaration </h3><h4 id="_007_000_functions_swg__007_001_declaration_swg">Introduction to Function Declarations </h4>
<p>A function declaration starts with the <span class="code-inline">func</span> keyword, followed by the function name and parentheses. If no parameters are needed, the parentheses remain empty. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Overload]</span>
<span class="SKwd">func</span> <span class="SFct">toto</span>() {}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Returning Values from Functions </h4>
<p>If a function returns a value, use <span class="code-inline">-&gt;</span> followed by the return type. The body must contain a <span class="code-inline">return</span> statement. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">toto1</span>()-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">return</span> <span class="SNum">0</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Inferring Return Types </h4>
<p>Use <span class="code-inline">=&gt;</span> for simple expressions when the return type can be inferred automatically. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Shorter Syntax for Functions Without Return Values </h4>
<p>Functions that do not return a value can use the same concise <span class="code-inline">=&gt;</span> syntax. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">print</span>(val: <span class="STpe">string</span>) =&gt; <span class="SItr">@print</span>(val)</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Defining Parameters in Functions </h4>
<p>Parameters are declared within parentheses after the function name, each with a name and type. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum1</span>(x, y: <span class="STpe">s32</span>, unused: <span class="STpe">f32</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">return</span> x + y
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Using Default Parameter Values </h4>
<p>Parameters may have default values, used when not provided by the caller. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum2</span>(x, y: <span class="STpe">s32</span>, unused: <span class="STpe">f32</span> = <span class="SNum">666</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">return</span> x + y
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Inferred Parameter Types </h4>
<p>If a parameter has a default value, its type can be inferred from it. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum3</span>(x, y = <span class="SNum">0.0</span>)
{
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(x) == <span class="STpe">f32</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(y) == <span class="STpe">f32</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Overloading Functions </h4>
<p>Multiple functions can share the same name if they differ in parameter count or types. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }

<span class="SAtr">#[Swag.Overload]</span>
<span class="SKwd">func</span> <span class="SFct">toto</span>(x: <span class="STpe">s32</span>, y = <span class="SCst">Values</span>.<span class="SCst">A</span>)
{
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(y) == <span class="SCst">Values</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Nested Functions </h4>
<p>Functions can be nested within other functions for local logic organization. Nested functions are scoped, not closures. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sub</span>(x, y: <span class="STpe">s32</span>) =&gt; x - y

    <span class="SKwd">let</span> x = <span class="SFct">sub</span>(<span class="SNum">5</span>, <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(x == <span class="SNum">3</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Named Parameters and Parameter Order </h4>
<p>Named parameters allow calling functions with arguments in any order. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sub</span>(x, y: <span class="STpe">s32</span>) =&gt; x - y
    {
        <span class="SKwd">let</span> x1 = <span class="SFct">sub</span>(x: <span class="SNum">5</span>, y: <span class="SNum">2</span>)
        <span class="SItr">@assert</span>(x1 == <span class="SNum">3</span>)

        <span class="SKwd">let</span> x2 = <span class="SFct">sub</span>(y: <span class="SNum">5</span>, x: <span class="SNum">2</span>)
        <span class="SItr">@assert</span>(x2 == -<span class="SNum">3</span>)
    }

    {
        <span class="SKwd">func</span> <span class="SFct">returnMe</span>(x, y: <span class="STpe">s32</span> = <span class="SNum">0</span>) =&gt; x + y * <span class="SNum">2</span>
        <span class="SItr">@assert</span>(<span class="SFct">returnMe</span>(x: <span class="SNum">10</span>) == <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(<span class="SFct">returnMe</span>(y: <span class="SNum">10</span>) == <span class="SNum">20</span>)
    }
}</span></div>
<h4 id="_007_000_functions_swg__007_001_declaration_swg">Returning Multiple Values with Anonymous Structs </h4>
<p>Functions can return anonymous structs to conveniently hold multiple values. These can be accessed directly or destructured. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>()-&gt;{ x, y: <span class="STpe">f32</span> }
    {
        <span class="SLgc">return</span> {<span class="SNum">1.0</span>, <span class="SNum">2.0</span>}
    }

    <span class="SKwd">let</span> result = <span class="SFct">myFunction</span>()
    <span class="SItr">@assert</span>(result.item0 == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(result.item1 == <span class="SNum">2.0</span>)

    <span class="SKwd">let</span> (x, y) = <span class="SFct">myFunction</span>()
    <span class="SItr">@assert</span>(x == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">2.0</span>)

    <span class="SKwd">let</span> (z, w) = <span class="SFct">myFunction</span>()
    <span class="SItr">@assert</span>(z == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(w == <span class="SNum">2.0</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_002_lambda_swg">Lambda </h3><h4 id="_007_000_functions_swg__007_002_lambda_swg">Introduction to Lambdas in Swag </h4>
<p>A lambda in Swag is a pointer to a function. This allows functions to be stored in variables, passed as arguments, or returned from other functions—enabling functional programming patterns. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction0</span>() {}
    <span class="SKwd">func</span> <span class="SFct">myFunction1</span>(x: <span class="STpe">s32</span>) =&gt; x * x

    <span class="SKwd">let</span> ptr0: <span class="SKwd">func</span>() = &myFunction0
    <span class="SFct">ptr0</span>()

    <span class="SKwd">let</span> ptr1 = &myFunction1
    <span class="SItr">@assert</span>(<span class="SFct">myFunction1</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SFct">ptr1</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Null Lambdas </h4>
<p>A lambda can be null, representing an uninitialized or absent function pointer. This is useful for optional callbacks or deferred initialization. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> lambda: <span class="SKwd">func</span>()-&gt;<span class="STpe">bool</span>
    <span class="SItr">@assert</span>(lambda == <span class="SKwd">null</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Using Lambdas as Function Parameters </h4>
<p>Lambdas can be passed as arguments, enabling higher-order functions that call other functions dynamically. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">alias</span> <span class="SCst">Callback</span> = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: <span class="SCst">Callback</span>)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value)

    <span class="SKwd">func</span> <span class="SFct">square</span>(x: <span class="STpe">s32</span>) =&gt; x * x
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, &square) == <span class="SNum">16</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Anonymous Functions </h4>
<p>Anonymous (inline) functions can be defined without names for short, inline logic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cb = <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> =&gt; x * x
    <span class="SItr">@assert</span>(<span class="SFct">cb</span>(<span class="SNum">4</span>) == <span class="SNum">16</span>)

    cb = <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> =&gt; x * x * x
    <span class="SItr">@assert</span>(<span class="SFct">cb</span>(<span class="SNum">4</span>) == <span class="SNum">64</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Passing Anonymous Functions as Parameters </h4>
<p>Anonymous functions can be passed directly as arguments. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">alias</span> <span class="SCst">Callback</span> = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: <span class="SCst">Callback</span>)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value)

    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>) =&gt; x * x) == <span class="SNum">16</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>) =&gt; x + x) == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> { <span class="SLgc">return</span> x - x; }) == <span class="SNum">0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Inferred Parameter Types in Anonymous Functions </h4>
<p>If the type is clear from context, lambda parameters can omit explicit types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">alias</span> <span class="SCst">Callback</span> = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: <span class="SCst">Callback</span>)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value)

    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) =&gt; x * x) == <span class="SNum">16</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) =&gt; x + x) == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) { <span class="SLgc">return</span> x - x; }) == <span class="SNum">0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Omitting Types When Assigning Lambdas </h4>
<p>When the variable type is known, parameter and return types can be omitted in the lambda. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> fct: <span class="SKwd">func</span>(<span class="STpe">s32</span>, <span class="STpe">s32</span>)-&gt;<span class="STpe">bool</span>

    fct = <span class="SKwd">func</span>(x, y) =&gt; x == y
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">10</span>, <span class="SNum">10</span>))

    fct = <span class="SKwd">func</span>(x, y)
    {
        <span class="SLgc">return</span> x != y
    }

    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">20</span>, <span class="SNum">120</span>))
}</span></div>
<h4 id="_007_000_functions_swg__007_002_lambda_swg">Lambdas with Default Parameter Values </h4>
<p>Lambdas may have parameters with default values, allowing flexible invocation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> x = <span class="SKwd">func</span>(val = <span class="SKwd">true</span>)
        {
            <span class="SItr">@assert</span>(val == <span class="SKwd">true</span>)
        }
        <span class="SFct">x</span>()
    }

    {
        <span class="SKwd">var</span> x: <span class="SKwd">func</span>(val: <span class="STpe">bool</span> = <span class="SKwd">true</span>)
        x = <span class="SKwd">func</span>(val)
        {
            <span class="SItr">@assert</span>(val == <span class="SKwd">true</span>)
        }

        <span class="SFct">x</span>()
        <span class="SFct">x</span>(<span class="SKwd">true</span>)
    }
}</span></div>

<h3 id="_007_000_functions_swg__007_003_closure_swg">Closure </h3><h4 id="_007_000_functions_swg__007_003_closure_swg">Introduction to Closures in Swag </h4>
<p>Swag supports limited closures, allowing functions to capture variables from their surrounding scope. Up to 48 bytes can be captured without heap allocation. Only simple types (without <span class="code-inline">opDrop</span>, <span class="code-inline">opPostCopy</span>, or <span class="code-inline">opPostMove</span>) can be captured. </p>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Declaring a Closure </h4>
<p>A closure is declared like a lambda, with captured variables listed between <span class="code-inline">|...|</span> before the parameter list. The type uses <span class="code-inline">func||(...)</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">125</span>
    <span class="SKwd">let</span> b = <span class="SNum">521</span>

    <span class="SKwd">let</span> fct: <span class="SKwd">func</span>||() = <span class="SKwd">func</span>|a, b|()
    {
        <span class="SItr">@assert</span>(a == <span class="SNum">125</span>)
        <span class="SItr">@assert</span>(b == <span class="SNum">521</span>)
    }

    <span class="SFct">fct</span>()
}</span></div>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Capturing Variables by Reference </h4>
<p>Use <span class="code-inline">&</span> to capture by reference; otherwise, capture is by value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SNum">125</span>

    <span class="SKwd">let</span> fct: <span class="SKwd">func</span>||() = <span class="SKwd">func</span>|&a|()
    {
        a += <span class="SNum">1</span>
    }

    <span class="SFct">fct</span>()
    <span class="SItr">@assert</span>(a == <span class="SNum">126</span>)

    <span class="SFct">fct</span>()
    <span class="SItr">@assert</span>(a == <span class="SNum">127</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Assigning Lambdas to Closure Variables </h4>
<p>A closure variable can also hold a regular lambda (no captures). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> fct: <span class="SKwd">func</span>||(<span class="STpe">s32</span>, <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>

    fct = <span class="SKwd">func</span>(x, y) =&gt; x + y
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">1</span>, <span class="SNum">2</span>) == <span class="SNum">3</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Capturing Complex Types </h4>
<p>Arrays, structs, and slices can be captured by value if they fit in the capture size and are plain data (POD). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>]

    <span class="SKwd">var</span> fct: <span class="SKwd">func</span>||(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>

    fct = <span class="SKwd">func</span>|x|(toAdd)
    {
        <span class="SKwd">var</span> res = <span class="SNum">0</span>
        <span class="SLgc">foreach</span> v <span class="SLgc">in</span> x <span class="SLgc">do</span>
            res += v
        res += toAdd
        <span class="SLgc">return</span> res
    }

    <span class="SKwd">let</span> result = <span class="SFct">fct</span>(<span class="SNum">4</span>)
    <span class="SItr">@assert</span>(result == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_003_closure_swg">Modifying Captured Variables </h4>
<p>Captured values belong to the closure and can be mutated, enabling stateful behavior. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">getInc</span>()-&gt;<span class="SKwd">func</span>||()-&gt;<span class="STpe">s32</span>
    {
        <span class="SKwd">let</span> x = <span class="SNum">10</span>

        <span class="SLgc">return</span> <span class="SKwd">func</span>|x|()-&gt;<span class="STpe">s32</span>
        {
            x += <span class="SNum">1</span>
            <span class="SLgc">return</span> x
        }
    }

    <span class="SKwd">let</span> fct = <span class="SFct">getInc</span>()

    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">11</span>)
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">12</span>)
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">13</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_004_mixin_swg">Mixin </h3><h4 id="_007_000_functions_swg__007_004_mixin_swg">Introduction to Swag Mixins </h4>
<p>A mixin in Swag is declared similarly to a function but with the attribute <span class="code-inline">#[Swag.Mixin]</span>. Mixins inject code into the caller's scope, manipulate variables, or execute as if written in that scope. This file provides a clear set of examples and tests. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>()
    {
        <span class="SCmt">// Basic empty mixin</span>
    }
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Basic Example of a Mixin </h4>
<p>A mixin can directly modify variables in the caller's scope. This example increments <span class="code-inline">a</span> by 1 each time it is called. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>()
    {
        a += <span class="SNum">1</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">myMixin</span>() <span class="SCmt">// Equivalent to writing 'a += 1' directly here</span>
    <span class="SFct">myMixin</span>()
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Mixins with Parameters </h4>
<p>Mixins behave like functions: they can take parameters, default values, and return values. Here, <span class="code-inline">increment</span> defaults to 1. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>(increment: <span class="STpe">s32</span> = <span class="SNum">1</span>)
    {
        a += increment
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">myMixin</span>() <span class="SCmt">// Uses default: 'a += 1'</span>
    <span class="SFct">myMixin</span>(<span class="SNum">2</span>) <span class="SCmt">// Uses provided value: 'a += 2'</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">3</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Mixins with Code Blocks </h4>
<p>A mixin can accept a parameter of type <span class="code-inline">code</span>, representing a Swag code block defined at the call site. The mixin can execute this block multiple times using <span class="code-inline">#inject</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">doItTwice</span>(what: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SCmp">#inject</span>(what)
        <span class="SCmt">// first execution</span>
        <span class="SCmp">#inject</span>(what)
        <span class="SCmt">// second execution</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">doItTwice</span>(<span class="SItr">#code</span> { a += <span class="SNum">1</span>; })
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Passing Code Blocks in Separate Statements </h4>
<p>When the last parameter is of type <span class="code-inline">code</span>, the code can be provided in a separate block after the call. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">doItTwice</span>(value: <span class="STpe">s32</span>, what: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SCmp">#inject</span>(what)
        <span class="SCmp">#inject</span>(what)
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SCmt">// Inline code argument</span>
    <span class="SFct">doItTwice</span>(<span class="SNum">4</span>, <span class="SItr">#code</span> { a += value; })

    <span class="SCmt">// Separate trailing block</span>
    <span class="SFct">doItTwice</span>(<span class="SNum">2</span>)
    {
        a += value
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">12</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Creating Aliases with Mixins </h4>
<p>Use the special name <span class="code-inline">#alias</span> to create a named alias for an identifier. This enables flexible manipulation of variables through mixins. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">inc10</span>()
    {
        <span class="SItr">#alias0</span> += <span class="SNum">10</span>
    }

    <span class="SKwd">var</span> a, b = <span class="SNum">0</span>
    <span class="SFct">inc10</span>(|a|) <span class="SCmt">// use 'a' as the alias</span>
    <span class="SFct">inc10</span>(|b|) <span class="SCmt">// use 'b' as the alias</span>
    <span class="SItr">@assert</span>(a == b <span class="SLgc">and</span> b == <span class="SNum">10</span>)
}

<span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">setVar</span>(value: <span class="STpe">s32</span>)
    {
        <span class="SKwd">let</span> <span class="SItr">#alias0</span> = value
    }

    <span class="SFct">setVar</span>(|a| <span class="SNum">10</span>)
    <span class="SFct">setVar</span>(|b| <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(a == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">20</span>)

    <span class="SCmt">// No explicit alias: default '#alias0' is used</span>
    <span class="SFct">setVar</span>(<span class="SNum">30</span>)
    <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SNum">30</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_004_mixin_swg">Unique Variable Names with <span class="code-inline">#uniq?</span> </h4>
<p>Mixins can declare special variables named <span class="code-inline">#uniq?</span>. Each invocation receives a unique symbol, avoiding naming conflicts and allowing multiple calls in the same scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> total: <span class="STpe">s32</span>

    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">toScope</span>()
    {
        <span class="SKwd">var</span> <span class="SItr">#uniq0</span>: <span class="STpe">s32</span> = <span class="SNum">1</span>
        total += <span class="SItr">#uniq0</span>
    }

    <span class="SFct">toScope</span>()
    <span class="SFct">toScope</span>()
    <span class="SFct">toScope</span>()

    <span class="SItr">@assert</span>(total == <span class="SNum">3</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_005_macro_swg">Macro </h3><h4 id="_007_000_functions_swg__007_005_macro_swg">Introduction to Swag Macros </h4>
<p>Macros in Swag are declared like functions, but with the <span class="code-inline">#[Swag.Macro]</span> attribute. They are expanded at compile time and can be reused to generate code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>() {}
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Macro Scope </h4>
<p>Macros run in their own scope, isolated from the caller. Unlike mixins, they do not share the caller's scope. Variables defined inside a macro cannot interfere with the caller unless explicitly elevated. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>()
    {
        <span class="SCmt">// 'a' here is local to the macro</span>
        <span class="SKwd">var</span> a = <span class="SNum">666</span>
    }

    <span class="SKwd">let</span> a = <span class="SNum">0</span>
    <span class="SFct">myMacro</span>() <span class="SCmt">// no conflict with outer 'a'</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Resolving Identifiers Outside the Macro Scope </h4>
<p>Use <span class="code-inline">#up</span> to explicitly reference and modify variables from the caller's scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>()
    {
        <span class="SItr">#up</span> a += <span class="SNum">1</span> <span class="SCmt">// increments the caller's 'a'</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">myMacro</span>()
    <span class="SFct">myMacro</span>()
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Macros with <span class="code-inline">#code</span> Parameters </h4>
<p>Macros can accept <span class="code-inline">#code</span> parameters to inject caller-provided code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>(what: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SCmp">#inject</span>(what) <span class="SCmt">// insert provided code</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SCmt">// Use '#code' to pass a block or expression as code (not evaluated at call site)</span>
    <span class="SFct">myMacro</span>(<span class="SItr">#code</span> { <span class="SItr">#up</span> a += <span class="SNum">1</span>; })

    <span class="SCmt">// If the last parameter is '#code void', the following statement becomes the last argument</span>
    <span class="SFct">myMacro</span>()
    {
        <span class="SItr">#up</span> a += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Typed <span class="code-inline">#code</span> Parameters </h4>
<p>A <span class="code-inline">#code</span> parameter can be typed: - Use '#code void' for a code statement. - Use '#code &lt;type&gt;' for a code expression that returns a specific type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>(what: <span class="SItr">#code</span> <span class="STpe">bool</span>)
    {
        <span class="SItr">@assert</span>(<span class="SCmp">#inject</span>(what))
    }

    <span class="SCmt">// The expression is transformed to code and evaluated only after injection</span>
    <span class="SFct">myMacro</span>(<span class="SNum">1</span> == <span class="SNum">1</span>)
    <span class="SFct">myMacro</span>(<span class="SNum">3</span> &gt; <span class="SNum">2</span> <span class="SLgc">and</span> <span class="SNum">2</span> &lt; <span class="SNum">4</span>)
    <span class="SFct">myMacro</span>(<span class="SKwd">true</span>)

    <span class="SCmt">// Note: '#code' creates an untyped piece of code usable with any argument type</span>
    <span class="SFct">myMacro</span>(<span class="SItr">#code</span> <span class="SKwd">true</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Forcing Code into the Caller’s Scope with <span class="code-inline">#macro</span> </h4>
<p>Use <span class="code-inline">#macro</span> to run injected code as if it were in the caller's scope, avoiding the need for <span class="code-inline">#up</span> inside the injected block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>(what: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SKwd">var</span> a = <span class="SNum">666</span> <span class="SCmt">// macro-local 'a'</span>

        <span class="SCmp">#macro</span>
        {
            <span class="SCmt">// references the caller's scope</span>
            <span class="SCmp">#inject</span>(<span class="SItr">#up</span> what)
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">1</span>
    <span class="SFct">myMacro</span>()
    {
        a += <span class="SNum">2</span> <span class="SCmt">// operates on caller's 'a' due to '#macro'</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">3</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Performance Considerations with Macros </h4>
<p>Macros extend the language without function-pointer/lambda overhead. They can be used to generate tight loops with caller-visible indices, etc. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">repeat</span>(count: <span class="STpe">s32</span>, what: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SKwd">var</span> a = <span class="SNum">0</span>
        <span class="SLgc">while</span> a &lt; count
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SKwd">var</span> index = <span class="SItr">#up</span> a <span class="SCmt">// 'index' visible in caller via macro scope</span>
                <span class="SCmp">#inject</span>(<span class="SItr">#up</span> what)
                <span class="SCmt">// insert caller code</span>
            }
            a += <span class="SNum">1</span>
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">repeat</span>(<span class="SNum">5</span>)
    {
        a += index <span class="SCmt">// sum 0..4</span>
    }
    <span class="SItr">@assert</span>(a == <span class="SNum">0</span> + <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)

    <span class="SFct">repeat</span>(<span class="SNum">3</span>)
    {
        a += index <span class="SCmt">// add 0..2</span>
    }
    <span class="SItr">@assert</span>(a == <span class="SNum">10</span> + <span class="SNum">3</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Handling <span class="code-inline">break</span> and <span class="code-inline">continue</span> in User Code with Macros </h4>
<p>You can remap <span class="code-inline">break</span>/<span class="code-inline">continue</span> in injected user code to control which loop they target. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">repeatSquare</span>(count: <span class="STpe">u32</span>, what: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SCmt">// Define a scope label used as the break target</span>
        <span class="SCmp">#scope</span>(<span class="SCst">ScopeTarget</span>)

        <span class="SLgc">for</span> count
        {
            <span class="SLgc">for</span> count
            {
                <span class="SCmp">#macro</span>
                {
                    <span class="SCmt">// Remap 'break' in user code to 'break to ScopeTarget' (outer loop exit)</span>
                    <span class="SCmp">#inject</span>(<span class="SItr">#up</span> what, <span class="SLgc">break</span> = <span class="SLgc">break</span> <span class="SLgc">to</span> <span class="SCst">ScopeTarget</span>)
                }
            }
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SFct">repeatSquare</span>(<span class="SNum">5</span>)
    {
        a += <span class="SNum">1</span>
        <span class="SLgc">if</span> a == <span class="SNum">10</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span> <span class="SCmt">// remapped to 'break to ScopeTarget'</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">10</span>)
}</span></div>
<h5 id="_007_000_functions_swg__007_005_macro_swg">Another example: </h5>
<p>Remap both <span class="code-inline">break</span> and <span class="code-inline">continue</span> to influence outer/inner loop flow. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">repeatSquare</span>(count: <span class="STpe">u32</span>, what: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SCmt">// Label for controlling the outer loop</span>
        <span class="SCmp">#scope</span>(<span class="SCst">Outer</span>)

        <span class="SLgc">for</span> count
        {
            <span class="SLgc">for</span> count
            {
                <span class="SCmp">#macro</span>
                {
                    <span class="SCmt">// 'break' -&gt; exit outer loop; 'continue' -&gt; skip inner iteration</span>
                    <span class="SCmp">#inject</span>(<span class="SItr">#up</span> what, <span class="SLgc">break</span> = <span class="SLgc">break</span> <span class="SLgc">to</span> <span class="SCst">Outer</span>, <span class="SLgc">continue</span> = <span class="SLgc">break</span>)
                }
            }
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SKwd">var</span> b = <span class="SNum">0</span>

    <span class="SFct">repeatSquare</span>(<span class="SNum">5</span>)
    {
        a += <span class="SNum">1</span>

        <span class="SCmt">// If 'a' divisible by 3, skip to next inner iteration (acts like 'continue')</span>
        <span class="SLgc">if</span> a % <span class="SNum">3</span> == <span class="SNum">0</span> <span class="SLgc">do</span>
            <span class="SLgc">continue</span>

        b += <span class="SNum">1</span>

        <span class="SCmt">// Exit both loops when 'a' reaches 8</span>
        <span class="SLgc">if</span> a == <span class="SNum">8</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">6</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_005_macro_swg">Using Aliases in Macros </h4>
<p>Special variables <span class="code-inline">#alias&lt;num&gt;</span> inside a macro can be overridden with named aliases at the call site for clearer code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">call</span>(v: <span class="STpe">s32</span>, stmt: <span class="SItr">#code</span> <span class="STpe">void</span>)
    {
        <span class="SKwd">let</span> <span class="SItr">#alias0</span> = v
        <span class="SKwd">let</span> <span class="SItr">#alias1</span> = v * <span class="SNum">2</span>
        <span class="SCmp">#inject</span>(stmt)
    }

    <span class="SFct">call</span>(<span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(<span class="SItr">#alias0</span> == <span class="SNum">20</span>)
        <span class="SItr">@assert</span>(<span class="SItr">#alias1</span> == <span class="SNum">40</span>)
    }

    <span class="SFct">call</span>(|x| <span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(x == <span class="SNum">20</span>) <span class="SCmt">// 'x' aliases '#alias0'</span>
        <span class="SItr">@assert</span>(<span class="SItr">#alias1</span> == <span class="SNum">40</span>) <span class="SCmt">// '#alias1' unchanged</span>
    }

    <span class="SFct">call</span>(|x, y| <span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(x == <span class="SNum">20</span>) <span class="SCmt">// replaces '#alias0'</span>
        <span class="SItr">@assert</span>(y == <span class="SNum">40</span>) <span class="SCmt">// replaces '#alias1'</span>
    }
}</span></div>

<h3 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Variadic Parameters </h3><h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Introduction to Variadic Functions </h4>
<p>Variadic functions accept a variable number of arguments using <span class="code-inline">...</span>. They allow flexibility in cases where the number of arguments is not known in advance. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(value: <span class="STpe">bool</span>, parameters: ...)
    {
        <span class="SCmt">// This function can accept any number of extra arguments after 'value'.</span>
    }

    <span class="SFct">myFunction</span>(<span class="SKwd">true</span>, <span class="SNum">4</span>, <span class="SStr">"true"</span>, <span class="SNum">5.6</span>) <span class="SCmt">// Passes extra arguments after 'value'</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Working with Variadic Parameters as Slices </h4>
<p>Variadic parameters are treated as slices of type <span class="code-inline">any</span>, allowing you to process mixed argument types dynamically. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(parameters: ...)
    {
        <span class="SCmt">// Check the number of arguments</span>
        <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(parameters) == <span class="SNum">3</span>)

        <span class="SCmt">// Initially, each parameter is of type 'any'</span>
        <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(parameters[<span class="SNum">0</span>]) == <span class="STpe">any</span>)
        <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(parameters[<span class="SNum">1</span>]) == <span class="STpe">any</span>)
        <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">any</span>)

        <span class="SCmt">// Determine actual runtime types</span>
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">0</span>]) == <span class="STpe">s32</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">1</span>]) == <span class="STpe">string</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">f32</span>)
    }

    <span class="SFct">myFunction</span>(<span class="SNum">4</span>, <span class="SStr">"true"</span>, <span class="SNum">5.6</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Forcing Variadic Parameters to a Specific Type </h4>
<p>When all arguments are of the same type, you can enforce it using type annotations. This prevents parameters from defaulting to <span class="code-inline">any</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(value: <span class="STpe">bool</span>, parameters: <span class="STpe">s32</span>...)
    {
        <span class="SCmt">// All 'parameters' elements must be of type 's32'</span>
        <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(parameters[<span class="SNum">0</span>]).name == <span class="SStr">"s32"</span>)
        <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(parameters[<span class="SNum">1</span>]).name == <span class="SStr">"s32"</span>)
        <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">s32</span>)
        <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(parameters[<span class="SNum">3</span>]) == <span class="STpe">s32</span>)

        <span class="SCmt">// Check values</span>
        <span class="SItr">@assert</span>(parameters[<span class="SNum">0</span>] == <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">1</span>] == <span class="SNum">20</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">2</span>] == <span class="SNum">30</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">3</span>] == <span class="SNum">40</span>)
    }

    <span class="SFct">myFunction</span>(<span class="SKwd">true</span>, <span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Passing Variadic Parameters Between Functions </h4>
<p>Variadic parameters can be forwarded between functions while preserving their types and values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">A</span>(params: ...)
    {
        <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(params) == <span class="SNum">2</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(params[<span class="SNum">0</span>]) == <span class="STpe">string</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(params[<span class="SNum">1</span>]) == <span class="STpe">bool</span>)
        <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) params[<span class="SNum">0</span>] == <span class="SStr">"value"</span>)
        <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) params[<span class="SNum">1</span>] == <span class="SKwd">true</span>)
    }

    <span class="SKwd">func</span> <span class="SFct">B</span>(params: ...)
    {
        <span class="SFct">A</span>(params) <span class="SCmt">// Forward the parameters</span>
    }

    <span class="SFct">B</span>(<span class="SStr">"value"</span>, <span class="SKwd">true</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Combining Fixed and Variadic Parameters </h4>
<p>You can mix fixed parameters with variadic ones to make function calls more expressive. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">private</span> <span class="SKwd">func</span> <span class="SFct">print</span>()
{
    <span class="SKwd">func</span> <span class="SFct">logMessage</span>(prefix: <span class="STpe">string</span>, messages: ...)
    {
        <span class="SLgc">foreach</span> msg <span class="SLgc">in</span> messages
        {
            <span class="SItr">@print</span>(prefix, <span class="SStr">" =&gt; "</span>, <span class="SKwd">cast</span>(<span class="STpe">string</span>) msg)
        }
    }

    <span class="SFct">logMessage</span>(<span class="SStr">"Error:"</span>, <span class="SStr">"File not found"</span>, <span class="SStr">"Access denied"</span>, <span class="SStr">"Disk full"</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_006_variadic_parameters_swg">Handling Different Types in Variadic Parameters </h4>
<p>Handle mixed-type parameters dynamically, performing type-specific actions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">processParameters</span>(params: ...)-&gt;<span class="STpe">s32</span>
    {
        <span class="SKwd">var</span> sum = <span class="SNum">0</span>

        <span class="SLgc">foreach</span> p <span class="SLgc">in</span> params
        {
            <span class="SLgc">switch</span> <span class="SItr">@kindof</span>(p)
            {
            <span class="SLgc">case</span> <span class="STpe">s32</span>:
                sum += <span class="SNum">1</span>
            <span class="SLgc">case</span> <span class="STpe">string</span>:
                sum += <span class="SNum">10</span>
            }
        }

        <span class="SLgc">return</span> sum
    }

    <span class="SKwd">let</span> result = <span class="SFct">processParameters</span>(<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SStr">"Hello, "</span>, <span class="SNum">3</span>, <span class="SStr">"World!"</span>)
    <span class="SItr">@assert</span>(result == <span class="SNum">1</span> + <span class="SNum">1</span> + <span class="SNum">10</span> + <span class="SNum">1</span> + <span class="SNum">10</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_007_ufcs_swg">Ufcs </h3><h4 id="_007_000_functions_swg__007_007_ufcs_swg">Introduction to Uniform Function Call Syntax (UFCS) </h4>
<p><i>UFCS</i> (Uniform Function Call Syntax) allows a function to be called in the <span class="code-inline">param.func()</span> form when the first parameter type of <span class="code-inline">func()</span> matches <span class="code-inline">param</span>. This enables calling standalone functions as if they were instance methods, improving readability. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunc</span>(param: <span class="STpe">bool</span>) =&gt; param

    <span class="SKwd">let</span> b = <span class="SKwd">false</span>
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(b) == b.<span class="SFct">myFunc</span>()) <span class="SCmt">// UFCS allows method-like syntax</span>
}</span></div>
<h4 id="_007_000_functions_swg__007_007_ufcs_swg">Static Functions as Methods </h4>
<p>All functions in Swag are static, but UFCS enables them to be invoked with instance-style syntax. This improves clarity when working with structs or objects. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x, y: <span class="STpe">s32</span> }

    <span class="SKwd">func</span> <span class="SFct">set</span>(pt: *<span class="SCst">Point</span>, value: <span class="STpe">s32</span>)
    {
        pt.x, pt.y = value
    }

    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>

    <span class="SCmt">// UFCS — called like a method</span>
    pt.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">10</span>)

    <span class="SCmt">// Normal static function call</span>
    <span class="SFct">set</span>(&pt, <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">20</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_007_ufcs_swg">UFCS with Multiple Parameters </h4>
<p>UFCS works with multi-parameter functions as long as the first parameter type matches the instance type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Vector</span> { x, y: <span class="STpe">f32</span> }

    <span class="SKwd">func</span> <span class="SFct">add</span>(vec: *<span class="SCst">Vector</span>, dx: <span class="STpe">f32</span>, dy: <span class="STpe">f32</span>)
    {
        vec.x += dx
        vec.y += dy
    }

    <span class="SKwd">var</span> v: <span class="SCst">Vector</span>

    <span class="SCmt">// UFCS style</span>
    v.<span class="SFct">add</span>(<span class="SNum">1.0</span>, <span class="SNum">2.0</span>)
    <span class="SItr">@assert</span>(v.x == <span class="SNum">1.0</span> <span class="SLgc">and</span> v.y == <span class="SNum">2.0</span>)

    <span class="SCmt">// Standard function call</span>
    <span class="SFct">add</span>(&v, <span class="SNum">3.0</span>, <span class="SNum">4.0</span>)
    <span class="SItr">@assert</span>(v.x == <span class="SNum">4.0</span> <span class="SLgc">and</span> v.y == <span class="SNum">6.0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_007_ufcs_swg">UFCS and Function Overloading </h4>
<p>UFCS supports overloaded functions, selecting the correct overload based on argument types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Complex</span> { real, imag: <span class="STpe">f32</span> }

    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">multiply</span>(c: *<span class="SCst">Complex</span>, scalar: <span class="STpe">f32</span>)
    {
        c.real *= scalar
        c.imag *= scalar
    }

    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span> <span class="SFct">multiply</span>(c: *<span class="SCst">Complex</span>, other: *<span class="SCst">Complex</span>)
    {
        <span class="SCmt">// Use temporary variables to prevent reuse of modified values</span>
        <span class="SKwd">let</span> r = (c.real * other.real) - (c.imag * other.imag)
        <span class="SKwd">let</span> i = (c.real * other.imag) + (c.imag * other.real)
        c.real = r
        c.imag = i
    }

    <span class="SKwd">var</span> c1 = <span class="SCst">Complex</span>{<span class="SNum">2.0</span>, <span class="SNum">3.0</span>}
    <span class="SKwd">var</span> c2 = <span class="SCst">Complex</span>{<span class="SNum">4.0</span>, <span class="SNum">5.0</span>}

    <span class="SCmt">// UFCS: multiply by scalar</span>
    c1.<span class="SFct">multiply</span>(<span class="SNum">2.0</span>)
    <span class="SItr">@assert</span>(c1.real == <span class="SNum">4.0</span> <span class="SLgc">and</span> c1.imag == <span class="SNum">6.0</span>)

    <span class="SCmt">// UFCS: multiply by another complex number</span>
    c1.<span class="SFct">multiply</span>(&c2)
    <span class="SItr">@assert</span>(c1.real == -<span class="SNum">14.0</span> <span class="SLgc">and</span> c1.imag == <span class="SNum">44.0</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_008_constexpr_swg">Constexpr </h3><h4 id="_007_000_functions_swg__007_008_constexpr_swg"><span class="code-inline">Swag.ConstExpr</span> Functions </h4>
<p>Functions marked with <span class="code-inline">#[Swag.ConstExpr]</span> can be executed at compile time if their inputs are known. The compiler computes their results during compilation, embedding the values directly into the code for zero runtime overhead. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">f32</span>) =&gt; x + y</span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Compile-Time Computation </h4>
<p>The compiler executes 'sum(1, 2)' at compile time, embedding the result directly in <span class="code-inline">G</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">G</span> = <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)
<span class="SCmp">#assert</span>(<span class="SCst">G</span> == <span class="SNum">3</span>)</span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Using <span class="code-inline">Swag.ConstExpr</span> with Complex Expressions </h4>
<p>ConstExpr functions can evaluate compound arithmetic expressions at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">complexCalc</span>(a, b, c: <span class="STpe">f32</span>) =&gt; (a + b) * c / <span class="SNum">2</span>

<span class="SKwd">const</span> result = <span class="SFct">complexCalc</span>(<span class="SNum">4</span>, <span class="SNum">5</span>, <span class="SNum">6</span>)
<span class="SCmp">#assert</span>(result == <span class="SNum">27.0</span>)</span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Compile-Time Execution of Array Initializations </h4>
<p>ConstExpr functions can initialize arrays and collections at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">square</span>(n: <span class="STpe">s32</span>) =&gt; n * n

<span class="SKwd">const</span> <span class="SCst">Squares</span> = [<span class="SFct">square</span>(<span class="SNum">1</span>), <span class="SFct">square</span>(<span class="SNum">2</span>), <span class="SFct">square</span>(<span class="SNum">3</span>), <span class="SFct">square</span>(<span class="SNum">4</span>), <span class="SFct">square</span>(<span class="SNum">5</span>)]
<span class="SCmp">#assert</span>(<span class="SCst">Squares</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>)
<span class="SCmp">#assert</span>(<span class="SCst">Squares</span>[<span class="SNum">1</span>] == <span class="SNum">4</span>)
<span class="SCmp">#assert</span>(<span class="SCst">Squares</span>[<span class="SNum">2</span>] == <span class="SNum">9</span>)
<span class="SCmp">#assert</span>(<span class="SCst">Squares</span>[<span class="SNum">3</span>] == <span class="SNum">16</span>)
<span class="SCmp">#assert</span>(<span class="SCst">Squares</span>[<span class="SNum">4</span>] == <span class="SNum">25</span>)</span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Forcing Compile-Time Execution with <span class="code-inline">#run</span> </h4>
<p><span class="code-inline">#run</span> forces compile-time execution even for functions not marked as ConstExpr. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">mul</span>(x, y: <span class="STpe">f32</span>) =&gt; x * y

<span class="SKwd">const</span> <span class="SCst">G1</span> = <span class="SFct">#run</span> <span class="SFct">mul</span>(<span class="SNum">3</span>, <span class="SNum">6</span>)
<span class="SCmp">#assert</span>(<span class="SCst">G1</span> == <span class="SNum">18</span>)</span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Compile-Time Evaluation of Conditional Logic </h4>
<p>You can evaluate conditions and branches at compile time using ConstExpr functions. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">max</span>(a, b: <span class="STpe">s32</span>) =&gt; a &gt; b ? a : b

<span class="SKwd">const</span> <span class="SCst">MaxValue</span> = <span class="SFct">max</span>(<span class="SNum">10</span>, <span class="SNum">20</span>)
<span class="SCmp">#assert</span>(<span class="SCst">MaxValue</span> == <span class="SNum">20</span>)</span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Compile-Time Initialization of Structs </h4>
<p>ConstExpr functions can construct and initialize user-defined structs during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">struct</span> <span class="SCst">Point</span> { x, y: <span class="STpe">s32</span> }

<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">createPoint</span>(a, b: <span class="STpe">s32</span>) =&gt; <span class="SCst">Point</span>{a, b}

<span class="SKwd">const</span> <span class="SCst">Origin</span> = <span class="SFct">createPoint</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)
<span class="SCmp">#assert</span>(<span class="SCst">Origin</span>.x == <span class="SNum">1</span> <span class="SLgc">and</span> <span class="SCst">Origin</span>.y == <span class="SNum">2</span>)</span></div>
<h4 id="_007_000_functions_swg__007_008_constexpr_swg">Example: Using <span class="code-inline">#run</span> with User-Defined Types </h4>
<p><span class="code-inline">#run</span> can be used to execute ordinary functions with structs at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Rectangle</span> { width, height: <span class="STpe">s32</span> }

<span class="SKwd">func</span> <span class="SFct">area</span>(rect: <span class="SCst">Rectangle</span>) =&gt; rect.width * rect.height

<span class="SKwd">const</span> <span class="SCst">RectStatic</span> = <span class="SCst">Rectangle</span>{<span class="SNum">5</span>, <span class="SNum">10</span>}
<span class="SKwd">const</span> <span class="SCst">RectArea</span>   = <span class="SFct">#run</span> <span class="SFct">area</span>(<span class="SCst">RectStatic</span>)
<span class="SCmp">#assert</span>(<span class="SCst">RectArea</span> == <span class="SNum">50</span>)</span></div>

<h3 id="_007_000_functions_swg__007_009_function_overloading_swg">Function Overloading </h3><h4 id="_007_000_functions_swg__007_009_function_overloading_swg">Function Overloading with <span class="code-inline">Swag.Overload</span> </h4>
<p>Swag allows multiple functions to share the same name when their parameter signatures differ. This feature, called <i>function overloading</i>, enables writing concise and intuitive APIs. To activate it, each version of the function must be decorated with <span class="code-inline">#[Swag.Overload]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr, Swag.Overload]</span>
{
    <span class="SCmt">// Overload: two parameters</span>
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y

    <span class="SCmt">// Overload: three parameters</span>
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y, z: <span class="STpe">s32</span>) =&gt; x + y + z
}</span></div>
<p>The compiler chooses the correct overload based on the number and types of arguments. This allows calling <span class="code-inline">sum</span> naturally for different scenarios. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span>(<span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>) == <span class="SNum">3</span>) <span class="SCmt">// Calls the two-parameter version</span>
<span class="SCmp">#assert</span>(<span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>) == <span class="SNum">6</span>) <span class="SCmt">// Calls the three-parameter version</span></span></div>

<h3 id="_007_000_functions_swg__007_010_discard_swg">Discard </h3><h4 id="_007_000_functions_swg__007_010_discard_swg">Return Value Usage </h4>
<p>Swag enforces that all function return values must be used. If a function’s result is ignored, the compiler raises an error. This prevents accidental omission of important results and ensures deliberate handling of all return values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y

    <span class="SCmt">// Uncommenting the following line would cause a compile-time error:</span>
    <span class="SCmt">// sum(2, 3)</span>

    <span class="SCmt">// Use 'discard' to explicitly ignore the return value</span>
    <span class="SKwd">discard</span> <span class="SFct">sum</span>(<span class="SNum">2</span>, <span class="SNum">3</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_010_discard_swg"><span class="code-inline">Swag.Discardable</span> Attribute </h4>
<p>Marking a function with <span class="code-inline">#[Swag.Discardable]</span> allows its return value to be safely ignored. Use this for utility functions whose results are optional. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Discardable]</span>
    <span class="SKwd">func</span> <span class="SFct">mul</span>(x, y: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> =&gt; x * y

    <span class="SCmt">// Return value can be ignored without using 'discard'</span>
    <span class="SFct">mul</span>(<span class="SNum">2</span>, <span class="SNum">4</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_011_retval_swg">Retval </h3><h4 id="_007_000_functions_swg__007_011_retval_swg">The <span class="code-inline">retval</span> Special Type </h4>
<p>In Swag, <span class="code-inline">retval</span> represents the current function’s return type. It allows you to declare and manipulate the return value directly inside the function, without repeating the type declaration. This improves code readability and flexibility, especially when working with complex or generic return types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>()-&gt;<span class="STpe">s32</span>
    {
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span> <span class="SCmt">// 'retval' resolves to 's32' in this context.</span>
        result = <span class="SNum">10</span>
        <span class="SLgc">return</span> result
    }

    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">10</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_011_retval_swg">Optimizing Return Values </h4>
<p><span class="code-inline">retval</span> provides an optimization hint that allows the compiler to use the caller’s memory for the return value, reducing unnecessary copies. This is especially beneficial when returning large structs, arrays, or tuples. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { x, y, z: <span class="STpe">f64</span> }

    <span class="SKwd">func</span> <span class="SFct">getWhite</span>()-&gt;<span class="SCst">RGB</span>
    {
        <span class="SCmt">// 'retval = undefined' prevents unnecessary clearing of the return structure.</span>
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span> = <span class="SKwd">undefined</span>
        result.x = <span class="SNum">0.5</span>
        result.y = <span class="SNum">0.1</span>
        result.z = <span class="SNum">1.0</span>
        <span class="SLgc">return</span> result
    }

    <span class="SKwd">let</span> (r, g, b) = <span class="SFct">getWhite</span>()
    <span class="SItr">@assert</span>(r == <span class="SNum">0.5</span>)
    <span class="SItr">@assert</span>(g == <span class="SNum">0.1</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">1.0</span>)
}</span></div>
<h4 id="_007_000_functions_swg__007_011_retval_swg">Returning Arrays Efficiently </h4>
<p>When returning large data structures like arrays, using <span class="code-inline">retval</span> avoids redundant initialization or copying, resulting in faster, more memory-efficient code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>()-&gt;[<span class="SNum">255</span>] <span class="STpe">s32</span>
    {
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span> = <span class="SKwd">undefined</span>
        <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SNum">255</span> <span class="SLgc">do</span>
            result[i] = i
        <span class="SLgc">return</span> result
    }

    <span class="SKwd">var</span> arr = <span class="SFct">toto</span>()
    <span class="SItr">@assert</span>(arr[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(arr[<span class="SNum">100</span>] == <span class="SNum">100</span>)
    <span class="SItr">@assert</span>(arr[<span class="SNum">254</span>] == <span class="SNum">254</span>)
}</span></div>

<h3 id="_007_000_functions_swg__007_012_foreign_swg">Foreign </h3><h4 id="_007_000_functions_swg__007_012_foreign_swg">Interoperability with External Modules </h4>
<p>Swag supports calling external system or third-party library functions, such as those from Windows DLLs or shared objects on other platforms. This allows Swag applications to interact directly with system APIs or external C libraries for extended functionality. </p>
<h4 id="_007_000_functions_swg__007_012_foreign_swg">Declaring External Functions </h4>
<p>Use the <span class="code-inline">#[Swag.Foreign("&lt;module&gt;")]</span> attribute to declare functions that exist in external modules (DLLs or shared libraries). The specified module name must match the external library name. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Declare functions from the Windows 'kernel32.dll' library</span>
<span class="SAtr">#[Swag.Foreign("kernel32")]</span>
<span class="SKwd">func</span> <span class="SFct">ExitProcess</span>(uExitCode: <span class="STpe">u32</span>);

<span class="SAtr">#[Swag.Foreign("kernel32")]</span>
{
    <span class="SKwd">func</span> <span class="SFct">Sleep</span>(dwMilliseconds: <span class="STpe">u32</span>);
}</span></div>
<h4 id="_007_000_functions_swg__007_012_foreign_swg">Example: Windows API Integration </h4>
<p>These declarations enable Swag code to directly call Windows API functions like <span class="code-inline">Sleep</span> or <span class="code-inline">ExitProcess</span> from <span class="code-inline">kernel32.dll</span>. For instance: - <span class="code-inline">Sleep(1000)</span> pauses execution for 1 second. - <span class="code-inline">ExitProcess(0)</span> terminates the running process cleanly. </p>
<h4 id="_007_000_functions_swg__007_012_foreign_swg">Linking to External Libraries </h4>
<p>To ensure external calls resolve correctly, use the <span class="code-inline">#foreignlib</span> directive. This instructs the compiler and linker to include the specified module when building the executable or shared library. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Link the 'kernel32.dll' library for Windows builds</span>
<span class="SCmp">#foreignlib</span>(<span class="SStr">"kernel32"</span>)</span></div>

<h3 id="_007_000_functions_swg__007_013_special_functions_swg">Special Functions </h3><div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Main Function (<span class="code-inline">#main</span>) </h4>
<p>The <span class="code-inline">#main</span> function serves as the program's primary entry point — similar to C/C++'s <span class="code-inline">main()</span>. It is unique per module and marks where execution begins when the program starts. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Handling Program Arguments </h4>
<p>Command-line arguments are accessed via the intrinsic <span class="code-inline">@args</span>, which returns a slice of strings representing all arguments passed to the program. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SKwd">var</span> myArgs = <span class="SItr">@args</span>
    <span class="SKwd">var</span> count = <span class="SItr">@countof</span>(myArgs)

    <span class="SLgc">if</span> myArgs[<span class="SNum">0</span>] == <span class="SStr">"fullscreen"</span>
    {
        <span class="SCmt">// Example: Enable fullscreen mode here</span>
        ...
    }
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Pre-Main Function (<span class="code-inline">#premain</span>) </h4>
<p>The <span class="code-inline">#premain</span> function executes after all <span class="code-inline">#init</span> functions in every module have run, but before <span class="code-inline">#main</span>. It's ideal for setup tasks that depend on completed module initialization. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#premain</span>
{
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Initialization Function (<span class="code-inline">#init</span>) </h4>
<p><span class="code-inline">#init</span> runs during module initialization. Multiple <span class="code-inline">#init</span> functions can exist within a module and execute before <span class="code-inline">#premain</span> and <span class="code-inline">#main</span>. Execution order between multiple <span class="code-inline">#init</span> functions is undefined. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#init</span>
{
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Drop Function (<span class="code-inline">#drop</span>) </h4>
<p><span class="code-inline">#drop</span> acts as the cleanup counterpart to <span class="code-inline">#init</span>. It executes when a module is unloaded, releasing any resources acquired during initialization. Multiple <span class="code-inline">#drop</span> functions can exist, and they execute in reverse order relative to <span class="code-inline">#init</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#drop</span>
{
}</span></div>
<h4 id="_007_000_functions_swg__007_013_special_functions_swg">Test Function (<span class="code-inline">#test</span>) </h4>
<p><span class="code-inline">#test</span> is used exclusively for testing code. Functions marked with <span class="code-inline">#test</span> are executed only in test mode, allowing developers to validate functionality through assertions and controlled test cases. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
}</span></div>

<h2 id="_008_000_intrinsics_swg">Intrinsics </h2><h3 id="_008_000_intrinsics_swg">Intrinsics in Swag </h3>
<p>Intrinsics are built-in functions provided by the Swag compiler that offer low-level operations, often directly mapping to specific machine instructions or providing essential compiler utilities. All intrinsics in Swag are prefixed with <span class="code-inline">@</span>, which is reserved exclusively for these functions. </p>
<p>This document provides a categorized list of all intrinsics available in Swag. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip</span></div>
<h3 id="_008_000_intrinsics_swg">Base Intrinsics </h3>
<p>Fundamental intrinsics commonly needed across Swag programs. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@assert</span>(value: <span class="STpe">bool</span>);                       <span class="SCmt">// Assert that a condition is true (debugging).</span>
<span class="SKwd">func</span> <span class="SItr">@breakpoint</span>();                              <span class="SCmt">// Trigger a debugger breakpoint.</span>
<span class="SKwd">func</span> <span class="SItr">@getcontext</span>() -&gt; *<span class="SCst">Swag</span>.<span class="SCst">Context</span>;             <span class="SCmt">// Retrieve the current execution context.</span>
<span class="SKwd">func</span> <span class="SItr">@setcontext</span>(context: <span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">Context</span>);  <span class="SCmt">// Set the current execution context.</span>
<span class="SKwd">func</span> <span class="SItr">@compiler</span>() -&gt; <span class="SCst">Swag</span>.<span class="SCst">ICompiler</span>;              <span class="SCmt">// Retrieve the current compiler interface.</span>

<span class="SItr">@panic</span>();                                        <span class="SCmt">// Trigger a panic, stopping program execution.</span>
<span class="SItr">@compilererror</span>();                                <span class="SCmt">// Generate a compile-time error.</span>
<span class="SItr">@compilerwarning</span>();                              <span class="SCmt">// Generate a compile-time warning.</span></span></div>
<h3 id="_008_000_intrinsics_swg">Value Intrinsics </h3>
<div class="code-block"><span class="SCde"><span class="SItr">@err</span>:        <span class="STpe">any</span>                 <span class="SCmt">// The current raised error (null if none).</span>
<span class="SItr">@args</span>:       <span class="SKwd">const</span> [..] <span class="STpe">string</span>   <span class="SCmt">// Command-line arguments passed to the program.</span>
<span class="SItr">@bytecode</span>:   <span class="STpe">bool</span>                <span class="SCmt">// True if the code is being executed as bytecode.</span>
<span class="SItr">@pinfos</span>:    *<span class="SCst">Swag</span>.<span class="SCst">ProcessInfos</span>   <span class="SCmt">// Retrieve program information.</span></span></div>
<h3 id="_008_000_intrinsics_swg">Built-in Intrinsics </h3>
<p>Essential operations related to type and memory management for low-level or performance-critical code. </p>
<div class="code-block"><span class="SCde"><span class="SItr">@init</span>();                        <span class="SCmt">// Initialize a variable or memory area.</span>
<span class="SItr">@drop</span>();                        <span class="SCmt">// Destroy a variable or memory area.</span>
<span class="SItr">@postmove</span>();                    <span class="SCmt">// Post-move hook.</span>
<span class="SItr">@postcopy</span>();                    <span class="SCmt">// Post-copy hook.</span>
<span class="SItr">@kindof</span>();                      <span class="SCmt">// Kind of a type (e.g., primitive, struct).</span>
<span class="SItr">@countof</span>();                     <span class="SCmt">// Number of elements in an array.</span>
<span class="SItr">@dataof</span>();                      <span class="SCmt">// Pointer to underlying data of a type.</span>
<span class="SItr">@mkslice</span>();                     <span class="SCmt">// Create a slice from a data pointer and length.</span>
<span class="SItr">@mkstring</span>();                    <span class="SCmt">// Create a string from a data pointer and length.</span>
<span class="SItr">@mkany</span>();                       <span class="SCmt">// Create a generic 'any' from a value.</span>
<span class="SItr">@mkinterface</span>();                 <span class="SCmt">// Create an interface from an implementation.</span>
<span class="SItr">@mkcallback</span>();                  <span class="SCmt">// Create a callback from a function pointer.</span>
<span class="SItr">@tableof</span>();                     <span class="SCmt">// Interface table for a given type.</span>

<span class="SItr">#sizeof</span>();                      <span class="SCmt">// Size in bytes of a type or variable.</span>
<span class="SItr">#alignof</span>();                     <span class="SCmt">// Alignment requirement of a type.</span>
<span class="SItr">#offsetof</span>();                    <span class="SCmt">// Offset in bytes of a struct field.</span>
<span class="SItr">#typeof</span>();                      <span class="SCmt">// Type of an expression.</span>
<span class="SItr">#stringof</span>();                    <span class="SCmt">// String representation of a type or expression.</span>
<span class="SItr">#isconstexpr</span>();                 <span class="SCmt">// Check if an expression is a constant expression.</span></span></div>
<h3 id="_008_000_intrinsics_swg">Memory Intrinsics </h3>
<p>Memory management operations for allocation, deallocation, and manipulation. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@alloc</span>(size: <span class="STpe">u64</span>) -&gt; *<span class="STpe">void</span>;                         <span class="SCmt">// Allocate a block of memory.</span>
<span class="SKwd">func</span> <span class="SItr">@realloc</span>(ptr: *<span class="STpe">void</span>, size: <span class="STpe">u64</span>) -&gt; *<span class="STpe">void</span>;           <span class="SCmt">// Reallocate a block of memory.</span>
<span class="SKwd">func</span> <span class="SItr">@free</span>(ptr: *<span class="STpe">void</span>);                                  <span class="SCmt">// Free a previously allocated block.</span>
<span class="SKwd">func</span> <span class="SItr">@memset</span>(dst: *<span class="STpe">void</span>, value: <span class="STpe">u8</span>, size: <span class="STpe">u64</span>);          <span class="SCmt">// Set a block of memory to a value.</span>
<span class="SKwd">func</span> <span class="SItr">@memcpy</span>(dst: *<span class="STpe">void</span>, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>);   <span class="SCmt">// Copy a block of memory.</span>
<span class="SKwd">func</span> <span class="SItr">@memmove</span>(dst: *<span class="STpe">void</span>, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>);  <span class="SCmt">// Move a block of memory (overlap-safe).</span>
<span class="SKwd">func</span> <span class="SItr">@memcmp</span>(dst: <span class="SKwd">const</span> *<span class="STpe">void</span>, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>) -&gt; <span class="STpe">s32</span>; <span class="SCmt">// Compare two blocks of memory.</span>
<span class="SKwd">func</span> <span class="SItr">@strlen</span>(value: <span class="SKwd">const</span> *<span class="STpe">u8</span>) -&gt; <span class="STpe">u64</span>;                   <span class="SCmt">// Length of a null-terminated string.</span></span></div>
<h3 id="_008_000_intrinsics_swg">Atomic Intrinsics </h3>
<p>Thread-safe manipulation of variables in shared memory. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s8</span>,  value: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u8</span>,  value: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s8</span>,  value: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u8</span>,  value: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s8</span>,  value: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u8</span>,  value: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s8</span>,  value: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u8</span>,  value: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s8</span>,  exchangeWith: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s16</span>, exchangeWith: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s32</span>, exchangeWith: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s64</span>, exchangeWith: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u8</span>,  exchangeWith: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u16</span>, exchangeWith: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u32</span>, exchangeWith: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u64</span>, exchangeWith: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s8</span>,  compareTo: <span class="STpe">s8</span>,  exchangeWith: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s16</span>, compareTo: <span class="STpe">s16</span>, exchangeWith: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s32</span>, compareTo: <span class="STpe">s32</span>, exchangeWith: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s64</span>, compareTo: <span class="STpe">s64</span>, exchangeWith: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u8</span>,  compareTo: <span class="STpe">u8</span>,  exchangeWith: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u16</span>, compareTo: <span class="STpe">u16</span>, exchangeWith: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u32</span>, compareTo: <span class="STpe">u32</span>, exchangeWith: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u64</span>, compareTo: <span class="STpe">u64</span>, exchangeWith: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;</span></div>
<h3 id="_008_000_intrinsics_swg">Math Intrinsics </h3>
<p>Mathematical operations including trigonometric, logarithmic, rounding, and bit utilities. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@sqrt</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@sqrt</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@sin</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@sin</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@cos</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@cos</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@tan</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@tan</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@sinh</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@sinh</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@cosh</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@cosh</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@tanh</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@tanh</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@asin</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@asin</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@acos</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@acos</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@atan</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@atan</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@log</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@log</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@log2</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@log2</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@log10</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@log10</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@floor</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@floor</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@ceil</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@ceil</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@trunc</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@trunc</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@round</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@round</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@exp</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@exp</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@exp2</span>(value: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@exp2</span>(value: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@pow</span>(value1: <span class="STpe">f32</span>, value2: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@pow</span>(value1: <span class="STpe">f64</span>, value2: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">s8</span>,  value2: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">s16</span>, value2: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">s32</span>, value2: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">s64</span>, value2: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">u8</span>,  value2: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">u16</span>, value2: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">u32</span>, value2: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">u64</span>, value2: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">f32</span>, value2: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1: <span class="STpe">f64</span>, value2: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">s8</span>,  value2: <span class="STpe">s8</span>)  -&gt; <span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">s16</span>, value2: <span class="STpe">s16</span>) -&gt; <span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">s32</span>, value2: <span class="STpe">s32</span>) -&gt; <span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">s64</span>, value2: <span class="STpe">s64</span>) -&gt; <span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">u8</span>,  value2: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">u16</span>, value2: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">u32</span>, value2: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">u64</span>, value2: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">f32</span>, value2: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1: <span class="STpe">f64</span>, value2: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@rol</span>(value: <span class="STpe">u8</span>,  num: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@rol</span>(value: <span class="STpe">u16</span>, num: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@rol</span>(value: <span class="STpe">u32</span>, num: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@rol</span>(value: <span class="STpe">u64</span>, num: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@ror</span>(value: <span class="STpe">u8</span>,  num: <span class="STpe">u8</span>)  -&gt; <span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@ror</span>(value: <span class="STpe">u16</span>, num: <span class="STpe">u16</span>) -&gt; <span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@ror</span>(value: <span class="STpe">u32</span>, num: <span class="STpe">u32</span>) -&gt; <span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@ror</span>(value: <span class="STpe">u64</span>, num: <span class="STpe">u64</span>) -&gt; <span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@muladd</span>(val1: <span class="STpe">f32</span>, val2: <span class="STpe">f32</span>, val3: <span class="STpe">f32</span>) -&gt; <span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@muladd</span>(val1: <span class="STpe">f64</span>, val2: <span class="STpe">f64</span>, val3: <span class="STpe">f64</span>) -&gt; <span class="STpe">f64</span>;</span></div>

<h3 id="_008_000_intrinsics_swg__008_001_init_swg">Init </h3><h4 id="_008_000_intrinsics_swg__008_001_init_swg"><span class="code-inline">@init</span> Intrinsic </h4>
<p>Reinitializes a variable or memory region to either its type default value or a provided custom value (tuple for aggregates). </p>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Scalars — Default Initialization </h4>
<p>Reinitialize a single variable to its default value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">666</span>
    <span class="SItr">@init</span>(x) <span class="SCmt">// Reset variable 'x' to its default (0)</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Scalars — Initialization with a Specific Value </h4>
<p>Reinitialize a variable with a custom value instead of its default. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">666</span>'<span class="STpe">f32</span>
    <span class="SItr">@init</span>(x)(<span class="SNum">3.14</span>) <span class="SCmt">// Initialize variable 'x' with 3.14 instead of 0</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">3.14</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Arrays — Count-Based Default Initialization </h4>
<p>Reinitialize a specified number of elements in an array or memory block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>]

    <span class="SItr">@init</span>(&x, <span class="SNum">2</span>) <span class="SCmt">// Reset first 2 elements to their default (0)</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">0</span>)

    x[<span class="SNum">0</span>] = <span class="SNum">1</span>
    x[<span class="SNum">1</span>] = <span class="SNum">2</span>

    <span class="SItr">@init</span>(x) <span class="SCmt">// Reset the entire array to default values</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">0</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Arrays — Initialization with a Specific Value </h4>
<p>Initialize all targeted elements in an array to a given value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>]

    <span class="SItr">@init</span>(&x, <span class="SNum">2</span>)(<span class="SNum">555</span>) <span class="SCmt">// Initialize both elements to 555</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">555</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Structs — Reset to Declared Defaults </h4>
<p>Reinitialize a struct instance to its declared default field values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span> }

    <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span>{<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>}
    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">30</span>)

    <span class="SItr">@init</span>(rgb) <span class="SCmt">// Reset struct fields to their declared defaults</span>
    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">3</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Structs — Initialization with Specific Field Values </h4>
<p>Reinitialize a struct instance with custom field values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span> }

    <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span>{<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>}
    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">30</span>)

    <span class="SItr">@init</span>(rgb)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>) <span class="SCmt">// Assign new custom values to all struct fields</span>
    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">7</span>)
}</span></div>
<h4 id="_008_000_intrinsics_swg__008_001_init_swg">Arrays of Structs — Bulk Initialization and Reinitialization </h4>
<p>Reinitialize all elements of an array of structs with specified field values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span> }

    <span class="SKwd">var</span> rgb: [<span class="SNum">4</span>] <span class="SCst">RGB</span>

    <span class="SItr">@init</span>(&rgb, <span class="SNum">4</span>)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>) <span class="SCmt">// Initialize all 4 elements with (5, 6, 7)</span>
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].b == <span class="SNum">7</span>)

    <span class="SItr">@init</span>(rgb)(<span class="SNum">50</span>, <span class="SNum">60</span>, <span class="SNum">70</span>) <span class="SCmt">// Reinitialize entire array with new values</span>
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].r == <span class="SNum">50</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].g == <span class="SNum">60</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].b == <span class="SNum">70</span>)
}</span></div>

<h3 id="_008_000_intrinsics_swg__008_002_drop_swg">Drop </h3><h4 id="_008_000_intrinsics_swg__008_002_drop_swg"><span class="code-inline">@drop</span> Intrinsic </h4>
<p>The <span class="code-inline">@drop</span> intrinsic calls the <span class="code-inline">opDrop</span> method if it is defined for the struct. This ensures that any necessary cleanup operations (such as freeing resources) are performed before the variable is reinitialized. <span class="code-inline">@drop</span> is particularly useful in resource management, where explicit cleanup is required before resetting the variable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span> }

    <span class="SKwd">var</span> rgb: [<span class="SNum">4</span>] <span class="SCst">RGB</span>

    <span class="SItr">@drop</span>(&rgb, <span class="SNum">4</span>) <span class="SCmt">// If RGB defines opDrop, it will be invoked here for each element</span>

    <span class="SItr">@init</span>(&rgb, <span class="SNum">4</span>)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>) <span class="SCmt">// Reinitialize array elements after dropping</span>
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].b == <span class="SNum">7</span>)
}</span></div>

<h2 id="_009_000_generics_swg">Generics </h2>
<h3 id="_009_000_generics_swg__009_001_functions_swg">Functions </h3><h4 id="_009_000_generics_swg__009_001_functions_swg"><span class="code-inline">@generic</span> Functions </h4>
<p>A function can be made generic by specifying type parameters after the <span class="code-inline">func</span> keyword. These type parameters allow the function to operate on various types using the same implementation. The generic type parameters are placed within parentheses after <span class="code-inline">func</span>. When calling the function, the generic types are specified using <span class="code-inline">funcCall'(type1, type2, ...)</span>. If there is only one generic parameter, you can omit the parentheses. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Generic function where 'T' is the type parameter.</span>
        <span class="SKwd">func</span>(<span class="SKwd">var</span> <span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">s32</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>) <span class="SCmt">// Explicitly using 's32' as the generic type.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>) <span class="SCmt">// Explicitly using 'f32' as the generic type.</span>
    }

    {
        <span class="SCmt">// Declaring a generic function without 'var'.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">s32</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>) <span class="SCmt">// Type 's32' is inferred as the generic type.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>) <span class="SCmt">// Type 'f32' is inferred as the generic type.</span>
    }

    {
        <span class="SCmt">// Generic function with a default type parameter.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span> = <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">4</span>) <span class="SCmt">// Uses default type 's32'.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>) <span class="SCmt">// Overrides the default type with 'f32'.</span>
    }

    {
        <span class="SCmt">// Function with multiple generic parameters.</span>
        <span class="SKwd">func</span>(<span class="SCst">K</span>, <span class="SCst">V</span>) <span class="SFct">myFunc</span>(key: <span class="SCst">K</span>, value: <span class="SCst">V</span>) =&gt; value

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>, <span class="SStr">"value"</span>) == <span class="SStr">"value"</span>) <span class="SCmt">// K and V inferred from arguments.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="STpe">string</span>)(<span class="SNum">2</span>, <span class="SStr">"value"</span>) == <span class="SStr">"value"</span>) <span class="SCmt">// K and V explicitly specified.</span>

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>, <span class="SKwd">true</span>) == <span class="SKwd">true</span>) <span class="SCmt">// Type deduction for both K and V.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="STpe">bool</span>)(<span class="SNum">2</span>, <span class="SKwd">true</span>) == <span class="SKwd">true</span>) <span class="SCmt">// Explicit type declaration for K and V.</span>
    }
}</span></div>
<h4 id="_009_000_generics_swg__009_001_functions_swg">Type Deduction </h4>
<p>Generic types can often be deduced from the function's parameters, eliminating the need to specify the type explicitly at the call site. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">4</span>) <span class="SCmt">// Type 'T' deduced as 's32'.</span>
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2.0</span>'<span class="STpe">f32</span>) == <span class="SNum">4.0</span>) <span class="SCmt">// Type 'T' deduced as 'f32'.</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_001_functions_swg">Using Constants as Generic Parameters </h4>
<p>In addition to types, constants can also be used as generic parameters. </p>
<p>In this example, <span class="code-inline">N</span> is a constant of type <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SKwd">const</span> <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() =&gt; <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>'<span class="SNum">10</span>() <span class="SCmt">// Calls the function with constant value 10.</span>
}</span></div>
<p><span class="code-inline">const</span> can be omitted when declaring constants, as an identifier followed by a type is treated as a constant. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() =&gt; <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>'<span class="SNum">10</span>() <span class="SCmt">// Equivalent to using 'const'.</span>
}</span></div>
<p>You can also assign a default value to a constant parameter. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">N</span>: <span class="STpe">s32</span> = <span class="SNum">10</span>) <span class="SFct">myFunc</span>() =&gt; <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>() <span class="SCmt">// Uses the default constant value 10.</span>
}</span></div>
<p>If you declare the constant using <span class="code-inline">const</span>, the type can be omitted, and it will be deduced from the assigned value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SKwd">const</span> <span class="SCst">N</span> = <span class="SNum">10</span>) <span class="SFct">myFunc</span>() =&gt; <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>() <span class="SCmt">// Type of N deduced from literal 10.</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_001_functions_swg">Mixing Types and Constants </h4>
<p>You can mix type parameters and constant parameters within the same generic function. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Example where 'T' is a type and 'N' is a constant of type s32.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(x: <span class="SCst">T</span>) =&gt; x * <span class="SCst">N</span>

        <span class="SKwd">alias</span> call = <span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(<span class="SFct">call</span>(<span class="SNum">2</span>) == <span class="SNum">20</span>) <span class="SCmt">// 's32' type and constant 10 used.</span>
        <span class="SItr">@assert</span>(<span class="SFct">call</span>(<span class="SNum">100</span>) == <span class="SNum">1000</span>) <span class="SCmt">// Same type and constant reused.</span>
    }

    {
        <span class="SCmt">// Example using multiple constant parameters.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>: <span class="STpe">s32</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() =&gt; <span class="SCst">T</span> * <span class="SCst">N</span>

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="SNum">5</span>, <span class="SNum">10</span>)() == <span class="SNum">50</span>) <span class="SCmt">// Function called with two s32 constants.</span>
    }

    {
        <span class="SCmt">// Multiple type parameters with default values.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span> = <span class="STpe">s32</span>, <span class="SCst">V</span> = <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(x: <span class="SCst">T</span>, y: <span class="SCst">V</span>) =&gt; x * y

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">1</span>'<span class="STpe">s32</span>, <span class="SNum">2</span>'<span class="STpe">f32</span>) == <span class="SNum">2.0</span>) <span class="SCmt">// Mixed s32 and f32, type deduced.</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">1</span>'<span class="STpe">s32</span>, <span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">2</span>) <span class="SCmt">// Both parameters use s32.</span>
    }
}</span></div>

<h3 id="_009_000_generics_swg__009_002_structs_swg">Structs </h3><h4 id="_009_000_generics_swg__009_002_structs_swg">Generic Structs </h4>
<p>Structs in Swag can also be made generic, allowing them to operate with different types and constants. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Generic struct example where 'T' represents a type parameter.</span>
        <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">Struct</span>
        {
            val: <span class="SCst">T</span>
        }

        <span class="SKwd">let</span> x: <span class="SFct">Struct</span>'<span class="STpe">s32</span>
        <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(x.val) == <span class="STpe">s32</span>) <span class="SCmt">// The field 'val' has type 's32'.</span>

        <span class="SKwd">let</span> x1: <span class="SFct">Struct</span>'<span class="STpe">f32</span>
        <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(x1.val) == <span class="STpe">f32</span>) <span class="SCmt">// The field 'val' has type 'f32'.</span>
    }

    {
        <span class="SCmt">// Generic struct with both a type and a constant parameter.</span>
        <span class="SKwd">struct</span>(<span class="SCst">T</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SCst">Struct</span>
        {
            val: [<span class="SCst">N</span>] <span class="SCst">T</span> <span class="SCmt">// Array of 'N' elements of type 'T'.</span>
        }

        <span class="SKwd">let</span> x: <span class="SFct">Struct</span>'(<span class="STpe">bool</span>, <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(x.val) == <span class="SItr">#type</span> [<span class="SNum">10</span>] <span class="STpe">bool</span>) <span class="SCmt">// 'val' is an array of 10 booleans.</span>
    }
}</span></div>

<h3 id="_009_000_generics_swg__009_003_where_constraints_swg">Where Constraints </h3><h4 id="_009_000_generics_swg__009_003_where_constraints_swg">'Single Evaluation' </h4>
<p>The <span class="code-inline">where</span> clause in Swag applies constraints on function invocations, ensuring they can only be called when specific conditions are met. This is especially useful in generic functions where you want to restrict permissible types or values. </p>
<p>When the <span class="code-inline">where</span> expression evaluates to false, the function is not considered during the call; if no alternative overloads match, the compiler raises an error. The <span class="code-inline">where</span> expression is evaluated only once, usually during function instantiation, making it ideal for stable constraints on generic parameters. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Validate the type: only 's32' or 's64' are accepted for T.</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x: <span class="SCst">T</span>...)-&gt;<span class="SCst">T</span>
        <span class="SLgc">where</span> <span class="SCst">T</span> == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">s64</span>
    {
        <span class="SKwd">var</span> total = <span class="SNum">0</span>'<span class="SCst">T</span>
        <span class="SLgc">foreach</span> it <span class="SLgc">in</span> x <span class="SLgc">do</span>
            total += it
        <span class="SLgc">return</span> total
    }

    <span class="SCmt">// Valid calls: T is 's32' or 's64'.</span>
    <span class="SKwd">let</span> res1 = <span class="SFct">sum</span>'<span class="STpe">s32</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(res1 == <span class="SNum">3</span>)

    <span class="SKwd">let</span> res2 = <span class="SFct">sum</span>'<span class="STpe">s64</span>(<span class="SNum">10</span>, <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(res2 == <span class="SNum">30</span>)

    <span class="SCmt">// The following would be an error: 'f32' is not accepted.</span>
    <span class="SCmt">// var res3 = sum'f32(1, 2)</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">'Generic Specialization' </h4>
<p>The <span class="code-inline">where</span> clause supports specialized implementations of generic functions. You can provide distinct implementations based on type or value to improve clarity and efficiency. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Specialization for 's32'.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">isNull</span>(x: <span class="SCst">T</span>)-&gt;<span class="STpe">bool</span>
        <span class="SLgc">where</span> <span class="SCst">T</span> == <span class="STpe">s32</span>
    {
        <span class="SLgc">return</span> x == <span class="SNum">0</span>
    }

    <span class="SCmt">// Specialization for 'f32' and 'f64'.</span>
    <span class="SAtr">#[Swag.Overload]</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">isNull</span>(x: <span class="SCst">T</span>)-&gt;<span class="STpe">bool</span>
        <span class="SLgc">where</span> <span class="SCst">T</span> == <span class="STpe">f32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">f64</span>
    {
        <span class="SLgc">return</span> <span class="SItr">@abs</span>(x) &lt; <span class="SNum">0.01</span>
    }

    <span class="SItr">@assert</span>(<span class="SFct">isNull</span>(<span class="SNum">0</span>'<span class="STpe">s32</span>))
    <span class="SItr">@assert</span>(<span class="SFct">isNull</span>(<span class="SNum">0.001</span>'<span class="STpe">f32</span>))
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">'Block-based where' Clause </h4>
<p>The <span class="code-inline">where</span> clause can be a block returning a bool, which enables more complex compile-time checks. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Function accepts only T in {'s32', 's64'} via a block-based condition.</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x: <span class="SCst">T</span>...)-&gt;<span class="SCst">T</span>
        <span class="SLgc">where</span>
        {
            <span class="SLgc">if</span> <span class="SItr">#typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SItr">#typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s64</span> <span class="SLgc">do</span>
                <span class="SLgc">return</span> <span class="SKwd">true</span>
            <span class="SLgc">return</span> <span class="SKwd">false</span>
        }
    {
        <span class="SKwd">var</span> total = <span class="SNum">0</span>'<span class="SCst">T</span>
        <span class="SLgc">foreach</span> it <span class="SLgc">in</span> x <span class="SLgc">do</span>
            total += it
        <span class="SLgc">return</span> total
    }
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">'Custom Compile-time Errors' </h4>
<p>Using the <span class="code-inline">@compilererror</span> intrinsic, you can emit custom compile-time errors when <span class="code-inline">where</span> conditions fail. This guides users with clear diagnostics. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x, y: <span class="SCst">T</span>)-&gt;<span class="SCst">T</span>
        <span class="SLgc">where</span>
        {
            <span class="SLgc">if</span> <span class="SCst">T</span> == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">s64</span> <span class="SLgc">do</span>
                <span class="SLgc">return</span> <span class="SKwd">true</span>

            <span class="SItr">@compilererror</span>('<span class="SCst">Invalid</span> type ' ++ <span class="SItr">#stringof</span>(<span class="SCst">T</span>), <span class="SItr">#location</span>(<span class="SCst">T</span>))
            <span class="SLgc">return</span> <span class="SKwd">false</span>
        }
    {
        <span class="SLgc">return</span> x + y
    }

    <span class="SCmt">// This would trigger a compile-time error: 'f32' is not valid here.</span>
    <span class="SCmt">// var x = sum'f32(1, 2)</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">'Generic Structs' with <span class="code-inline">where</span> </h4>
<p>The <span class="code-inline">where</span> clause also applies to generic structs. If the condition is not met, an error is emitted immediately (there is no overload resolution for structs). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Point constrained to floating types 'f32' or 'f64'.</span>
    <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">Point</span>
            <span class="SLgc">where</span> <span class="SCst">T</span> == <span class="STpe">f32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">f64</span>
    {
        x, y: <span class="SCst">T</span>
    }

    <span class="SCmt">// Valid instantiation with 'f32'.</span>
    <span class="SKwd">var</span> v: <span class="SFct">Point</span>'<span class="STpe">f32</span>

    <span class="SCmt">// Error: 's32' is not permitted by the struct constraint.</span>
    <span class="SCmt">// var v: Point's32</span>
}</span></div>
<h4 id="_009_000_generics_swg__009_003_where_constraints_swg">'Multiple Evaluations' with <span class="code-inline">verify</span> </h4>
<p>With <span class="code-inline">verify</span> mode, the constraint is evaluated for each call (rather than once per instantiation). This suits conditions depending on actual arguments, provided they are evaluable at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Division function: ensure 'y' is not zero at compile time when possible.</span>
        <span class="SKwd">func</span> <span class="SFct">div</span>(x, y: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
            <span class="SLgc">verify</span>
            {
                <span class="SCmt">// If 'y' is not constexpr, allow the call; otherwise check for zero.</span>
                <span class="SLgc">if</span> !<span class="SItr">#isconstexpr</span>(y) <span class="SLgc">do</span>
                    <span class="SLgc">return</span> <span class="SKwd">true</span>
                <span class="SLgc">if</span> y == <span class="SNum">0</span> <span class="SLgc">do</span>
                    <span class="SItr">@compilererror</span>(<span class="SStr">"Division by zero"</span>, <span class="SItr">#location</span>(y))
                <span class="SLgc">return</span> <span class="SKwd">true</span>
            }
        {
            <span class="SLgc">return</span> x / y
        }

        <span class="SCmt">// Valid division.</span>
        <span class="SKwd">var</span> x1 = <span class="SFct">div</span>(<span class="SNum">1</span>, <span class="SNum">1</span>)

        <span class="SCmt">// Compile-time error example:</span>
        <span class="SCmt">// var x2 = div(1, 0)</span>
    }

    {
        <span class="SCmt">// Overload selected when 'x' is known at compile time.</span>
        <span class="SAtr">#[Swag.Overload]</span>
        <span class="SKwd">func</span> <span class="SFct">first</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
            <span class="SLgc">verify</span> <span class="SItr">#isconstexpr</span>(x)
        {
            <span class="SLgc">return</span> <span class="SNum">555</span>
        }

        <span class="SCmt">// Overload selected when 'x' is not known at compile time.</span>
        <span class="SAtr">#[Swag.Overload]</span>
        <span class="SKwd">func</span> <span class="SFct">first</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
            <span class="SLgc">verify</span> !<span class="SItr">#isconstexpr</span>(x)
        {
            <span class="SLgc">return</span> <span class="SNum">666</span>
        }

        <span class="SCmt">// Literal: chooses the constexpr version.</span>
        <span class="SItr">@assert</span>(<span class="SFct">first</span>(<span class="SNum">0</span>) == <span class="SNum">555</span>)

        <span class="SCmt">// Variable: chooses the non-constexpr version.</span>
        <span class="SKwd">var</span> a: <span class="STpe">s32</span>
        <span class="SItr">@assert</span>(<span class="SFct">first</span>(a) == <span class="SNum">666</span>)
    }
}</span></div>

<h2 id="_010_000_attributes_swg">Attributes </h2><p>Attributes are tags associated with functions, structures etc... </p>

<h3 id="_010_000_attributes_swg__010_001_user_attributes_swg">User Attributes </h3><h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">'User Attributes in Swag' </h4>
<p>Attributes in Swag let you annotate code elements (functions, structs, etc.) with metadata. These annotations, defined with the <span class="code-inline">attr</span> keyword, can power code generation, documentation, and reflection. By attaching attributes, you enrich code with extra information usable at compile time and at runtime. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Swag</span>

<span class="SKwd">attr</span> <span class="SFct">AttributeA</span>()
<span class="SCmt">// Simple attribute without parameters</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">'Attributes with Parameters' </h4>
<p>Attributes can accept parameters, similar to functions. Parameters let you customize how the attribute configures the annotated element. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">attr</span> <span class="SFct">AttributeB</span>(x, y: <span class="STpe">s32</span>, z: <span class="STpe">string</span>)
<span class="SCmt">// Attribute with multiple parameters</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">'Attributes with Default Values' </h4>
<p>Attributes may define default parameter values. When applied, omitted arguments fall back to their defaults. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">attr</span> <span class="SFct">AttributeBA</span>(x: <span class="STpe">s32</span>, y: <span class="STpe">string</span> = <span class="SStr">"string"</span>)
<span class="SCmt">// Attribute with a defaulted parameter</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">'Restricting Attribute Usage' </h4>
<p>Use the <span class="code-inline">AttrUsage</span> specifier to control where an attribute may be applied (e.g., function-only, struct-only). This improves safety and clarity. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">AttributeC</span>()
<span class="SCmt">// Restricted to function usage</span></span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">'Applying Attributes' </h4>
<p>Apply attributes with the syntax '#[attribute, attribute...]' placed immediately before the code element. Multiple attributes are comma-separated. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttributeA, AttributeB(0, 0, "string")]</span>
<span class="SKwd">func</span> <span class="SFct">function1</span>()
{
    <span class="SCmt">// Function annotated with multiple attributes</span>
}</span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">'Multiple Usages' </h4>
<p>An attribute can target several element kinds by combining <span class="code-inline">AttrUsage</span> flags with a bitwise OR. This enables reuse across contexts (e.g., functions, structs). </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">AttributeD</span>(x: <span class="STpe">s32</span>)
<span class="SCmt">// Applicable to both functions and structs</span>

<span class="SAtr">#[AttributeD(6)]</span>
<span class="SKwd">func</span> <span class="SFct">function2</span>()
{
    <span class="SCmt">// Function annotated with a multi-usage attribute</span>
}

<span class="SAtr">#[AttributeD(150)]</span>
<span class="SKwd">struct</span> struct1
{
    <span class="SCmt">// Struct annotated with the same attribute</span>
}</span></div>
<h4 id="_010_000_attributes_swg__010_001_user_attributes_swg">'Retrieving Attributes at Runtime' </h4>
<p>You can inspect attributes via type reflection at runtime. This enables behavior that adapts based on which attributes are present and how they are configured. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> type = <span class="SItr">#typeof</span>(function2) <span class="SCmt">// Reflect the function type</span>
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(type.attributes) == <span class="SNum">1</span>) <span class="SCmt">// Exactly one attribute on 'function2'</span>
}</span></div>

<h3 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Predefined Attributes </h3><h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Predefined Attributes </h4>
<p>This is the list of predefined attributes. All are located in the reserved <span class="code-inline">Swag</span> namespace. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip</span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Compile-time & Code Generation </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">ConstExpr</span>()            <span class="SCmt">// Executable at compile time</span>

<span class="SCmt">// Print generated bytecode right after generation (no optimizations yet)</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SFct">PrintGenBc</span>()

<span class="SCmt">// Print generated bytecode after bytecode optimizations</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SFct">PrintBc</span>()

<span class="SCmt">// Function or variable exists only at compile time</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.GlobalVariable | AttributeUsage.Constant)]</span>
<span class="SKwd">attr</span> <span class="SFct">Compiler</span>()</span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Inlining & Call Semantics </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Inline</span>()               <span class="SCmt">// Force inlining</span>

<span class="SCmt">// Hint for the 'llvm' backend to never inline</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">NoInline</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">CalleeReturn</span>()         <span class="SCmt">// 'return' in inlined function returns from caller</span></span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Metaprogramming </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Macro</span>()                <span class="SCmt">// Function is a macro</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Mixin</span>()                <span class="SCmt">// Function is a mixin</span></span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Casting & Overloads & Switches </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Implicit</span>()             <span class="SCmt">// Allow 'opCast' to be implicit</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Complete</span>()             <span class="SCmt">// Following switch must be complete</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Overload</span>()             <span class="SCmt">// Function can be overloaded</span></span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Foreign Interop </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Foreign</span>(module: <span class="STpe">string</span>, function: <span class="STpe">string</span> = <span class="SStr">''</span>) <span class="SCmt">// Imported function</span></span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Result Usage & Deprecation & Generic Control </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Variable)]</span>
<span class="SKwd">attr</span> <span class="SFct">Discardable</span>()          <span class="SCmt">// Allow caller to ignore return value</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct | AttributeUsage.Enum | AttributeUsage.EnumValue)]</span>
<span class="SKwd">attr</span> <span class="SFct">Deprecated</span>(msg: <span class="STpe">string</span> = <span class="SKwd">null</span>) <span class="SCmt">// Mark definition as deprecated</span>

<span class="SCmt">// Force function to not be generic, even inside a generic struct</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">NotGeneric</span>()</span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Memory & Layout (Globals and Structs) </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.GlobalVariable)]</span>
<span class="SKwd">attr</span> <span class="SFct">Tls</span>()                  <span class="SCmt">// Put global variable in TLS segment</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">Pack</span>(value: <span class="STpe">u8</span>)        <span class="SCmt">// Struct packing information</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">NoCopy</span>()               <span class="SCmt">// Struct should never be copied</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">Opaque</span>()               <span class="SCmt">// When exporting, do not export struct content</span>

<span class="SCmt">// Field member relocation: field offset matches variable 'name'</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.StructVariable)]</span>
<span class="SKwd">attr</span> <span class="SFct">Offset</span>(name: <span class="STpe">string</span>)</span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Enum Constraints </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SFct">EnumFlags</span>()            <span class="SCmt">// Enum represents a set of flags</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SFct">EnumIndex</span>()            <span class="SCmt">// Enum can index arrays without casting</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SFct">NoDuplicate</span>()          <span class="SCmt">// Enum values must be unique</span>

<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SFct">Incomplete</span>()           <span class="SCmt">// Following switch is incomplete</span></span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Module Export & Documentation </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SFct">ExportType</span>(what: <span class="STpe">string</span>)

<span class="SAtr">#[AttrUsage(AttributeUsage.All | AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SFct">NoDoc</span>()                <span class="SCmt">// Do not generate documentation</span></span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Safety Controls </h4>
<p>Enable or disable safety checks. Examples: </p>
<div class="code-block"><span class="SCde">#[Swag.Safety('', false)]                 // Disable all checks
#[Swag.Safety('boundcheck|nan', false)]   // Disable 'boundcheck' and 'nan'</span></div>
<p>Checks: </p>
<ul>
<li><span class="code-inline">boundcheck</span>  -&gt; Out-of-bounds access</li>
<li><span class="code-inline">overflow</span>    -&gt; Loss on type conversion</li>
<li><span class="code-inline">math</span>        -&gt; Math checks (e.g., negative <span class="code-inline">@sqrt</span>)</li>
<li><span class="code-inline">switch</span>      -&gt; Invalid case in <span class="code-inline">#[Swag.Complete]</span> switch</li>
<li><span class="code-inline">unreachable</span> -&gt; Panic on <span class="code-inline">@unreachable</span></li>
<li><span class="code-inline">any</span>         -&gt; Panic if <span class="code-inline">any</span> cast mismatches runtime type</li>
<li><span class="code-inline">bool</span>        -&gt; Panic if <span class="code-inline">bool</span> is not <span class="code-inline">true</span> or <span class="code-inline">false</span></li>
<li><span class="code-inline">nan</span>         -&gt; Panic if <span class="code-inline">nan</span> used in float arithmetic</li>
<li><span class="code-inline">sanity</span>      -&gt; Per-function sanity check</li>
<li><span class="code-inline">null</span>        -&gt; Panic on dereferencing null pointers</li>
</ul>
<p>If <span class="code-inline">what</span> is null or empty, every option will be affected. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.All | AttributeUsage.File), AttrMulti]</span>
<span class="SKwd">attr</span> <span class="SFct">Safety</span>(what: <span class="STpe">string</span>, value: <span class="STpe">bool</span>)</span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Optimization Controls </h4>
<p>Enable or disable optimizations. Options: </p>
<ul>
<li><span class="code-inline">bytecode</span> -&gt; Toggle bytecode optimization</li>
<li><span class="code-inline">backend</span>  -&gt; Toggle backend machine code optimization (<span class="code-inline">llvm</span> only)</li>
</ul>
<p>If <span class="code-inline">what</span> is null or empty, every option will be affected. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.File), AttrMulti]</span>
<span class="SKwd">attr</span> <span class="SFct">Optimize</span>(what: <span class="STpe">string</span>, value: <span class="STpe">bool</span>)</span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Arithmetic Behavior </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.All | AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SFct">CanOverflow</span>(value: <span class="STpe">bool</span>)</span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Warning Controls </h4>
<div class="code-block"><span class="SCde"><span class="SKwd">enum</span> <span class="SCst">WarningLevel</span>: <span class="STpe">u8</span>
{
    <span class="SCst">Enable</span>      <span class="SCmt">// Enable the given warning</span>
    <span class="SCst">Disable</span>     <span class="SCmt">// Disable the given warning</span>
    <span class="SCst">Error</span>       <span class="SCmt">// Raise the given warning as an error</span>
}

<span class="SCmt">// Change behavior of one or more warnings.</span>
<span class="SCmt">// Examples:</span>
<span class="SCmt">// ```</span>
<span class="SCmt">// #[Swag.Warning('Wrn0006', Swag.WarningLevel.Error)]</span>
<span class="SCmt">// #[Swag.Warning('Wrn0002|Wrn0006', Swag.WarningLevel.Disable)]</span>
<span class="SCmt">// #global #[Swag.Warning('Wrn0005', Swag.WarningLevel.Enable)]</span>
<span class="SCmt">// ```</span>
<span class="SCmt">// You can also configure module-wide behavior in your 'BuildCfg'.</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.All | AttributeUsage.File), AttrMulti]</span>
<span class="SKwd">attr</span> <span class="SFct">Warning</span>(what: <span class="STpe">string</span>, level: <span class="SCst">WarningLevel</span>)</span></div>
<h4 id="_010_000_attributes_swg__010_002_predefined_attributes_swg">Matching & Misc </h4>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.All)]</span>
<span class="SKwd">attr</span> <span class="SFct">Match</span>(what: <span class="STpe">string</span>, value: <span class="STpe">bool</span>)

<span class="SKwd">attr</span> <span class="SFct">Strict</span>()
<span class="SKwd">attr</span> <span class="SFct">Global</span>()
<span class="SKwd">attr</span> <span class="SFct">Align</span>(value: <span class="STpe">u8</span>)</span></div>

<h2 id="_011_000_scoping_swg">Scoping </h2>
<h3 id="_011_000_scoping_swg__011_001_namespace_swg">Namespace </h3><h4 id="_011_000_scoping_swg__011_001_namespace_swg">'Namespaces in Swag' </h4>
<p>Namespaces in Swag provide a structured way to organize symbols — functions, variables, and types — within a specific scope. Grouping related symbols under a namespace helps prevent naming conflicts and makes the code more modular and maintainable. </p>
<p>Symbols in a namespace are accessible only through that namespace unless they are explicitly imported or exposed. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Define a simple namespace 'A'</span>
<span class="SKwd">namespace</span> <span class="SCst">A</span>
{
    <span class="SCmt">// Function 'a' is defined within the namespace 'A'.</span>
    <span class="SKwd">func</span> <span class="SFct">a</span>() =&gt; <span class="SNum">1</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_001_namespace_swg">'Nested Namespaces' </h4>
<p>Swag supports nested namespaces, allowing hierarchical organization of symbols. This enables fine-grained structuring of code, which is especially helpful in large projects. In the example below, <span class="code-inline">C</span> is nested inside <span class="code-inline">B</span>, which is nested inside <span class="code-inline">A</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Define a nested namespace 'A.B.C'</span>
<span class="SKwd">namespace</span> <span class="SCst">A</span>.<span class="SCst">B</span>.<span class="SCst">C</span>
{
    <span class="SCmt">// Function 'a' is defined within the nested namespace 'A.B.C'.</span>
    <span class="SKwd">func</span> <span class="SFct">a</span>() =&gt; <span class="SNum">2</span>
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Access functions using their fully qualified namespace paths.</span>
    <span class="SItr">@assert</span>(<span class="SCst">A</span>.<span class="SFct">a</span>() == <span class="SNum">1</span>) <span class="SCmt">// Calls 'a' from namespace 'A'</span>
    <span class="SItr">@assert</span>(<span class="SCst">A</span>.<span class="SCst">B</span>.<span class="SCst">C</span>.<span class="SFct">a</span>() == <span class="SNum">2</span>) <span class="SCmt">// Calls 'a' from nested namespace 'A.B.C'</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_001_namespace_swg"><span class="code-inline">Using</span> with Namespaces </h4>
<p>The <span class="code-inline">using</span> keyword imports symbols from a namespace into the current scope. This eliminates the need to fully qualify symbols, improving readability, especially when dealing with deeply nested namespaces. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SKwd">namespace</span> <span class="SCst">Private</span>
{
    <span class="SKwd">const</span> <span class="SCst">FileSymbol</span> = <span class="SNum">0</span> <span class="SCmt">// Constant defined within namespace 'Private'</span>
}

<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCst">Private</span>.<span class="SCst">FileSymbol</span>     <span class="SCmt">// Access via fully qualified name</span>
<span class="SKwd">const</span> <span class="SCst">C</span> = <span class="SCst">FileSymbol</span>             <span class="SCmt">// Direct access via 'using' directive</span></span></div>
<h4 id="_011_000_scoping_swg__011_001_namespace_swg"><span class="code-inline">Private</span> Scopes </h4>
<p>In addition to named namespaces, Swag provides <span class="code-inline">private</span> scopes. A private scope creates a unique, unnamed namespace restricted to the current file. Symbols defined in such a scope are inaccessible outside it, making this useful for isolating internal details. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">private</span>
{
    <span class="SKwd">const</span> <span class="SCst">OtherSymbol</span> = <span class="SNum">0</span> <span class="SCmt">// Constant defined in a file-local private scope</span>
}

<span class="SKwd">const</span> <span class="SCst">D</span> = <span class="SCst">OtherSymbol</span> <span class="SCmt">// Accessible within this file only</span></span></div>
<h4 id="_011_000_scoping_swg__011_001_namespace_swg">'Exporting Symbols' </h4>
<p>By default, all symbols in a Swag file are exported to other files within the same module. Using explicit namespaces or private scopes provides protection against accidental symbol conflicts across files. </p>

<h3 id="_011_000_scoping_swg__011_002_defer_swg">Defer </h3><h4 id="_011_000_scoping_swg__011_002_defer_swg"><span class="code-inline">defer</span> Statement </h4>
<p>The <span class="code-inline">defer</span> statement registers an expression that executes automatically when the current scope is exited. It runs purely at compile time and ensures that cleanup or finalization logic is always performed. This helps maintain clarity and safety in resource management. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v = <span class="SNum">0</span>
    <span class="SLgc">defer</span> <span class="SItr">@assert</span>(v == <span class="SNum">1</span>) <span class="SCmt">// Ensures v equals 1 on scope exit.</span>
    v += <span class="SNum">1</span> <span class="SCmt">// Increment v.</span>

    <span class="SCmt">// When the scope ends, the deferred expression executes here.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">'Defer in a Block' </h4>
<p>A <span class="code-inline">defer</span> can also enclose multiple expressions within a block. This allows you to group operations that should all run when leaving the scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v = <span class="SNum">0</span>
    <span class="SLgc">defer</span>
    {
        v += <span class="SNum">10</span>
        <span class="SItr">@assert</span>(v == <span class="SNum">15</span>)
    }

    v += <span class="SNum">5</span>
    <span class="SCmt">// Upon scope exit, the defer block executes, ensuring v == 15.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">'Defer with Control Flow' </h4>
<p>The deferred expression executes every time a scope exits, even when leaving via <span class="code-inline">return</span>, <span class="code-inline">break</span>, or <span class="code-inline">continue</span>. This guarantees proper cleanup in all control flow paths. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        <span class="SLgc">defer</span> <span class="SCst">G</span> += <span class="SNum">1</span> <span class="SCmt">// Increment G at end of each iteration, even if broken.</span>

        <span class="SLgc">if</span> <span class="SCst">G</span> == <span class="SNum">2</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span> <span class="SCmt">// Exiting early still triggers the defer expression.</span>
    }

    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">3</span>)
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">'Defer Execution Order' </h4>
<p>When multiple <span class="code-inline">defer</span> statements exist, they execute in reverse declaration order. The most recent defer runs first when the scope ends. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>
    <span class="SLgc">defer</span> <span class="SItr">@assert</span>(x == <span class="SNum">2</span>) <span class="SCmt">// Executes second</span>
    <span class="SLgc">defer</span> x *= <span class="SNum">2</span> <span class="SCmt">// Executes first</span>

    <span class="SCmt">// Execution order is reversed for predictable cleanup flow.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">Example: Resource Management </h4>
<p><span class="code-inline">defer</span> is ideal for resource handling — ensuring that allocation and release logic stay close together and cleanup always happens. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">createResource</span>()                 =&gt; <span class="SKwd">true</span>
    <span class="SKwd">func</span> <span class="SFct">releaseResource</span>(resource: *<span class="STpe">bool</span>) =&gt; <span class="SKwd">dref</span> resource = <span class="SKwd">false</span>
    <span class="SKwd">func</span> <span class="SFct">isResourceCreated</span>(b: <span class="STpe">bool</span>)       =&gt; b

    <span class="SKwd">var</span> resource = <span class="SKwd">false</span>
    <span class="SLgc">for</span> <span class="SNum">10</span>
    {
        resource = <span class="SFct">createResource</span>()
        <span class="SLgc">defer</span>
        {
            <span class="SItr">@assert</span>(resource.<span class="SFct">isResourceCreated</span>())
            <span class="SFct">releaseResource</span>(&resource)
        }

        <span class="SLgc">if</span> <span class="SItr">@index</span> == <span class="SNum">2</span> <span class="SLgc">do</span>
            <span class="SLgc">break</span> <span class="SCmt">// Defer ensures cleanup even on early exit.</span>
    }

    <span class="SItr">@assert</span>(!resource.<span class="SFct">isResourceCreated</span>())
}</span></div>
<h4 id="_011_000_scoping_swg__011_002_defer_swg">Example: Error Handling </h4>
<p><span class="code-inline">defer</span> ensures reliable cleanup even in functions that may return early due to errors. This pattern creates robust, error-resilient code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">createResource</span>()                 =&gt; <span class="SKwd">true</span>
    <span class="SKwd">func</span> <span class="SFct">releaseResource</span>(resource: *<span class="STpe">bool</span>) =&gt; <span class="SKwd">dref</span> resource = <span class="SKwd">false</span>
    <span class="SKwd">func</span> <span class="SFct">isResourceCreated</span>(b: <span class="STpe">bool</span>)       =&gt; b

    <span class="SKwd">func</span> <span class="SFct">performTask</span>()-&gt;<span class="STpe">bool</span>
    {
        <span class="SKwd">var</span> resource = <span class="SFct">createResource</span>()
        <span class="SLgc">defer</span> <span class="SFct">releaseResource</span>(&resource) <span class="SCmt">// Always release resource.</span>

        <span class="SLgc">if</span> !resource.<span class="SFct">isResourceCreated</span>()
        {
            <span class="SCmt">// Early return still triggers defer.</span>
            <span class="SLgc">return</span> <span class="SKwd">false</span>
        }

        <span class="SCmt">// Perform work...</span>
        <span class="SLgc">return</span> <span class="SKwd">true</span>
    }

    <span class="SKwd">let</span> success = <span class="SFct">performTask</span>()
    <span class="SItr">@assert</span>(success)
}</span></div>

<h3 id="_011_000_scoping_swg__011_003_using_swg">Using </h3><h4 id="_011_000_scoping_swg__011_003_using_swg"><span class="code-inline">using</span> with Enums and Namespaces </h4>
<p>The <span class="code-inline">using</span> statement can bring the scope of a namespace, struct, or enum into the current context. This removes the need for full qualification when accessing members. For enums, it simplifies code by avoiding repetitive type prefixes. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span> == <span class="SNum">0</span>) <span class="SCmt">// Fully qualified access.</span>

    <span class="SKwd">using</span> <span class="SCst">RGB</span> <span class="SCmt">// Import enum members into the current scope.</span>
    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">1</span>) <span class="SCmt">// 'G' accessible directly without 'RGB.' prefix.</span>
}</span></div>
<h4 id="_011_000_scoping_swg__011_003_using_swg"><span class="code-inline">using</span> with Struct Fields </h4>
<p>The <span class="code-inline">using</span> statement can be applied to struct fields, exposing the fields of a nested struct as if they were part of the containing struct. This is useful for composition-like behavior, improving code readability and reducing nesting. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point2</span> { x, y: <span class="STpe">s32</span> }

    <span class="SKwd">struct</span> <span class="SCst">Point3</span>
    {
        <span class="SKwd">using</span> base:     <span class="SCst">Point2</span>     <span class="SCmt">// Bring 'Point2' fields into 'Point3' scope.</span>
        z:              <span class="STpe">s32</span>
    }

    <span class="SKwd">var</span> value: <span class="SCst">Point3</span>

    <span class="SCmt">// Fields from 'base' are directly accessible.</span>
    value.x = <span class="SNum">0</span>
    value.y = <span class="SNum">0</span>
    value.z = <span class="SNum">0</span>

    <span class="SItr">@assert</span>(&value.x == &value.base.x)
    <span class="SItr">@assert</span>(&value.y == &value.base.y)

    <span class="SCmt">// Automatic cast: Point3 can be treated as Point2.</span>
    <span class="SKwd">func</span> <span class="SFct">set1</span>(ptr: *<span class="SCst">Point2</span>)
    {
        ptr.x, ptr.y = <span class="SNum">1</span>
    }

    <span class="SFct">set1</span>(&value)

    <span class="SItr">@assert</span>(value.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(value.y == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(value.base.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(value.base.y == <span class="SNum">1</span>)
}</span></div>

<h3 id="_011_000_scoping_swg__011_004_with_swg">With </h3><h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> Statement </h4>
<p>The <span class="code-inline">with</span> statement reduces repetition by letting you access fields and methods of a variable, struct, or namespace within a scoped block. Inside a <span class="code-inline">with</span> block, the <span class="code-inline">.</span> prefix refers to the selected object, yielding concise, readable code. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Point</span> { x, y: <span class="STpe">s32</span> }

<span class="SKwd">impl</span> <span class="SCst">Point</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">setOne</span>()
    {
        <span class="STpe">me</span>.x, <span class="STpe">me</span>.y = <span class="SNum">1</span>
        <span class="SCmt">// Set both coordinates to 1 on this Point.</span>
    }
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with a Namespace </h4>
<p>You can apply <span class="code-inline">with</span> to a namespace to call functions or access constants without fully qualifying names. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">namespace</span> <span class="SCst">NameSpace</span>
{
    <span class="SKwd">func</span> <span class="SFct">inside0</span>()
    {
        <span class="SCmt">// Example namespaced function.</span>
    }

    <span class="SKwd">func</span> <span class="SFct">inside1</span>()
    {
        <span class="SCmt">// Another namespaced function.</span>
    }
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> on a Variable </h4>
<p>Use <span class="code-inline">with</span> with a variable to streamline field access without repeating the variable name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    <span class="SKwd">with</span> pt
    {
        .x = <span class="SNum">1</span> <span class="SCmt">// Equivalent to 'pt.x = 1'</span>
        .y = <span class="SNum">2</span> <span class="SCmt">// Equivalent to 'pt.y = 2'</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with Function Calls </h4>
<p>Inside a <span class="code-inline">with</span> block, you can invoke methods and access fields directly. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    <span class="SKwd">with</span> pt
    {
        .<span class="SFct">setOne</span>() <span class="SCmt">// Equivalent to 'pt.setOne()'</span>
        .y = <span class="SNum">2</span> <span class="SCmt">// Adjust a single field afterward</span>
        <span class="SItr">@assert</span>(.x == <span class="SNum">1</span>)
        <span class="SItr">@assert</span>(.y == <span class="SNum">2</span>)
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with a Namespace (Usage) </h4>
<p>Demonstrates calling namespaced functions via <span class="code-inline">with</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SCst">NameSpace</span>
    {
        .<span class="SFct">inside0</span>()
        .<span class="SFct">inside1</span>()
    }
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with Variable Declaration </h4>
<p>You can declare a variable directly in the <span class="code-inline">with</span> header and work with it immediately inside the block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SKwd">var</span> pt = <span class="SCst">Point</span>{<span class="SNum">1</span>, <span class="SNum">2</span>}
    {
        .x = <span class="SNum">10</span>
        .y = <span class="SNum">20</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SKwd">var</span> pt: <span class="SCst">Point</span> <span class="SCmt">// Declaration without initializer</span>
    {
        .x = <span class="SNum">10</span>
        .y = <span class="SNum">20</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}</span></div>
<h4 id="_011_000_scoping_swg__011_004_with_swg"><span class="code-inline">with</span> with an Assignment Statement </h4>
<p>You can also use <span class="code-inline">with</span> on an assignment to modify the freshly assigned value immediately. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    <span class="SKwd">with</span> pt = <span class="SCst">Point</span>{<span class="SNum">1</span>, <span class="SNum">2</span>}
    {
        .x = <span class="SNum">10</span>
        .y = <span class="SNum">20</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}</span></div>

<h2 id="_012_000_type_reflection_swg">Type Reflection </h2><h3 id="_012_000_type_reflection_swg">'Types as Values in Swag' </h3>
<p>In Swag, types are treated as first-class values that can be inspected and manipulated at both compile time and runtime. This enables powerful metaprogramming patterns for flexible, reusable code. </p>
<p>The primary intrinsics for interacting with types are <span class="code-inline">#typeof</span> and <span class="code-inline">@kindof</span>, which let you introspect and work with types dynamically. </p>
<h3 id="_012_000_type_reflection_swg">Using <span class="code-inline">#typeof</span> to Inspect Types </h3>
<p>The <span class="code-inline">#typeof</span> intrinsic retrieves the type information of an expression. When an expression explicitly represents a type, you can also use the type itself. This is useful for compile-time inspection and validation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Basic types via '#typeof' and direct type usage</span>
    <span class="SKwd">let</span> ptr1 = <span class="SItr">#typeof</span>(<span class="STpe">s8</span>)
    <span class="SItr">@assert</span>(ptr1.name == <span class="SStr">"s8"</span>)
    <span class="SItr">@assert</span>(ptr1 == <span class="STpe">s8</span>)

    <span class="SKwd">let</span> ptr2 = <span class="SItr">#typeof</span>(<span class="STpe">s16</span>)
    <span class="SItr">@assert</span>(ptr2.name == <span class="SStr">"s16"</span>)
    <span class="SItr">@assert</span>(ptr2 == <span class="STpe">s16</span>)

    <span class="SKwd">let</span> ptr3 = <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(ptr3.name == <span class="SStr">"s32"</span>)
    <span class="SItr">@assert</span>(ptr3 == <span class="SItr">#typeof</span>(<span class="STpe">s32</span>))

    <span class="SKwd">let</span> ptr4 = <span class="STpe">s64</span>
    <span class="SItr">@assert</span>(ptr4.name == <span class="SStr">"s64"</span>)
    <span class="SItr">@assert</span>(ptr4 == <span class="STpe">s64</span>)
}</span></div>
<h3 id="_012_000_type_reflection_swg">Understanding the Result of <span class="code-inline">#typeof</span> </h3>
<p><span class="code-inline">#typeof</span> yields a constant pointer to a <span class="code-inline">Swag.TypeInfo</span> structure (alias of <span class="code-inline">typeinfo</span>). Each Swag type maps to a specific <span class="code-inline">TypeInfo</span> descriptor in the <span class="code-inline">Swag</span> namespace, which is part of the compiler runtime. </p>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> You can explore all type descriptors in the runtime documentation on the Swag website. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Native type -&gt; native typeinfo</span>
    <span class="SKwd">let</span> ptr = <span class="STpe">bool</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr) == <span class="SItr">#typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoNative</span>))

    <span class="SCmt">// Use '#type' to disambiguate when the expression could be parsed as a value</span>
    <span class="SKwd">let</span> ptr1 = <span class="SItr">#type</span> [<span class="SNum">2</span>] <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr1) == <span class="SItr">#typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoArray</span>))
    <span class="SItr">@assert</span>(ptr1.name == <span class="SStr">"[2] s32"</span>)

    <span class="SCmt">// Array literal -&gt; array typeinfo</span>
    <span class="SKwd">let</span> ptr2 = <span class="SItr">#typeof</span>([<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>])
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(ptr2) == <span class="SItr">#typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoArray</span>))
    <span class="SItr">@assert</span>(ptr2.name == <span class="SStr">"const [3] s32"</span>)
}</span></div>
<h3 id="_012_000_type_reflection_swg">Working with <span class="code-inline">TypeInfo</span> Structures </h3>
<p><span class="code-inline">TypeInfo</span> exposes a <span class="code-inline">kind</span> field identifying the category: native, pointer, array, struct, etc. This is essential when handling types generically. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// 'f64' is a native type</span>
    <span class="SKwd">let</span> typeOf = <span class="STpe">f64</span>
    <span class="SItr">@assert</span>(typeOf.kind == <span class="SCst">Swag</span>.<span class="SCst">TypeInfoKind</span>.<span class="SCst">Native</span>)

    <span class="SCmt">// Compile-time checks of kind</span>
    <span class="SKwd">using</span> <span class="SCst">Swag</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(*<span class="STpe">u8</span>).kind == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Pointer</span>) <span class="SCmt">// Pointer</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>([<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>]).kind == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Array</span>) <span class="SCmt">// Array</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>({<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>}).kind == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Struct</span>) <span class="SCmt">// Struct</span>
}</span></div>
<h3 id="_012_000_type_reflection_swg"><span class="code-inline">#decltype</span> </h3>
<p><span class="code-inline">#decltype</span> performs the reverse of <span class="code-inline">#typeof</span>/<span class="code-inline">@kindof</span>: it converts a <span class="code-inline">typeinfo</span> back into a compiler type. Use it to materialize a type determined by compile-time information. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Create a variable whose type is resolved from typeinfo</span>
    <span class="SKwd">var</span> x: <span class="SItr">#decltype</span>(<span class="SItr">#typeof</span>(<span class="STpe">s32</span>))
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(x) == <span class="STpe">s32</span>)
}</span></div>
<h3 id="_012_000_type_reflection_swg">Using <span class="code-inline">#decltype</span> with Compile-Time Expressions </h3>
<p><span class="code-inline">#decltype</span> can evaluate a constexpr that returns a <span class="code-inline">typeinfo</span> and materialize the corresponding type. This enables dynamic yet type-safe patterns. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Return a typeinfo based on a constexpr condition</span>
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">getType</span>(needAString: <span class="STpe">bool</span>)-&gt;<span class="STpe">typeinfo</span>
    {
        <span class="SLgc">if</span> needAString <span class="SLgc">do</span>
            <span class="SLgc">return</span> <span class="STpe">string</span>
        <span class="SLgc">else</span> <span class="SLgc">do</span>
            <span class="SLgc">return</span> <span class="STpe">s32</span>
    }

    <span class="SCmt">// Materialize the chosen type via '#decltype'</span>
    <span class="SKwd">var</span> x: <span class="SItr">#decltype</span>(<span class="SFct">getType</span>(needAString: <span class="SKwd">false</span>))
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(x) == <span class="STpe">s32</span>)
    x = <span class="SNum">0</span>

    <span class="SKwd">var</span> x1: <span class="SItr">#decltype</span>(<span class="SFct">getType</span>(needAString: <span class="SKwd">true</span>))
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(x1) == <span class="STpe">string</span>)
    x1 = <span class="SStr">"0"</span>
}</span></div>

<h2 id="_013_000_error_management_and_safety_swg">Error Management and Safety </h2>
<h3 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">Error Management </h3><h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Errors with throw/try/catch' </h4>
<p>A function marked with <span class="code-inline">throw</span> can return an error by using <span class="code-inline">throw</span> followed by an error value. The value is a struct that carries error details. </p>
<p>These are not traditional exceptions. Think of <span class="code-inline">throw</span> as a specialized <span class="code-inline">return</span> that carries an error value. </p>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Using throw with Custom Errors' </h4>
<p>A function that may return an error must be annotated with <span class="code-inline">throw</span>. When an error is raised, it is a structured value (often a custom error struct). </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Custom error extending the runtime base error.</span>
<span class="SKwd">struct</span> <span class="SCst">MyError</span>
{
    <span class="SKwd">using</span> base: <span class="SCst">Swag</span>.<span class="SCst">BaseError</span>
}</span></div>
<p>When a function exits early due to <span class="code-inline">throw</span>, the <i>returned value</i> is the default for the function return type (e.g., 0 for integers). </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// 'count' returns the length of 'name', or throws if 'name' is null.</span>
<span class="SCmt">// On error, it returns the default 'u64' value (0).</span>
<span class="SKwd">func</span> <span class="SFct">count</span>(name: <span class="STpe">string</span>)-&gt;<span class="STpe">u64</span> <span class="SKwd">throw</span>
{
    <span class="SLgc">if</span> name == <span class="SKwd">null</span>
    {
        <span class="SKwd">throw</span> <span class="SCst">MyError</span>{<span class="SStr">"null pointer"</span>}
    }
    <span class="SLgc">return</span> <span class="SItr">@countof</span>(name)
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Handling Errors with catch and @err' </h4>
<p>Use <span class="code-inline">catch</span> at the call site to dismiss a raised error. The result becomes the default value of the callee's return type. Check <span class="code-inline">@err</span> to see what was caught (type <span class="code-inline">any</span>). </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc</span>()
{
    <span class="SKwd">let</span> cpt = <span class="SKwd">catch</span> <span class="SFct">count</span>(<span class="SStr">"fileName"</span>)

    <span class="SLgc">if</span> <span class="SItr">@err</span> != <span class="SKwd">null</span>
    {
        <span class="SCmt">// '@err' is an 'any' representing the caught error.</span>
        <span class="SItr">@assert</span>(<span class="SItr">@err</span> == <span class="SCst">MyError</span>)
        <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span>)
        <span class="SItr">@print</span>(<span class="SStr">"An error was raised"</span>)
        <span class="SLgc">return</span>
    }

    <span class="SCmt">// No error: continue normally.</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Error Handling with trycatch' </h4>
<p><span class="code-inline">trycatch</span> dismisses the error and continues, returning the default value. This contains errors within the current function. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myOtherFunc</span>()
{
    <span class="SKwd">var</span> cpt1 = <span class="SKwd">trycatch</span> <span class="SFct">count</span>(<span class="SStr">"fileName"</span>)

    <span class="SCmt">// Equivalent pattern using 'catch':</span>
    <span class="SKwd">var</span> cpt2 = <span class="SKwd">catch</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
    <span class="SLgc">if</span> <span class="SItr">@err</span> != <span class="SKwd">null</span> <span class="SLgc">do</span>
        <span class="SLgc">return</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Propagating Errors with try' </h4>
<p><span class="code-inline">try</span> halts execution and propagates the error to the caller. The callee must be annotated with <span class="code-inline">throw</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc1</span>() <span class="SKwd">throw</span>
{
    <span class="SKwd">var</span> cpt = <span class="SKwd">try</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>) <span class="SCmt">// Propagate on error</span>
}</span></div>
<p>Equivalent to catching and re-throwing the error explicitly. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc2</span>() <span class="SKwd">throw</span>
{
    <span class="SKwd">var</span> cpt = <span class="SKwd">catch</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
    <span class="SLgc">if</span> <span class="SItr">@err</span> != <span class="SKwd">null</span>
    {
        <span class="SKwd">throw</span> <span class="SItr">@err</span>
    }
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Forcing Panic with assume' </h4>
<p><span class="code-inline">assume</span> forces a panic if an error occurs, instead of handling or propagating. Useful when errors are not expected. </p>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> In <span class="code-inline">release</span> builds, <span class="code-inline">assume</span> may be disabled, which can lead to undefined  behavior if an error occurs. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc3</span>()
{
    <span class="SKwd">var</span> cpt = <span class="SKwd">assume</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>) <span class="SCmt">// Panic on error</span>
}</span></div>
<p>WARNING: If an error is not caught, Swag will panic at runtime. The top-level caller assumes safe execution and halts the program on unhandled errors. </p>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Blocks in Error Handling' </h4>
<p>Blocks can be used with <span class="code-inline">try</span>, <span class="code-inline">assume</span>, <span class="code-inline">catch</span>, and <span class="code-inline">trycatch</span> to apply the handling strategy to multiple operations. These blocks do not create a new scope. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc4</span>() <span class="SKwd">throw</span>
{
    <span class="SCmt">// Propagate errors from several calls.</span>
    <span class="SKwd">try</span>
    {
        <span class="SKwd">var</span> cpt0 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt1 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SCmt">// Panic if any call fails.</span>
    <span class="SKwd">assume</span>
    {
        <span class="SKwd">var</span> cpt2 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt3 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SCmt">// Dismiss errors and continue (checking '@err' is irrelevant here).</span>
    <span class="SKwd">catch</span>
    {
        <span class="SKwd">var</span> cpt4 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt5 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SCmt">// Dismiss errors and exit immediately without propagation.</span>
    <span class="SKwd">trycatch</span>
    {
        <span class="SKwd">var</span> cpt6 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt7 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Implicit try' </h4>
<p>Inside a function annotated with <span class="code-inline">throw</span>, calls to throwing functions are implicitly treated as <span class="code-inline">try</span> unless overridden. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">mySubFunc2</span>() <span class="SKwd">throw</span>
    {
        <span class="SKwd">throw</span> <span class="SCst">MyError</span>{<span class="SStr">"error from mySubFunc2"</span>}
    }

    <span class="SKwd">func</span> <span class="SFct">mySubFunc3</span>() <span class="SKwd">throw</span>
    {
        <span class="SKwd">throw</span> <span class="SCst">MyError</span>{<span class="SStr">"error from mySubFunc3"</span>}
    }

    <span class="SKwd">func</span> <span class="SFct">mySubFunc1</span>() <span class="SKwd">throw</span>
    {
        <span class="SCmt">// Implicit 'try' because this function itself is 'throw'.</span>
        <span class="SFct">mySubFunc2</span>()

        <span class="SCmt">// Still allowed to be explicit when desired.</span>
        <span class="SKwd">try</span> <span class="SFct">mySubFunc3</span>()
    }

    <span class="SKwd">catch</span> <span class="SFct">mySubFunc1</span>()
    <span class="SItr">@assert</span>(<span class="SItr">@err</span> == <span class="SCst">MyError</span>)
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'The error struct' </h4>
<p>An error is a struct. You can add custom fields (e.g., line/column for a syntax error). </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">SyntaxError</span>
{
    <span class="SKwd">using</span> base:     <span class="SCst">Swag</span>.<span class="SCst">BaseError</span>
    line, col:      <span class="STpe">u32</span>
}</span></div>
<p>WARNING: Ensure references stored in an error (e.g., "string", "any") remain valid for the error lifetime. Prefer heap or a context allocator when needed. </p>
<h4 id="_013_000_error_management_and_safety_swg__013_001_error_management_swg">'Using defer for Controlled Cleanup' </h4>
<p><span class="code-inline">defer</span> schedules code to run on function exit (normal return or error). Since <span class="code-inline">throw</span> behaves like <span class="code-inline">return</span>, <span class="code-inline">defer</span> runs consistently in both cases. </p>
<p>You can filter execution with modes: - 'defer #err'    -&gt; run only when an error is raised - 'defer #noerr'  -&gt; run only when no error is raised - <span class="code-inline">defer</span>         -&gt; run always </p>
<div class="code-block"><span class="SCde"><span class="SKwd">var</span> g_Defer = <span class="SNum">0</span>

<span class="SKwd">func</span> <span class="SFct">raiseError</span>() <span class="SKwd">throw</span>
{
    <span class="SKwd">throw</span> <span class="SCst">MyError</span>{<span class="SStr">"error"</span>}
}

<span class="SKwd">func</span> <span class="SFct">testDefer</span>(err: <span class="STpe">bool</span>) <span class="SKwd">throw</span>
{
    <span class="SLgc">defer</span> <span class="SItr">#err</span> g_Defer += <span class="SNum">1</span> <span class="SCmt">// Run on error only</span>
    <span class="SLgc">defer</span> <span class="SItr">#noerr</span> g_Defer += <span class="SNum">2</span> <span class="SCmt">// Run on success only</span>
    <span class="SLgc">defer</span> g_Defer += <span class="SNum">3</span> <span class="SCmt">// Run always</span>

    <span class="SLgc">if</span> err <span class="SLgc">do</span>
        <span class="SFct">raiseError</span>()
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Error path: only '#err' and unconditional run.</span>
    g_Defer = <span class="SNum">0</span>
    <span class="SKwd">catch</span> <span class="SFct">testDefer</span>(<span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(g_Defer == <span class="SNum">4</span>) <span class="SCmt">// 1 + 3</span>

    <span class="SCmt">// Success path: only '#noerr' and unconditional run.</span>
    g_Defer = <span class="SNum">0</span>
    <span class="SKwd">catch</span> <span class="SFct">testDefer</span>(<span class="SKwd">false</span>)
    <span class="SItr">@assert</span>(g_Defer == <span class="SNum">5</span>) <span class="SCmt">// 2 + 3</span>
}</span></div>

<h3 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety </h3><h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'Safety Checks in Swag' </h4>
<p>Swag provides safety checks that can be enabled at different granularity levels — module, function, or even individual instruction — via <span class="code-inline">#[Swag.Safety]</span>. </p>
<p>These checks prevent common programming errors by triggering panics during unsafe operations (overflows, invalid math, out-of-bounds access, etc.). </p>
<p>You can also configure safety checks globally from the build configuration with <span class="code-inline">buildCfg.safetyGuards</span>. </p>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> Swag offers four predefined build configurations: <span class="code-inline">debug</span>, <span class="code-inline">fast-debug</span>,  <span class="code-inline">fast-compile</span>, and <span class="code-inline">release</span>. Safety checks are enabled by default in  <span class="code-inline">debug</span> and <span class="code-inline">fast-debug</span>, and disabled in <span class="code-inline">fast-compile</span> and <span class="code-inline">release</span>  for performance. </p>
</div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'Overflow Safety' </h4>
<p>Example: #[Swag.Safety("overflow", true)] When enabled, Swag panics on arithmetic overflow or when bits are lost during integer conversions. </p>
<p>Operators that can overflow include '+ - * &lt;&lt; &gt;&gt;' and compound forms '+= -= <i>= &lt;&lt;= &gt;&gt;='.</i> </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>
    <span class="SCmt">// x += 1  // Uncomment to see overflow panic</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Disabling Overflow Safety with <span class="code-inline">#wrap</span> </h5>
<p>Use <span class="code-inline">#wrap</span> on the operation if overflow is expected and should not panic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>
    x += <span class="SItr">#wrap</span> <span class="SNum">1</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Global Overflow Safety Control </h5>
<p>Disable overflow safety checks in a scope with <span class="code-inline">#[Swag.CanOverflow(true)]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.CanOverflow(true)]</span>
<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>
    x += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Promoting Operations to Prevent Overflow </h5>
<p>For 8/16-bit operations, use <span class="code-inline">#prom</span> to promote to 32-bit and avoid overflow. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span> + <span class="SItr">#prom</span> <span class="SNum">1</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">256</span>)
    <span class="SItr">@assert</span>(<span class="SItr">#typeof</span>(x) == <span class="STpe">u32</span>)
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'Information Loss During Casting' </h4>
<p>Swag checks casts for potential information loss between integer types. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x1 = <span class="SNum">255</span>'<span class="STpe">u8</span>

    <span class="SCmt">// var y0 = cast(s8) x1  // Would panic: 255 not representable as s8</span>

    <span class="SKwd">let</span> y1 = <span class="SKwd">cast</span> <span class="SItr">#wrap</span> (<span class="STpe">s8</span>) x1
    <span class="SItr">@assert</span>(y1 == -<span class="SNum">1</span>)

    <span class="SKwd">let</span> x2 = -<span class="SNum">1</span>'<span class="STpe">s8</span>
    <span class="SCmt">// var y2 = cast(u8) x2  // Would panic: negative to unsigned</span>
    <span class="SKwd">let</span> y2 = <span class="SKwd">cast</span> <span class="SItr">#wrap</span> (<span class="STpe">u8</span>) x2
    <span class="SItr">@assert</span>(y2 == <span class="SNum">255</span>)
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Disabling Overflow Safety Globally </h5>
<p>Same as above: <span class="code-inline">#[Swag.CanOverflow(true)]</span> allows overflowing operations. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.CanOverflow(true)]</span>
<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>
    x += <span class="SNum">255</span> <span class="SCmt">// -&gt; 254 (wrap)</span>
    x += <span class="SNum">1</span> <span class="SCmt">// -&gt; 255</span>
    x &gt;&gt;= <span class="SNum">1</span> <span class="SCmt">// -&gt; 127</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">127</span>)
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'Dynamic Cast Type Safety' </h4>
<p>Example: #[Swag.Safety("dyncast", true)] Swag panics if a cast from <span class="code-inline">any</span> to another type is invalid. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"1"</span>
    <span class="SKwd">let</span> y  = <span class="SKwd">cast</span>(<span class="STpe">string</span>) x
    <span class="SCmt">// var z = cast(s32) x  // Would panic: underlying type mismatch</span>
    <span class="SCmt">// @assert(z == 0)</span>
}</span></div>
<p>Swag also panics if casting from an interface to a pointer-to-struct cannot be performed. </p>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'Array Bounds Checking' </h4>
<p>Example: #[Swag.Safety("boundcheck", true)] Swag panics if an index is out of range when dereferencing sized values (arrays, slices, strings). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x   = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SKwd">var</span> idx = <span class="SNum">10</span>
    <span class="SCmt">// @assert(x[idx] == 1)  // Would panic: out-of-bounds</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety When Indexing a Slice </h5>
<p>Indexing a slice is checked for bounds. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x:  <span class="SKwd">const</span> [..] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SKwd">var</span> idx = <span class="SNum">1</span>
    <span class="SItr">@assert</span>(x[idx] == <span class="SNum">1</span>)
    idx += <span class="SNum">9</span>
    <span class="SCmt">// @assert(x[idx] == 1)  // Would panic: out-of-bounds</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Safety When Slicing a Sized Value </h5>
<p>Slice operations are checked for bounds. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="SKwd">const</span> [..] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SCmt">// var slice = x[1..4]   // Would panic: out-of-bounds</span>
    <span class="SCmt">// @assert(slice[0] == 1)</span>
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x   = <span class="SStr">"string"</span>
    <span class="SKwd">var</span> idx = <span class="SNum">10</span>
    <span class="SCmt">// var slice = x[0..idx] // Would panic: out-of-bounds</span>
    <span class="SCmt">// @assert(slice[0] == 's')</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'Math Safety' </h4>
<p>Example: #[Swag.Safety("math", true)] Swag panics for invalid math, such as division by zero or invalid intrinsic arguments. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>'<span class="STpe">f32</span>
    <span class="SKwd">var</span> y = <span class="SNum">0</span>'<span class="STpe">f32</span>
    <span class="SCmt">// var z = x / y  // Would panic: division by zero</span>
    <span class="SCmt">// @print(z)</span>
}</span></div>
<h5 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">Checking Invalid Math Intrinsic Arguments </h5>
<p>Swag validates arguments for several math intrinsics and panics if invalid. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// @abs(-128)        // Invalid for abs on this target</span>
    <span class="SCmt">// @log(-2'f32)      // Invalid: log of negative</span>
    <span class="SCmt">// @log2(-2'f32)     // Invalid: log2 of negative</span>
    <span class="SCmt">// @log10(2'f64)     // Example: implementation-specific constraints</span>
    <span class="SCmt">// @sqrt(-2'f32)     // Invalid: sqrt of negative</span>
    <span class="SCmt">// @asin(-2'f32)     // Invalid: asin out of range</span>
    <span class="SCmt">// @acos(2'f32)      // Invalid: acos out of range</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'Switch Safety' </h4>
<p>Example: #[Swag.Safety("switch", true)] With <span class="code-inline">#[Swag.Complete]</span>, Swag panics if a switch does not cover all cases. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Color</span>
    {
        <span class="SCst">Red</span>
        <span class="SCst">Green</span>
        <span class="SCst">Blue</span>
    }

    <span class="SKwd">func</span> <span class="SFct">colorToString</span>(color: <span class="SCst">Color</span>)-&gt;<span class="STpe">string</span>
    {
        <span class="SCmt">// #[Swag.Complete]</span>
        <span class="SLgc">switch</span> color
        {
        <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Red</span>:
            <span class="SLgc">return</span> <span class="SStr">"Red"</span>
        <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Green</span>:
            <span class="SLgc">return</span> <span class="SStr">"Green"</span>
        }

        <span class="SLgc">return</span> <span class="SStr">""</span>
    }
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'Boolean Safety' </h4>
<p>Example: #[Swag.Safety("bool", true)] Swag panics if a <span class="code-inline">bool</span> is not <span class="code-inline">true</span> (1) or <span class="code-inline">false</span> (0). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> b: <span class="STpe">u8</span> = <span class="SNum">2</span>
    <span class="SCmt">// if b { }  // Would panic: invalid boolean value</span>
}</span></div>
<h4 id="_013_000_error_management_and_safety_swg__013_002_safety_swg">'NaN Safety' </h4>
<p>Example: #[Swag.Safety("nan", true)] Swag panics if a floating-point <span class="code-inline">NaN</span> participates in an operation, preventing propagation of invalid values. </p>

<h2 id="_014_000_compile-time_evaluation_swg">Compile-time Evaluation </h2><h3 id="_014_000_compile-time_evaluation_swg">'Compile-Time Execution in Swag' </h3>
<p>One of Swag’s most powerful features is its ability to execute <b>everything</b> at compile time. This means Swag can function both as a compiled language and as a scripting language, with the compiler acting as an interpreter. </p>
<p>This flexibility allows developers to perform tasks at compile time that would otherwise require runtime computation — resulting in more efficient, expressive, and versatile programs. </p>

<h3 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">Constexpr </h3><h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">'Compile-Time Function Evaluation with #[Swag.ConstExpr]' </h4>
<p>The <span class="code-inline">#[Swag.ConstExpr]</span> attribute marks a function as evaluable during compile time. If all inputs are known at compile time, the compiler can resolve the function result immediately, avoiding runtime computation. </p>
<p>This precomputation improves efficiency and reduces runtime overhead, making such functions ideal for constant logic or static initialization. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Simple example: always returns true, resolved at compile time.</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">isThisDebug</span>() =&gt; <span class="SKwd">true</span>

<span class="SCmt">// Compile-time conditional block.</span>
<span class="SCmt">// Since 'isThisDebug()' is true, the code inside will never compile.</span>
<span class="SCmp">#if</span> <span class="SFct">isThisDebug</span>() == <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span>(<span class="SStr">"this should not be called!"</span>)
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">'Recursive Compile-Time Evaluation' </h4>
<p>Recursive functions can also be marked <span class="code-inline">ConstExpr</span>. Swag evaluates them entirely at compile time, eliminating runtime cost. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">factorial</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">if</span> x == <span class="SNum">1</span> <span class="SLgc">do</span>
        <span class="SLgc">return</span> <span class="SNum">1</span>
    <span class="SLgc">return</span> x * <span class="SFct">factorial</span>(x - <span class="SNum">1</span>)
}

<span class="SCmp">#assert</span>(<span class="SFct">factorial</span>(<span class="SNum">4</span>) == <span class="SNum">24</span>)</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">'Compile-Time Constant Expressions' </h4>
<p>ConstExpr functions can return fixed values that the compiler resolves immediately during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">getMagicNumber</span>()-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">return</span> <span class="SNum">42</span>
}

<span class="SCmp">#assert</span>(<span class="SFct">getMagicNumber</span>() == <span class="SNum">42</span>)</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">'Compile-Time Conditional Logic' </h4>
<p>Logic such as even/odd checks can be done at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">isEven</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">bool</span>
{
    <span class="SLgc">return</span> x % <span class="SNum">2</span> == <span class="SNum">0</span>
}

<span class="SCmp">#if</span> <span class="SFct">isEven</span>(<span class="SNum">4</span>) == <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span>(<span class="SStr">"4 should be even!"</span>)
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">'Compile-Time Slice Operations' </h4>
<p>ConstExpr functions can iterate and compute over constant arrays. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">arraySum</span>(arr: <span class="SKwd">const</span> [..] <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>
    <span class="SLgc">foreach</span> val <span class="SLgc">in</span> arr <span class="SLgc">do</span>
        sum += val
    <span class="SLgc">return</span> sum
}

<span class="SCmp">#assert</span>(<span class="SFct">arraySum</span>([<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>, <span class="SNum">5</span>]) == <span class="SNum">15</span>)</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">'Compile-Time Fibonacci Sequence' </h4>
<p>Recursive computation of Fibonacci numbers at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">fibonacci</span>(n: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">if</span> n &lt;= <span class="SNum">1</span> <span class="SLgc">do</span>
        <span class="SLgc">return</span> n
    <span class="SLgc">return</span> <span class="SFct">fibonacci</span>(n - <span class="SNum">1</span>) + <span class="SFct">fibonacci</span>(n - <span class="SNum">2</span>)
}

<span class="SCmp">#assert</span>(<span class="SFct">fibonacci</span>(<span class="SNum">5</span>) == <span class="SNum">5</span>)</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_001_constexpr_swg">'Compile-Time Bitwise Operations' </h4>
<p>Bitwise operations can be resolved at compile time too. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">isBitSet</span>(num: <span class="STpe">s32</span>, bit: <span class="STpe">s32</span>)-&gt;<span class="STpe">bool</span>
{
    <span class="SLgc">return</span> (num & (<span class="SNum">1</span> &lt;&lt; bit)) != <span class="SNum">0</span>
}

<span class="SCmp">#assert</span>(<span class="SFct">isBitSet</span>(<span class="SNum">8</span>, <span class="SNum">3</span>) == <span class="SKwd">true</span>)</span></div>

<h3 id="_014_000_compile-time_evaluation_swg__014_002_run_swg">Run </h3><h4 id="_014_000_compile-time_evaluation_swg__014_002_run_swg">'Force Compile-Time Execution with #run' </h4>
<p>The <span class="code-inline">#run</span> directive allows any function to execute at compile time, even if it’s not marked with <span class="code-inline">#[Swag.ConstExpr]</span>. This means you can trigger compile-time execution of regular, external, or system functions as part of your program. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Regular runtime function</span>
<span class="SKwd">func</span> <span class="SFct">isThisRelease</span>() =&gt; <span class="SKwd">true</span>

<span class="SCmt">// Forcing compile-time evaluation with '#run'</span>
<span class="SCmp">#if</span> <span class="SFct">#run</span> <span class="SFct">isThisRelease</span>() == <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span>(<span class="SStr">"this should not be called!"</span>)
}</span></div>
<p>Any function — including system or user-defined ones — can be executed at compile time using <span class="code-inline">#run</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Example: sum without 'ConstExpr'</span>
<span class="SKwd">func</span> <span class="SFct">sum</span>(values: <span class="STpe">s32</span>...)-&gt;<span class="STpe">s32</span>
{
    <span class="SKwd">var</span> result = <span class="SNum">0</span>'<span class="STpe">s32</span>
    <span class="SLgc">foreach</span> v <span class="SLgc">in</span> values <span class="SLgc">do</span>
        result += v
    <span class="SLgc">return</span> result
}

<span class="SCmt">// Force execution at compile time</span>
<span class="SKwd">const</span> <span class="SCst">SumValue</span> = <span class="SFct">#run</span> <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>) + <span class="SNum">10</span>
<span class="SCmp">#assert</span>(<span class="SCst">SumValue</span> == <span class="SNum">20</span>)</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_002_run_swg"><span class="code-inline">#run</span> Block </h4>
<p><span class="code-inline">#run</span> blocks execute arbitrary logic at compile time. They are useful for initializing globals or precomputing data before runtime. </p>
<p>Execution order between <span class="code-inline">#run</span> blocks is undefined, so avoid relying on order. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Global array initialized at compile time</span>
<span class="SKwd">var</span> <span class="SCst">G</span>: [<span class="SNum">5</span>] <span class="STpe">f32</span> = <span class="SKwd">undefined</span>

<span class="SFct">#run</span>
{
    <span class="SKwd">var</span> value = <span class="SNum">1</span>'<span class="STpe">f32</span>
    <span class="SLgc">for</span> i <span class="SLgc">in</span> <span class="SItr">@countof</span>(<span class="SCst">G</span>)
    {
        <span class="SCst">G</span>[i] = value
        value *= <span class="SNum">2</span>
    }
}

<span class="SCmt">// Validate precomputed results</span>
<span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">2</span>] == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">3</span>] == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">4</span>] == <span class="SNum">16</span>)
}</span></div>
<p>Swag can act like a scripting language: if a project only contains <span class="code-inline">#run</span> blocks, it behaves like a compile-time script. </p>
<h4 id="_014_000_compile-time_evaluation_swg__014_002_run_swg"><span class="code-inline">#run</span> Expression </h4>
<p><span class="code-inline">#run</span> can also be used as an expression block. Its return type is inferred from the <span class="code-inline">return</span> statement inside the block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">Value</span> = <span class="SFct">#run</span>
    {
        <span class="SKwd">var</span> result: <span class="STpe">f32</span>
        <span class="SLgc">for</span> <span class="SNum">10</span> <span class="SLgc">do</span>
            result += <span class="SNum">1</span>
        <span class="SLgc">return</span> result
    }
    <span class="SCmp">#assert</span>(<span class="SCst">Value</span> == <span class="SNum">10.0</span>)
}</span></div>
<p>Example: initializing a static array at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">N</span>           = <span class="SNum">4</span>
    <span class="SKwd">const</span> <span class="SCst">PowerOfTwo</span>: [<span class="SCst">N</span>] <span class="STpe">s32</span> = <span class="SFct">#run</span>
    {
        <span class="SKwd">var</span> arr: [<span class="SCst">N</span>] <span class="STpe">s32</span>
        <span class="SLgc">for</span> i <span class="SLgc">in</span> arr <span class="SLgc">do</span>
            arr[i] = <span class="SNum">1</span> &lt;&lt; <span class="SKwd">cast</span>(<span class="STpe">u32</span>) i
        <span class="SLgc">return</span> arr
    }

    <span class="SCmp">#assert</span>(<span class="SCst">PowerOfTwo</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">PowerOfTwo</span>[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">PowerOfTwo</span>[<span class="SNum">2</span>] == <span class="SNum">4</span>)
    <span class="SCmp">#assert</span>(<span class="SCst">PowerOfTwo</span>[<span class="SNum">3</span>] == <span class="SNum">8</span>)
}</span></div>
<p>Example: compile-time string construction. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">MyString</span>: <span class="STpe">string</span> = <span class="SFct">#run</span>
    {
        <span class="SKwd">var</span> str: [<span class="SNum">3</span>] <span class="STpe">u8</span>
        str[<span class="SNum">0</span>] = <span class="SStr">'a'</span>
        str[<span class="SNum">1</span>] = <span class="SStr">'b'</span>
        str[<span class="SNum">2</span>] = str[<span class="SNum">1</span>] + <span class="SNum">1</span>
        <span class="SLgc">return</span> <span class="SKwd">cast</span>(<span class="STpe">string</span>) str
    }
    <span class="SCmp">#assert</span>(<span class="SCst">MyString</span> == <span class="SStr">"abc"</span>)
}</span></div>
<p>Example: initializing a struct in a <span class="code-inline">#run</span> block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { r, g, b: <span class="STpe">u8</span> }

    <span class="SKwd">const</span> <span class="SCst">White</span>: <span class="SCst">RGB</span> = <span class="SFct">#run</span>
    {
        <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span> = <span class="SKwd">undefined</span>
        rgb.r = <span class="SNum">255</span>
        rgb.g = rgb.r
        rgb.b = rgb.r
        <span class="SLgc">return</span> rgb
    }

    <span class="SItr">@assert</span>(<span class="SCst">White</span>.r == <span class="SNum">255</span> <span class="SLgc">and</span> <span class="SCst">White</span>.g == <span class="SNum">255</span> <span class="SLgc">and</span> <span class="SCst">White</span>.b == <span class="SNum">255</span>)
}</span></div>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> Complex structs that implement <span class="code-inline">opCount</span> and <span class="code-inline">opSlice</span> can be converted to  static arrays at compile time. The compiler calls <span class="code-inline">opCount</span> for array size,  <span class="code-inline">opSlice</span> for initialization, and <span class="code-inline">opDrop</span> after conversion if present. </p>
</div>

<h3 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg">Compiler Instructions </h3><h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#assert</span> </h4>
<p>The <span class="code-inline">#assert</span> directive performs a static assertion during compilation. If the condition is false, compilation fails with an error message. Use it to enforce compile-time invariants and validate assumptions. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span>(<span class="SKwd">true</span>) <span class="SCmt">// Always passes; no error.</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#defined(SYMBOL)</span> </h4>
<p><span class="code-inline">#defined(SYMBOL)</span> checks at compile time whether a symbol exists in the current context. It returns true if defined, false otherwise. Useful for conditional compilation before referencing variables, constants, or functions. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span>(!<span class="SItr">#defined</span>(<span class="SCst">DOES_NOT_EXISTS</span>)) <span class="SCmt">// Ensure the symbol is not defined.</span>
<span class="SCmp">#assert</span>(<span class="SItr">#defined</span>(<span class="SCst">Global</span>)) <span class="SCmt">// Confirms 'Global' is defined.</span>
<span class="SKwd">var</span> <span class="SCst">Global</span> = <span class="SNum">0</span> <span class="SCmt">// Define a global variable 'Global'.</span></span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#if</span>/<span class="code-inline">#elif</span>/<span class="code-inline">#else</span> </h4>
<p>Static conditional compilation. Expressions are evaluated at compile time to include or exclude code based on constants or conditions. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">DEBUG</span>   = <span class="SNum">1</span>
<span class="SKwd">const</span> <span class="SCst">RELEASE</span> = <span class="SNum">0</span>

<span class="SCmp">#if</span> <span class="SCst">DEBUG</span>
{
    <span class="SCmt">// Compiled because DEBUG == 1.</span>
}
<span class="SCmp">#elif</span> <span class="SCst">RELEASE</span>
{
    <span class="SCmt">// Would compile if RELEASE were true and DEBUG were false.</span>
}
<span class="SCmp">#else</span>
{
    <span class="SCmt">// Compiled if neither DEBUG nor RELEASE is true.</span>
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#error</span>/<span class="code-inline">#warning</span> </h4>
<p><span class="code-inline">#error</span> raises a compile-time error with a custom message. <span class="code-inline">#warning</span> emits a compile-time warning without stopping compilation. Useful for enforcing checks and surfacing build-time information. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#if</span> <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span>(<span class="SStr">"this is an error"</span>) <span class="SCmt">// Compile-time error (if reached).</span>
    <span class="SCmp">#warning</span>(<span class="SStr">"this is a warning"</span>) <span class="SCmt">// Compile-time warning (if reached).</span>
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#global</span> </h4>
<p>Place <span class="code-inline">#global</span> at the top of a source file to apply global settings or attributes across the entire file. Controls compilation and symbol visibility. </p>
<p>Examples (write these as top-level directives):   #global skip                        // Skip file content (file must still be valid).   #global public                      // All symbols become public.   #global internal                    // All symbols are internal to the module.   #global namespace Toto              // Place all symbols in namespace <span class="code-inline">Toto</span>.   #global #if DEBUG == true           // Conditional compilation for the file.   #global #[Swag.Safety(<span class="code-inline"></span>, true)]    // Apply an attribute to all declarations.   #global export                      // Export the file; copied to the public folder. </p>
<h4 id="_014_000_compile-time_evaluation_swg__014_003_compiler_instructions_swg"><span class="code-inline">#foreignlib</span> </h4>
<p>Link against an external library during compilation to use its functions, variables, or resources. Provide the library name as a string. </p>
<p>Example:   #foreignlib("windows.lib") This links the program with "windows.lib" and enables Windows API usage. </p>

<h3 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Code Inspection </h3><h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg"><span class="code-inline">#message</span> Function </h4>
<p>The <span class="code-inline">#message</span> function in Swag is a special compiler hook invoked when certain build events occur. It allows custom actions or checks to run at specific stages of compilation. </p>
<p>The function receives a mask defining which events trigger it, such as function typing, global variable processing, or semantic pass completion. </p>
<h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Function Message Mask </h4>
<p>Using <span class="code-inline">Swag.CompilerMsgMask.SemFunctions</span>, <span class="code-inline">#message</span> runs whenever a function in the module is fully typed (its type info is available). Inside the function, <span class="code-inline">@compiler.getMessage()</span> retrieves information about the event. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemFunctions</span>)
{
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>
    <span class="SKwd">let</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// Since the message is about a function, cast its type.</span>
    <span class="SKwd">let</span> typeFunc = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoFunc</span>) msg.type
    <span class="SKwd">let</span> nameFunc = msg.name

    <span class="SCmt">// Count functions starting with "XX"</span>
    <span class="SLgc">if</span> <span class="SItr">@countof</span>(nameFunc) &gt; <span class="SNum">2</span> <span class="SLgc">and</span> nameFunc[<span class="SNum">0</span>] == <span class="SStr">'X'</span> <span class="SLgc">and</span> nameFunc[<span class="SNum">1</span>] == <span class="SStr">'X'</span> <span class="SLgc">do</span>
        <span class="SCst">G</span> += <span class="SNum">1</span>
}

<span class="SCmt">// Global counter for functions starting with "XX"</span>
<span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span>

<span class="SKwd">func</span> <span class="SFct">XXTestFunc1</span>() {}
<span class="SKwd">func</span> <span class="SFct">XXTestFunc2</span>() {}
<span class="SKwd">func</span> <span class="SFct">XXTestFunc3</span>() {}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Semantic Pass Completion </h4>
<p>After the semantic pass (once all functions are parsed and typed), <span class="code-inline">#message(Swag.CompilerMsgMask.PassAfterSemantic)</span> is triggered. Ideal for whole-module checks or summary actions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">PassAfterSemantic</span>)
{
    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">3</span>)
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Global Variables Message Mask </h4>
<p><span class="code-inline">Swag.CompilerMsgMask.SemGlobals</span> triggers for each global variable during semantic analysis. This can be used to validate or analyze globals. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemGlobals</span>)
{
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// Example placeholder for analyzing global variable properties</span>
}</span></div>
<h4 id="_014_000_compile-time_evaluation_swg__014_004_code_inspection_swg">Global Types Message Mask </h4>
<p><span class="code-inline">Swag.CompilerMsgMask.SemTypes</span> triggers for each global type (struct, enum, interface) encountered by the compiler. This enables compile-time inspection or analysis of type information. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemTypes</span>)
{
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// Example placeholder for analyzing global type attributes</span>
}</span></div>

<h2 id="_017_000_meta_programming_swg">Meta Programming </h2><h3 id="_017_000_meta_programming_swg">'Compile-Time Source Code Generation' </h3>
<p>Swag allows you to construct and inject source code dynamically at compile time. The code is provided as a <b>string</b> containing valid Swag syntax, which the compiler then parses and integrates into the final program. </p>
<p>This feature enables powerful metaprogramming patterns — you can generate, modify, or extend code during compilation, reducing duplication and creating highly flexible, adaptive programs. </p>

<h3 id="_017_000_meta_programming_swg__017_001_ast_swg">Ast </h3><h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> Block </h4>
<p>The <span class="code-inline">#ast</span> block lets you dynamically generate and inject Swag code at compile time. It produces a string that the compiler treats as if it were written directly in the source. This allows for dynamic, context-dependent code generation. </p>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg">Basic <span class="code-inline">#ast</span> Usage </h4>
<p>A <span class="code-inline">#ast</span> block can return a simple string expression representing Swag code. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SFct">#ast</span> <span class="SStr">"var x = 666"</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">666</span>)
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> Block with <span class="code-inline">return</span> </h4>
<p>A <span class="code-inline">#ast</span> block can include logic and must return a string to compile. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">2</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">const</span> <span class="SCst">INC</span> = <span class="SNum">5</span>
        <span class="SLgc">return</span> <span class="SStr">"cpt += "</span> ++ <span class="SCst">INC</span>
    }
    <span class="SItr">@assert</span>(cpt == <span class="SNum">7</span>)
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> for Structs and Enums </h4>
<p>You can use <span class="code-inline">#ast</span> inside struct or enum definitions to generate members dynamically. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SLgc">return</span> <span class="SStr">"x, y: s32 = 666"</span>
        }
    }

    <span class="SKwd">let</span> v: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">666</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> with Generics </h4>
<p><span class="code-inline">#ast</span> works with generics for flexible and reusable code generation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">MyStruct</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SLgc">return</span> <span class="SStr">"x, y: "</span> ++ <span class="SItr">#typeof</span>(<span class="SCst">T</span>).name
        }

        z:   <span class="STpe">string</span>
    }

    <span class="SKwd">let</span> v: <span class="SFct">MyStruct</span>'<span class="STpe">bool</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(v.x) == <span class="STpe">bool</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(v.y) == <span class="STpe">bool</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(v.z) == <span class="STpe">string</span>)

    <span class="SKwd">let</span> v1: <span class="SFct">MyStruct</span>'<span class="STpe">f64</span>
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(v1.x) == <span class="STpe">f64</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(v1.y) == <span class="STpe">f64</span>)
    <span class="SCmp">#assert</span>(<span class="SItr">#typeof</span>(v1.z) == <span class="STpe">string</span>)
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg">Constructing Strings in <span class="code-inline">#ast</span> </h4>
<p><span class="code-inline">#ast</span> must return a string. You can construct it dynamically, e.g. by using a buffer. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Compiler]</span>
    <span class="SKwd">func</span> <span class="SFct">append</span>(buf: [*] <span class="STpe">u8</span>, val: <span class="STpe">string</span>)
    {
        <span class="SKwd">var</span> len = <span class="SNum">0</span>
        <span class="SLgc">while</span> buf[len] <span class="SLgc">do</span>
            len += <span class="SNum">1</span>
        <span class="SItr">@memcpy</span>(buf + len, <span class="SItr">@dataof</span>(val), <span class="SKwd">cast</span>(<span class="STpe">u64</span>) <span class="SItr">@countof</span>(val) + <span class="SNum">1</span>)
    }

    <span class="SKwd">struct</span> <span class="SCst">Vector3</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SKwd">var</span> buf: [<span class="SNum">256</span>] <span class="STpe">u8</span>
            <span class="SFct">append</span>(buf, <span class="SStr">"x: f32 = 1\n"</span>)
            <span class="SFct">append</span>(buf, <span class="SStr">"y: f32 = 2\n"</span>)
            <span class="SFct">append</span>(buf, <span class="SStr">"z: f32 = 3\n"</span>)
            <span class="SLgc">return</span> <span class="SKwd">cast</span>(<span class="STpe">string</span>) buf
        }
    }

    <span class="SKwd">let</span> v: <span class="SCst">Vector3</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(v.z == <span class="SNum">3</span>)
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg">Real-World Example </h4>
<p>Example from Std.Core — dynamically generates a struct with all fields of another struct replaced by bools. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">IsSet</span>
{
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">var</span> str = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}
        <span class="SKwd">let</span> typeof = <span class="SItr">#typeof</span>(<span class="SCst">T</span>)
        <span class="SLgc">foreach</span> f <span class="SLgc">in</span> typeof.fields:
            str.<span class="SFct">appendFormat</span>(<span class="SStr">"%: bool\n"</span>, f.name)
        <span class="SLgc">return</span> str.<span class="SFct">toString</span>()
    }
}</span></div>
<h4 id="_017_000_meta_programming_swg__017_001_ast_swg"><span class="code-inline">#ast</span> at Global Scope </h4>
<p><span class="code-inline">#ast</span> can generate global declarations dynamically as well. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#ast</span>
{
    <span class="SKwd">const</span> value = <span class="SNum">666</span>
    <span class="SLgc">return</span> <span class="SStr">"const myGeneratedConst = "</span> ++ value
}

<span class="SCmp">#assert</span>(myGeneratedConst == <span class="SNum">666</span>)</span></div>

<h3 id="_017_000_meta_programming_swg__017_002_compiler_interface_swg">Compiler Interface </h3><h4 id="_017_000_meta_programming_swg__017_002_compiler_interface_swg"><span class="code-inline">compileString()</span> in <span class="code-inline">@compiler</span> </h4>
<p>The <span class="code-inline">compileString()</span> function, available through the <span class="code-inline">@compiler</span> interface, allows you to inject and compile dynamically generated Swag source code during compilation. It is typically used inside a <span class="code-inline">#message</span> block to generate code after specific compiler events. </p>
<h4 id="_017_000_meta_programming_swg__017_002_compiler_interface_swg">Example — OpenGL Function Registration </h4>
<p>In this example (from <span class="code-inline">Std.Ogl</span>), <span class="code-inline">compileString()</span> is used within a <span class="code-inline">#message</span> hook to find all functions tagged with a custom attribute <span class="code-inline">Ogl.Extension</span> and automatically generate extension initialization code. </p>
<p>First, define a user attribute for marking OpenGL extension functions. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SFct">Extension</span>()</span></div>
<p>Then, apply it to placeholder OpenGL functions. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Extension, Swag.PlaceHolder]</span>
{
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix2x3fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>)
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix2x4fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>)
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix3x2fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>)
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix3x4fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>)
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix4x2fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>)
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix4x3fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>)
}</span></div>
<p>Track all functions with that attribute. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">OneFunc</span>
{
    type: <span class="STpe">typeinfo</span>
    name: <span class="STpe">string</span>
}

<span class="SAtr">#[Compiler]</span>
<span class="SKwd">var</span> g_Functions: <span class="SFct">Array</span>'<span class="SCst">OneFunc</span></span></div>
<p>Register all tagged functions as they are typed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemFunctions</span>)
{
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SLgc">if</span> !<span class="SCst">Reflection</span>.<span class="SFct">hasAttribute</span>(msg.type, <span class="SCst">Extension</span>)
        <span class="SLgc">return</span>

    g_Functions.<span class="SFct">add</span>({msg.type, msg.name})
}</span></div>
<p>Once semantic analysis finishes, generate code for all registered functions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">CompilerMsgMask</span>.<span class="SCst">PassAfterSemantic</span>)
{
    <span class="SKwd">var</span> builderVars: <span class="SCst">StringBuilder</span>
    <span class="SKwd">var</span> builderInit: <span class="SCst">StringBuilder</span>

    builderInit.<span class="SFct">appendString</span>(<span class="SStr">"public func glInitExtensions()\n{\n"</span>)

    <span class="SLgc">foreach</span> e <span class="SLgc">in</span> g_Functions
    {
        <span class="SKwd">let</span> typeFunc = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="SCst">TypeInfoFunc</span>) e.type

        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"var ext_%: %\n"</span>, e.name, typeFunc.name)
        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"public func %("</span>, e.name)

        <span class="SLgc">foreach</span> p, i <span class="SLgc">in</span> typeFunc.parameters
        {
            <span class="SLgc">if</span> i != <span class="SNum">0</span> builderVars.<span class="SFct">appendString</span>(<span class="SStr">", "</span>)
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"p%: %"</span>, i, p.pointedType.name)
        }

        <span class="SLgc">if</span> typeFunc.returnType == <span class="STpe">void</span>
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">")\n{\n"</span>)
        <span class="SLgc">else</span>
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">")-&gt;%\n{\n"</span>, typeFunc.returnType.name)

        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"\treturn ext_%("</span>, e.name)

        <span class="SLgc">foreach</span> p, i <span class="SLgc">in</span> typeFunc.parameters
        {
            <span class="SLgc">if</span> i != <span class="SNum">0</span> builderVars.<span class="SFct">appendString</span>(<span class="SStr">", "</span>)
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"p%"</span>, i)
        }

        builderVars.<span class="SFct">appendString</span>(<span class="SStr">");\n}\n\n"</span>)

        builderInit.<span class="SFct">appendFormat</span>(
            <span class="SStr">"\text_% = cast(%) getExtensionAddress(@dataof(\"%\"))\n"</span>,
            e.name, typeFunc.name, e.name)
    }

    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>
    <span class="SKwd">var</span> str = builderVars.<span class="SFct">toString</span>()
    itf.<span class="SFct">compileString</span>(str.<span class="SFct">toString</span>())

    builderInit.<span class="SFct">appendString</span>(<span class="SStr">"}\n"</span>)
    str = builderInit.<span class="SFct">toString</span>()
    itf.<span class="SFct">compileString</span>(str.<span class="SFct">toString</span>())
}</span></div>

<h2 id="_018_000_documentation_md">Documentation </h2><p>The Swag compiler is capable of generating comprehensive documentation for all modules within a specified workspace. </p>
<p>To generate documentation for your workspace, use the following command: </p>
<div class="code-block"><span class="SCde">swag doc -w:myWorkspaceFolder</span></div>
<p>Swag supports various documentation generation modes, which should be specified in the module.swg file within the <a href="swag.runtime.php#Swag_BuildCfg">Swag.BuildCfg</a> structure. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#dependencies</span>
{
    <span class="SCmp">#import</span> <span class="SStr">"pixel"</span>

    <span class="SFct">#run</span>
    {
        <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
        <span class="SKwd">let</span> cfg = itf.<span class="SFct">getBuildCfg</span>()
        cfg.genDoc.kind = .<span class="SCst">Api</span> <span class="SCmt">// Specify the documentation generation mode</span>
    }
}</span></div>
<table class="table-markdown">
<tr><th style="text-align: left;">Kind</th><th style="text-align: left;">Purpose</th></tr><tr><td style="text-align: left;"> Swag.DocKind.Api      </td><td style="text-align: left;"> Generates an api documentation (all public symbols)</td></tr>
<tr><td style="text-align: left;"> Swag.DocKind.Examples </td><td style="text-align: left;"> Generates a documentation like this one</td></tr>
<tr><td style="text-align: left;"> Swag.DocKind.Pages    </td><td style="text-align: left;"> Generates different pages, where each file is a page (a variation of  <span class="code-inline">Examples</span>)</td></tr>
</table>
<h3 id="_018_000_documentation_md">Markdown files </h3>
<p>If the module contains <b>markdown</b> files with the <span class="code-inline">.md</span> extension, they will be processed as if they were Swag comments. </p>
<h3 id="_018_000_documentation_md">Format of comments </h3>
<h4 id="_018_000_documentation_md">Paragraphs </h4>
<div class="code-block"><span class="SCde"><span class="SCmt">// Everything between empty lines is considered to be a simple paragraph. Which</span>
<span class="SCmt">// means that if you put several comments on several lines like this, they all</span>
<span class="SCmt">// will be part of the same paragraph.</span>
<span class="SCmt">//</span>
<span class="SCmt">// This is another paragraph because there's an empty line before.</span>
<span class="SCmt">//</span>
<span class="SCmt">// This is yet another paragraph.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> Everything between empty lines is considered to be a simple paragraph. Which  means that if you put several comments on several lines like this, they all  will be part of the same paragraph. </p>
<p> This is another paragraph because there's an empty line before. </p>
<p> This is yet another paragraph. </p>
</div>
<p>Inside a paragraph, you can end of line with <span class="code-inline">\</span> to force a break without creating a new paragraph. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// First line.</span>
<span class="SCmt">// Second line is on first line.\</span>
<span class="SCmt">// But third line has a break before.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> First line.  Second line is on first line.<br/>  But third line has a break before. </p>
</div>
<p>A paragraph that starts with <span class="code-inline">&lt;html&gt;</span> is a <b>verbatim</b> paragraph where every blanks and end of lines are respected. The paragraph will be generated <b>as is</b> without any markdown change. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// &lt;html&gt;</span>
<span class="SCmt">// Even...</span>
<span class="SCmt">//</span>
<span class="SCmt">// ...empty lines are preserved.</span>
<span class="SCmt">//</span>
<span class="SCmt">// You end that kind of paragraph with '&lt;/html&gt;' alone on its line.</span>
<span class="SCmt">// Note that **everything** is not bold, put printed 'as it is'.</span>
<span class="SCmt">// &lt;/html&gt;</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p style="white-space: break-spaces"> Even...

 ...empty lines are preserved.

 You end that kind of paragraph with '</html>' alone on its line.
 Note that **everything** is not bold, put printed 'as it is'.</p>
</div>
<h4 id="_018_000_documentation_md">Horizontal Lines </h4>
<p>Use <span class="code-inline">---</span> at the start of a line to create an HTML horizontal line (<span class="code-inline">&lt;br&gt;</span>) </p>
<h4 id="_018_000_documentation_md">Lists </h4>
<p>You can create a <b>list</b> of bullet points with <span class="code-inline">*</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// * This is a bullet point</span>
<span class="SCmt">// * This is a bullet point</span>
<span class="SCmt">// * This is a bullet point</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><ul>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
</ul>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// - This is a bullet point</span>
<span class="SCmt">// - This is a bullet point</span>
<span class="SCmt">// - This is a bullet point</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><ul>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
</ul>
</div>
<p>You can create an <b>ordered</b> list by starting the line with a digit followed by a <span class="code-inline">.</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// 1. This is an ordered list</span>
<span class="SCmt">// 1. The digit itself does not matter, real numbers will be computed</span>
<span class="SCmt">// 0. This is another one</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><ol>
<li>This is an ordered list</li>
<li>The digit itself does not matter, real numbers will be computed</li>
<li>This is another one</li>
</ol>
</div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> Swag only supports single line list items. You cannot have complex paragraphs (or sub lists). </p>
</div>
<h4 id="_018_000_documentation_md">Definition Lists </h4>
<p>You can add a definition title with the <span class="code-inline">+</span> character followed by a blank, and then the title. The description paragraph should come just after the title, with at least 4 blanks or one tabulation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Title</span>
<span class="SCmt">//     This is the description.</span>
<span class="SCmt">// + Other title</span>
<span class="SCmt">//     This is the other description.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Title</p></div>
<div class="description-list-block">
<p> This is the description. </p>
</div>
<div class="description-list-title"><p>Other title</p></div>
<div class="description-list-block">
<p> This is the other description. </p>
</div>
</div>
<p>A description can contain complex paragraphs. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Title</span>
<span class="SCmt">//     This is an embedded list.</span>
<span class="SCmt">//     * Item1</span>
<span class="SCmt">//     * Item2</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Title</p></div>
<div class="description-list-block">
<p> This is an embedded list. </p>
<ul>
<li>Item1</li>
<li>Item2</li>
</ul>
</div>
</div>
<p>The description paragraph can contain some empty lines. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Other title</span>
<span class="SCmt">//</span>
<span class="SCmt">//     This is the other description</span>
<span class="SCmt">//     on more than one line.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Other title</p></div>
<div class="description-list-block">
<p> This is the other description  on more than one line. </p>
</div>
</div>
<h4 id="_018_000_documentation_md">Quotes </h4>
<p>You can create a <b>quote</b> with <span class="code-inline">&gt;</span> </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; This is a block quote on multiple</span>
<span class="SCmt">// &gt; lines.</span>
<span class="SCmt">// &gt;</span>
<span class="SCmt">// &gt; End of the quote.</span></span></div>
<div class="blockquote blockquote-default">
<p> This is a block quote on multiple  lines. </p>
<p> End of the quote. </p>
</div>
<p>You can create a special quote by adding a title on the first line. There must be exactly one blank between <span class="code-inline">&gt;</span> and the title, and the title case should be respected. </p>
<ul>
<li><span class="code-inline">NOTE:</span></li>
<li><span class="code-inline">TIP:</span></li>
<li><span class="code-inline">WARNING:</span></li>
<li><span class="code-inline">ATTENTION:</span></li>
<li><span class="code-inline">EXAMPLE:</span></li>
</ul>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; NOTE:</span>
<span class="SCmt">// &gt; This is the note content</span></span></div>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> This is the note content </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; TIP:</span>
<span class="SCmt">// &gt; This is a tip.</span></span></div>
<div class="blockquote blockquote-tip">
<div class="blockquote-title-block"><i class="fa fa-lightbulb-o"></i>  <span class="blockquote-title">Tip</span></div><p> This is a tip. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; WARNING:</span>
<span class="SCmt">// &gt; This is the warning content</span>
<span class="SCmt">// &gt;</span>
<span class="SCmt">// &gt; Another paragraph</span></span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> This is the warning content </p>
<p> Another paragraph </p>
</div>
<div class="code-block"><span class="SCmt">// &gt; ATTENTION: The content of the quote can be written on the same line as the title</span></div>
<div class="blockquote blockquote-attention">
<div class="blockquote-title-block"><i class="fa fa-ban"></i>  <span class="blockquote-title">Attention</span></div><p> The content of the quote can be written on the same line as the title </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; EXAMPLE:</span>
<span class="SCmt">// &gt; In the 'module.swg' file, we have changed the 'example' title to be `"Result"` instead of `"Example"`.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> In the <span class="code-inline">module.swg</span> file, we have changed the <span class="code-inline">example</span> title to be <span class="code-inline">"Result"</span> instead of <span class="code-inline">"Example"</span>. </p>
</div>
<h4 id="_018_000_documentation_md">Tables </h4>
<p>You can create a <b>table</b> by starting a line with <span class="code-inline">|</span>. Each column must then be separated with <span class="code-inline">|</span>. The last column can end with <span class="code-inline">|</span>, but this is not mandatory. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// A table with 4 lines of 2 columns:</span>
<span class="SCmt">// | boundcheck   | Check out of bound access</span>
<span class="SCmt">// | overflow     | Check type conversion lost of bits or precision</span>
<span class="SCmt">// | math         | Various math checks (like a negative '@sqrt')        |</span>
<span class="SCmt">// | switch       | Check an invalid case in a '#[Swag.Complete]' switch |</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><td> boundcheck   </td><td> Check out of bound access</td></tr>
<tr><td> overflow     </td><td> Check type conversion lost of bits or precision</td></tr>
<tr><td> math         </td><td> Various math checks (like a negative <span class="code-inline">@sqrt</span>)        </td></tr>
<tr><td> switch       </td><td> Check an invalid case in a <span class="code-inline">#[Swag.Complete]</span> switch </td></tr>
</table>
</div>
<p>You can define a header to the table if you separate the first line from the second one with a separator like <span class="code-inline">---</span>. A valid separator must have a length of at least 3 characters, and must only contain <span class="code-inline">-</span> or <span class="code-inline">:</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// | Title1 | Title2</span>
<span class="SCmt">// | ------ | ------</span>
<span class="SCmt">// | Item1  | Item2</span>
<span class="SCmt">// | Item1  | Item2</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><th style="text-align: left;">Title1</th><th style="text-align: left;">Title2</th></tr><tr><td style="text-align: left;"> Item1  </td><td style="text-align: left;"> Item2</td></tr>
<tr><td style="text-align: left;"> Item1  </td><td style="text-align: left;"> Item2</td></tr>
</table>
</div>
<p>You can define the <b>column alignment</b> by adding <span class="code-inline">:</span> at the start and/or at the end of a separator. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// | Title1     | Title2       | Title3</span>
<span class="SCmt">// | :-----     | :----:       | -----:</span>
<span class="SCmt">// | Align left | Align center | Align right</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><th style="text-align: left;">Title1</th><th style="text-align: center;">Title2</th><th style="text-align: right;">Title3</th></tr><tr><td style="text-align: left;"> Align left </td><td style="text-align: center;"> Align center </td><td style="text-align: right;"> Align right</td></tr>
</table>
</div>
<h4 id="_018_000_documentation_md">Code </h4>
<p>You can create a simple <b>code paragraph</b> with three backticks before and after the code. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// ```</span>
<span class="SCmt">// if a == true</span>
<span class="SCmt">//   @print("true")</span>
<span class="SCmt">// ```</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="code-block"><span class="SCde">if a == true
   @print("true")</span></div>
</div>
<p>You can also create that kind of paragraph by simply indenting the code with four blanks or one tabulation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">//    if a == false</span>
<span class="SCmt">//        @print("false")</span></span></div>
<p>And if you want <b>syntax coloration</b>, add <span class="code-inline">swag</span> after the three backticks. Only Swag syntax is supported right now. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// ```swag</span>
<span class="SCmt">// if a == true</span>
<span class="SCmt">//   @print("true")</span>
<span class="SCmt">// ```</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="code-block"><span class="SCde"><span class="SLgc">if</span> a == <span class="SKwd">true</span>
   <span class="SItr">@print</span>(<span class="SStr">"true"</span>)</span></div>
</div>
<h4 id="_018_000_documentation_md">Titles </h4>
<p>You can define <b>titles</b> with <span class="code-inline">#</span>, <span class="code-inline">##</span> ... followed by a blank, and then the text. The real level of the title will depend on the context and the generated documentation kind. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// # Title 1</span>
<span class="SCmt">// ## Title 2</span>
<span class="SCmt">// ### Title 3</span>
<span class="SCmt">// #### Title 4</span>
<span class="SCmt">// ##### Title 5</span>
<span class="SCmt">// ###### Title 6</span></span></div>
<h4 id="_018_000_documentation_md">References </h4>
<p>You can create an external <b>reference</b> with <span class="code-inline">[name](link)</span>. </p>
<div class="code-block"><span class="SCmt">// This is a [reference](https://github.com/swag-lang/swag) to the Swag repository on GitHub.</span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> This is a <a href="https://github.com/swag-lang/swag">reference</a> to the Swag repository on GitHub. </p>
</div>
<h4 id="_018_000_documentation_md">Images </h4>
<p>You can insert an external <b>image</b> with <span class="code-inline">![name](link)</span>. </p>
<div class="code-block"><span class="SCmt">// This is an image ![image](https://swag-lang/imgs/swag_icon.png).</span></div>
<h4 id="_018_000_documentation_md">Markdown </h4>
<p>Some other markers are also supported inside texts. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is `inline code` with back ticks.\</span>
<span class="SCmt">// This is inline 'code' with normal ticks, but just for a single word (no blanks).\</span>
<span class="SCmt">// This is **bold**.\</span>
<span class="SCmt">// This is *italic*.\</span>
<span class="SCmt">// This is ***bold and italic***.\</span>
<span class="SCmt">// This is ~~strikethrough~~.\</span>
<span class="SCmt">// This character \n is escaped, and 'n' will be output as is.\</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> This is <span class="code-inline">inline code</span> with back ticks.<br/>  This is inline <span class="code-inline">code</span> with normal ticks, but just for a single word (no blanks).<br/>  This is <b>bold</b>.<br/>  This is <i>italic</i>.<br/>  This is <b><i>bold and italic</i></b>.<br/>  This is <span class="strikethrough-text">strikethrough</span>.<br/>  This character n is escaped, and <span class="code-inline">n</span> will be output as is.<br/> </p>
</div>

<h3 id="_018_000_documentation_md__018_001_api_swg">Api </h3><h4 id="_018_000_documentation_md__018_001_api_swg">Documentation Generation in Swag </h4>
<p>When using <span class="code-inline">Swag.DocKind.Api</span> mode, Swag collects all <b>public definitions</b> to automatically generate API documentation. </p>
<p>A good example of this is the documentation for <a href="std.core.php">Std.Core</a>. </p>
<h4 id="_018_000_documentation_md__018_001_api_swg">Module-Level Documentation </h4>
<p>The main module documentation should be placed at the top of the <span class="code-inline">module.swg</span> file. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is the main module documentation.</span>
<span class="SFct">#dependencies</span>
{
}</span></div>
<h4 id="_018_000_documentation_md__018_001_api_swg">Element-Level Documentation </h4>
<p>Comments placed immediately before a <span class="code-inline">func</span>, <span class="code-inline">struct</span>, or <span class="code-inline">enum</span> become their documentation entries. </p>
<p>The <b>first paragraph</b> acts as the <i>short description</i> that appears in summaries. </p>
<p>If the first line ends with a dot <span class="code-inline">.</span>, it marks the end of the short description. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This first paragraph is the short description of function 'test1'.</span>
<span class="SCmt">//</span>
<span class="SCmt">// This second paragraph serves as the long description.</span>
<span class="SKwd">func</span> <span class="SFct">test1</span>() {}

<span class="SCmt">// This is the short description of 'test'.</span>
<span class="SCmt">// As the previous line ends with '.', the following text becomes</span>
<span class="SCmt">// the long description, even without a blank line.</span>
<span class="SKwd">func</span> <span class="SFct">test</span>() {}</span></div>
<h4 id="_018_000_documentation_md__018_001_api_swg">Inline Comments for Constants and Enums </h4>
<p>Constants and enum values can include documentation comments on the same line. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SNum">0</span> <span class="SCmt">// This is the documentation comment of constant 'A'</span>

<span class="SKwd">enum</span> <span class="SCst">Color</span>
{
    <span class="SCst">Red</span>      <span class="SCmt">// This is the documentation comment of enum value 'Red'</span>
    <span class="SCst">Blue</span>     <span class="SCmt">// This is the documentation comment of enum value 'Blue'</span>
}</span></div>
<h4 id="_018_000_documentation_md__018_001_api_swg">References </h4>
<p>You can reference other documented elements using <span class="code-inline">[[name]]</span> or fully qualified forms like <span class="code-inline">[[name1.name2]]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is a function with a 'value' parameter.</span>
<span class="SKwd">func</span> <span class="SFct">one</span>(value: <span class="STpe">s32</span>) {}

<span class="SCmt">// This is a reference to [[one]].</span>
<span class="SKwd">func</span> <span class="SFct">two</span>() {}</span></div>
<h4 id="_018_000_documentation_md__018_001_api_swg">Hiding from Documentation </h4>
<p>Use the <span class="code-inline">#[Swag.NoDoc]</span> attribute to exclude an element from the generated documentation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The function 'three' will be ignored by the documentation generator.</span>
<span class="SAtr">#[Swag.NoDoc]</span>
<span class="SKwd">func</span> <span class="SFct">three</span>() {}</span></div>

<h3 id="_018_000_documentation_md__018_002_examples_md">Examples </h3><p>In <span class="code-inline">Swag.DocKind.Examples</span> mode, documentation is generated systematically, with each file representing a chapter or subchapter. The following guidelines outline the structure and formatting required for effective documentation creation. </p>
<h4 id="_018_000_documentation_md__018_002_examples_md">File Naming Convention </h4>
<p>File names must adhere to the format <span class="code-inline">DDD_DDD_name</span>, where each <span class="code-inline">D</span> represents a digit. This naming convention facilitates the hierarchical organization of the documentation. </p>
<div class="description-list-title"><p>Main Titles</p></div>
<div class="description-list-block">
<p>Files with names formatted as <span class="code-inline">100_000_my_title.swg</span> will generate a main heading (<span class="code-inline">&lt;h1&gt;My Title&lt;/h1&gt;</span>). </p>
</div>
<div class="description-list-title"><p>Subtitles</p></div>
<div class="description-list-block">
<p>Files named <span class="code-inline">101_001_my_sub_title.swg</span> or <span class="code-inline">102_002_my_sub_title.swg</span> will generate subheadings (<span class="code-inline">&lt;h2&gt;My Sub Title&lt;/h2&gt;</span>) under the corresponding main title. </p>
</div>
<div class="description-list-title"><p>Multiple Main Titles</p></div>
<div class="description-list-block">
<p>For separate sections, such as <span class="code-inline">110_000_my_other_title.swg</span>, another main heading (<span class="code-inline">&lt;h1&gt;My Other Title&lt;/h1&gt;</span>) will be generated. </p>
</div>
<div class="description-list-title"><p>File Type Flexibility</p></div>
<div class="description-list-block">
<p>You can mix <span class="code-inline">.swg</span> files with <span class="code-inline">.md</span> files. For example, <span class="code-inline">111_000_my_other_title.md</span> will seamlessly integrate Markdown files into the documentation structure. </p>
</div>
<h4 id="_018_000_documentation_md__018_002_examples_md">Comment Format for Documentation </h4>
<p>To include comments in your code that should be interpreted as part of the documentation (as opposed to standard Swag comments), use the following syntax: </p>
<div class="code-block"><span class="SCde">/**
 This is a valid documentation comment.
 The comment must start with /** and end with */, each on a separate line.
 */</span></div>
<p>These comments will be processed and included in the generated documentation, ensuring that inline comments are properly formatted and contribute to the final output. </p>
<h4 id="_018_000_documentation_md__018_002_examples_md">Source of Documentation </h4>
<p>The documentation you are reading is generated from the <a href="https://github.com/swag-lang/swag/tree/master/bin/reference/tests/language">std/reference/language</a> module. This directory contains examples and files structured according to these guidelines, showcasing how to effectively create and manage documentation in <span class="code-inline">Swag.DocKind.Examples</span> mode. </p>

<h3 id="_018_000_documentation_md__018_003_pages_md">Pages </h3><p>In <span class="code-inline">Swag.DocKind.Pages</span> mode, each file generates an individual webpage, with the page name matching the file name. Aside from this distinction, the behavior is consistent with that of <span class="code-inline">Swag.DocKind.Examples</span> mode. </p>
<h4 id="_018_000_documentation_md__018_003_pages_md">File Naming and Page Generation </h4>
<p>Each file in this mode generates a separate webpage. The page name will directly correspond to the file name. </p>
<h4 id="_018_000_documentation_md__018_003_pages_md">Use Case </h4>
<p><span class="code-inline">Swag.DocKind.Pages</span> mode is particularly useful for generating individual web pages, as demonstrated in the <a href="https://github.com/swag-lang/swag/tree/master/bin/reference/tests/web">example directory</a>. This mode is ideal for creating standalone pages that can be linked together or accessed independently, making it a versatile option for web-based documentation projects. </p>
<div class="swag-watermark">
Generated on 12-10-2025 with <a href="https://swag-lang.org/index.php">swag</a> 0.45.0</div>
</div>
</div>
</div>

    <script> 
		function getOffsetTop(element, parent) {
			let offsetTop = 0;
			while (element && element != parent) {
				offsetTop += element.offsetTop;
				element = element.offsetParent;
			}
			return offsetTop;
		}	
		document.addEventListener("DOMContentLoaded", function() {
			let hash = window.location.hash;
			if (hash)
			{
				let parentScrollable = document.querySelector('.right');
				if (parentScrollable)
				{
					let targetElement = parentScrollable.querySelector(hash);
					if (targetElement)
					{
						parentScrollable.scrollTop = getOffsetTop(targetElement, parentScrollable);
					}
				}
			}
        });
    </script>
</body>
</html>
