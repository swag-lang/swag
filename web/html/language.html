<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<?php include('common/start-head.php'); ?><title>Swag Language Reference</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<link rel="stylesheet" type="text/css" href="css/style.css">
<script src="https://kit.fontawesome.com/f76be2b3ee.js" crossorigin="anonymous"></script>
<style>

        .container  { display: flex; flex-wrap: nowrap; flex-direction: row; margin: 0px auto; padding: 0px; }
        .left       { display: block; overflow-y: scroll; width: 500px; }
        .left-page  { margin: 10px; }
        .right      { display: block; width: 100%; }
        .right-page { max-width: 1024px; margin: 10px auto; }
        
        @media(min-width: 640px)  { .container { max-width: 640px; }}
        @media(min-width: 768px)  { .container { max-width: 768px; }}
        @media(min-width: 1024px) { .container { max-width: 1024px; }}
        @media(min-width: 1280px) { .container { max-width: 1280px; }}
        @media(min-width: 1536px) { .container { max-width: 1536px; }}
        
        @media screen and (max-width: 600px) {
            .left       { display: none; }
            .right-page { margin:  10px; }
        }

            .container { height: 100vh; }
            .right     { overflow-y: scroll; }

        html { font-family: ui-sans-serif, system-ui, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif; }
        body { margin: 0px; line-height: 1.3em; }
        
        .container a        { color: DoggerBlue; }
        .container a:hover  { text-decoration: underline; }
        .container img      { margin: 0 auto; }
        
        .left a     { text-decoration: none; }
        .left ul    { list-style-type: none; margin-left: -20px; }
        .left h3    { background-color: Black; color: White; padding: 6px; }
        .right h1   { margin-top: 50px; margin-bottom: 50px; }
        .right h2   { margin-top: 35px; }
        
        .strikethrough-text { text-decoration: line-through; }
        .swag-watermark     { text-align:right; font-size: 80%; margin-top: 30px; }
        .swag-watermark a   { text-decoration: none; color: inherit; }
        
        .blockquote               { border-radius: 5px; border: 1px solid; margin: 20px; padding: 10px; }
        .blockquote-default       { border-color: Orange; border-left: 6px solid Orange; background-color: LightYellow; }
        .blockquote-note          { border-color: #ADCEDD; background-color: #CDEEFD; }
        .blockquote-tip           { border-color: #BCCFBC; background-color: #DCEFDC; }
        .blockquote-warning       { border-color: #DFBDB3; background-color: #FFDDD3; }
        .blockquote-attention     { border-color: #DDBAB8; background-color: #FDDAD8; }
        .blockquote-example       { border: 2px solid LightGrey; }
        .blockquote-title-block   { margin-bottom: 10px; }
        .blockquote-title         { font-weight: bold; }
        .blockquote-default       p:first-child { margin-top: 0px; }
        .blockquote-default       p:last-child  { margin-bottom: 0px; }
        .blockquote               p:last-child  { margin-bottom: 0px; }
        
        .description-list-title   { font-weight: bold; font-style: italic; }
        .description-list-block   { margin-left: 30px; }
        
        .container table          { border: 1px solid LightGrey; border-collapse: collapse; font-size: 90%; margin-left: 20px; margin-right: 20px; }
        .container td             { border: 1px solid LightGrey; border-collapse: collapse; padding: 6px; min-width: 100px; }
        .container th             { border: 1px solid LightGrey; border-collapse: collapse; padding: 6px; min-width: 100px; background-color: #eeeeee; }
        
        table.api-item            { border-collapse: separate; background-color: Black; color: White; width: 100%; margin-top: 70px; margin-right: 0px; font-size: 110%; }
        .api-item td              { font-size: revert; border: 0; }
        .api-item td:first-child  { width: 33%; white-space: nowrap; }
        .api-item-title-src-ref   { text-align:  right; }
        .api-item-title-src-ref a { color:       inherit; }
        .api-item-title-kind      { font-weight: normal; font-size: 80%; }
        .api-item-title-light     { font-weight: normal; }
        .api-item-title-strong    { font-weight: bold; font-size: 100%; }
        .api-additional-infos     { font-size: 90%; white-space: break-spaces; overflow-wrap: break-word; }
        
        table.table-enumeration           { width: calc(100% - 40px); }
        .table-enumeration td:first-child { background-color: #f8f8f8; white-space: nowrap; }
        .table-enumeration td:last-child  { width: 100%; }
        .table-enumeration td.code-type   { background-color: #eeeeee; }
        .table-enumeration a              { text-decoration: none; color: inherit; }
        
        .code-inline  { background-color: #eeeeee; border-radius: 5px; border: 1px dotted #cccccc; padding: 0px 8px; font-size: 110%; font-family: monospace; display: inline-block; }
        .code-block   { background-color: #eeeeee; border-radius: 5px; border: 1px solid LightGrey; padding: 10px; margin: 20px; white-space: pre; overflow-x: auto; }
        .code-block   { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
        .code-block a { color: inherit; }
        
    .SCde { color: #222222; }
    .SCmt { color: #71a35b; }
    .SCmp { color: #7f7f7f; }
    .SFct { color: #ff6a00; }
    .SCst { color: #3bc3a7; }
    .SItr { color: #b4b44a; }
    .STpe { color: #ed9a11; }
    .SKwd { color: #3186cd; }
    .SLgc { color: #b040be; }
    .SNum { color: #74a35b; }
    .SStr { color: #bb6643; }
    .SAtr { color: #7f7f7f; }
    .SInv { color: #ff0000; }
</style>
<?php include('common/end-head.php'); ?></head>
<body>
<?php include('common/start-body.php'); ?><div class="container">
<div class="left">
<div class="left-page">
<h2>Table of Contents</h2>
<ul>
<li><a href="#000_introduction">Introduction</a></li>
<li><a href="#001_hello_mad_world">Hello mad world</a></li>
<li><a href="#002_source_code_organization">Source code organization</a></li>
<li><a href="#003_comments">Comments</a></li>
<li><a href="#004_identifiers">Identifiers</a></li>
<li><a href="#005_keywords">Keywords</a></li>
<ul>
<li><a href="#005_keywords_Special_keywords">Special keywords</a></li>
<li><a href="#005_keywords_Reserved_keywords">Reserved keywords</a></li>
<li><a href="#005_keywords_Basic_types">Basic types</a></li>
<li><a href="#005_keywords_Compiler_keywords">Compiler keywords</a></li>
<li><a href="#005_keywords_Misc_intrinsics">Misc intrinsics</a></li>
<li><a href="#005_keywords_Intrinsics_libc">Intrinsics libc</a></li>
<li><a href="#005_keywords_Modifiers">Modifiers</a></li>
</ul>
<li><a href="#006_semicolon">Semicolon</a></li>
<li><a href="#007_global_declaration_order">Global declaration order</a></li>
<li><a href="#010_basic_types">Basic types</a></li>
<ul>
<li><a href="#010_basic_types_Type_reflection">Type reflection</a></li>
</ul>
<li><a href="#011_number_literals">Number literals</a></li>
<ul>
<li><a href="#011_number_literals_Suffix">Suffix</a></li>
</ul>
<li><a href="#012_string">String</a></li>
<ul>
<li><a href="#012_string_Character_literals">Character literals</a></li>
<li><a href="#012_string_Escape_sequences">Escape sequences</a></li>
<li><a href="#012_string_Raw_string">Raw string</a></li>
<li><a href="#012_string_Multiline_string">Multiline string</a></li>
<li><a href="#012_string_@stringof_and_@nameof">@stringof and @nameof</a></li>
</ul>
<li><a href="#013_variables">Variables</a></li>
<ul>
<li><a href="#013_variables_Special_variables">Special variables</a></li>
</ul>
<li><a href="#014_const">Const</a></li>
<li><a href="#015_operators">Operators</a></li>
<ul>
<li><a href="#015_operators_Arithmetic_operators">Arithmetic operators</a></li>
<li><a href="#015_operators_Bitwise_operators">Bitwise operators</a></li>
<li><a href="#015_operators_Assignment_operators">Assignment operators</a></li>
<li><a href="#015_operators_Unary_operators">Unary operators</a></li>
<li><a href="#015_operators_Comparison_operators">Comparison operators</a></li>
<li><a href="#015_operators_Logical_operators">Logical operators</a></li>
<li><a href="#015_operators_Ternary_operator">Ternary operator</a></li>
<li><a href="#015_operators_Spaceshift_operator">Spaceshift operator</a></li>
<li><a href="#015_operators_Null-coalescing_operator">Null-coalescing operator</a></li>
<li><a href="#015_operators_Type_promotion">Type promotion</a></li>
<li><a href="#015_operators_Operator_precedence">Operator precedence</a></li>
</ul>
<li><a href="#016_cast">Cast</a></li>
<ul>
<li><a href="#016_cast_Explicit_cast">Explicit cast</a></li>
<li><a href="#016_cast_acast">acast</a></li>
<li><a href="#016_cast_bitcast">bitcast</a></li>
<li><a href="#016_cast_Implicit_casts">Implicit casts</a></li>
</ul>
<li><a href="#020_array">Array</a></li>
<li><a href="#021_slice">Slice</a></li>
<ul>
<li><a href="#021_slice_The_slicing_operator">The slicing operator</a></li>
</ul>
<li><a href="#022_pointers">Pointers</a></li>
<ul>
<li><a href="#022_pointers_Single_value_pointers">Single value pointers</a></li>
<li><a href="#022_pointers_Multiple_values_pointers">Multiple values pointers</a></li>
</ul>
<li><a href="#023_references">References</a></li>
<li><a href="#024_any">Any</a></li>
<li><a href="#025_tuple">Tuple</a></li>
<ul>
<li><a href="#025_tuple_Tuple_unpacking">Tuple unpacking</a></li>
</ul>
<li><a href="#030_enum">Enum</a></li>
<ul>
<li><a href="#030_enum_Enum_as_flags">Enum as flags</a></li>
<li><a href="#030_enum_Enum_of_arrays">Enum of arrays</a></li>
<li><a href="#030_enum_Enum_of_slices">Enum of slices</a></li>
<li><a href="#030_enum_Nested_enums">Nested enums</a></li>
<li><a href="#030_enum_Specific_attributes">Specific attributes</a></li>
<li><a href="#030_enum_Enum_type_inference">Enum type inference</a></li>
</ul>
<li><a href="#031_impl">Impl</a></li>
<li><a href="#035_namespace">Namespace</a></li>
<li><a href="#050_if">If</a></li>
<li><a href="#051_loop">Loop</a></li>
<ul>
<li><a href="#051_loop_break,_continue">break, continue</a></li>
<li><a href="#051_loop_Ranges">Ranges</a></li>
<li><a href="#051_loop_Infinite_loop">Infinite loop</a></li>
</ul>
<li><a href="#052_visit">Visit</a></li>
<li><a href="#053_for">For</a></li>
<li><a href="#054_while">While</a></li>
<li><a href="#055_switch">Switch</a></li>
<ul>
<li><a href="#055_switch_The_complete_attribute">The complete attribute</a></li>
<li><a href="#055_switch_On_specific_types">On specific types</a></li>
<li><a href="#055_switch_On_ranges">On ranges</a></li>
<li><a href="#055_switch_Without_an_expression">Without an expression</a></li>
</ul>
<li><a href="#056_break">Break</a></li>
<li><a href="#060_struct">Struct</a></li>
<ul>
<li><a href="#060_struct_061_001_declaration">Declaration</a></li>
<li><a href="#060_struct_062_002_impl">Impl</a></li>
<li><a href="#060_struct_063_003_special_functions">Special functions</a></li>
<li><a href="#060_struct_064_004_affectation">Affectation</a></li>
<li><a href="#060_struct_064_005_count">Count</a></li>
<li><a href="#060_struct_064_006_post_copy_and_post_move">Post copy and post move</a></li>
<ul>
<li><a href="#060_struct_064_006_post_copy_and_post_move_moveref">moveref</a></li>
</ul>
<li><a href="#060_struct_064_007_visit">Visit</a></li>
<li><a href="#060_struct_067_008_offset">Offset</a></li>
<li><a href="#060_struct_068_009_packing">Packing</a></li>
</ul>
<li><a href="#070_union">Union</a></li>
<li><a href="#075_interface">Interface</a></li>
<li><a href="#100_function">Function</a></li>
<ul>
<li><a href="#100_function_101_001_declaration">Declaration</a></li>
<ul>
<li><a href="#100_function_101_001_declaration_Multiple_return_values">Multiple return values</a></li>
</ul>
<li><a href="#100_function_102_002_lambda">Lambda</a></li>
<ul>
<li><a href="#100_function_102_002_lambda_Anonymous_functions">Anonymous functions</a></li>
</ul>
<li><a href="#100_function_103_003_closure">Closure</a></li>
<li><a href="#100_function_104_004_mixin">Mixin</a></li>
<li><a href="#100_function_105_005_macro">Macro</a></li>
<li><a href="#100_function_105_006_variadic_parameters">Variadic parameters</a></li>
<li><a href="#100_function_106_007_ufcs">Ufcs</a></li>
<li><a href="#100_function_107_008_constexpr">Constexpr</a></li>
<li><a href="#100_function_108_009_function_overloading">Function overloading</a></li>
<li><a href="#100_function_109_010_discard">Discard</a></li>
<li><a href="#100_function_110_011_retval">Retval</a></li>
<li><a href="#100_function_111_012_foreign">Foreign</a></li>
</ul>
<li><a href="#120_intrinsics">Intrinsics</a></li>
<ul>
<li><a href="#120_intrinsics_Base">Base</a></li>
<li><a href="#120_intrinsics_Buildin">Buildin</a></li>
<li><a href="#120_intrinsics_Memory_related">Memory related</a></li>
<li><a href="#120_intrinsics_Atomic_operations">Atomic operations</a></li>
<li><a href="#120_intrinsics_Math">Math</a></li>
</ul>
<li><a href="#121_init">Init</a></li>
<ul>
<li><a href="#121_init_@init">@init</a></li>
<li><a href="#121_init_@drop">@drop</a></li>
</ul>
<li><a href="#130_generic">Generic</a></li>
<ul>
<li><a href="#130_generic_131_001_declaration">Declaration</a></li>
<li><a href="#130_generic_132_002_validif">Validif</a></li>
<ul>
<li><a href="#130_generic_132_002_validif_One_time_evaluation">One time evaluation</a></li>
<li><a href="#130_generic_132_002_validif_Multiple_evaluations">Multiple evaluations</a></li>
</ul>
<li><a href="#130_generic_133_003_constraint">Constraint</a></li>
</ul>
<li><a href="#140_attributes">Attributes</a></li>
<ul>
<li><a href="#140_attributes_141_001_user_attributes">User attributes</a></li>
<li><a href="#140_attributes_142_002_predefined_attributes">Predefined attributes</a></li>
</ul>
<li><a href="#160_scoping">Scoping</a></li>
<ul>
<li><a href="#160_scoping_161_001_defer">Defer</a></li>
<li><a href="#160_scoping_162_002_using">Using</a></li>
<ul>
<li><a href="#160_scoping_162_002_using_For_a_function_parameter">For a function parameter</a></li>
<li><a href="#160_scoping_162_002_using_For_a_field">For a field</a></li>
</ul>
<li><a href="#160_scoping_163_003_with">With</a></li>
</ul>
<li><a href="#164_alias">Alias</a></li>
<ul>
<li><a href="#164_alias_Type_alias">Type alias</a></li>
<li><a href="#164_alias_Name_alias">Name alias</a></li>
</ul>
<li><a href="#170_error_management">Error management</a></li>
<ul>
<li><a href="#170_error_management_defer">defer</a></li>
</ul>
<li><a href="#175_safety">Safety</a></li>
<ul>
<li><a href="#175_safety_overflow">overflow</a></li>
<li><a href="#175_safety_any">any</a></li>
<li><a href="#175_safety_boundcheck">boundcheck</a></li>
<li><a href="#175_safety_math">math</a></li>
<li><a href="#175_safety_switch">switch</a></li>
<li><a href="#175_safety_bool">bool</a></li>
<li><a href="#175_safety_nan">nan</a></li>
</ul>
<li><a href="#180_type_reflection">Type reflection</a></li>
<ul>
<li><a href="#180_type_reflection_@decltype">@decltype</a></li>
</ul>
<li><a href="#190_compile-time_evaluation">Compile-time evaluation</a></li>
<ul>
<li><a href="#190_compile-time_evaluation_191_001_constexpr">Constexpr</a></li>
<li><a href="#190_compile-time_evaluation_192_002_run">Run</a></li>
<ul>
<li><a href="#190_compile-time_evaluation_192_002_run_Force_compile-time_call">Force compile-time call</a></li>
<li><a href="#190_compile-time_evaluation_192_002_run_#run_block">#run block</a></li>
<li><a href="#190_compile-time_evaluation_192_002_run_#run_expression">#run expression</a></li>
</ul>
<li><a href="#190_compile-time_evaluation_193_003_special_functions">Special functions</a></li>
<ul>
<li><a href="#190_compile-time_evaluation_193_003_special_functions_#main">#main</a></li>
<li><a href="#190_compile-time_evaluation_193_003_special_functions_#premain">#premain</a></li>
<li><a href="#190_compile-time_evaluation_193_003_special_functions_#init">#init</a></li>
<li><a href="#190_compile-time_evaluation_193_003_special_functions_#drop">#drop</a></li>
<li><a href="#190_compile-time_evaluation_193_003_special_functions_#test">#test</a></li>
</ul>
<li><a href="#190_compile-time_evaluation_194_004_compiler_instructions">Compiler instructions</a></li>
<ul>
<li><a href="#190_compile-time_evaluation_194_004_compiler_instructions_#assert">#assert</a></li>
<li><a href="#190_compile-time_evaluation_194_004_compiler_instructions_#if/#else">#if/#else</a></li>
<li><a href="#190_compile-time_evaluation_194_004_compiler_instructions_#error/#warning">#error/#warning</a></li>
<li><a href="#190_compile-time_evaluation_194_004_compiler_instructions_#global">#global</a></li>
<li><a href="#190_compile-time_evaluation_194_004_compiler_instructions_#foreignlib">#foreignlib</a></li>
</ul>
</ul>
<li><a href="#210_code_inspection">Code inspection</a></li>
<li><a href="#220_meta_programming">Meta programming</a></li>
<ul>
<li><a href="#220_meta_programming_221_001_ast">Ast</a></li>
<ul>
<li><a href="#220_meta_programming_221_001_ast_Struct_and_enums">Struct and enums</a></li>
<li><a href="#220_meta_programming_221_001_ast_For_example">For example</a></li>
<li><a href="#220_meta_programming_221_001_ast_At_global_scope">At global scope</a></li>
</ul>
<li><a href="#220_meta_programming_222_002_compiler_interface">Compiler interface</a></li>
</ul>
<li><a href="#230_documentation">Documentation</a></li>
<ul>
<li><a href="#230_documentation_Markdown_files">Markdown files</a></li>
<li><a href="#230_documentation_Format_of_comments">Format of comments</a></li>
<ul>
<li><a href="#230_documentation_Format_of_comments_Paragraphs">Paragraphs</a></li>
<li><a href="#230_documentation_Format_of_comments_Lists">Lists</a></li>
<li><a href="#230_documentation_Format_of_comments_Definition_Lists">Definition Lists</a></li>
<li><a href="#230_documentation_Format_of_comments_Quotes">Quotes</a></li>
<li><a href="#230_documentation_Format_of_comments_Tables">Tables</a></li>
<li><a href="#230_documentation_Format_of_comments_Code">Code</a></li>
<li><a href="#230_documentation_Format_of_comments_Titles">Titles</a></li>
<li><a href="#230_documentation_Format_of_comments_References">References</a></li>
<li><a href="#230_documentation_Format_of_comments_Images">Images</a></li>
<li><a href="#230_documentation_Format_of_comments_Markdown">Markdown</a></li>
</ul>
<li><a href="#230_documentation_231_001_Api">Api</a></li>
<ul>
<li><a href="#230_documentation_231_001_Api_References">References</a></li>
<li><a href="#230_documentation_231_001_Api_NoDoc">NoDoc</a></li>
</ul>
<li><a href="#230_documentation_231_002_Examples">Examples</a></li>
<li><a href="#230_documentation_231_003_Pages">Pages</a></li>
</ul>
</div>
</div>
<div class="right">
<div class="right-page">
<h1>Swag Language Reference</h1>

<h2 id="000_introduction">Introduction</h2><p>The <span class="code-inline">swag-lang/swag/bin/reference/language</span> module provides a brief explanation of the language basic syntax and usage without the need of the <a href="std.php">Swag standard modules</a> (<span class="code-inline">Std</span>). This documentation has been generated directly from the source tree of that module. </p>
<p>More advanced features such as dynamic arrays, dynamic strings or hash maps can be found in the <a href="std.core.php">Std.Core</a> module and will not be covered in the examples to come. For now we will focus on the language itself. </p>
<p>As <span class="code-inline">reference/language</span> is written as a test module, you can run it with : </p>
<div class="code-block"><span class="SCde">swag test --workspace:c:/swag-lang/swag/bin/reference
swag test -w:c:/swag-lang/swag/bin/reference</span></div>
<p>This will run all the test modules of the specified workspace (including this one). You can also omit the <span class="code-inline">--workspace</span> parameter (or <span class="code-inline">-w</span> in its short form) if you run Swag directly from the workspace folder. </p>
<p>Note that if you want to compile and run a single module in the workspace, you can specify it with the <span class="code-inline">--module</span> (<span class="code-inline">-m</span>) parameter. </p>
<div class="code-block"><span class="SCde">swag test -w:c:/swag-lang/swag/bin/reference -m:test_language</span></div>

<h2 id="001_hello_mad_world">Hello mad world</h2><p>Let's start with the most simple version of the "hello world" example. This is a version that does not require external dependencies like the <a href="std.php">Swag standard modules</a>. </p>
<p><span class="code-inline">#main</span> is the <b>program entry point</b>, a special compiler function (that's why the name starts with <span class="code-inline">#</span>). It must be defined only once for a native executable. <span class="code-inline">@print</span> is an <b>intrinsic</b>, a special built-in function (that's why the name starts with <span class="code-inline">@</span>). </p>
<p>All intrinsics are part of the <a href="std/swag.runtime.php">compiler runtime</a> which comes with the compiler. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SItr">@print</span>(<span class="SStr">"Hello mad world !\n"</span>)
}</span></div>
<p>Next, a version that this time uses the <span class="code-inline">Core.Console.print</span> function in the <a href="std.core.html">Std.Core</a> module. The <span class="code-inline">Std.Core</span> module would have to be imported in order to be used, but let's keep it simple. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world !"</span>, <span class="SStr">"\n"</span>)
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">printf</span>(<span class="SStr">"%\n"</span>, <span class="SStr">"Hello mad world again !"</span>)
}</span></div>
<p>A <span class="code-inline">#run</span> block is executed at <b>compile time</b>, and can make Swag behaves like a kind of a <b>scripting language</b>. So in the following example, the famous message will be printed by the compiler during compilation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
{
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SStr">"Hello mad world !\n"</span>   <span class="SCmt">// Creates a compiler constant of type 'string'</span>
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)             <span class="SCmt">// And call 'Console.print' at compile time</span>
}</span></div>
<p>A version that calls a <b>nested function</b> at compile time (only) to initialize the string constant to print. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Brings the 'Core' namespace into scope, to avoid repeating it again and again</span>
<span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">nestedFunc</span>() =&gt; <span class="SStr">"Hello mad world !\n"</span>   <span class="SCmt">// Function short syntax</span>

    <span class="SCmt">// nestedFunc() can be called at compile time because it is marked with</span>
    <span class="SCmt">// the 'Swag.ConstExpr' attribute.</span>
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SFct">nestedFunc</span>()
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)
}</span></div>
<p>Now a stupid version that generates the code to do the print thanks to <b>meta programming</b>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SStr">"Hello mad world !\n"</span>

    <span class="SCmt">// The result of an '#ast' block is a string that will be compiled in place.</span>
    <span class="SCmt">// So this whole thing is equivalent to a simple 'Console.print(Msg)'.</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">var</span> sb = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}
        sb.<span class="SFct">appendString</span>(<span class="SStr">"Console.print(Msg)"</span>)
        <span class="SLgc">return</span> sb.<span class="SFct">toString</span>()
    }
}</span></div>
<p>And finally let's be more and more crazy. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Core</span>

<span class="SFct">#main</span>
{
    <span class="SCmt">// #run will force the call of mySillyFunction() at compile time even if it's not marked</span>
    <span class="SCmt">// with #[Swag.ConstExpr]</span>
    <span class="SKwd">const</span> <span class="SCst">Msg</span> = <span class="SFct">#run</span> <span class="SFct">mySillyFunction</span>()
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SCst">Msg</span>)
}

<span class="SCmt">// The attribute #[Swag.Compiler] tells Swag that this is a compile time function only.</span>
<span class="SCmt">// So this function will not be exported to the final executable or module.</span>
<span class="SAtr">#[Swag.Compiler]</span>
<span class="SKwd">func</span> <span class="SFct">mySillyFunction</span>()-&gt;<span class="STpe">string</span>
{
    <span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world at compile time !\n"</span>)

    <span class="SCmt">// This creates a constant named 'MyConst'</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">var</span> sb = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}
        sb.<span class="SFct">appendString</span>(<span class="SStr">"const MyConst = \"Hello "</span>)
        sb.<span class="SFct">appendString</span>(<span class="SStr">"mad world "</span>)
        sb.<span class="SFct">appendString</span>(<span class="SStr">"at runtime !\""</span>)
        <span class="SLgc">return</span> sb.<span class="SFct">toString</span>()
    }

    <span class="SLgc">return</span> <span class="SCst">MyConst</span>
}</span></div>
<p>This whole piece of code is equivalent to... </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SCst">Core</span>.<span class="SCst">Console</span>.<span class="SFct">print</span>(<span class="SStr">"Hello mad world at runtime !"</span>)
}</span></div>

<h2 id="002_source_code_organization">Source code organization</h2><p>All source files in Swag have the <span class="code-inline">.swg</span> extension, except if you write a simple script with the <span class="code-inline">.swgs</span> extension. They must be encoded in <b>UTF8</b>. </p>
<p>In Swag you cannot compile a single file (with the exception of <span class="code-inline">.swgs</span> script files). The source code is organized in a <b>workspace</b> which contains one or multiple <b>modules</b>. </p>
<p>For example, <span class="code-inline">Std</span> is a workspace that contains all the Swag standard modules. </p>
<p>A module is a <span class="code-inline">dll</span> (under windows) or an executable, and a workspace can include many of them. So a workspace will contain the modules you write (like your main executable) but also all your dependencies (some external modules you use). </p>
<p>Typically, the entire workspace is compiled. </p>

<h2 id="003_comments">Comments</h2><p>Let's start with the basics. Swag support classical single-line and multi-line comments. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Single-line comment</span>

<span class="SCmt">/*
    Multi-line comment on...
    ... multiple lines
*/</span>

<span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SNum">0</span> <span class="SCmt">// This is a constant with the value '0' assigned to it</span>
<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCmt">/* false */</span> <span class="SKwd">true</span></span></div>
<p>Nested comments are supported. </p>
<div class="code-block"><span class="SCmt">/*
    */ You can also nest multi-line comments */
*/</span></div>

<h2 id="004_identifiers">Identifiers</h2><p>User identifiers (like variables, constants, function names...) must start with an underscore or an ascii letter. Those identifiers can then contain underscores, ascii letters and digit numbers. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> thisIsAValidIdentifier0   = <span class="SNum">0</span>
<span class="SKwd">const</span> this_is_also_valid        = <span class="SNum">0</span>
<span class="SKwd">const</span> this_1_is_2_also__3_valid = <span class="SNum">0</span></span></div>
<p>But your identifiers cannot start with two underscores. This is reserved by the compiler. </p>
<div class="code-block"><span class="SCmt">// const __this_is_invalid = 0</span></div>
<p>Note that some identifiers may start with <span class="code-inline">#</span>. This indicates a <b>compiler special keyword</b>. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span>
<span class="SFct">#run</span>
<span class="SFct">#main</span></span></div>
<p>Some identifiers can also start with <span class="code-inline">@</span>. This indicates an <b>intrinsic</b> function which can be compile time only or also available at runtime (this depends on the intrinsic). </p>
<div class="code-block"><span class="SCde"><span class="SItr">@min</span>()
<span class="SItr">@max</span>()
<span class="SItr">@sqrt</span>()
<span class="SItr">@print</span>()</span></div>

<h2 id="005_keywords">Keywords</h2><p>This is the list of all keywords in the language. </p>
<h3 id="005_keywords_Special_keywords">Special keywords </h3>
<p>Keywords are predefined, reserved identifiers that have special meanings to the compiler. They can't be used as identifiers in your program. </p>
<div class="code-block"><span class="SCde"><span class="SLgc">if</span>
<span class="SLgc">else</span>
<span class="SLgc">elif</span>
<span class="SLgc">switch</span>
<span class="SLgc">case</span>
<span class="SLgc">default</span>
<span class="SLgc">break</span>
<span class="SLgc">continue</span>
<span class="SLgc">fallthrough</span>
<span class="SLgc">unreachable</span>
<span class="SLgc">for</span>
<span class="SLgc">loop</span>
<span class="SLgc">while</span>
<span class="SLgc">visit</span>
<span class="SLgc">return</span>
<span class="SLgc">defer</span>
<span class="SLgc">and</span>
<span class="SLgc">or</span>
<span class="SLgc">orelse</span>
<span class="SLgc">to</span>
<span class="SLgc">until</span>

<span class="SKwd">false</span>
<span class="SKwd">true</span>
<span class="SKwd">null</span>
<span class="SKwd">undefined</span>
<span class="SKwd">retval</span>

<span class="SKwd">const</span>
<span class="SKwd">var</span>
<span class="SKwd">let</span>
<span class="SKwd">ref</span>
<span class="SKwd">moveref</span>
<span class="SKwd">acast</span>
<span class="SKwd">cast</span>
<span class="SKwd">assume</span>
<span class="SKwd">try</span>
<span class="SKwd">catch</span>
<span class="SKwd">throw</span>
<span class="SKwd">closure</span>
<span class="SKwd">func</span>
<span class="SKwd">mtd</span>
<span class="SKwd">attr</span>
<span class="SKwd">enum</span>
<span class="SKwd">struct</span>
<span class="SKwd">union</span>
<span class="SKwd">namespace</span>
<span class="SKwd">impl</span>
<span class="SKwd">public</span>
<span class="SKwd">internal</span>
<span class="SKwd">private</span>
<span class="SKwd">interface</span>
<span class="SKwd">using</span>
<span class="SKwd">typealias</span>
<span class="SKwd">namealias</span>
<span class="SKwd">discard</span>
<span class="SKwd">dref</span></span></div>
<h3 id="005_keywords_Reserved_keywords">Reserved keywords </h3>
<p>These keywords are reserved by the language, just in case... </p>
<div class="code-block"><span class="SCde"><span class="SInv">is</span>
<span class="SInv">in</span>
<span class="SInv">not</span></span></div>
<h3 id="005_keywords_Basic_types">Basic types </h3>
<p>These are all the native types of the language. All are reserved keywords too. </p>
<div class="code-block"><span class="SCde"><span class="STpe">s8</span>
<span class="STpe">s16</span>
<span class="STpe">s32</span>
<span class="STpe">s64</span>
<span class="STpe">u8</span>
<span class="STpe">u16</span>
<span class="STpe">u32</span>
<span class="STpe">u64</span>
<span class="STpe">f32</span>
<span class="STpe">f64</span>
<span class="STpe">bool</span>
<span class="STpe">string</span>
<span class="STpe">rune</span>
<span class="STpe">any</span>
<span class="STpe">typeinfo</span>
<span class="STpe">void</span>
<span class="STpe">code</span>
<span class="STpe">cstring</span>
<span class="STpe">cvarargs</span></span></div>
<h3 id="005_keywords_Compiler_keywords">Compiler keywords </h3>
<p>Compiler keywords always start with <span class="code-inline">#</span>. As user identifiers cannot start the same way, compiler keywords will never collide with user identifiers. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#arch</span>
<span class="SCmp">#backend</span>
<span class="SCmp">#callerfunction</span>
<span class="SCmp">#callerlocation</span>
<span class="SCmp">#cfg</span>
<span class="SCmp">#code</span>
<span class="SCmp">#file</span>
<span class="SCmp">#line</span>
<span class="SCmp">#location</span>
<span class="SCmp">#module</span>
<span class="SCmp">#os</span>
<span class="SCmp">#self</span>
<span class="SCmp">#swagbuildnum</span>
<span class="SCmp">#swagos</span>
<span class="SCmp">#swagrevision</span>
<span class="SCmp">#swagversion</span>
<span class="SCmp">#up</span>

<span class="SCmp">#assert</span>
<span class="SCmp">#elif</span>
<span class="SCmp">#else</span>
<span class="SCmp">#error</span>
<span class="SCmp">#global</span>
<span class="SCmp">#if</span>
<span class="SCmp">#import</span>
<span class="SCmp">#load</span>
<span class="SCmp">#macro</span>
<span class="SCmp">#mixin</span>
<span class="SCmp">#placeholder</span>
<span class="SCmp">#print</span>
<span class="SCmp">#validifx</span>
<span class="SCmp">#validif</span>
<span class="SCmp">#warning</span>
<span class="SCmp">#scope</span>

<span class="STpe">#type</span>

<span class="SFct">#ast</span>
<span class="SFct">#drop</span>
<span class="SFct">#init</span>
<span class="SFct">#main</span>
<span class="SFct">#message</span>
<span class="SFct">#premain</span>
<span class="SFct">#run</span></span></div>
<h3 id="005_keywords_Misc_intrinsics">Misc intrinsics </h3>
<p>Intrisic keywords always start with <span class="code-inline">@</span>. As user identifiers cannot start the same way, intrinsics keywords will never collide with user identifiers. </p>
<div class="code-block"><span class="SCde"><span class="SItr">@index</span>
<span class="SItr">@err</span>
<span class="SItr">@alias0</span>
<span class="SItr">@alias1</span>
<span class="SItr">@alias2</span> <span class="SCmt">// and more generally @aliasN</span>
<span class="SItr">@alignof</span>
<span class="SItr">@args</span>
<span class="SItr">@assert</span>
<span class="SItr">@breakpoint</span>
<span class="SItr">@compiler</span>
<span class="SItr">@countof</span>
<span class="SItr">@dataof</span>
<span class="SItr">@dbgalloc</span>
<span class="SItr">@defined</span>
<span class="SItr">@include</span>
<span class="SItr">@drop</span>
<span class="SItr">@compilererror</span>
<span class="SItr">@compilerwarning</span>
<span class="SItr">@getcontext</span>
<span class="SItr">@getpinfos</span>
<span class="SItr">@gettag</span>
<span class="SItr">@hastag</span>
<span class="SItr">@init</span>
<span class="SItr">@isbytecode</span>
<span class="SItr">@isconstexpr</span>
<span class="SItr">@itftableof</span>
<span class="SItr">@kindof</span>
<span class="SItr">@location</span>
<span class="SItr">@mixin0</span>
<span class="SItr">@mixin1</span>
<span class="SItr">@mixin2</span> <span class="SCmt">// and more generally @mixinN</span>
<span class="SItr">@mkany</span>
<span class="SItr">@mkcallback</span>
<span class="SItr">@mkinterface</span>
<span class="SItr">@mkslice</span>
<span class="SItr">@mkstring</span>
<span class="SItr">@decltype</span>
<span class="SItr">@modules</span>
<span class="SItr">@nameof</span>
<span class="SItr">@offsetof</span>
<span class="SItr">@panic</span>
<span class="SItr">@postcopy</span>
<span class="SItr">@postmove</span>
<span class="SItr">@print</span>
<span class="SItr">@rtflags</span>
<span class="SItr">@safety</span>
<span class="SItr">@setcontext</span>
<span class="SItr">@sizeof</span>
<span class="SItr">@spread</span>
<span class="SItr">@stringcmp</span>
<span class="SItr">@stringof</span>
<span class="SItr">@sysalloc</span>
<span class="SItr">@typecmp</span>
<span class="SItr">@typeof</span></span></div>
<h3 id="005_keywords_Intrinsics_libc">Intrinsics libc </h3>
<div class="code-block"><span class="SCde"><span class="SItr">@abs</span>
<span class="SItr">@acos</span>
<span class="SItr">@alloc</span>
<span class="SItr">@asin</span>
<span class="SItr">@atan</span>
<span class="SItr">@atomadd</span>
<span class="SItr">@atomand</span>
<span class="SItr">@atomcmpxchg</span>
<span class="SItr">@atomor</span>
<span class="SItr">@atomxchg</span>
<span class="SItr">@atomxor</span>
<span class="SItr">@bitcountlz</span>
<span class="SItr">@bitcountnz</span>
<span class="SItr">@bitcounttz</span>
<span class="SItr">@byteswap</span>
<span class="SItr">@ceil</span>
<span class="SItr">@cos</span>
<span class="SItr">@cosh</span>
<span class="SItr">@cvaarg</span>
<span class="SItr">@cvaend</span>
<span class="SItr">@cvastart</span>
<span class="SItr">@exp</span>
<span class="SItr">@exp2</span>
<span class="SItr">@floor</span>
<span class="SItr">@free</span>
<span class="SItr">@log</span>
<span class="SItr">@log10</span>
<span class="SItr">@log2</span>
<span class="SItr">@max</span>
<span class="SItr">@memcmp</span>
<span class="SItr">@memcpy</span>
<span class="SItr">@memmove</span>
<span class="SItr">@memset</span>
<span class="SItr">@muladd</span>
<span class="SItr">@min</span>
<span class="SItr">@pow</span>
<span class="SItr">@realloc</span>
<span class="SItr">@round</span>
<span class="SItr">@sin</span>
<span class="SItr">@sinh</span>
<span class="SItr">@sqrt</span>
<span class="SItr">@strcmp</span>
<span class="SItr">@strlen</span>
<span class="SItr">@tan</span>
<span class="SItr">@tanh</span>
<span class="SItr">@trunc</span></span></div>
<h3 id="005_keywords_Modifiers">Modifiers </h3>
<p>Modifiers can be applied to some specific keywords or operators to change their behaviours. </p>
<div class="code-block"><span class="SCde"><span class="SItr">,up</span>
<span class="SItr">,over</span>
<span class="SItr">,nodrop</span>
<span class="SItr">,move</span>
<span class="SItr">,moveraw</span>
<span class="SItr">,bit</span>
<span class="SItr">,unconst</span>
<span class="SItr">,back</span></span></div>

<h2 id="006_semicolon">Semicolon</h2><p>In Swag, there's no need to end a statement with <span class="code-inline">;</span> like in C/C++. Most of the time a <span class="code-inline">end of line</span> is enough. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Declare two variables x and y of type s32 (signed 32 bits), and initialize them to 1.</span>
    <span class="SKwd">var</span> x, y: <span class="STpe">s32</span> = <span class="SNum">1</span>

    <span class="SCmt">// Increment x and y by 1.</span>
    x += <span class="SNum">1</span>
    y += <span class="SNum">1</span>

    <span class="SCmt">// When running the tests, the '@assert' intrinsic will verify that those values are correct.</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">2</span>)     <span class="SCmt">// Verify that x is equal to 2, and raise an error if not.</span>
    <span class="SItr">@assert</span>(y == x)     <span class="SCmt">// Verify that y is equal to x.</span>
}</span></div>
<p>The semicolons are not mandatory, but it's possible to use them if you want. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// You can notice that the type of x and y is not specified here.</span>
    <span class="SCmt">// This is due to type inference (we will see that later).</span>
    <span class="SKwd">var</span> x, y = <span class="SNum">0</span>;

    <span class="SCmt">// You can also notice the short syntax to do the same operation on multiple variables at once.</span>
    x, y += <span class="SNum">1</span>;
}</span></div>
<p>Semicolons can be usefull if you want to do multiple things on the same line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Two instructions on the same line separated with ';'</span>
    <span class="SKwd">var</span> x = <span class="SNum">0</span>; <span class="SKwd">var</span> y = <span class="SNum">0</span>

    <span class="SCmt">// Two instructions on the same line separated with ';'</span>
    x += <span class="SNum">1</span>; y += <span class="SNum">1</span>

    <span class="SCmt">// Two instructions on the same line separated with ';'</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>); <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)
}</span></div>

<h2 id="007_global_declaration_order">Global declaration order</h2><p>The order of all <b>top level</b> declarations does not matter. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Here we declare a constant 'A' and initialize it with 'B', which is not</span>
<span class="SCmt">// yet known (neither its value or its type).</span>
<span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SCst">B</span>

<span class="SCmt">// Declare a constant 'B' equals to 'C', still unknown at this point.</span>
<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCst">C</span>

<span class="SCmt">// Declare a constant C of type 'u64' (unsigned 64 bits integer) and assigned it to 1.</span>
<span class="SCmt">// At this point A and B are then also defined.</span>
<span class="SKwd">const</span> <span class="SCst">C</span>: <span class="STpe">u64</span> = <span class="SNum">1</span></span></div>
<p>In this test, we call the function <span class="code-inline">functionDeclaredLater</span> before it is known. This is fine. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
{
    <span class="SCmt">// First, call a unknown function named 'functionDeclaredLater'</span>
    <span class="SFct">functionDeclaredLater</span>()
}

<span class="SCmt">// Then declare it after</span>
<span class="SKwd">func</span> <span class="SFct">functionDeclaredLater</span>()
{
}</span></div>
<p>Note that the order is not relevant in the same file, but it is also irrelevant across multiple files. You can for example call a function in one file and declare it in another one. Global ordrer does not matter ! </p>

<h2 id="010_basic_types">Basic types</h2><p>These are all signed integers types <span class="code-inline">s8</span>, <span class="code-inline">s16</span>, <span class="code-inline">s32</span> and <span class="code-inline">s64</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">s8</span>  = -<span class="SNum">1</span>     <span class="SCmt">// 8 bits signed integer</span>
    <span class="SKwd">let</span> b: <span class="STpe">s16</span> = -<span class="SNum">2</span>     <span class="SCmt">// 16 bits signed integer</span>
    <span class="SKwd">let</span> c: <span class="STpe">s32</span> = -<span class="SNum">3</span>     <span class="SCmt">// 32 bits signed integer</span>
    <span class="SKwd">let</span> d: <span class="STpe">s64</span> = -<span class="SNum">4</span>     <span class="SCmt">// 64 bits signed integer</span>

    <span class="SCmt">// Remember that the instrinsic '@assert' will raise an error at runtime if</span>
    <span class="SCmt">// the enclosed expression is false.</span>
    <span class="SItr">@assert</span>(a == -<span class="SNum">1</span>)
    <span class="SItr">@assert</span>(b == -<span class="SNum">2</span>)
    <span class="SItr">@assert</span>(c == -<span class="SNum">3</span>)
    <span class="SItr">@assert</span>(d == -<span class="SNum">4</span>)

    <span class="SCmt">// The instrinsic '@sizeof' gives the size, in bytes, of a variable.</span>
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(a) == <span class="SNum">1</span>)    <span class="SCmt">// 'a' has type 's8', so this should be 1 byte.</span>
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(b) == <span class="SNum">2</span>)    <span class="SCmt">// 'b' has type 's16', so this should be 2 bytes.</span>
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(c) == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(d) == <span class="SNum">8</span>)
}</span></div>
<p>These are all unsigned integers types <span class="code-inline">u8</span>, <span class="code-inline">u16</span>, <span class="code-inline">u32</span> and <span class="code-inline">u64</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">u8</span>  = <span class="SNum">1</span>      <span class="SCmt">// 8 bits unsigned integer</span>
    <span class="SKwd">let</span> b: <span class="STpe">u16</span> = <span class="SNum">2</span>      <span class="SCmt">// 16 bits unsigned integer</span>
    <span class="SKwd">let</span> c: <span class="STpe">u32</span> = <span class="SNum">3</span>      <span class="SCmt">// 32 bits unsigned integer</span>
    <span class="SKwd">let</span> d: <span class="STpe">u64</span> = <span class="SNum">4</span>      <span class="SCmt">// 64 bits unsigned integer</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(c == <span class="SNum">3</span>)
    <span class="SItr">@assert</span>(d == <span class="SNum">4</span>)

    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(a) == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(b) == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(c) == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(d) == <span class="SNum">8</span>)
}</span></div>
<p>These are all floating point types <span class="code-inline">f32</span> and <span class="code-inline">f64</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">f32</span> = <span class="SNum">3.14</span>       <span class="SCmt">// 32 bits floating point value</span>
    <span class="SKwd">let</span> b: <span class="STpe">f64</span> = <span class="SNum">3.14159</span>    <span class="SCmt">// 64 bits floating point value</span>

    <span class="SItr">@assert</span>(a == <span class="SNum">3.14</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">3.14159</span>)

    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(a) == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(b) == <span class="SNum">8</span>)
}</span></div>
<p>The boolean type <span class="code-inline">bool</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">bool</span> = <span class="SKwd">true</span>      <span class="SCmt">// Stored in 1 byte</span>
    <span class="SKwd">let</span> b: <span class="STpe">bool</span> = <span class="SKwd">false</span>     <span class="SCmt">// Stored in 1 byte</span>

    <span class="SItr">@assert</span>(a == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(b == <span class="SKwd">false</span>)

    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(a) == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(b) == <span class="SNum">1</span>)
}</span></div>
<p>The <span class="code-inline">string</span> type. Strings are <b>UTF8</b>, and are stored as two 64 bits (the pointer to the value and the string length in bytes). Note that a string literal also ends with a null byte like in C. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">string</span> = <span class="SStr">"string 是"</span>
    <span class="SItr">@assert</span>(a == <span class="SStr">"string 是"</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(a) == <span class="SNum">2</span> * <span class="SItr">@sizeof</span>(*<span class="STpe">void</span>))
}</span></div>
<p>The <span class="code-inline">rune</span> type is a 32 bits unicode code point. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">rune</span> = <span class="SStr">`是`</span>
    <span class="SItr">@assert</span>(a == <span class="SStr">`是`</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@sizeof</span>(a) == <span class="SNum">4</span>)
}</span></div>
<h3 id="010_basic_types_Type_reflection">Type reflection </h3>
<p>Swag has <b>type reflection</b> at <b>compile time</b> and at <b>runtime</b>. We will see that later in more details. </p>
<p>You can use <span class="code-inline">@decltype</span> to create a type based on an expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">0</span>                   <span class="SCmt">// 'a' is inferred to have the 's32' type</span>
    <span class="SKwd">let</span> b: <span class="SItr">@decltype</span>(a) = <span class="SNum">1</span>     <span class="SCmt">// 'b' will have the same type as 'a'</span>

    <span class="SCmt">// We can verify with '@typeof' that 'a' and 'b' have the same type.</span>
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(a) == <span class="SItr">@typeof</span>(b))
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(a) == <span class="STpe">s32</span>)

    <span class="SCmt">// As the types of 'a' and 'b' are known by the compiler, we can use '#assert' instead of '@assert'.</span>
    <span class="SCmt">// The '#assert' will be done at compile time, and will not generate code (unlike '@assert').</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="SItr">@typeof</span>(b)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="STpe">s32</span>
}</span></div>
<p>Short notice that types are also values, at compile time and at runtime. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SItr">@typeof</span>(<span class="STpe">s32</span>)   <span class="SCmt">// 'x' is now a variable that contains a type</span>
    <span class="SItr">@assert</span>(x == <span class="STpe">s32</span>)   <span class="SCmt">// So it can be compared to a type</span>

    <span class="SCmt">// A type is a predefined struct, which contains some fields to inspect it.</span>
    <span class="SCmt">// You can for example get the name.</span>
    <span class="SItr">@assert</span>(x.name == <span class="SStr">"s32"</span>)

    <span class="SCmt">// @typeof is not really necessary when there's no ambiguity about the expression.</span>
    <span class="SKwd">let</span> y = <span class="STpe">bool</span>
    <span class="SItr">@assert</span>(y == <span class="STpe">bool</span>)
}</span></div>

<h2 id="011_number_literals">Number literals</h2><p>Integers in <i>decimal</i>, <i>hexadecimal</i> or <i>binary</i> forms. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">u32</span> = <span class="SNum">123456</span>           <span class="SCmt">// Decimal</span>
    <span class="SKwd">const</span> b: <span class="STpe">u32</span> = <span class="SNum">0xFFFF</span>           <span class="SCmt">// Hexadecimal, with '0x'</span>
    <span class="SKwd">const</span> c: <span class="STpe">u32</span> = <span class="SNum">0b00001111</span>       <span class="SCmt">// Binary, with '0b'</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">123456</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">65535</span>)
    <span class="SItr">@assert</span>(c == <span class="SNum">15</span>)
}</span></div>
<p>You can separate the digits with the <span class="code-inline">_</span> character. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">u32</span> = <span class="SNum">123_456</span>
    <span class="SKwd">const</span> b: <span class="STpe">u32</span> = <span class="SNum">0xF_F_F_F</span>
    <span class="SKwd">const</span> c: <span class="STpe">u32</span> = <span class="SNum">0b0000_1111</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">123456</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">65_535</span>)
    <span class="SItr">@assert</span>(c == <span class="SNum">15</span>)
}</span></div>
<p>The default type of an hexadecimal number or a binary number is <span class="code-inline">u32</span> or <span class="code-inline">u64</span> depending on its value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// The compiler will deduce that the type of 'a' is 'u32'.</span>
    <span class="SKwd">const</span> a = <span class="SNum">0xFF</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="STpe">u32</span>

    <span class="SCmt">// The compiler will deduce that the type of 'b' is 'u64' because the constant</span>
    <span class="SCmt">// is too big for 32 bits.</span>
    <span class="SKwd">const</span> b = <span class="SNum">0xF_FFFFF_FFFFFF</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(b) == <span class="STpe">u64</span>

    <span class="SKwd">const</span> c = <span class="SNum">0b00000001</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(c) == <span class="STpe">u32</span>
    <span class="SKwd">const</span> d = <span class="SNum">0b00000001_00000001_00000001_00000001_00000001</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(d) == <span class="STpe">u64</span>
}</span></div>
<p>A boolean is <span class="code-inline">true</span> or <span class="code-inline">false</span>. Note again that as constants are known at compile time, we can  use <span class="code-inline">#assert</span> to check the values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SKwd">true</span>
    <span class="SCmp">#assert</span> a == <span class="SKwd">true</span>

    <span class="SKwd">const</span> b, c = <span class="SKwd">false</span>
    <span class="SCmp">#assert</span> b == <span class="SKwd">false</span>
    <span class="SCmp">#assert</span> c == <span class="SKwd">false</span>
}</span></div>
<p>A floating point value has the usual C/C++ form. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="STpe">f32</span>

    <span class="SKwd">let</span> b = <span class="SNum">0.11</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">0.11</span>)

    <span class="SKwd">let</span> c = <span class="SNum">15e2</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">15e2</span>)

    <span class="SKwd">let</span> d = <span class="SNum">15e+2</span>
    <span class="SItr">@assert</span>(d == <span class="SNum">15e2</span>)

    <span class="SKwd">let</span> e = -<span class="SNum">1E-1</span>
    <span class="SItr">@assert</span>(e == -<span class="SNum">0.1</span>)
}</span></div>
<p>By default, a floating point value is <span class="code-inline">f32</span>, not <span class="code-inline">f64</span> (aka <span class="code-inline">double</span>) like in C/C++. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="STpe">f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) != <span class="STpe">f64</span>
}</span></div>
<h3 id="011_number_literals_Suffix">Suffix </h3>
<p>You can also force the type by adding a <b>suffix</b> to a literal number. We will see later that this syntax is also used for generic arguments. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Declare 'a' to be a 'f64' variable assigned to '1.5'</span>
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>'<span class="STpe">f64</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>'<span class="STpe">f64</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="STpe">f64</span>

    <span class="SCmt">// 'b' is a new variable of type 'u8' initialized with '10'.</span>
    <span class="SKwd">let</span> b = <span class="SNum">10</span>'<span class="STpe">u8</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">10</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(b) == <span class="STpe">u8</span>

    <span class="SKwd">let</span> c = <span class="SNum">1</span>'<span class="STpe">u32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(c) == <span class="STpe">u32</span>
}</span></div>

<h2 id="012_string">String</h2><p>In Swag, strings are encoded in UTF8. </p>
<p>They also can be compared. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is a chinese character: 是"</span>
    <span class="SCmp">#assert</span> a == <span class="SStr">"this is a chinese character: 是"</span>

    <span class="SKwd">const</span> b = <span class="SStr">"these are some cyrillic characters: ӜИ"</span>
    <span class="SCmp">#assert</span> b == <span class="SStr">"these are some cyrillic characters: ӜИ"</span>
}</span></div>
<p>A rune is an unicode codepoint, and is 32 bits. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: <span class="STpe">rune</span> = <span class="SStr">`是`</span>
    <span class="SCmp">#assert</span> a == <span class="SStr">`是`</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(a) == <span class="SItr">@sizeof</span>(<span class="STpe">u32</span>)
}</span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> You cannot index a string to get a rune, except in ascii strings. This is because we didn't want the runtime to come with the cost of UTF8 encoding/decoding. But note that the <span class="code-inline">Std.Core</span> module will have all you need to manipulate UTF8 strings. </p>
</div>
<p>So in that case you will retrieve a byte. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is a chinese character: 是"</span>

    <span class="SCmt">// Get the first byte of the string</span>
    <span class="SKwd">const</span> b = a[<span class="SNum">0</span>]
    <span class="SCmp">#assert</span> b == <span class="SStr">`t`</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(b) == <span class="SItr">@typeof</span>(<span class="STpe">u8</span>)

    <span class="SCmt">// Here, the 'X' character in the middle does not have the index '1', because the</span>
    <span class="SCmt">// chinese character before is encoded in UTF8 with more than 1 byte.</span>
    <span class="SKwd">const</span> c = <span class="SStr">"是X是"</span>
    <span class="SCmp">#assert</span> c[<span class="SNum">1</span>] != <span class="SStr">`X`</span> <span class="SCmt">// False because the byte number 1 is not the character 'X'</span>
}</span></div>
<p>You can concatenate some values if the values are known at compile time. Use the <span class="code-inline">++</span> operator for that. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"the devil number is "</span> ++ <span class="SNum">666</span>
    <span class="SCmp">#assert</span> a == <span class="SStr">"the devil number is 666"</span>

    <span class="SKwd">const</span> b = <span class="SNum">666</span>
    <span class="SKwd">let</span> c = <span class="SStr">"the devil number is not "</span> ++ (b + <span class="SNum">1</span>) ++ <span class="SStr">"!"</span>
    <span class="SItr">@assert</span>(c == <span class="SStr">"the devil number is not 667!"</span>)

    <span class="SKwd">let</span> d = <span class="SStr">"they are "</span> ++ <span class="SNum">4</span> ++ <span class="SStr">" apples in "</span> ++ (<span class="SNum">2</span>*<span class="SNum">2</span>) ++ <span class="SStr">" baskets"</span>
    <span class="SItr">@assert</span>(d == <span class="SStr">"they are 4 apples in 4 baskets"</span>)
}</span></div>
<p>A string can be <span class="code-inline">null</span> if not defined. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">string</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">null</span>)
    a = <span class="SStr">"null"</span>
    <span class="SItr">@assert</span>(a != <span class="SKwd">null</span>)
    a = <span class="SKwd">null</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">null</span>)
}</span></div>
<h3 id="012_string_Character_literals">Character literals </h3>
<p>A <i>character</i> is enclosed with <b>backticks</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> char0 = <span class="SStr">`a`</span>
    <span class="SKwd">let</span> char1 = <span class="SStr">`我`</span>
}</span></div>
<p>By default, it's a lazy 32 bits integer that can be assigned to all integers (as long as it fits) and to the type <span class="code-inline">rune</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> a: <span class="STpe">u8</span>   = <span class="SStr">`a`</span>
        <span class="SKwd">let</span> b: <span class="STpe">u16</span>  = <span class="SStr">`a`</span>
        <span class="SKwd">let</span> c: <span class="STpe">u32</span>  = <span class="SStr">`我`</span>
        <span class="SKwd">let</span> d: <span class="STpe">u64</span>  = <span class="SStr">`我`</span>
        <span class="SKwd">let</span> e: <span class="STpe">rune</span> = <span class="SStr">`我`</span>
    }

    {
        <span class="SKwd">let</span> a: <span class="STpe">s8</span>   = <span class="SStr">`a`</span>
        <span class="SKwd">let</span> b: <span class="STpe">s16</span>  = <span class="SStr">`a`</span>
        <span class="SKwd">let</span> c: <span class="STpe">s32</span>  = <span class="SStr">`我`</span>
        <span class="SKwd">let</span> d: <span class="STpe">s64</span>  = <span class="SStr">`我`</span>
    }
}</span></div>
<p>But the underlying type of a character can be forced with the use of a type postfix. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SStr">`0`</span>'<span class="STpe">u8</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">48</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(a) == <span class="STpe">u8</span>)

    <span class="SKwd">let</span> b = <span class="SStr">`1`</span>'<span class="STpe">u16</span>
    <span class="SItr">@assert</span>(b == <span class="SNum">49</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(b) == <span class="STpe">u16</span>)

    <span class="SKwd">let</span> c = <span class="SStr">`2`</span>'<span class="STpe">u32</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">50</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(c) == <span class="STpe">u32</span>)

    <span class="SKwd">let</span> d = <span class="SStr">`3`</span>'<span class="STpe">u64</span>
    <span class="SItr">@assert</span>(d == <span class="SNum">51</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(d) == <span class="STpe">u64</span>)

    <span class="SKwd">let</span> e = <span class="SStr">`4`</span>'<span class="STpe">rune</span>
    <span class="SItr">@assert</span>(e == <span class="SNum">52</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(e) == <span class="STpe">rune</span>)
}</span></div>
<h3 id="012_string_Escape_sequences">Escape sequences </h3>
<p>A string and a character can contain some <i>escape sequences</i> to specify special characters. </p>
<p>An escape sequence starts with a backslash <span class="code-inline">\</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"this is code ascii 0x00:   \0"</span>   <span class="SCmt">// null</span>
    <span class="SKwd">const</span> b = <span class="SStr">"this is code ascii 0x07:   \a"</span>   <span class="SCmt">// bell</span>
    <span class="SKwd">const</span> c = <span class="SStr">"this is code ascii 0x08:   \b"</span>   <span class="SCmt">// backspace</span>
    <span class="SKwd">const</span> d = <span class="SStr">"this is code ascii 0x09:   \t"</span>   <span class="SCmt">// horizontal tab</span>
    <span class="SKwd">const</span> e = <span class="SStr">"this is code ascii 0x0A:   \n"</span>   <span class="SCmt">// line feed</span>
    <span class="SKwd">const</span> f = <span class="SStr">"this is code ascii 0x0B:   \v"</span>   <span class="SCmt">// vertical tab</span>
    <span class="SKwd">const</span> g = <span class="SStr">"this is code ascii 0x0C:   \f"</span>   <span class="SCmt">// form feed</span>
    <span class="SKwd">const</span> h = <span class="SStr">"this is code ascii 0x0D:   \r"</span>   <span class="SCmt">// carriage return</span>
    <span class="SKwd">const</span> i = <span class="SStr">"this is code ascii 0x22:   \""</span>   <span class="SCmt">// double quote</span>
    <span class="SKwd">const</span> j = <span class="SStr">"this is code ascii 0x27:   \'"</span>   <span class="SCmt">// single quote</span>
    <span class="SKwd">const</span> k = <span class="SStr">"this is code ascii 0x60:   \`"</span>   <span class="SCmt">// backtick</span>
    <span class="SKwd">const</span> l = <span class="SStr">"this is code ascii 0x5C:   \\"</span>   <span class="SCmt">// backslash</span>
}</span></div>
<p>An escape sequence can also be used to specify an ascii or a unicode value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">const</span> a = <span class="SStr">"\x26"</span>        <span class="SCmt">// 1 byte, hexadecimal, extended ascii</span>
        <span class="SKwd">const</span> b = <span class="SStr">"\u2626"</span>      <span class="SCmt">// 2 bytes, hexadecimal, unicode 16 bits</span>
        <span class="SKwd">const</span> c = <span class="SStr">"\U00101234"</span>  <span class="SCmt">// 4 bytes, hexadecimal, unicode 32 bits</span>
    }

    {
        <span class="SKwd">const</span> d = <span class="SStr">"\u2F46\u2F46"</span>
        <span class="SCmp">#assert</span> d == <span class="SStr">"⽆⽆"</span>

        <span class="SKwd">const</span> e = <span class="SStr">`\u2F46`</span>
        <span class="SCmp">#assert</span> e == <span class="SStr">`⽆`</span>
    }
}</span></div>
<h3 id="012_string_Raw_string">Raw string </h3>
<p>A <i>raw string</i> does not transform the escape sequences inside it. </p>
<p>A raw string starts and ends with the character <span class="code-inline">$</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">$"\u2F46"$</span>
    <span class="SCmp">#assert</span> a != <span class="SStr">"⽆"</span>
    <span class="SCmp">#assert</span> a == <span class="SStr">$"\u2F46"$</span>
}</span></div>
<p>This are equivalent: </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">"\\hello \\world"</span>     <span class="SCmt">// By using an escape character</span>
    <span class="SKwd">const</span> b = <span class="SStr">$"\hello \world"$</span>     <span class="SCmt">// Without, because they are not transformed</span>
    <span class="SCmp">#assert</span> a == b
}</span></div>
<p>A raw string can spawn on multiple lines because the line feed is now part of the string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">$"this is
                a
                string
                "$</span>
}</span></div>
<p>Every blanks <b>before</b> the ending mark <span class="code-inline">"@</span> will be removed from every other lines, so the string before is equivalent to : </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// this is</span>
    <span class="SCmt">// a</span>
    <span class="SCmt">// string</span>
}</span></div>
<h3 id="012_string_Multiline_string">Multiline string </h3>
<p>A multiline string starts and ends with <span class="code-inline">"""</span>. Unlike raw strings, they still evaluate escape sequences. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">""</span><span class="SStr">"this is
                 a
                 string
                 "</span><span class="SStr">""</span>

    <span class="SCmt">// Equivalent to :</span>

    <span class="SCmt">// this is</span>
    <span class="SCmt">// a</span>
    <span class="SCmt">// string</span>
}</span></div>
<p>In a multiline or a raw string, if you end a line with <span class="code-inline">\</span>, the following <span class="code-inline">eol</span> will <b>not</b> be part of the string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a = <span class="SStr">""</span><span class="SStr">"\
              this is
              a
              string
              "</span><span class="SStr">""</span>
    <span class="SCmt">// Is equivalent to :</span>
    <span class="SCmt">// this is</span>
    <span class="SCmt">// a</span>
    <span class="SCmt">// string</span>
}</span></div>
<h3 id="012_string_@stringof_and_@nameof">@stringof and @nameof </h3>
<p>You can use the instrinsic <span class="code-inline">@stringof</span> to return at compile time the result of a constant expression as a string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">X</span> = <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">@stringof</span>(<span class="SCst">X</span>) == <span class="SStr">"1"</span>
    <span class="SCmp">#assert</span> <span class="SItr">@stringof</span>(<span class="SCst">X</span> + <span class="SNum">10</span>) == <span class="SStr">"11"</span>
}</span></div>
<p>You can also use <span class="code-inline">@nameof</span> to return the name of a variable, function etc. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">X</span> = <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">@nameof</span>(<span class="SCst">X</span>) == <span class="SStr">"X"</span>
}</span></div>

<h2 id="013_variables">Variables</h2><p>To declare a variable, use the <span class="code-inline">let</span> or <span class="code-inline">var</span> keyword, followed by <span class="code-inline">:</span> and then the type. </p>
<p><span class="code-inline">let</span> is used for a variable that cannot be changed after the initial affectation. </p>
<p><span class="code-inline">var</span> is used for a variable that can be changed again after the initial affectation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Variable 'a' is of type 'u32' and its value is '1'. It cannot be changed.</span>
    <span class="SKwd">let</span> a: <span class="STpe">u32</span> = <span class="SNum">1</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)

    <span class="SKwd">let</span> b: <span class="STpe">string</span> = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(b == <span class="SStr">"string"</span>)

    <span class="SCmt">// Variable 'c' is declared with 'var', so it can be changed.</span>
    <span class="SKwd">var</span> c: <span class="STpe">s32</span> = <span class="SNum">42</span>
    c += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">43</span>)
}</span></div>
<p>We have already seen that we can declare multiple variables on the same line. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a, b: <span class="STpe">u32</span> = <span class="SNum">123</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">123</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">123</span>)
}</span></div>
<p>Or </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">u32</span> = <span class="SNum">12</span>, b: <span class="STpe">f32</span> = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">12</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">1.5</span>)
}</span></div>
<p>If you don't assign a value, then the variable will be initialized with its default value (0). So a variable is <b>always</b> initialized. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">bool</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">false</span>)

    <span class="SKwd">var</span> b: <span class="STpe">string</span>
    <span class="SItr">@assert</span>(b == <span class="SKwd">null</span>)

    <span class="SKwd">var</span> c: <span class="STpe">f64</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">0</span>)
}</span></div>
<p>But if you really do not want the variable to be initialized, you can assign it with <span class="code-inline">undefined</span>. To use with care, of course, but this is sometimes necessary to avoid the initialization cost. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">bool</span> = <span class="SKwd">undefined</span>
    <span class="SKwd">var</span> b: <span class="STpe">string</span> = <span class="SKwd">undefined</span>
}</span></div>
<p>We have seen that the type is optional in the declaration if it can be deduced from the assignment. </p>
<p>These are a bunch of <b>type inferences</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">1.5</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="STpe">f32</span>

    <span class="SKwd">let</span> b = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(b == <span class="SStr">"string"</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(b) == <span class="STpe">string</span>

    <span class="SKwd">let</span> c = <span class="SNum">1.5</span>'<span class="STpe">f64</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">1.5</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(c) == <span class="STpe">f64</span>
}</span></div>
<p>The same goes for multiple variables. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a, b = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(a == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(b == <span class="SKwd">true</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="SItr">@typeof</span>(<span class="SKwd">true</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(b) == <span class="SItr">@typeof</span>(a)

    <span class="SKwd">let</span> c = <span class="SNum">1.5</span>, d = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(c == <span class="SNum">1.5</span>)
    <span class="SItr">@assert</span>(d == <span class="SStr">"string"</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(c) == <span class="STpe">f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(d) == <span class="STpe">string</span>
}</span></div>
<h3 id="013_variables_Special_variables">Special variables </h3>
<p>A global variable can be tagged with <span class="code-inline">#[Swag.Tls]</span> to store it in the thread local storage (one copy per thread). </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Tls]</span>
<span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span></span></div>
<p>A local variable can be tagged with <span class="code-inline">#[Swag.Global]</span> to make it global (aka <span class="code-inline">static</span> in C/C++). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>()-&gt;<span class="STpe">s32</span>
    {
        <span class="SAtr">#[Swag.Global]</span>
        <span class="SKwd">var</span> <span class="SCst">G1</span> = <span class="SNum">0</span>

        <span class="SCst">G1</span> += <span class="SNum">1</span>
        <span class="SLgc">return</span> <span class="SCst">G1</span>
    }

    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">3</span>)
}</span></div>
<p>A global variable can also be marked as <span class="code-inline">#[Swag.Compiler]</span>. That kind of variable will not be exported to the runtime and can only be used in compile-time code. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Compiler]</span>
<span class="SKwd">var</span> <span class="SCst">G2</span> = <span class="SNum">0</span>

<span class="SFct">#run</span>
{
    <span class="SCst">G2</span> += <span class="SNum">5</span>
}</span></div>

<h2 id="014_const">Const</h2><p>If you use <span class="code-inline">const</span> instead of <span class="code-inline">var</span> or <span class="code-inline">let</span>, the value must be <b>known by the compiler</b>. There's no memory footprint if the type is a value or a string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// These are constants and not variables. So they cannot be changed after the declaration.</span>
    <span class="SKwd">const</span> a = <span class="SNum">666</span>
    <span class="SCmp">#assert</span> a == <span class="SNum">666</span>

    <span class="SKwd">const</span> b: <span class="STpe">string</span> = <span class="SStr">"string"</span>
    <span class="SCmp">#assert</span> b == <span class="SStr">"string"</span>
}</span></div>
<p>Constants can have more than just simple types. In that case, there's a memory footprint, because those constants are stored in the data segment. But that means also you could take the address of such constants at runtime. </p>
<p>This is our first static array. It contains <span class="code-inline">3</span> elements, and the type of the elements is <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> a: [<span class="SNum">3</span>] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]

    <span class="SKwd">let</span> ptr = &a[<span class="SNum">0</span>] <span class="SCmt">// Take the address of the first element</span>
    <span class="SItr">@assert</span>(ptr[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(ptr[<span class="SNum">2</span>] == <span class="SNum">2</span>)

    <span class="SCmt">// But as this is a constant, we can also test the values at compile time.</span>
    <span class="SCmp">#assert</span> a[<span class="SNum">0</span>] == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> a[<span class="SNum">1</span>] == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> a[<span class="SNum">2</span>] == <span class="SNum">2</span>
}</span></div>
<p>An example of a multidimensional array as a constant. We will detail arrays later. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">M4x4</span>: [<span class="SNum">4</span>, <span class="SNum">4</span>] <span class="STpe">f32</span> = [
        [<span class="SNum">1</span>, <span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">0</span>],
        [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">0</span>, <span class="SNum">0</span>],
        [<span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">0</span>],
        [<span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">0</span>, <span class="SNum">1</span>]
    ]
}</span></div>
<p>So the difference between <span class="code-inline">let</span> and <span class="code-inline">const</span> is that the value of a constant should be known at compile time, where the value of a <span class="code-inline">let</span> can be dynamic. Other than that, both must be assigned once and only once. </p>

<h2 id="015_operators">Operators</h2><p>These are all the Swag operators that can be used to manipulate variables and values. </p>
<h3 id="015_operators_Arithmetic_operators">Arithmetic operators </h3>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    <span class="SCmt">// Addition</span>
    x = x + <span class="SNum">1</span>

    <span class="SCmt">// Substraction</span>
    x = x - <span class="SNum">1</span>

    <span class="SCmt">// Multiplication</span>
    x = x * <span class="SNum">2</span>

    <span class="SCmt">// Division</span>
    x = x / <span class="SNum">2</span>

    <span class="SCmt">// Modulus</span>
    x = x % <span class="SNum">2</span>
}</span></div>
<h3 id="015_operators_Bitwise_operators">Bitwise operators </h3>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    <span class="SCmt">// Xor</span>
    x = x ^ <span class="SNum">2</span>

    <span class="SCmt">// Bitmask and</span>
    x = x & <span class="SNum">0b0000_0001</span>'<span class="STpe">s32</span>

    <span class="SCmt">// Bitmask or</span>
    x = x | <span class="SKwd">cast</span>(<span class="STpe">s32</span>) <span class="SNum">0b0000_0001</span>

    <span class="SCmt">// Shift bits left</span>
    x = x &lt;&lt; <span class="SNum">1</span>

    <span class="SCmt">// Shift bits right</span>
    x = x &gt;&gt; <span class="SNum">1</span>
}</span></div>
<h3 id="015_operators_Assignment_operators">Assignment operators </h3>
<p>All the arithmetic and bitwise operators have an <span class="code-inline">affect</span> version. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">s32</span> = <span class="SNum">10</span>

    x += <span class="SNum">1</span>
    x -= <span class="SNum">1</span>
    x *= <span class="SNum">2</span>
    x /= <span class="SNum">2</span>
    x %= <span class="SNum">2</span>
    x ^= <span class="SNum">2</span>
    x |= <span class="SNum">0b0000_0001</span>
    x &= <span class="SNum">0b0000_0001</span>
    x &lt;&lt;= <span class="SNum">1</span>
    x &gt;&gt;= <span class="SNum">1</span>
}</span></div>
<h3 id="015_operators_Unary_operators">Unary operators </h3>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SKwd">true</span>
    <span class="SKwd">var</span> y = <span class="SNum">0b0000_0001</span>'<span class="STpe">u8</span>
    <span class="SKwd">var</span> z = <span class="SNum">1</span>

    <span class="SCmt">// Invert boolean</span>
    x = !x

    <span class="SCmt">// Invert bits</span>
    y = ~y

    <span class="SCmt">// Negative</span>
    z = -z

    <span class="SItr">@assert</span>(z == -<span class="SNum">1</span>)
    <span class="SItr">@assert</span>(x == <span class="SKwd">false</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">0b1111_1110</span>)
}</span></div>
<h3 id="015_operators_Comparison_operators">Comparison operators </h3>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">var</span> a = <span class="SKwd">false</span>

        <span class="SCmt">// Equal</span>
        a = <span class="SNum">1</span> == <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>

        <span class="SCmt">// Not equal</span>
        a = <span class="SNum">1</span> != <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>

        <span class="SCmt">// Lower equal</span>
        a = <span class="SNum">1</span> &lt;= <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>

        <span class="SCmt">// Greater equal</span>
        a = <span class="SNum">1</span> &gt;= <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>

        <span class="SCmt">// Lower</span>
        a = <span class="SNum">1</span> &lt; <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>

        <span class="SCmt">// Greater</span>
        a = <span class="SNum">1</span> &gt; <span class="SNum">1</span> ? <span class="SKwd">true</span> : <span class="SKwd">false</span>
    }

    {
        <span class="SKwd">let</span> x = <span class="SNum">5</span>
        <span class="SKwd">let</span> y = <span class="SNum">10</span>
        <span class="SItr">@assert</span>(x == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x != <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(x &lt;= <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x &lt; <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(x &gt;= <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(x &gt; <span class="SNum">0</span>)
    }
}</span></div>
<h3 id="015_operators_Logical_operators">Logical operators </h3>
<p>This is <b>not</b> <span class="code-inline">&&</span> and <span class="code-inline">||</span> like in C/C++, but <span class="code-inline">and</span> and <span class="code-inline">or</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SKwd">false</span>
    a = (<span class="SNum">1</span> &gt; <span class="SNum">10</span>) <span class="SLgc">and</span> (<span class="SNum">10</span> &lt; <span class="SNum">1</span>)
    a = (<span class="SNum">1</span> &gt; <span class="SNum">10</span>) <span class="SLgc">or</span> (<span class="SNum">10</span> &lt; <span class="SNum">1</span>)
}</span></div>
<h3 id="015_operators_Ternary_operator">Ternary operator </h3>
<p>The ternary operator will test an expression, and will return a value depending on the result of the test. <span class="code-inline">A = Expression ? B : C</span> will return <span class="code-inline">B</span> if the expression is true, and will return <span class="code-inline">C</span> if the expression is false. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Returns 1 because the expression 'true' is... true.</span>
    <span class="SKwd">let</span> x = <span class="SKwd">true</span> ? <span class="SNum">1</span> : <span class="SNum">666</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>)

    <span class="SCmt">// Returns 666 because the expression 'x == 52' is false.</span>
    <span class="SKwd">let</span> y = (x == <span class="SNum">52</span>) ? <span class="SNum">1</span> : <span class="SNum">666</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">666</span>)
}</span></div>
<h3 id="015_operators_Spaceshift_operator">Spaceshift operator </h3>
<p>Operator <span class="code-inline">&lt;=&gt;</span> will return -1, 0 or 1 if the expression on the left is <b>lower</b>, <b>equal</b> or <b>greater</b> than the expression on the right. The returned type is <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> == -<span class="SNum">1</span> <span class="SLgc">if</span> <span class="SCst">A</span> &lt; <span class="SCst">B</span>
<span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> == <span class="SNum">0</span>  <span class="SLgc">if</span> <span class="SCst">A</span> == <span class="SCst">B</span>
<span class="SCst">A</span> &lt;=&gt; <span class="SCst">B</span> == <span class="SNum">1</span>  <span class="SLgc">if</span> <span class="SCst">A</span> &gt; <span class="SCst">B</span></span></div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> a = -<span class="SNum">1.5</span> &lt;=&gt; <span class="SNum">2.31</span>
        <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="STpe">s32</span>
        <span class="SItr">@assert</span>(a == -<span class="SNum">1</span>)

        <span class="SItr">@assert</span>(-<span class="SNum">10</span> &lt;=&gt;  <span class="SNum">10</span> == -<span class="SNum">1</span>)
        <span class="SItr">@assert</span>( <span class="SNum">10</span> &lt;=&gt; -<span class="SNum">10</span> == <span class="SNum">1</span>)
        <span class="SItr">@assert</span>( <span class="SNum">10</span> &lt;=&gt;  <span class="SNum">10</span> == <span class="SNum">0</span>)
    }

    {
        <span class="SKwd">let</span> x1 = <span class="SNum">10</span> &lt;=&gt; <span class="SNum">20</span>
        <span class="SItr">@assert</span>(x1 == -<span class="SNum">1</span>)
        <span class="SKwd">let</span> x2 = <span class="SNum">20</span> &lt;=&gt; <span class="SNum">10</span>
        <span class="SItr">@assert</span>(x2 == <span class="SNum">1</span>)
        <span class="SKwd">let</span> x3 = <span class="SNum">20</span> &lt;=&gt; <span class="SNum">20</span>
        <span class="SItr">@assert</span>(x3 == <span class="SNum">0</span>)
    }
}</span></div>
<h3 id="015_operators_Null-coalescing_operator">Null-coalescing operator </h3>
<p>The operator <span class="code-inline">orelse</span> will return the left expression if it is not zero, otherwise it will return the right expression. </p>
<p>Works with strings, pointers and structures with the <span class="code-inline">opData</span> special function (we'll see that later). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SStr">"string1"</span>
    <span class="SKwd">let</span> b = <span class="SStr">"string2"</span>

    <span class="SCmt">// c = a if a is not null, else c = b.</span>
    <span class="SKwd">var</span> c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == <span class="SStr">"string1"</span>)

    a = <span class="SKwd">null</span>
    c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == <span class="SStr">"string2"</span>)
}</span></div>
<p>Works also for basic types like integers. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">0</span>
    <span class="SKwd">let</span> b = <span class="SNum">1</span>
    <span class="SKwd">let</span> c = a <span class="SLgc">orelse</span> b
    <span class="SItr">@assert</span>(c == b)
}</span></div>
<h3 id="015_operators_Type_promotion">Type promotion </h3>
<p>Unlike C, types are not promoted to 32 bits when dealing with 8 or 16 bits types. But types will be promoted if the two sides of an operation do not have the same type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u8</span>)  == <span class="STpe">u8</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u16</span>) == <span class="STpe">u16</span>    <span class="SCmt">// Priority to bigger type</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u32</span>) == <span class="STpe">u32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">u64</span>) == <span class="STpe">u64</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s8</span>)  == <span class="STpe">s8</span>     <span class="SCmt">// Priority to signed type</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s16</span>) == <span class="STpe">s16</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s32</span>) == <span class="STpe">s32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">s64</span>) == <span class="STpe">s64</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">f32</span>) == <span class="STpe">f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">u8</span> + <span class="SNum">1</span>'<span class="STpe">f64</span>) == <span class="STpe">f64</span>

    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">0</span>'<span class="STpe">s8</span> + <span class="SNum">1</span>'<span class="STpe">u16</span>) == <span class="STpe">u16</span>   <span class="SCmt">// Priority to bigger type also</span>
}</span></div>
<p>This means that a 8/16 bits operation (like an addition) can more easily <b>overflow</b> if you do not take care. In that case, you can use the <span class="code-inline">,up</span> <b>modifier</b> on the operation, which will promote the type to at least 32 bits. The operation will be done accordingly. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SNum">255</span>'<span class="STpe">u8</span> +<span class="SItr">,up</span> <span class="SNum">1</span>'<span class="STpe">u8</span>) == <span class="STpe">u32</span>
    <span class="SCmp">#assert</span> <span class="SNum">255</span>'<span class="STpe">u8</span> +<span class="SItr">,up</span> <span class="SNum">1</span>'<span class="STpe">u8</span> == <span class="SNum">256</span> <span class="SCmt">// No overflow, because the operation is done in 32 bits.</span>
}</span></div>
<p>We'll see later how Swag deals with that kind of overflow, and more generally, with <b>safety</b>. </p>
<h3 id="015_operators_Operator_precedence">Operator precedence </h3>
<div class="code-block"><span class="SCde">~
* / %
+ -
&gt;&gt; &lt;&lt;
&
|
^
&lt;=&gt;
== !=
&lt; &lt;= &gt; &gt;=
<span class="SLgc">and</span>
<span class="SLgc">or</span></span></div>
<p>If two operators have the same precedence, the expression is evaluated from left to right. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Multiplication before addition</span>
    <span class="SItr">@assert</span>(<span class="SNum">10</span> + <span class="SNum">2</span> * <span class="SNum">3</span> == <span class="SNum">16</span>)
    <span class="SCmt">// Parentheses change precedence</span>
    <span class="SItr">@assert</span>((<span class="SNum">10</span> + <span class="SNum">2</span>) * <span class="SNum">3</span> == <span class="SNum">36</span>)
    <span class="SCmt">// Addition and subtraction before comparison</span>
    <span class="SItr">@assert</span>((<span class="SNum">5</span> + <span class="SNum">3</span> &lt; <span class="SNum">10</span> - <span class="SNum">2</span>) == <span class="SKwd">false</span>)
    <span class="SCmt">// 'and' before 'or'</span>
    <span class="SItr">@assert</span>((<span class="SKwd">false</span> <span class="SLgc">and</span> <span class="SKwd">false</span> <span class="SLgc">or</span> <span class="SKwd">true</span>) == <span class="SKwd">true</span>)
    <span class="SCmt">// '&lt;&lt;' before '&'</span>
    <span class="SItr">@assert</span>((<span class="SNum">10</span> & <span class="SNum">2</span> &lt;&lt; <span class="SNum">1</span>) == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(((<span class="SNum">10</span> & <span class="SNum">2</span>) &lt;&lt; <span class="SNum">1</span>) == <span class="SNum">4</span>)
}</span></div>

<h2 id="016_cast">Cast</h2><h3 id="016_cast_Explicit_cast">Explicit cast </h3>
<p>Sometimes it can be necessary to change the type of a value. Use <span class="code-inline">cast(type)</span> to cast from one type to another. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// 'x' is a float</span>
    <span class="SKwd">let</span> x = <span class="SNum">1.0</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(x) == <span class="STpe">f32</span>

    <span class="SCmt">// 'y' is a 32 bits integer</span>
    <span class="SKwd">let</span> y = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) x
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(y) == <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)
}</span></div>
<h3 id="016_cast_acast">acast </h3>
<p><span class="code-inline">acast</span> stands for <span class="code-inline">automatic</span> cast. Use it to let the compiler automatically cast to the expression on the left. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">f32</span> = <span class="SNum">1.0</span>
    <span class="SKwd">let</span> y: <span class="STpe">s32</span> = <span class="SKwd">acast</span> x    <span class="SCmt">// cast 'x' to 's32'</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(y) == <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(y == <span class="SNum">1</span>)
}</span></div>
<h3 id="016_cast_bitcast">bitcast </h3>
<p>Use the <span class="code-inline">bit</span> modifier to convert a native type to another without converting the value. Works only if the two types are of the same size. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">f32</span> = <span class="SNum">1.0</span>
    <span class="SKwd">let</span> y: <span class="STpe">u32</span> = <span class="SKwd">cast</span><span class="SItr">,bit</span>(<span class="STpe">u32</span>) x
    <span class="SItr">@assert</span>(y == <span class="SNum">0x3f800000</span>)
    <span class="SCmp">#assert</span> <span class="SKwd">cast</span><span class="SItr">,bit</span>(<span class="STpe">u32</span>) <span class="SNum">1.0</span> == <span class="SNum">0x3f800000</span>
    <span class="SCmp">#assert</span> <span class="SKwd">cast</span><span class="SItr">,bit</span>(<span class="STpe">f32</span>) <span class="SNum">0x3f800000</span> == <span class="SNum">1.0</span>
}</span></div>
<h3 id="016_cast_Implicit_casts">Implicit casts </h3>
<p>Swag can sometimes cast from one type to another for you. This is an <i>implicit</i> cast. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// An implicit cast is done if there's no loss of precision.</span>
    <span class="SCmt">// In that case, you can affect different types.</span>

    <span class="SKwd">let</span> x: <span class="STpe">s16</span> = <span class="SNum">1</span>'<span class="STpe">s8</span>   <span class="SCmt">// 8 bits to 16 bits, fine</span>
    <span class="SKwd">let</span> y: <span class="STpe">s32</span> = <span class="SNum">1</span>'<span class="STpe">s16</span>  <span class="SCmt">// 16 bits to 32 bits, fine</span>

    <span class="SCmt">// But the following would generate an error as you cannot affect 's16' to 's8'</span>
    <span class="SCmt">// without an explicit cast(s16).</span>

    <span class="SCmt">// let z0: s16 = 1</span>
    <span class="SCmt">// let z1: s8 = z0</span>
}</span></div>

<h2 id="020_array">Array</h2><p>Remember that dynamic arrays are part of the <span class="code-inline">Std.Core</span> module. Here we are only talking about native static arrays. </p>
<p>A static array is declared with <span class="code-inline">[N]</span> followed by the type, where <span class="code-inline">N</span> is the dimension. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>  <span class="SCmt">// Static array of two s32</span>
        array[<span class="SNum">0</span>] = <span class="SNum">1</span>
        array[<span class="SNum">1</span>] = <span class="SNum">2</span>
    }
}</span></div>
<p>You can get the number of elements of an array with <span class="code-inline">@countof</span>, and the size in bytes with <span class="code-inline">@sizeof</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array) == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(array) == <span class="SNum">2</span> * <span class="SItr">@sizeof</span>(<span class="STpe">s32</span>)
}</span></div>
<p>You can get the address of the array with <span class="code-inline">@dataof</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>
    <span class="SKwd">var</span> ptr0 = <span class="SItr">@dataof</span>(array)
    ptr0[<span class="SNum">0</span>] = <span class="SNum">1</span>

    <span class="SCmt">// This is equivalent of taking the address of the first element</span>
    <span class="SKwd">var</span> ptr1 = &array[<span class="SNum">0</span>]
    ptr1[<span class="SNum">1</span>] = <span class="SNum">2</span>

    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">2</span>)
}</span></div>
<p>An <b>array literal</b> has the form <span class="code-inline">[A, B, ...]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>] <span class="SCmt">// An array of four s32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(arr) == <span class="STpe">#type</span> [<span class="SNum">4</span>] <span class="STpe">s32</span>
}</span></div>
<p>The size of the array can be deduced from the initialisation expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Here the dimension is not specified, but as the array is initialized with 2 elements, it can be deduced.</span>
    <span class="SKwd">var</span> array: [] <span class="STpe">s32</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array) == <span class="SNum">2</span>

    <span class="SCmt">// Here both dimensions and types are deduced thanks to the initialization expression.</span>
    <span class="SKwd">var</span> array1 = [<span class="SStr">"10"</span>, <span class="SStr">"20"</span>, <span class="SStr">"30"</span>]
    <span class="SItr">@assert</span>(array1[<span class="SNum">0</span>] == <span class="SStr">"10"</span>)
    <span class="SItr">@assert</span>(array1[<span class="SNum">1</span>] == <span class="SStr">"20"</span>)
    <span class="SItr">@assert</span>(array1[<span class="SNum">2</span>] == <span class="SStr">"30"</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array1) == <span class="SNum">3</span>
}</span></div>
<p>Like every other types, an array is initialized by default to 0 </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>] <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>] == <span class="SNum">0</span>)
}</span></div>
<p>But for speed, you can force the array to be not initialized with <span class="code-inline">undefined</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">100</span>] <span class="STpe">s32</span> = <span class="SKwd">undefined</span>
}</span></div>
<p>A static array (with compile time values) can be stored as a constant. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> array = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SCmp">#assert</span> array[<span class="SNum">0</span>] == <span class="SNum">1</span>   <span class="SCmt">// Dereference is done at compile time</span>
    <span class="SCmp">#assert</span> array[<span class="SNum">3</span>] == <span class="SNum">4</span>
}</span></div>
<p>If the type of the array is not specified, the type of the <b>first</b> literal value will be used for all other members. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>'<span class="STpe">f64</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]    <span class="SCmt">// Every values are forced to be 'f64'</span>

    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(arr) == <span class="STpe">#type</span> [<span class="SNum">4</span>] <span class="STpe">f64</span>
    <span class="SItr">@assert</span>(arr[<span class="SNum">3</span>] == <span class="SNum">4.0</span>)
}</span></div>
<p>Of course an array can have multiple dimensions. </p>
<p>Syntax is <span class="code-inline">[X, Y, Z...]</span> where <span class="code-inline">X</span>, <span class="code-inline">Y</span> and <span class="code-inline">Z</span> are dimensions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span>   <span class="SCmt">// Declare a 2x2 array</span>
    array[<span class="SNum">0</span>, <span class="SNum">0</span>] = <span class="SNum">1</span>         <span class="SCmt">// To access it, the same syntax is used</span>
    array[<span class="SNum">0</span>, <span class="SNum">1</span>] = <span class="SNum">2</span>
    array[<span class="SNum">1</span>, <span class="SNum">0</span>] = <span class="SNum">3</span>
    array[<span class="SNum">1</span>, <span class="SNum">1</span>] = <span class="SNum">4</span>
}</span></div>
<p>But the C/C++ syntax is also accepted. You will then declare an array of array instead of an array with multiple dimensions, which in fact is the same... </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>][<span class="SNum">2</span>] <span class="STpe">s32</span>
    array[<span class="SNum">0</span>, <span class="SNum">0</span>] = <span class="SNum">1</span>
    array[<span class="SNum">0</span>, <span class="SNum">1</span>] = <span class="SNum">2</span>
    array[<span class="SNum">1</span>, <span class="SNum">0</span>] = <span class="SNum">3</span>
    array[<span class="SNum">1</span>, <span class="SNum">1</span>] = <span class="SNum">4</span>
}</span></div>
<p>The sizes can be deduced from the initialization expression too. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SKwd">var</span> array1 = [[<span class="SNum">1</span>, <span class="SNum">2</span>], [<span class="SNum">3</span>, <span class="SNum">4</span>]]

    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array) == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(array1) == <span class="SNum">2</span>
}</span></div>
<p>You can initialize a whole array variable (but <b>not a constant</b>) with one single value. Only basic types are accepted (integers, float, string, bool, rune). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// The whole array is initialized with 'true'</span>
    <span class="SKwd">var</span> arr: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">bool</span> = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(arr[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(arr[<span class="SNum">1</span>, <span class="SNum">1</span>] == <span class="SKwd">true</span>)

    <span class="SCmt">// The whole array is initialized with 'string'</span>
    <span class="SKwd">var</span> arr1: [<span class="SNum">5</span>, <span class="SNum">10</span>] <span class="STpe">string</span> = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(arr1[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SStr">"string"</span>)
    <span class="SItr">@assert</span>(arr1[<span class="SNum">4</span>, <span class="SNum">9</span>] == <span class="SStr">"string"</span>)
}</span></div>

<h2 id="021_slice">Slice</h2><p>A slice is a pointer on a buffer of datas, and a <span class="code-inline">u64</span> to count the number of elements. Unlike a static array, its value can be changed at runtime. </p>
<p>It is declared with <span class="code-inline">[..]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: [..] <span class="STpe">bool</span>    <span class="SCmt">// Slice of bools</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(a) == <span class="SItr">@sizeof</span>(*<span class="STpe">void</span>) + <span class="SItr">@sizeof</span>(<span class="STpe">u64</span>)
}</span></div>
<p>You can initialize a slice like an array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="SKwd">const</span> [..] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>, <span class="SNum">50</span>]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">0</span>] == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">4</span>] == <span class="SNum">50</span>)

    <span class="SCmt">// But as this is a slice and not a static array, you can change the value at runtime.</span>
    <span class="SCmt">// So now 'a' is a slice of two s32 values.</span>
    a = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(a[<span class="SNum">1</span>] == <span class="SNum">2</span>)
}</span></div>
<p>At runtime, <span class="code-inline">@dataof</span> will return the address of the values, <span class="code-inline">@countof</span> the number of elements. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="SKwd">const</span> [..] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>, <span class="SNum">50</span>]
    <span class="SKwd">let</span> count = <span class="SItr">@countof</span>(a)
    <span class="SKwd">let</span> addr = <span class="SItr">@dataof</span>(a)
    <span class="SItr">@assert</span>(count == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(addr[<span class="SNum">0</span>] == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(addr[<span class="SNum">4</span>] == <span class="SNum">50</span>)

    a = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(a) == <span class="SNum">2</span>)
}</span></div>
<p>You can create a slice with your own <span class="code-inline">pointer</span> and <span class="code-inline">count</span> using <span class="code-inline">@mkslice</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">4</span>] <span class="STpe">u32</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]

    <span class="SCmt">// Creates a slice of 'array' (a view, or subpart) starting at index 2, with 2 elements.</span>
    <span class="SKwd">let</span> slice: [..] <span class="STpe">u32</span> = <span class="SItr">@mkslice</span>(&array[<span class="SNum">0</span>] + <span class="SNum">2</span>, <span class="SNum">2</span>)

    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)

    <span class="SItr">@assert</span>(array[<span class="SNum">2</span>] == <span class="SNum">30</span>)
    slice[<span class="SNum">0</span>] = <span class="SNum">314</span>
    <span class="SItr">@assert</span>(array[<span class="SNum">2</span>] == <span class="SNum">314</span>)
}</span></div>
<p>For a string, the slice must be <span class="code-inline">const</span> because a string is immutable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> strSlice: <span class="SKwd">const</span> [..] <span class="STpe">u8</span> = <span class="SItr">@mkslice</span>(<span class="SItr">@dataof</span>(str), <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(strSlice[<span class="SNum">0</span>] == <span class="SStr">`s`</span>)
    <span class="SItr">@assert</span>(strSlice[<span class="SNum">1</span>] == <span class="SStr">`t`</span>)
}</span></div>
<h3 id="021_slice_The_slicing_operator">The slicing operator </h3>
<p>Instead of <span class="code-inline">@mkslice</span>, you can slice something with the <span class="code-inline">..</span> operator. For example you can slice a string. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>

    <span class="SCmt">// Creates a slice starting at byte 0 and ending at byte 3.</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">1.</span>.<span class="SNum">3</span>]

    <span class="SItr">@assert</span>(slice == <span class="SStr">"tri"</span>)
}</span></div>
<p>The upper limit is <b>included</b> by default. If you want to exclude it, use <span class="code-inline">..&lt;</span> insteand of <span class="code-inline">..</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">1.</span>.&lt;<span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice == <span class="SStr">"tr"</span>)
}</span></div>
<p>You can omit the upper bound if you want to slice to the end. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice = str[<span class="SNum">2.</span>.]
    <span class="SItr">@assert</span>(slice == <span class="SStr">"ring"</span>)
}</span></div>
<p>You can omit the lower bound if you want to slice from the start (0). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> slice = str[..<span class="SNum">2</span>]        <span class="SCmt">// Index 2 is included</span>
    <span class="SItr">@assert</span>(slice == <span class="SStr">"str"</span>)
    <span class="SKwd">let</span> slice1 = str[..&lt;<span class="SNum">2</span>]      <span class="SCmt">// Index 2 is excluded</span>
    <span class="SItr">@assert</span>(slice1 == <span class="SStr">"st"</span>)
}</span></div>
<p>You can also slice an array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> arr = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> slice = arr[<span class="SNum">2.</span>.<span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)

    <span class="SCmt">// Creates a slice for the whole array</span>
    <span class="SKwd">let</span> slice1 = arr[..]
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice1) == <span class="SItr">@countof</span>(arr))
}</span></div>
<p>You can slice another slice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> arr = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> slice1 = arr[<span class="SNum">1.</span>.<span class="SNum">3</span>]
    <span class="SItr">@assert</span>(slice1[<span class="SNum">0</span>] == <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(slice1[<span class="SNum">1</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice1[<span class="SNum">2</span>] == <span class="SNum">40</span>)

    <span class="SKwd">let</span> slice2 = slice1[<span class="SNum">1.</span>.<span class="SNum">2</span>]
    <span class="SItr">@assert</span>(slice2[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice2[<span class="SNum">1</span>] == <span class="SNum">40</span>)
}</span></div>
<p>You can transform a pointer to a slice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SKwd">let</span> ptr = &arr[<span class="SNum">2</span>]
    <span class="SKwd">let</span> slice = ptr[<span class="SNum">0.</span>.<span class="SNum">1</span>]
    <span class="SItr">@assert</span>(slice[<span class="SNum">0</span>] == <span class="SNum">30</span>)
    <span class="SItr">@assert</span>(slice[<span class="SNum">1</span>] == <span class="SNum">40</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(slice) == <span class="SNum">2</span>)
}</span></div>

<h2 id="022_pointers">Pointers</h2><h3 id="022_pointers_Single_value_pointers">Single value pointers </h3>
<p>A pointer to a <b>single element</b> is declared with <span class="code-inline">*</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr1: *<span class="STpe">u8</span>   <span class="SCmt">// This is a pointer to one single 'u8'</span>
    <span class="SKwd">var</span> ptr2: **<span class="STpe">u8</span>  <span class="SCmt">// This is a pointer to one other pointer to one single 'u8'</span>
}</span></div>
<p>A pointer can be <span class="code-inline">null</span> (i know some of you will collapse here). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr1: *<span class="STpe">u8</span>
    <span class="SItr">@assert</span>(ptr1 == <span class="SKwd">null</span>)
}</span></div>
<p>You can take the address of something with <span class="code-inline">&</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = <span class="SNum">1</span>
    <span class="SKwd">let</span> ptr = &arr <span class="SCmt">// Take the address of the variable 'arr'</span>
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(ptr) == *<span class="STpe">s32</span>)
}</span></div>
<p>You can get the pointed value with <span class="code-inline">dref</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = <span class="SNum">42</span>
    <span class="SKwd">let</span> ptr = &arr
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">42</span>)
}</span></div>
<p>Pointers can be <span class="code-inline">const</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> str = <span class="SStr">"string"</span>
    <span class="SKwd">let</span> ptr: <span class="SKwd">const</span> *<span class="STpe">u8</span> = <span class="SItr">@dataof</span>(str)
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SStr">`s`</span>)
}</span></div>
<p>You can be weird, but is this necessary ? </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> ptr:  *<span class="SKwd">const</span> *<span class="STpe">u8</span>        <span class="SCmt">// Normal pointer to a const pointer</span>
    <span class="SKwd">var</span> ptr1: <span class="SKwd">const</span> *<span class="SKwd">const</span> *<span class="STpe">u8</span>  <span class="SCmt">// Const pointer to a const pointer</span>
    <span class="SKwd">var</span> ptr2: <span class="SKwd">const</span> **<span class="STpe">u8</span>        <span class="SCmt">// Const pointer to a normal pointer</span>
}</span></div>
<h3 id="022_pointers_Multiple_values_pointers">Multiple values pointers </h3>
<p>If you want to enable <b>pointer arithmetic</b>, and make a pointer to <b>multiple values</b>, declare your pointer with <span class="code-inline">^</span> instead of <span class="code-inline">*</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// `ptr` is a pointer to a memory block of `u8`.</span>
    <span class="SKwd">var</span> ptr: ^<span class="STpe">u8</span>

    <span class="SCmt">// Pointer arithmetic is now possible</span>
    ptr = ptr - <span class="SNum">1</span>
}</span></div>
<p>Taking the address of an array element enables pointer arithmetic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: [<span class="SNum">4</span>] <span class="STpe">s32</span>
    <span class="SKwd">var</span> ptr = &x[<span class="SNum">1</span>]
    ptr = ptr - <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(ptr) == ^<span class="STpe">s32</span>
}</span></div>
<p>As pointer arithmetic is enabled, you can dereference that kind of pointer by index. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SKwd">let</span> ptr = &arr[<span class="SNum">0</span>]
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(ptr) == ^<span class="STpe">s32</span>)

    <span class="SCmt">// The type of 'ptr' is ^s32, so it can be dereferenced by index</span>
    <span class="SKwd">let</span> value1 = ptr[<span class="SNum">0</span>]
    <span class="SItr">@assert</span>(value1 == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(value1) == <span class="STpe">s32</span>

    <span class="SKwd">let</span> value2 = ptr[<span class="SNum">1</span>]
    <span class="SItr">@assert</span>(value2 == <span class="SNum">2</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(value2) == <span class="STpe">s32</span>

    <span class="SCmt">// But 'dref' still works for the first element</span>
    <span class="SKwd">let</span> value = <span class="SKwd">dref</span> ptr
    <span class="SItr">@assert</span>(value == <span class="SNum">1</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(value) == <span class="STpe">s32</span>
}</span></div>

<h2 id="023_references">References</h2><p>Swag has also <b>references</b>, which are pointers that behave like values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">42</span>

    <span class="SCmt">// Use 'ref' to declare a reference.</span>
    <span class="SCmt">// Here we declare a reference to the variable 'x'.</span>
    <span class="SCmt">// Note that unlike C++, you have to take the address of 'x' to convert it to a reference.</span>
    <span class="SKwd">let</span> myRef: <span class="SKwd">const</span> <span class="SKwd">ref</span> <span class="STpe">s32</span> = &x

    <span class="SCmt">// This is a pointer that behaves like a value, so no explicit dereferencing is necessary.</span>
    <span class="SCmt">// You can see this as a kind of an alias.</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">42</span>)
}</span></div>
<p>When an affectation is done outside of an initialization, you will change the pointed value, and not the reference itself. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">42</span>
    <span class="SKwd">var</span> myRef: <span class="SKwd">ref</span> <span class="STpe">s32</span> = &x <span class="SCmt">// Note here that the reference is no more 'const'</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">42</span>)

    <span class="SCmt">// Here we will change the pointed value 'x'</span>
    myRef = <span class="SNum">66</span>
    <span class="SItr">@assert</span>(myRef == <span class="SNum">66</span>)

    <span class="SCmt">// Remember that 'myRef' is an alias for 'x', so 'x' has also been changed.</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">66</span>)
}</span></div>
<p>But unlike C++, you can change the reference (reassign it) and not the pointed value if you want. You must then use <span class="code-inline">ref</span> in the affectation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>
    <span class="SKwd">var</span> y = <span class="SNum">1000</span>

    <span class="SKwd">var</span> myRef: <span class="SKwd">const</span> <span class="SKwd">ref</span> <span class="STpe">s32</span> = &x
    <span class="SItr">@assert</span>(myRef == <span class="SNum">1</span>)

    <span class="SCmt">// Here we force 'myRef' to point to 'y' and not to 'x' anymore.</span>
    <span class="SCmt">// We do *NOT* change the value of 'x'.</span>
    myRef = <span class="SKwd">ref</span> &y
    <span class="SItr">@assert</span>(myRef == <span class="SNum">1000</span>)
}</span></div>
<p>Most of the time, you have to take the address of a variable to make a reference to it. The only exception are function parameters, if the reference is <span class="code-inline">const</span>. In that case, taking the address is not necessary </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// We can pass a literal because the parameter 'x' of 'toto' is 'const ref' and not just 'ref'.</span>
    <span class="SFct">toto</span>(<span class="SNum">4</span>)
}

<span class="SKwd">func</span> <span class="SFct">toto</span>(x: <span class="SKwd">const</span> <span class="SKwd">ref</span> <span class="STpe">s32</span>)
{
    <span class="SItr">@assert</span>(x == <span class="SNum">4</span>)

    <span class="SCmt">// Under the hood, you will get a const address to an 's32'</span>
    <span class="SKwd">let</span> ptr = &x
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">4</span>)
}</span></div>
<p>This is usefull for structs for examples, as you can directly pass a literal to a function. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">MyStruct</span> {x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> }  <span class="SCmt">// Our first little struct !</span>

<span class="SFct">#test</span>
{
    <span class="SFct">titi0</span>({<span class="SNum">1</span>, <span class="SNum">2</span>})
    <span class="SFct">titi1</span>({<span class="SNum">3</span>, <span class="SNum">4</span>})
    <span class="SFct">titi2</span>({<span class="SNum">5</span>, <span class="SNum">6</span>})
}

<span class="SKwd">func</span> <span class="SFct">titi0</span>(param: <span class="SKwd">const</span> <span class="SKwd">ref</span> {x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span>})
{
    <span class="SCmt">// We'll see later about tuples and naming of fields.</span>
    <span class="SItr">@assert</span>(param.item0 == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(param.item1 == <span class="SNum">2</span>)
}</span></div>
<p>Note that declaring a tuple type or a struct type is equivalent to a constant reference. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">titi1</span>(param: {x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span>})
{
    <span class="SItr">@assert</span>(param.x == <span class="SNum">3</span>)
    <span class="SItr">@assert</span>(param.y == <span class="SNum">4</span>)
}

<span class="SKwd">func</span> <span class="SFct">titi2</span>(param: <span class="SCst">MyStruct</span>)
{
    <span class="SItr">@assert</span>(param.x == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(param.y == <span class="SNum">6</span>)
}</span></div>

<h2 id="024_any">Any</h2><p><span class="code-inline">any</span> is a specific type that can store every other types. <span class="code-inline">any</span> is <b>not a variant</b>. It's a dynamic typed reference to an existing value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">any</span>

    <span class="SCmt">// Store a 's32' literal value</span>
    a = <span class="SNum">6</span>

    <span class="SCmt">// In order to reference the value inside the 'any', you need to cast to the wanted type.</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) a == <span class="SNum">6</span>)

    <span class="SCmt">// Then now we store a string instead of the 's32' value</span>
    a = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) a == <span class="SStr">"string"</span>)

    <span class="SCmt">// Then we store a bool instead</span>
    a = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) a == <span class="SKwd">true</span>)
}</span></div>
<p><span class="code-inline">any</span> is in fact a pointer to the value, and a <span class="code-inline">typeinfo</span>. <span class="code-inline">@dataof</span> can be used to retrieve the pointer to the value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a: <span class="STpe">any</span> = <span class="SNum">6</span>
    <span class="SKwd">let</span> ptr = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="STpe">s32</span>) <span class="SItr">@dataof</span>(a)
    <span class="SItr">@assert</span>(<span class="SKwd">dref</span> ptr == <span class="SNum">6</span>)
}</span></div>
<p><span class="code-inline">@typeof</span> will give you the type <span class="code-inline">any</span>, but <span class="code-inline">@kindof</span> will give you the real underlying type. In that case, <span class="code-inline">@kindof</span> is evaluted at runtime. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a: <span class="STpe">any</span> = <span class="SStr">"string"</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(a) == <span class="STpe">any</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(a) == <span class="STpe">string</span>)

    a = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(a) == <span class="STpe">bool</span>)
}</span></div>
<p>You can declare an array with multiple types, with <span class="code-inline">any</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [] <span class="STpe">any</span> = [<span class="SKwd">true</span>, <span class="SNum">2</span>, <span class="SNum">3.0</span>, <span class="SStr">"4"</span>]
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">0</span>]) == <span class="STpe">bool</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">1</span>]) == <span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">2</span>]) == <span class="STpe">f32</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(array[<span class="SNum">3</span>]) == <span class="STpe">string</span>)

    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) array[<span class="SNum">0</span>] == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) array[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">f32</span>) array[<span class="SNum">2</span>] == <span class="SNum">3.0</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) array[<span class="SNum">3</span>] == <span class="SStr">"4"</span>)
}</span></div>
<p>An <span class="code-inline">any</span> value can be set to null, and tested against null. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">any</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)

    x = <span class="SNum">6</span>
    <span class="SItr">@assert</span>(x != <span class="SKwd">null</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">s32</span>) x == <span class="SNum">6</span>)

    x = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(x != <span class="SKwd">null</span>)
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) x == <span class="SStr">"string"</span>)

    x = <span class="SKwd">null</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)
}</span></div>
<p>An <span class="code-inline">any</span> value can be tested against a type with <span class="code-inline">==</span> and <span class="code-inline">!=</span>. This will call <span class="code-inline">@kindof</span> to get the underlying type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="STpe">any</span>
    <span class="SItr">@assert</span>(x == <span class="SKwd">null</span>)
    <span class="SItr">@assert</span>(x != <span class="STpe">s32</span>)

    x = <span class="SNum">6</span>
    <span class="SItr">@assert</span>(x == <span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(x != <span class="STpe">bool</span>)


    x = <span class="SStr">"string"</span>
    <span class="SItr">@assert</span>(x != <span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(x == <span class="STpe">string</span>)

    <span class="SKwd">struct</span> <span class="SCst">A</span>{}
    x = <span class="SCst">A</span>{}
    <span class="SItr">@assert</span>(x == <span class="SCst">A</span>)
}</span></div>

<h2 id="025_tuple">Tuple</h2><p>A tuple is an anonymous structure, aka a struct literal. Syntax is <span class="code-inline">{}</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple1 = {<span class="SNum">2</span>, <span class="SNum">2</span>}
    <span class="SKwd">let</span> tuple2 = {<span class="SStr">"string"</span>, <span class="SNum">2</span>, <span class="SKwd">true</span>}
}</span></div>
<p>Tuple values have default names to access them, in the form of <span class="code-inline">itemX</span> where <span class="code-inline">X</span> is the field rank. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple = {<span class="SStr">"string"</span>, <span class="SNum">2</span>, <span class="SKwd">true</span>}
    <span class="SItr">@assert</span>(tuple.item0 == <span class="SStr">"string"</span>)
    <span class="SItr">@assert</span>(tuple.item1 == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(tuple.item2 == <span class="SKwd">true</span>)
}</span></div>
<p>But you can specify your own names. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> tuple = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}
    <span class="SItr">@assert</span>(tuple.x == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(tuple.item0 == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(tuple.y == <span class="SNum">2.0</span>)
    <span class="SItr">@assert</span>(tuple.item1 == <span class="SNum">2.0</span>)
}</span></div>
<p>When creating a tuple literal with variables, the tuple fields will take the name of the variables (except if specified). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">555</span>
    <span class="SKwd">let</span> y = <span class="SNum">666</span>
    <span class="SKwd">let</span> t = {x, y}
    <span class="SItr">@assert</span>(t.x == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(t.item0 == t.x)
    <span class="SItr">@assert</span>(t.y == <span class="SNum">666</span>)
    <span class="SItr">@assert</span>(t.item1 == t.y)
}</span></div>
<p>Even if two tuples do not have the same field names, they can be assigned to each other if the field types are the same. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: {a: <span class="STpe">s32</span>, b: <span class="STpe">s32</span>}
    <span class="SKwd">var</span> y: {c: <span class="STpe">s32</span>, d: <span class="STpe">s32</span>}

    y = {<span class="SNum">1</span>, <span class="SNum">2</span>}
    x = y
    <span class="SItr">@assert</span>(x.a == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(x.b == <span class="SNum">2</span>)

    <span class="SCmt">// But note that 'x' and 'y' to not have the same type</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(x) != <span class="SItr">@typeof</span>(y)
}</span></div>
<h3 id="025_tuple_Tuple_unpacking">Tuple unpacking </h3>
<p>You can unpack a tuple field by field. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> tuple1 = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}

    <span class="SCmt">// 'value0' will be assigned with 'x', and 'value1' will be assigned with 'y'.</span>
    <span class="SKwd">let</span> (value0, value1) = tuple1
    <span class="SItr">@assert</span>(value0 == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(value1 == <span class="SNum">2.0</span>)

    <span class="SKwd">var</span> tuple2 = {<span class="SStr">"name"</span>, <span class="SKwd">true</span>}
    <span class="SKwd">let</span> (name, value) = tuple2
    <span class="SItr">@assert</span>(name == <span class="SStr">"name"</span>)
    <span class="SItr">@assert</span>(value == <span class="SKwd">true</span>)
}</span></div>
<p>You can ignore a tuple field by naming the variable <span class="code-inline">?</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> tuple1 = {x: <span class="SNum">1.0</span>, y: <span class="SNum">2.0</span>}
    <span class="SKwd">let</span> (x, ?) = tuple1
    <span class="SItr">@assert</span>(x == <span class="SNum">1.0</span>)
    <span class="SKwd">let</span> (?, y) = tuple1
    <span class="SItr">@assert</span>(y == <span class="SNum">2.0</span>)
}</span></div>

<h2 id="030_enum">Enum</h2><p>Enums values, unlike C/C++, can end with <span class="code-inline">;</span> or <span class="code-inline">,</span> or an <span class="code-inline">eol</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values0</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
    }

    <span class="SKwd">enum</span> <span class="SCst">Values1</span>
    {
        <span class="SCst">A</span>,
        <span class="SCst">B</span>,
    }

    <span class="SCmt">// The last comma is not necessary</span>
    <span class="SKwd">enum</span> <span class="SCst">Values2</span>
    {
        <span class="SCst">A</span>,
        <span class="SCst">B</span>
    }

    <span class="SKwd">enum</span> <span class="SCst">Values3</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">enum</span> <span class="SCst">Values4</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }
    <span class="SKwd">enum</span> <span class="SCst">Values5</span> { <span class="SCst">A</span>; <span class="SCst">B</span> }
}</span></div>
<p>By default, an enum is of type <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }
    <span class="SKwd">let</span> type = <span class="SItr">@typeof</span>(<span class="SCst">Values</span>)

    <span class="SCmt">// 'type' here is a 'typeinfo' dedicated to the enum type.</span>
    <span class="SCmt">// In that case, 'type.rawType' is the enum underlying type.</span>
    <span class="SItr">@assert</span>(type.rawType == <span class="STpe">s32</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SCst">Values</span>) == <span class="SCst">Values</span>
}</span></div>
<p><span class="code-inline">@kindof</span> will return the underlying type of the enum. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SCst">RGB</span>) == <span class="SCst">RGB</span>
    <span class="SCmp">#assert</span> <span class="SItr">@kindof</span>(<span class="SCst">RGB</span>) != <span class="SCst">RGB</span>
    <span class="SCmp">#assert</span> <span class="SItr">@kindof</span>(<span class="SCst">RGB</span>) == <span class="STpe">s32</span>
}</span></div>
<p>You can specify your own type after the enum name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values1</span>: <span class="STpe">s64</span> <span class="SCmt">// Forced to be 's64' instead of 's32'</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
        <span class="SCst">C</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@kindof</span>(<span class="SCst">Values1</span>) == <span class="STpe">s64</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SCst">Values1</span>.<span class="SCst">A</span>) == <span class="SCst">Values1</span>
}</span></div>
<p>Enum values, if not specified, start at 0 and are increased by 1 at each new value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">s64</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
        <span class="SCst">C</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">2</span>
}</span></div>
<p>You can specify your own values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">s64</span>
    {
        <span class="SCst">A</span> = <span class="SNum">10</span>
        <span class="SCst">B</span> = <span class="SNum">20</span>
        <span class="SCst">C</span> = <span class="SNum">30</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">10</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">20</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">30</span>
}</span></div>
<p>If you omit one value, it will be assigned to the previous value + 1. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">u32</span>
    {
        <span class="SCst">A</span> = <span class="SNum">10</span>
        <span class="SCst">B</span> <span class="SCmt">// 11</span>
        <span class="SCst">C</span> <span class="SCmt">// 12</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">10</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">11</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">12</span>
}</span></div>
<p>For non integer types, you <b>must</b> specify the values as they cannot be deduced. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value1</span>: <span class="STpe">string</span>
    {
        <span class="SCst">A</span> = <span class="SStr">"string 1"</span>
        <span class="SCst">B</span> = <span class="SStr">"string 2"</span>
        <span class="SCst">C</span> = <span class="SStr">"string 3"</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value1</span>.<span class="SCst">A</span> == <span class="SStr">"string 1"</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value1</span>.<span class="SCst">B</span> == <span class="SStr">"string 2"</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value1</span>.<span class="SCst">C</span> == <span class="SStr">"string 3"</span>

    <span class="SKwd">enum</span> <span class="SCst">Value2</span>: <span class="STpe">f32</span>
    {
        <span class="SCst">A</span> = <span class="SNum">1.0</span>
        <span class="SCst">B</span> = <span class="SNum">3.14</span>
        <span class="SCst">C</span> = <span class="SNum">6</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value2</span>.<span class="SCst">A</span> == <span class="SNum">1.0</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value2</span>.<span class="SCst">B</span> == <span class="SNum">3.14</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value2</span>.<span class="SCst">C</span> == <span class="SNum">6</span>
}</span></div>
<p><span class="code-inline">@countof</span> returns the number of values of an enum. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="STpe">string</span>
    {
        <span class="SCst">A</span> = <span class="SStr">"string 1"</span>
        <span class="SCst">B</span> = <span class="SStr">"string 2"</span>
        <span class="SCst">C</span> = <span class="SStr">"string 3"</span>
    }

    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(<span class="SCst">Value</span>) == <span class="SNum">3</span>)
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(<span class="SCst">Value</span>) == <span class="SNum">3</span>
}</span></div>
<p>You can use the keyword <span class="code-inline">using</span> for an enum. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>
    {
        <span class="SCst">A</span>
        <span class="SCst">B</span>
        <span class="SCst">C</span>
    }

    <span class="SKwd">using</span> <span class="SCst">Value</span>

    <span class="SCmt">// No need to say 'Value.A' thanks to the 'using' above</span>
    <span class="SItr">@assert</span>(<span class="SCst">A</span> == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(<span class="SCst">B</span> == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">C</span> == <span class="SNum">2</span>)

    <span class="SCmt">// But the normal form is still possible</span>
    <span class="SItr">@assert</span>(<span class="SCst">Value</span>.<span class="SCst">A</span> == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(<span class="SCst">Value</span>.<span class="SCst">B</span> == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">Value</span>.<span class="SCst">C</span> == <span class="SNum">2</span>)
}</span></div>
<h3 id="030_enum_Enum_as_flags">Enum as flags </h3>
<p>An enum can be a set of flags if you declare it with the <span class="code-inline">#[Swag.EnumFlags]</span> attribute. Its type should be <span class="code-inline">u8</span>, <span class="code-inline">u16</span>, <span class="code-inline">u32</span> or <span class="code-inline">u64</span>. </p>
<p>That kind of enum starts by default at 1, and not 0, and each value should be a power of 2. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumFlags]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyFlags</span>: <span class="STpe">u8</span>
    {
        <span class="SCst">A</span>   <span class="SCmt">// First value is 1 and *not* 0</span>
        <span class="SCst">B</span>   <span class="SCmt">// Value is 2</span>
        <span class="SCst">C</span>   <span class="SCmt">// Value is 4</span>
        <span class="SCst">D</span>   <span class="SCmt">// Value is 8</span>
    }

    <span class="SCmp">#assert</span> <span class="SCst">MyFlags</span>.<span class="SCst">A</span> == <span class="SNum">0b00000001</span>
    <span class="SCmp">#assert</span> <span class="SCst">MyFlags</span>.<span class="SCst">B</span> == <span class="SNum">0b00000010</span>
    <span class="SCmp">#assert</span> <span class="SCst">MyFlags</span>.<span class="SCst">C</span> == <span class="SNum">0b00000100</span>
    <span class="SCmp">#assert</span> <span class="SCst">MyFlags</span>.<span class="SCst">D</span> == <span class="SNum">0b00001000</span>

    <span class="SKwd">let</span> value = <span class="SCst">MyFlags</span>.<span class="SCst">B</span> | <span class="SCst">MyFlags</span>.<span class="SCst">C</span>
    <span class="SItr">@assert</span>(value == <span class="SNum">0b00000110</span>)
    <span class="SItr">@assert</span>(value & <span class="SCst">MyFlags</span>.<span class="SCst">B</span> == <span class="SCst">MyFlags</span>.<span class="SCst">B</span>)
    <span class="SItr">@assert</span>(value & <span class="SCst">MyFlags</span>.<span class="SCst">C</span> == <span class="SCst">MyFlags</span>.<span class="SCst">C</span>)
}</span></div>
<h3 id="030_enum_Enum_of_arrays">Enum of arrays </h3>
<p>You can have an enum of const static arrays. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="SKwd">const</span> [<span class="SNum">2</span>] <span class="STpe">s32</span>
    {
        <span class="SCst">A</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>]
        <span class="SCst">B</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>]
    }

    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">A</span>[<span class="SNum">1</span>] == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span>[<span class="SNum">0</span>] == <span class="SNum">10</span>
    <span class="SCmp">#assert</span> <span class="SCst">Value</span>.<span class="SCst">B</span>[<span class="SNum">1</span>] == <span class="SNum">20</span>
}</span></div>
<h3 id="030_enum_Enum_of_slices">Enum of slices </h3>
<p>You can have an enum of const slices. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Value</span>: <span class="SKwd">const</span> [..] <span class="STpe">s32</span>
    {
        <span class="SCst">A</span> = [<span class="SNum">1</span>, <span class="SNum">2</span>]
        <span class="SCst">B</span> = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    }

    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(<span class="SCst">Value</span>.<span class="SCst">A</span>) == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(<span class="SCst">Value</span>.<span class="SCst">B</span>) == <span class="SNum">4</span>

    <span class="SKwd">let</span> x = <span class="SCst">Value</span>.<span class="SCst">A</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SKwd">let</span> y = <span class="SCst">Value</span>.<span class="SCst">B</span>
    <span class="SItr">@assert</span>(y[<span class="SNum">0</span>] == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(y[<span class="SNum">1</span>] == <span class="SNum">20</span>)
}</span></div>
<h3 id="030_enum_Nested_enums">Nested enums </h3>
<p>An enum can be nested inside another enum with <span class="code-inline">using</span>. Both enums must of course have the same underlying type. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">enum</span> <span class="SCst">BasicErrors</span>
{
    <span class="SCst">FailedToLoad</span>
    <span class="SCst">FailedToSave</span>
}

<span class="SCmt">// The enum 'BasicErrors' is nested inside 'MyErrors'</span>
<span class="SKwd">enum</span> <span class="SCst">MyErrors</span>
{
    <span class="SKwd">using</span> <span class="SCst">BasicErrors</span>
    <span class="SCst">NotFound</span> = <span class="SNum">100</span>
}</span></div>
<p>To access a value inside the nested enum, use the enum name (a scope has been created). </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">MyError0</span> = <span class="SCst">MyErrors</span>.<span class="SCst">BasicErrors</span>.<span class="SCst">FailedToSave</span></span></div>
<p>An <b>automatic cast</b> will be done if you try to convert a nested enum to an owner enum. For example, a value of type <span class="code-inline">BasicErrors</span> can be converted to a parameter of type <span class="code-inline">MyErrors</span> because <span class="code-inline">MyErrors</span> contains <span class="code-inline">BasicErrors</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">E0</span>: <span class="SCst">MyErrors</span>    = <span class="SCst">MyErrors</span>.<span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>
    <span class="SKwd">const</span> <span class="SCst">E1</span>: <span class="SCst">BasicErrors</span> = <span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>

    <span class="SKwd">func</span> <span class="SFct">toto</span>(err: <span class="SCst">MyErrors</span>)
    {
        <span class="SItr">@assert</span>(err == <span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>)
        <span class="SItr">@assert</span>(err == <span class="SCst">MyErrors</span>.<span class="SCst">BasicErrors</span>.<span class="SCst">FailedToLoad</span>)
    }

    <span class="SFct">toto</span>(<span class="SCst">E0</span>)
    <span class="SFct">toto</span>(<span class="SCst">E1</span>) <span class="SCmt">// Automatic cast from 'BasicErrors' to 'MyErrors'</span>
}</span></div>
<h3 id="030_enum_Specific_attributes">Specific attributes </h3>
<p>You can use <span class="code-inline">#[Swag.EnumIndex]</span> if an enum value can be used as a dereference index. This will avoid the necessity of an explicit cast. The underlying enum type must be integer. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumIndex]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyIndex</span> { <span class="SCst">First</span>, <span class="SCst">Second</span>, <span class="SCst">Third</span> }

    <span class="SKwd">const</span> <span class="SCst">Array</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SKwd">const</span> <span class="SCst">Valu</span> = <span class="SCst">Array</span>[<span class="SCst">MyIndex</span>.<span class="SCst">First</span>]   <span class="SCmt">// No need to cast 'MyIndex.First'</span>
}</span></div>
<p>You can use <span class="code-inline">#[Swag.NoDuplicate]</span> to avoid duplicated values inside an enum. If the compiler finds a value defined more than once, it will raise an error. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.NoDuplicate]</span>
    <span class="SKwd">enum</span> <span class="SCst">MyEnum</span>
    {
        <span class="SCst">Val0</span> = <span class="SNum">0</span>
        <span class="SCmt">//Val1 = 0      // Will raise an error because '0' is already defined</span>
    }
}</span></div>
<h3 id="030_enum_Enum_type_inference">Enum type inference </h3>
<p>The type of the enum is not necessary in the assignement expression when declaring a variable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }

    <span class="SCmt">// The normal form</span>
    <span class="SKwd">let</span> x: <span class="SCst">Values</span> = <span class="SCst">Values</span>.<span class="SCst">A</span>

    <span class="SCmt">// But in fact 'Values' is not necessary because it can be deduced</span>
    <span class="SKwd">let</span> y: <span class="SCst">Values</span> = <span class="SCst">A</span>

    <span class="SItr">@assert</span>(x == y)
}</span></div>
<p>The enum type is not necessary in a <span class="code-inline">case</span> expression of a <span class="code-inline">switch</span> block (it is deduced from the switch expression). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }
    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span>

    <span class="SCmt">// The 'normal' form</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SCst">Values</span>.<span class="SCst">A</span>: <span class="SLgc">break</span>
    <span class="SLgc">case</span> <span class="SCst">Values</span>.<span class="SCst">B</span>: <span class="SLgc">break</span>
    }

    <span class="SCmt">// The 'simplified' form</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SCst">A</span>: <span class="SLgc">break</span>
    <span class="SLgc">case</span> <span class="SCst">B</span>: <span class="SLgc">break</span>
    }
}</span></div>
<p>In an expression, and if the enum name can be deduced, you can omit it and use the <span class="code-inline">.Value</span> syntax. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }

    <span class="SCmt">// The normal form</span>
    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span>

    <span class="SCmt">// The simplified form, because 'Values' can be deduced from type of x</span>
    <span class="SItr">@assert</span>(x == .<span class="SCst">A</span>)
    <span class="SItr">@assert</span>(x != .<span class="SCst">B</span>)
}</span></div>
<p>Works also for flags. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.EnumFlags]</span>
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>, <span class="SCst">B</span> }

    <span class="SKwd">let</span> x = <span class="SCst">Values</span>.<span class="SCst">A</span> | <span class="SCst">Values</span>.<span class="SCst">B</span>
    <span class="SItr">@assert</span>((x & .<span class="SCst">A</span>) <span class="SLgc">and</span> (x & .<span class="SCst">B</span>))
}</span></div>
<p>Works also (most of the time), for functions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }
    <span class="SKwd">func</span> <span class="SFct">toto</span>(v1, v2: <span class="SCst">Values</span>) {}
    <span class="SFct">toto</span>(.<span class="SCst">A</span>, .<span class="SCst">B</span>)
}</span></div>
<p>By type reflection, you can loop/visit all values of an enum. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>, <span class="SCst">G</span>, <span class="SCst">B</span> }

        <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
        <span class="SLgc">loop</span> idx: <span class="SCst">RGB</span>
            cpt += <span class="SNum">1</span>
        <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)

        <span class="SLgc">visit</span> val: <span class="SCst">RGB</span>
        {
            <span class="SLgc">switch</span> val
            {
            <span class="SLgc">case</span> <span class="SCst">R</span>:     <span class="SLgc">break</span>
            <span class="SLgc">case</span> <span class="SCst">G</span>:     <span class="SLgc">break</span>
            <span class="SLgc">case</span> <span class="SCst">B</span>:     <span class="SLgc">break</span>
            <span class="SLgc">default</span>:    <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
            }
        }
    }
}</span></div>

<h2 id="031_impl">Impl</h2><p><span class="code-inline">impl</span> can be used to declare some stuff in the scope of an enum. The keyword <span class="code-inline">self</span> represents the enum value. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>; <span class="SCst">G</span>; <span class="SCst">B</span>; }</span></div>
<p>Note the <span class="code-inline">impl enum</span> syntax. We'll see later that <span class="code-inline">impl</span> is also used for structs. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SKwd">enum</span> <span class="SCst">RGB</span>
{
    <span class="SKwd">func</span> <span class="SFct">isRed</span>(<span class="SKwd">self</span>)       =&gt; <span class="SKwd">self</span> == <span class="SCst">R</span>
    <span class="SKwd">func</span> <span class="SFct">isRedOrBlue</span>(<span class="SKwd">self</span>) =&gt; <span class="SKwd">self</span> == <span class="SCst">R</span> <span class="SLgc">or</span> <span class="SKwd">self</span> == <span class="SCst">B</span>
}

<span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SFct">isRed</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span>))
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SFct">isRedOrBlue</span>(<span class="SCst">RGB</span>.<span class="SCst">B</span>))

    <span class="SKwd">using</span> <span class="SCst">RGB</span>
    <span class="SItr">@assert</span>(<span class="SFct">isRedOrBlue</span>(<span class="SCst">R</span>))
    <span class="SItr">@assert</span>(<span class="SFct">isRedOrBlue</span>(<span class="SCst">B</span>))

    <span class="SCmt">// A first look at 'ufcs' (uniform function call syntax)</span>
    <span class="SItr">@assert</span>(<span class="SCst">R</span>.<span class="SFct">isRedOrBlue</span>())
    <span class="SItr">@assert</span>(!<span class="SCst">RGB</span>.<span class="SCst">G</span>.<span class="SFct">isRedOrBlue</span>())
}</span></div>

<h2 id="035_namespace">Namespace</h2><p>You can create a global scope with a namespace. All symbols inside the namespace will be in the corresponding global scope. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">namespace</span> <span class="SCst">A</span>
{
    <span class="SKwd">func</span> <span class="SFct">a</span>() =&gt; <span class="SNum">1</span>
}</span></div>
<p>You can also specify more than one name. Here <span class="code-inline">C</span> will be a namespace inside <span class="code-inline">B</span> which is itself inside <span class="code-inline">A</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">namespace</span> <span class="SCst">A</span>.<span class="SCst">B</span>.<span class="SCst">C</span>
{
    <span class="SKwd">func</span> <span class="SFct">a</span>() =&gt; <span class="SNum">2</span>
}

<span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SCst">A</span>.<span class="SFct">a</span>() == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">A</span>.<span class="SCst">B</span>.<span class="SCst">C</span>.<span class="SFct">a</span>() == <span class="SNum">2</span>)
}</span></div>
<p>You can also put <span class="code-inline">using</span> in front of the namespace to be able to access the content without scoping in the <b>current</b> file. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SKwd">namespace</span> <span class="SCst">Private</span>
{
    <span class="SKwd">const</span> <span class="SCst">FileSymbol</span> = <span class="SNum">0</span>
}

<span class="SKwd">const</span> <span class="SCst">B</span> = <span class="SCst">Private</span>.<span class="SCst">FileSymbol</span>
<span class="SKwd">const</span> <span class="SCst">C</span> = <span class="SCst">FileSymbol</span> <span class="SCmt">// No need to specify 'Private' because of the 'using'</span></span></div>
<p>This is equivalent to <span class="code-inline">private</span>, but you don't have to specify a name, the compiler will generate it for you. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">private</span> {
    <span class="SKwd">const</span> <span class="SCst">OtherSymbol</span> = <span class="SNum">0</span>
}

<span class="SKwd">const</span> <span class="SCst">D</span> = <span class="SCst">OtherSymbol</span></span></div>
<p>All symbols from a Swag source file are exported to other files of the same module. So using <span class="code-inline">private</span> can protect from name conflicts. </p>

<h2 id="050_if">If</h2><p>A basic test with <span class="code-inline">if</span>. Curlies are optional, and the expression doesn't need to be enclosed with <span class="code-inline">()</span> like in C/C++. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SLgc">if</span> a == <span class="SNum">1</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">if</span> (a == <span class="SNum">1</span>)
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">if</span> a == <span class="SNum">0</span> {
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    }

    <span class="SCmt">// 'else' is of course also a thing</span>
    <span class="SLgc">if</span> a == <span class="SNum">0</span>
        a += <span class="SNum">1</span>
    <span class="SLgc">else</span>
        a += <span class="SNum">2</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)

    <span class="SCmt">// 'elif' is equivalent to 'else if'</span>
    <span class="SLgc">if</span> a == <span class="SNum">1</span>
        a += <span class="SNum">1</span>
    <span class="SLgc">else</span> <span class="SLgc">if</span> a == <span class="SNum">2</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">elif</span> a == <span class="SNum">3</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">elif</span> a == <span class="SNum">4</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)

    <span class="SCmt">// Boolean expression with 'and' and 'or'</span>
    <span class="SLgc">if</span> a == <span class="SNum">0</span> <span class="SLgc">and</span> a == <span class="SNum">1</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">if</span> a == <span class="SNum">0</span> <span class="SLgc">or</span> a == <span class="SNum">1</span>
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
}</span></div>
<p>You can also at the same time declare and test one variable in an <span class="code-inline">if</span> expression. <span class="code-inline">var</span>, <span class="code-inline">let</span> or <span class="code-inline">const</span> is mandatory in that case. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// This will declare a variable 'a', and test it against 0.</span>
    <span class="SCmt">// 'a' is then only visible in the 'if' block, and not outside.</span>
    <span class="SLgc">if</span> <span class="SKwd">var</span> a = <span class="SNum">0</span>
    {
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SCmt">// So you can redeclare 'a' (this time as a constant).</span>
    <span class="SLgc">if</span> <span class="SKwd">const</span> a = <span class="SNum">1</span>
        <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)
    <span class="SLgc">else</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)

    <span class="SLgc">if</span> <span class="SKwd">let</span> a = <span class="SNum">1</span>
        <span class="SItr">@assert</span>(a == <span class="SNum">1</span>)
    <span class="SLgc">else</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
}</span></div>

<h2 id="051_loop">Loop</h2><p><span class="code-inline">loop</span> are used to iterate a given amount of time. </p>
<p>The loop expression value is evaluated <b>once</b>, and must be a <b>positive value</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">loop</span> <span class="SNum">10</span> <span class="SCmt">// Loops 10 times</span>
        cpt += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)
}</span></div>
<p>The intrinsic <span class="code-inline">@index</span> returns the current index of the loop, starting at 0. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>'<span class="STpe">u64</span>
    <span class="SLgc">loop</span> <span class="SNum">5</span>
    {
        cpt += <span class="SItr">@index</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span>+<span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)
}</span></div>
<p>But you can name that index if you want. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SKwd">var</span> cpt1 = <span class="SNum">0</span>

    <span class="SLgc">loop</span> i: <span class="SNum">5</span>   <span class="SCmt">// index is named 'i'</span>
    {
        cpt  += i
        cpt1 += <span class="SItr">@index</span>  <span class="SCmt">// @index is always available, even when named</span>
    }

    <span class="SItr">@assert</span>(cpt  == <span class="SNum">0</span>+<span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)
    <span class="SItr">@assert</span>(cpt1 == cpt)
}</span></div>
<p><span class="code-inline">loop</span> can be used on every types that accept the <span class="code-inline">@countof</span> intrinsic. So you can loop on a slice, an array, a string... and we'll see later, even on a struct. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> arr = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>]
    <span class="SCmp">#assert</span> <span class="SItr">@countof</span>(arr) == <span class="SNum">4</span>

    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">loop</span> arr    <span class="SCmt">// The array contains 4 elements, so the loop count is 4</span>
        cpt += arr[<span class="SItr">@index</span>]
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>+<span class="SNum">20</span>+<span class="SNum">30</span>+<span class="SNum">40</span>)
}</span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> On a string, it will loop for each byte, <b>not</b> runes (if a rune is encoded in more than one byte). If you want to iterate on all runes, you will have to use the Std.Core module. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">loop</span> <span class="SStr">"⻘"</span>
        cpt += <span class="SNum">1</span>

    <span class="SCmt">// cpt is equal to 3 because '⻘' is encoded with 3 bytes</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>
<p>You can loop in reverse order by adding the modifier <span class="code-inline">back</span> just after the <span class="code-inline">loop</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// Index will be 2, 1 and then 0.</span>
    <span class="SLgc">loop</span><span class="SItr">,back</span> <span class="SNum">3</span>
    {
        <span class="SLgc">if</span>   cpt == <span class="SNum">0</span> <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">2</span>)
        <span class="SLgc">elif</span> cpt == <span class="SNum">1</span> <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">1</span>)
        <span class="SLgc">elif</span> cpt == <span class="SNum">2</span> <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">0</span>)

        cpt += <span class="SNum">1</span>
    }
}</span></div>
<h3 id="051_loop_break,_continue">break, continue </h3>
<p><span class="code-inline">break</span> and <span class="code-inline">continue</span> can be used inside a loop. </p>
<p>You can exit a loop with <span class="code-inline">break</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">loop</span> x: <span class="SNum">10</span>
    {
        <span class="SLgc">if</span> x == <span class="SNum">5</span>
            <span class="SLgc">break</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">5</span>)
}</span></div>
<p>You can force to return to the loop evaluation with <span class="code-inline">continue</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">loop</span> x: <span class="SNum">10</span>
    {
        <span class="SLgc">if</span> x == <span class="SNum">5</span>
            <span class="SLgc">continue</span> <span class="SCmt">// Do not count 5</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">9</span>)
}</span></div>
<h3 id="051_loop_Ranges">Ranges </h3>
<p>Loop can also be used to iterate on a <b>range</b> of signed values. </p>
<p>You can add <span class="code-inline">to</span> to loop from a given value <i>to</i> a given value. Note that the range should always have a first value lower or equal to the upper bound. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> count = <span class="SNum">0</span>
    <span class="SKwd">var</span> sum = <span class="SNum">0</span>
    <span class="SLgc">loop</span> i: -<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">1</span>   <span class="SCmt">// loop from -1 to 1, all included</span>
    {
        count += <span class="SNum">1</span>
        sum += i
    }

    <span class="SItr">@assert</span>(sum == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(count == <span class="SNum">3</span>)
}</span></div>
<p>You can exclude the last value with by using <span class="code-inline">until</span> instead of <span class="code-inline">to</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Will loop from 1 to 2 and **not** 1 to 3</span>
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">loop</span> i: <span class="SNum">1</span> <span class="SLgc">until</span> <span class="SNum">3</span>
    {
        cpt += i
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span>+<span class="SNum">2</span>)
}</span></div>
<p>With a range, you can also loop in reverse order if you add the <span class="code-inline">back</span> modifier. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Loop from 5 to 0</span>
    <span class="SLgc">loop</span><span class="SItr">,back</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">5</span>
    {
    }

    <span class="SCmt">// Loop from 1 to -1</span>
    <span class="SLgc">loop</span><span class="SItr">,back</span> -<span class="SNum">1</span> <span class="SLgc">to</span> <span class="SNum">1</span>
    {
    }

    <span class="SCmt">// Loop from 1 to -2 because we exclude the upper limit.</span>
    <span class="SLgc">loop</span><span class="SItr">,back</span> -<span class="SNum">2</span> <span class="SLgc">until</span> <span class="SNum">2</span>
    {
    }
}</span></div>
<h3 id="051_loop_Infinite_loop">Infinite loop </h3>
<p>A loop without an expression but with a block is infinite. This is equivalent to <span class="code-inline">while true {}</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">loop</span>
    {
        <span class="SLgc">if</span> <span class="SItr">@index</span> == <span class="SNum">4</span> <span class="SCmt">// @index is still valid in that case (but cannot be renamed)</span>
            <span class="SLgc">break</span>
    }
}</span></div>

<h2 id="052_visit">Visit</h2><p><span class="code-inline">visit</span> is used to visit all the elements of a collection. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Here we visit every bytes of the string.</span>
    <span class="SCmt">// At each iteration, the byte will be stored in the variable 'value'</span>
    <span class="SLgc">visit</span> value: <span class="SStr">"ABC"</span>
    {
        <span class="SCmt">// '@index' is also available. It stores the loop index.</span>
        <span class="SKwd">let</span> a = <span class="SItr">@index</span>
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`A`</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`B`</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`C`</span>)
        }
    }
}</span></div>
<p>You can name both the <b>value</b> and the loop <b>index</b>, in that order. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">visit</span> value, index: <span class="SStr">"ABC"</span>
    {
        <span class="SKwd">let</span> a = index
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`A`</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`B`</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`C`</span>)
        }
    }
}</span></div>
<p>Both names are optional. In that case, you can use <span class="code-inline">@alias0</span> and <span class="code-inline">@alias1</span>. <span class="code-inline">@alias0</span> for the value, and <span class="code-inline">@alias1</span> for the index. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">visit</span> <span class="SStr">"ABC"</span>
    {
        <span class="SKwd">let</span> a = <span class="SItr">@alias1</span>    <span class="SCmt">// This is the index</span>
        <span class="SItr">@assert</span>(a == <span class="SItr">@index</span>)
        <span class="SLgc">switch</span> a
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@assert</span>(<span class="SItr">@alias0</span> == <span class="SStr">`A`</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@assert</span>(<span class="SItr">@alias0</span> == <span class="SStr">`B`</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@assert</span>(<span class="SItr">@alias0</span> == <span class="SStr">`C`</span>)
        }
    }
}</span></div>
<p>You can visit in reverse order by adding the <span class="code-inline">back</span> modifier. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Here we visit every bytes of the string.</span>
    <span class="SCmt">// At each iteration, the byte will be stored in the variable 'value'</span>
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">visit</span><span class="SItr">,back</span> value: <span class="SStr">"ABC"</span>
    {
        <span class="SCmt">// '@index' is also available. It stores the loop index.</span>
        <span class="SLgc">switch</span> cpt
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`C`</span>); <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">2</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`B`</span>); <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">1</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@assert</span>(value == <span class="SStr">`A`</span>); <span class="SItr">@assert</span>(<span class="SItr">@index</span> == <span class="SNum">0</span>)
        }

        cpt += <span class="SNum">1</span>
    }
}</span></div>
<p>You can visit arrays or slices. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array = [<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>]

    <span class="SKwd">var</span> result = <span class="SNum">0</span>
    <span class="SLgc">visit</span> it: array
        result += it

    <span class="SItr">@assert</span>(result == <span class="SNum">10</span>+<span class="SNum">20</span>+<span class="SNum">30</span>)
}</span></div>
<p>Works also for multi dimensional arrays. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span> = [[<span class="SNum">10</span>, <span class="SNum">20</span>], [<span class="SNum">30</span>, <span class="SNum">40</span>]]

    <span class="SKwd">var</span> result = <span class="SNum">0</span>
    <span class="SLgc">visit</span> it: array
        result += it

    <span class="SItr">@assert</span>(result == <span class="SNum">10</span>+<span class="SNum">20</span>+<span class="SNum">30</span>+<span class="SNum">40</span>)
}</span></div>
<p>You can visit with a pointer to the value, and not the value itself, by adding <span class="code-inline">&</span> before the value name. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> array: [<span class="SNum">2</span>, <span class="SNum">2</span>] <span class="STpe">s32</span> = [[<span class="SNum">1</span>, <span class="SNum">2</span>], [<span class="SNum">3</span>, <span class="SNum">4</span>]]

    <span class="SKwd">var</span> result = <span class="SNum">0</span>
    <span class="SLgc">visit</span> &it: array
    {
        result += <span class="SKwd">dref</span> it
        <span class="SKwd">dref</span> it = <span class="SNum">555</span>
    }

    <span class="SItr">@assert</span>(result == <span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)

    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>, <span class="SNum">0</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">0</span>, <span class="SNum">1</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>, <span class="SNum">0</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(array[<span class="SNum">1</span>, <span class="SNum">1</span>] == <span class="SNum">555</span>)
}</span></div>

<h2 id="053_for">For</h2><p><span class="code-inline">for</span> accepts a <i>start statement</i>, an <i>expression to test</i>, and an <i>ending statement</i>. This is in fact the same as the C/C++ <span class="code-inline">for</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>
        cpt += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)

    <span class="SCmt">// ';' can be replaced by a newline (like always)</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>
        i &lt; <span class="SNum">10</span>
        i += <span class="SNum">1</span>
    {
        cpt += <span class="SNum">1</span>
    }
    <span class="SItr">@assert</span>(cpt == <span class="SNum">20</span>)

    <span class="SCmt">// Instead of one single expression, you can use a statement</span>
    <span class="SLgc">for</span> { <span class="SKwd">var</span> i = <span class="SNum">0</span>; cpt = <span class="SNum">0</span>; }
        i &lt; <span class="SNum">10</span>
        i += <span class="SNum">1</span>
    {
        cpt += <span class="SNum">1</span>
    }
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)

    <span class="SLgc">for</span> { <span class="SKwd">var</span> i = <span class="SNum">0</span>; cpt = <span class="SNum">0</span>; }
        i &lt; <span class="SNum">10</span>
        { i += <span class="SNum">2</span>; i -= <span class="SNum">1</span>; }
    {
        cpt += <span class="SNum">1</span>
    }
    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)
}</span></div>
<p>Like <span class="code-inline">loop</span>, <span class="code-inline">visit</span> and <span class="code-inline">while</span>, you have access to <span class="code-inline">@index</span>, the <b>current loop index</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>'<span class="STpe">u64</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i: <span class="STpe">u32</span> = <span class="SNum">10</span>; i &lt; <span class="SNum">15</span>; i += <span class="SNum">1</span>
        cpt += <span class="SItr">@index</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span>+<span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)

    <span class="SKwd">var</span> cpt1 = <span class="SNum">0</span>'<span class="STpe">u64</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">10</span>; i &lt; <span class="SNum">15</span>; i += <span class="SNum">1</span>
        cpt1 += <span class="SItr">@index</span>
    <span class="SItr">@assert</span>(cpt1 == <span class="SNum">0</span>+<span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)
}</span></div>

<h2 id="054_while">While</h2><p><span class="code-inline">while</span> is a loop that runs <b>until the expression is false</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> i = <span class="SNum">0</span>
    <span class="SLgc">while</span> i &lt; <span class="SNum">10</span>
        i += <span class="SNum">1</span>
    <span class="SItr">@assert</span>(i == <span class="SNum">10</span>)
}</span></div>
<p>You can also <span class="code-inline">break</span> and <span class="code-inline">continue</span> inside a <span class="code-inline">while</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> i = <span class="SNum">0</span>
    <span class="SLgc">while</span> i &lt; <span class="SNum">10</span>
    {
        <span class="SLgc">if</span> i == <span class="SNum">5</span>
            <span class="SLgc">break</span>
        i += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(i == <span class="SNum">5</span>)
}</span></div>

<h2 id="055_switch">Switch</h2><p><span class="code-inline">switch</span> works like in C/C++, except that no <span class="code-inline">break</span> is necessary (except if the <span class="code-inline">case</span> is empty). That means that there's no automatic <span class="code-inline">fallthrough</span> from one case to another. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">0</span>:  <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">5</span>:  <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">6</span>:  <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>: <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SKwd">let</span> ch = <span class="SStr">`A`</span>'<span class="STpe">rune</span>
    <span class="SLgc">switch</span> ch
    {
    <span class="SLgc">case</span> <span class="SStr">`B`</span>: <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SStr">`A`</span>: <span class="SLgc">break</span>
    }
}</span></div>
<p>You can put multiple values on the same <span class="code-inline">case</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">2</span>, <span class="SNum">4</span>, <span class="SNum">6</span>:   <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>:        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">2</span>,
         <span class="SNum">4</span>,
         <span class="SNum">6</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<p><span class="code-inline">switch</span> works with every types that accept the <span class="code-inline">==</span> operator. So you can use it on strings for example. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SStr">"myString"</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SStr">"myString"</span>:    <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">case</span> <span class="SStr">"otherString"</span>: <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">default</span>:            <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<p>If you want to pass from one case to another like in C/C++, use <span class="code-inline">fallthrough</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">6</span>:
        <span class="SLgc">fallthrough</span>
    <span class="SLgc">case</span> <span class="SNum">7</span>:
        <span class="SItr">@assert</span>(value == <span class="SNum">6</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    }
}</span></div>
<p><span class="code-inline">break</span> can be used to exit the current <span class="code-inline">case</span> statement. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">6</span>:
        <span class="SLgc">if</span> value == <span class="SNum">6</span>
            <span class="SLgc">break</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<p>A <span class="code-inline">case</span> statement cannot be empty. Use <span class="code-inline">break</span> if you want to do nothing. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>
    <span class="SLgc">switch</span> value
    {
    <span class="SLgc">case</span> <span class="SNum">5</span>:     <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">6</span>:     <span class="SLgc">break</span>
    <span class="SLgc">default</span>:    <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<p>A <span class="code-inline">case</span> expression doesn't need to be constant. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> test = <span class="SNum">2</span>
    <span class="SKwd">let</span> a = <span class="SNum">0</span>
    <span class="SKwd">let</span> b = <span class="SNum">1</span>

    <span class="SLgc">switch</span> test
    {
    <span class="SLgc">case</span> a:     <span class="SCmt">// Test with a variable</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> b:     <span class="SCmt">// Test with a variable</span>
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> b + <span class="SNum">1</span>: <span class="SCmt">// Test with an expression</span>
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    }
}</span></div>
<h3 id="055_switch_The_complete_attribute">The complete attribute </h3>
<p><span class="code-inline">switch</span> can be marked with <span class="code-inline">Swag.Complete</span> to force all the cases to be covered. If one or more values are missing, an error will be raised by the compiler. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">Color</span> { <span class="SCst">Red</span>, <span class="SCst">Green</span>, <span class="SCst">Blue</span> }
    <span class="SKwd">let</span> color = <span class="SCst">Color</span>.<span class="SCst">Red</span>

    <span class="SAtr">#[Swag.Complete]</span>
    <span class="SLgc">switch</span> color
    {
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Red</span>:     <span class="SLgc">break</span>
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Green</span>:   <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SCst">Color</span>.<span class="SCst">Blue</span>:    <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h3 id="055_switch_On_specific_types">On specific types </h3>
<p>When used on a variable of type <span class="code-inline">any</span> or <span class="code-inline">interface</span>, the switch is done on the underlying variable type. This is in fact equivalent of calling the <span class="code-inline">@kindof</span> intrinsic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"value"</span>

    <span class="SLgc">switch</span> x    <span class="SCmt">// implicit call of @kindof(x)</span>
    {
    <span class="SLgc">case</span> <span class="STpe">string</span>: <span class="SLgc">break</span>
    <span class="SLgc">default</span>:     <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>
<h3 id="055_switch_On_ranges">On ranges </h3>
<p>A <span class="code-inline">switch</span> can also be used with a (constant) <b>range of values</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> success = <span class="SKwd">false</span>
    <span class="SKwd">let</span> x = <span class="SNum">6</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">5</span>:  <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    <span class="SLgc">case</span> <span class="SNum">6</span> <span class="SLgc">to</span> <span class="SNum">15</span>: success = <span class="SKwd">true</span>
    }

    <span class="SItr">@assert</span>(success)
}</span></div>
<p>If they overlap, the first valid range will be used. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> success = <span class="SKwd">false</span>
    <span class="SKwd">let</span> x = <span class="SNum">6</span>
    <span class="SLgc">switch</span> x
    {
    <span class="SLgc">case</span> <span class="SNum">0</span> <span class="SLgc">to</span> <span class="SNum">10</span>:    success = <span class="SKwd">true</span>
    <span class="SLgc">case</span> <span class="SNum">5</span> <span class="SLgc">until</span> <span class="SNum">15</span>: <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SItr">@assert</span>(success)
}</span></div>
<h3 id="055_switch_Without_an_expression">Without an expression </h3>
<p>If the switch expression is omitted, then it will behave like a serie of <span class="code-inline">if/else</span>, resolved in order. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> value = <span class="SNum">6</span>
    <span class="SKwd">let</span> value1 = <span class="SStr">"true"</span>

    <span class="SLgc">switch</span>
    {
    <span class="SLgc">case</span> value == <span class="SNum">6</span> <span class="SLgc">or</span> value == <span class="SNum">7</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
        <span class="SLgc">fallthrough</span>
    <span class="SLgc">case</span> value1 == <span class="SStr">"true"</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">true</span>)
    <span class="SLgc">default</span>:
        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>

<h2 id="056_break">Break</h2><p>We have already seen than <span class="code-inline">break</span> is used to exit a <span class="code-inline">loop</span>, <span class="code-inline">visit</span>, <span class="code-inline">while</span>, <span class="code-inline">for</span>, <span class="code-inline">switch</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SLgc">loop</span> <span class="SNum">10</span>
        <span class="SLgc">break</span>
    <span class="SLgc">for</span> <span class="SKwd">var</span> i = <span class="SNum">0</span>; i &lt; <span class="SNum">10</span>; i += <span class="SNum">1</span>
        <span class="SLgc">break</span>
    <span class="SLgc">while</span> <span class="SKwd">false</span>
        <span class="SLgc">break</span>
}</span></div>
<p>By default, <span class="code-inline">break</span> will exit the parent scope only. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">loop</span> <span class="SNum">10</span>
    {
        <span class="SLgc">loop</span> <span class="SNum">10</span>
        {
            <span class="SLgc">break</span>   <span class="SCmt">// Exit the inner loop...</span>
        }

        <span class="SCmt">// ...and continue execution here</span>
        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">10</span>)
}</span></div>
<p>But you can <b>name a scope</b> with the <span class="code-inline">#scope</span> compiler keyword, and exit to the end of it with a <span class="code-inline">break</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// Creates a scope named 'BigScope'</span>
    <span class="SCmp">#scope</span> <span class="SCst">BigScope</span>
    {
        <span class="SLgc">loop</span> <span class="SNum">10</span>
        {
            cpt += <span class="SNum">1</span>
            <span class="SLgc">break</span> <span class="SCst">BigScope</span>  <span class="SCmt">// Break to the outer scope...</span>
        }

        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }

    <span class="SCmt">// ...and continue execution here</span>
    <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span>)
}</span></div>
<p>When used with a scope, a continue is a way to go back to the start of the scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SCmp">#scope</span> <span class="SCst">Loop</span>
    {
        cpt += <span class="SNum">1</span>
        <span class="SLgc">if</span> cpt == <span class="SNum">5</span>
            <span class="SLgc">break</span>
        <span class="SLgc">continue</span>    <span class="SCmt">// Loop</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">5</span>)
}</span></div>
<p>You are not obliged to name the scope, so this can also be used (for example) as an alternative of a bunch of if/else. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> cpt = <span class="SNum">0</span>
    <span class="SCmp">#scope</span>
    {
        <span class="SLgc">if</span> cpt == <span class="SNum">1</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">1</span>)
            <span class="SLgc">break</span>
        }

        <span class="SLgc">if</span> cpt == <span class="SNum">2</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">2</span>)
            <span class="SLgc">break</span>
        }

        <span class="SLgc">if</span> cpt == <span class="SNum">3</span>
        {
            <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
            <span class="SLgc">break</span>
        }
    }
}</span></div>
<p>Note that a scope can be followed by a simple statement, not always a block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmp">#scope</span> <span class="SCst">Up</span> <span class="SLgc">loop</span> <span class="SNum">10</span>
    {
        <span class="SLgc">loop</span> <span class="SNum">10</span>
        {
            <span class="SLgc">if</span> <span class="SItr">@index</span> == <span class="SNum">5</span>
                <span class="SLgc">break</span> <span class="SCst">Up</span>
        }

        <span class="SItr">@assert</span>(<span class="SKwd">false</span>)
    }
}</span></div>

<h2 id="060_struct">Struct</h2>
<h3 id="060_struct_061_001_declaration">Declaration</h3><p>This is a <span class="code-inline">struct</span> declaration. Note that <span class="code-inline">var</span> is not necessary for the fields. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        name: <span class="STpe">string</span>
    }

    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x:      <span class="STpe">s32</span>
        y, z:   <span class="STpe">s32</span>
        val:    <span class="STpe">bool</span>
        myS:    <span class="SCst">MyStruct</span>
    }
}</span></div>
<p>Variables can also be separated with <span class="code-inline">;</span> or <span class="code-inline">,</span>. The last one is not mandatory. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>{name: <span class="STpe">string</span>, val1: <span class="STpe">bool</span>}
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>{x: <span class="STpe">s32</span>; y, z: <span class="STpe">s32</span>; val: <span class="STpe">bool</span>; myS: <span class="SCst">MyStruct</span>}
}</span></div>
<p>A struct can be anonymous when declared as a variable type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> tuple: <span class="SKwd">struct</span>
    {
        x: <span class="STpe">f32</span>
        y: <span class="STpe">f32</span>
    }
    <span class="SKwd">var</span> tuple1: <span class="SKwd">struct</span>{x, y: <span class="STpe">f32</span>}

    tuple.x = <span class="SNum">1.0</span>
    tuple.y = <span class="SNum">2.0</span>
    <span class="SItr">@assert</span>(tuple.x == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(tuple.y == <span class="SNum">2.0</span>)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        rgb: <span class="SKwd">struct</span>{x, y, z: <span class="STpe">f32</span>}
        hsl: <span class="SKwd">struct</span>{h, s, l: <span class="STpe">f32</span>}
    }
}</span></div>
<p>The fields of a struct can be initialized at the declaration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x: <span class="STpe">s32</span>    = <span class="SNum">666</span>
        y: <span class="STpe">string</span> = <span class="SStr">"454"</span>
    }

    <span class="SKwd">var</span> v = <span class="SCst">MyStruct</span>{}
    <span class="SItr">@assert</span>(v.x == <span class="SNum">666</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SStr">"454"</span>)
}</span></div>
<p>You can initialize a struct variable in different ways. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// At fields declaration</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x, y: <span class="STpe">s32</span> = <span class="SNum">1</span>
    }

    <span class="SCmt">// Without parameters, all fields will have the default values as defined</span>
    <span class="SCmt">// in the struct itself.</span>
    <span class="SKwd">var</span> v0: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(v0.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(v0.y == <span class="SNum">1</span>)

    <span class="SCmt">// You can add parameters between {..}</span>
    <span class="SCmt">// The initialization must be done in the order of the fields.</span>
    <span class="SKwd">var</span> v1: <span class="SCst">MyStruct</span>{<span class="SNum">10</span>, <span class="SNum">20</span>}
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">20</span>)

    <span class="SCmt">// You can name fields, and omit some.</span>
    <span class="SKwd">var</span> v2 = <span class="SCst">MyStruct</span>{y: <span class="SNum">20</span>}
    <span class="SItr">@assert</span>(v2.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(v2.y == <span class="SNum">20</span>)

    <span class="SCmt">// You can assign a tuple as long as the types are correct.</span>
    <span class="SKwd">var</span> v3: <span class="SCst">MyStruct</span> = {<span class="SNum">10</span>, <span class="SNum">20</span>}
    <span class="SItr">@assert</span>(v3.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(v3.y == <span class="SNum">20</span>)
}</span></div>
<p>A struct can be affected to a constant, as long as it can be evaluated at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x: <span class="STpe">s32</span>    = <span class="SNum">666</span>
        y: <span class="STpe">string</span> = <span class="SStr">"454"</span>
    }

    <span class="SKwd">const</span> <span class="SCst">X</span>: <span class="SCst">MyStruct</span>{<span class="SNum">50</span>, <span class="SStr">"value"</span>}
    <span class="SCmp">#assert</span> <span class="SCst">X</span>.x == <span class="SNum">50</span>
    <span class="SCmp">#assert</span> <span class="SCst">X</span>.y == <span class="SStr">"value"</span>
}</span></div>
<p>A function can take an argument of type <span class="code-inline">struct</span>. No copy is done (this is equivalent to a const reference in C++). </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct3</span>
{
    x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span>
}

<span class="SKwd">func</span> <span class="SFct">toto</span>(v: <span class="SCst">Struct3</span>)
{
    <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)
}

<span class="SKwd">func</span> <span class="SFct">titi</span>(v: <span class="SCst">Struct3</span>)
{
    <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// Call with a struct literal</span>
    <span class="SFct">toto</span>(<span class="SCst">Struct3</span>{<span class="SNum">5</span>, <span class="SNum">5</span>, <span class="SNum">666</span>})

    <span class="SCmt">// Type can be deduced from the argument</span>
    <span class="SFct">toto</span>({<span class="SNum">5</span>, <span class="SNum">5</span>, <span class="SNum">666</span>})

    <span class="SCmt">// You can also just specify some parts of the struct, in the declaration order of the fields</span>
    <span class="SFct">titi</span>({<span class="SNum">5</span>})      <span class="SCmt">// Initialize x, which is the first field</span>
    <span class="SFct">titi</span>({<span class="SNum">5</span>, <span class="SNum">666</span>}) <span class="SCmt">// Initialize x and y</span>

    <span class="SCmt">// You can also name the fields, and omit some of them</span>
    <span class="SFct">titi</span>({x: <span class="SNum">5</span>, z: <span class="SNum">5</span>}) <span class="SCmt">// Here y will stay to the default value, which is 666</span>
}</span></div>

<h3 id="060_struct_062_002_impl">Impl</h3><p>Like for an enum, <span class="code-inline">impl</span> is used to declare some stuff in the scope of a struct. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ExportType("methods")]</span>   <span class="SCmt">// See later, used to export 'methods' in type reflection</span>
<span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
{
    x: <span class="STpe">s32</span> = <span class="SNum">5</span>
    y: <span class="STpe">s32</span> = <span class="SNum">10</span>
    z: <span class="STpe">s32</span> = <span class="SNum">20</span>
}

<span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SCmt">// Declare a constant in the scope of the struct</span>
    <span class="SKwd">const</span> <span class="SCst">MyConst</span> = <span class="SKwd">true</span>

    <span class="SCmt">// Declare a function in the scope of the struct</span>
    <span class="SKwd">func</span> <span class="SFct">returnTrue</span>() =&gt; <span class="SKwd">true</span>
}</span></div>
<p>So to access the constant and the function, you have to use the <span class="code-inline">MyStruct</span> namespace. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SCst">MyStruct</span>.<span class="SCst">MyConst</span>)
    <span class="SItr">@assert</span>(<span class="SCst">MyStruct</span>.<span class="SFct">returnTrue</span>())
}</span></div>
<p>You can have multiple <span class="code-inline">impl</span> blocks. The difference with a namespace is that <span class="code-inline">self</span> and <span class="code-inline">Self</span> are defined inside an <span class="code-inline">impl</span> block. They refere to the corresponding type. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SCmt">// 'self' is an alias for 'var self: Self'</span>
    <span class="SKwd">func</span> <span class="SFct">returnX</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>) =&gt; x
    <span class="SKwd">func</span> <span class="SFct">returnY</span>(<span class="SKwd">self</span>)       =&gt; <span class="SKwd">self</span>.y

    <span class="SCmt">// 'Self' is the corresponding type, in that case 'MyStruct'</span>
    <span class="SKwd">func</span> <span class="SFct">returnZ</span>(me: <span class="SKwd">Self</span>)   =&gt; me.z
}</span></div>
<p>If you declare your function with <span class="code-inline">mtd</span> (method) instead of <span class="code-inline">func</span>, then the first parameter is forced to be <span class="code-inline">using self</span>. If you declare your function with <span class="code-inline">mtd const</span> (method const) instead of <span class="code-inline">func</span>, then the first parameter is forced to be <span class="code-inline">const using self</span>. Other than that, it's exactly the same. So this is just <b>syntaxic sugar</b> to avoid repeating the <span class="code-inline">using self</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SKwd">mtd</span>  <span class="SFct">methodReturnX</span>()          =&gt; x
    <span class="SKwd">func</span> <span class="SFct">funcReturnX</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>)  =&gt; x
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> c: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(c.<span class="SFct">returnX</span>() == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(c.<span class="SFct">methodReturnX</span>() == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(c.<span class="SFct">funcReturnX</span>() == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(c.<span class="SFct">returnY</span>() == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(c.<span class="SFct">returnZ</span>() == <span class="SNum">20</span>)
}</span></div>
<p>All functions in an <span class="code-inline">impl</span> block can be retrieved by reflection, as long as the struct is declared with <span class="code-inline">#[Swag.ExportType("methods")]</span> (by default, methods are not exported). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Creates a type alias named 'Lambda'</span>
    <span class="SKwd">typealias</span> <span class="SCst">Lambda</span> = <span class="SKwd">func</span>(<span class="SCst">MyStruct</span>)-&gt;<span class="STpe">s32</span>

    <span class="SKwd">var</span> fnX: <span class="SCst">Lambda</span>
    <span class="SKwd">var</span> fnY: <span class="SCst">Lambda</span>
    <span class="SKwd">var</span> fnZ: <span class="SCst">Lambda</span>

    <span class="SCmt">// The 'typeinfo' of a struct contains a field 'methods' which is a slice</span>
    <span class="SKwd">let</span> t = <span class="SItr">@typeof</span>(<span class="SCst">MyStruct</span>)
    <span class="SLgc">visit</span> p: t.methods
    {
        <span class="SCmt">// When visiting 'methods', the 'value' field contains the function pointer,</span>
        <span class="SCmt">// which can be casted to the correct type</span>
        <span class="SLgc">switch</span> p.name
        {
        <span class="SLgc">case</span> <span class="SStr">"returnX"</span>: fnX = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value
        <span class="SLgc">case</span> <span class="SStr">"returnY"</span>: fnY = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value
        <span class="SLgc">case</span> <span class="SStr">"returnZ"</span>: fnZ = <span class="SKwd">cast</span>(<span class="SCst">Lambda</span>) p.value
        }
    }

    <span class="SCmt">// These are now valid functions, which can be called</span>
    <span class="SKwd">var</span> v: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(<span class="SFct">fnX</span>(v) == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(<span class="SFct">fnY</span>(v) == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(<span class="SFct">fnZ</span>(v) == <span class="SNum">20</span>)
}</span></div>

<h3 id="060_struct_063_003_special_functions">Special functions</h3><p>A struct can have special operations in the <span class="code-inline">impl</span> block. This operations are predefined, and known by the compiler.This is the way to go to <b>overload operators</b> for example. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct</span>
{
    x, y: <span class="STpe">s32</span>
}

<span class="SKwd">typealias</span> <span class="SCst">OneType</span>      = <span class="STpe">bool</span>
<span class="SKwd">typealias</span> <span class="SCst">AnotherType</span>  = <span class="STpe">s32</span>
<span class="SKwd">typealias</span> <span class="SCst">WhateverType</span> = <span class="STpe">bool</span>

<span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SCmt">// Called each time a variable needs to be dropped</span>
    <span class="SCmt">// This is the destructor in C++</span>
    <span class="SKwd">func</span> <span class="SFct">opDrop</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>) {}

    <span class="SCmt">// Called after a raw copy operation from one value to another</span>
    <span class="SKwd">func</span> <span class="SFct">opPostCopy</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>) {}

    <span class="SCmt">// Called after a move semantic operation from one value to another. We'll see that later.</span>
    <span class="SKwd">func</span> <span class="SFct">opPostMove</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>) {}

    <span class="SCmt">// Get value by slice [low..up]</span>
    <span class="SCmt">// Must return a string or a slice</span>
    <span class="SKwd">func</span> <span class="SFct">opSlice</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, low, up: <span class="STpe">u64</span>)-&gt;<span class="STpe">string</span> { <span class="SLgc">return</span> <span class="SStr">"true"</span>; }

    <span class="SCmt">// Get value by index</span>
    <span class="SKwd">func</span> <span class="SFct">opIndex</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, index: <span class="STpe">u64</span>)-&gt;<span class="SCst">WhateverType</span> { <span class="SLgc">return</span> <span class="SKwd">true</span>; }

    <span class="SCmt">// Called by @countof</span>
    <span class="SCmt">// Use in a 'loop' block for example</span>
    <span class="SKwd">func</span> <span class="SFct">opCount</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>)-&gt;<span class="STpe">u64</span>          { <span class="SLgc">return</span> <span class="SNum">0</span>; }
    <span class="SCmt">// Called by @dataof</span>
    <span class="SKwd">func</span> <span class="SFct">opData</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>)-&gt;*<span class="SCst">WhateverType</span>  { <span class="SLgc">return</span> <span class="SKwd">null</span>; }

    <span class="SCmt">// Called for explicit/implicit casting between struct value and return type</span>
    <span class="SCmt">// Can be overloaded by a different return type</span>
    <span class="SCmt">// Example: var x = cast(OneType) v</span>
    <span class="SKwd">func</span> <span class="SFct">opCast</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>)-&gt;<span class="SCst">OneType</span>      { <span class="SLgc">return</span> <span class="SKwd">true</span>; }
    <span class="SKwd">func</span> <span class="SFct">opCast</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>)-&gt;<span class="SCst">AnotherType</span>  { <span class="SLgc">return</span> <span class="SNum">0</span>; }

    <span class="SCmt">// Called to compare the struct value with something else</span>
    <span class="SCmt">// Can be overloaded</span>
    <span class="SCmt">// Returns true if they are equal, otherwise returns false</span>
    <span class="SCmt">// Called by '==', '!='</span>
    <span class="SKwd">func</span> <span class="SFct">opEquals</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="STpe">bool</span>      { <span class="SLgc">return</span> <span class="SKwd">false</span>; }
    <span class="SKwd">func</span> <span class="SFct">opEquals</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="STpe">bool</span>  { <span class="SLgc">return</span> <span class="SKwd">false</span>; }

    <span class="SCmt">// Called to compare the struct value with something else</span>
    <span class="SCmt">// Can be overloaded</span>
    <span class="SCmt">// Returns -1, 0 or 1</span>
    <span class="SCmt">// Called by '&lt;', '&gt;', '&lt;=', '&gt;=', '&lt;=&gt;'</span>
    <span class="SKwd">func</span> <span class="SFct">opCmp</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="STpe">s32</span>      { <span class="SLgc">return</span> <span class="SNum">0</span>; }
    <span class="SKwd">func</span> <span class="SFct">opCmp</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="STpe">s32</span>  { <span class="SLgc">return</span> <span class="SNum">0</span>; }

    <span class="SCmt">// Affect struct with another value</span>
    <span class="SCmt">// Can be overloaded</span>
    <span class="SCmt">// Called by '='</span>
    <span class="SKwd">func</span> <span class="SFct">opAffect</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">OneType</span>) {}
    <span class="SKwd">func</span> <span class="SFct">opAffect</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Affect struct with a literal value with a specified suffix</span>
    <span class="SCmt">// Generic function, can be overloaded</span>
    <span class="SCmt">// Called by '='</span>
    <span class="SKwd">func</span>(suffix: <span class="STpe">string</span>) <span class="SFct">opAffectSuffix</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SKwd">func</span>(suffix: <span class="STpe">string</span>) <span class="SFct">opAffectSuffix</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Affect struct with another value at a given index</span>
    <span class="SCmt">// Can be overloaded</span>
    <span class="SCmt">// Called by '[] ='</span>
    <span class="SKwd">func</span> <span class="SFct">opIndexAffect</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, index: <span class="STpe">u64</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SKwd">func</span> <span class="SFct">opIndexAffect</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, index: <span class="STpe">u64</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Binary operator. 'op' generic argument contains the operator string</span>
    <span class="SCmt">// Generic function, can be overloaded</span>
    <span class="SCmt">// Called by '+', '-', '*', '/', '%', '|', '&', '^', '&lt;&lt;', '&gt;&gt;'</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opBinary</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">OneType</span>)-&gt;<span class="SKwd">Self</span>     { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opBinary</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">AnotherType</span>)-&gt;<span class="SKwd">Self</span> { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }

    <span class="SCmt">// Unary operator. 'op' generic argument contains the operator string (see below)</span>
    <span class="SCmt">// Generic function</span>
    <span class="SCmt">// Called by '!', '-', '~'</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opUnary</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>)-&gt;<span class="SKwd">Self</span> { <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}; }

    <span class="SCmt">// Affect operator. 'op' generic argument contains the operator string (see below)</span>
    <span class="SCmt">// Generic function, can be overloaded</span>
    <span class="SCmt">// Called by '+=', '-=', '*=', '/=', '%=', '|=', '&=', '^=', '&lt;&lt;=', '&gt;&gt;='</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opAssign</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">OneType</span>) {}
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opAssign</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, other: <span class="SCst">AnotherType</span>)  {}

    <span class="SCmt">// Affect operator. 'op' generic argument contains the operator string (see below)</span>
    <span class="SCmt">// Generic function, can be overloaded</span>
    <span class="SCmt">// Called by '+=', '-=', '*=', '/=', '%=', '|=', '&=', '^=', '&lt;&lt;=', '&gt;&gt;='</span>
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opIndexAssign</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, index: <span class="STpe">u64</span>, value: <span class="SCst">OneType</span>) {}
    <span class="SKwd">func</span>(op: <span class="STpe">string</span>) <span class="SFct">opIndexAssign</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, index: <span class="STpe">u64</span>, value: <span class="SCst">AnotherType</span>) {}

    <span class="SCmt">// Called by a 'visit' block</span>
    <span class="SCmt">// Can have multiple versions, by adding a name after 'opVisit'</span>
    <span class="SCmt">// This is the way to go for iterators</span>
    <span class="SAtr">#[Swag.Macro]</span>
    {
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisit</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, stmt: <span class="STpe">code</span>) {}
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitWhatever</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, stmt: <span class="STpe">code</span>) {}
        <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitAnother</span>(<span class="SKwd">using</span> <span class="SKwd">self</span>, stmt: <span class="STpe">code</span>) {}
    }
}</span></div>

<h3 id="060_struct_064_004_affectation">Affectation</h3><p><span class="code-inline">opAffect</span> is a way of assigning to a struct with <span class="code-inline">=</span>. You can have more the one <span class="code-inline">opAffect</span> with different types. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Struct</span>
{
    x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span>
}

<span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">s32</span>)  { x, y = value; }
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">bool</span>) { x, y = value ? <span class="SNum">1</span> : <span class="SNum">0</span>; }
}

<span class="SFct">#test</span>
{
    <span class="SCmt">// This will initialize v and then call opAffect(s32) with '4'</span>
    <span class="SKwd">var</span> v: <span class="SCst">Struct</span> = <span class="SNum">4</span>'<span class="STpe">s32</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">4</span>)
    <span class="SCmt">// Note that variable 'v' is also initiliazed with the default values.</span>
    <span class="SCmt">// So here 'z' is still 666 because 'opAffect' does not change it.</span>
    <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)

    <span class="SCmt">// This will call opAffect(bool) with 'true'</span>
    <span class="SKwd">var</span> v1: <span class="SCst">Struct</span> = <span class="SKwd">true</span>
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">1</span>)

    <span class="SCmt">// This will call opAffect(bool) with 'false'</span>
    v1 = <span class="SKwd">false</span>
    <span class="SItr">@assert</span>(v1.x == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(v1.y == <span class="SNum">0</span>)
}</span></div>
<p>If <span class="code-inline">opAffect</span> is supposed to initialize the full content of the struct, you can add <span class="code-inline">#[Swag.Complete]</span>. This will avoid every variables to be initialized to the default values, then changed later with the <span class="code-inline">opAffect</span> call. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">Struct</span>
{
    <span class="SAtr">#[Swag.Complete]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">u64</span>)  { x, y, z = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) value; }

    <span class="SCmt">// For later</span>
    <span class="SAtr">#[Swag.Implicit]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(value: <span class="STpe">u16</span>)  { x, y = <span class="SKwd">cast</span>(<span class="STpe">s32</span>) value; }
}</span></div>
<p>Here the variable <span class="code-inline">v</span> will not be initialized prior to the affectation. This is more optimal, as there's only one initialization. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v: <span class="SCst">Struct</span> = <span class="SNum">2</span>'<span class="STpe">u64</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(v.z == <span class="SNum">2</span>)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>(v: <span class="SCst">Struct</span>)
    {
        <span class="SItr">@assert</span>(v.x == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(v.y == <span class="SNum">5</span>)
        <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)
    }

    <span class="SKwd">func</span> <span class="SFct">titi</span>(v: <span class="SCst">Struct</span>)
    {
        <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
    }

    <span class="SCmt">// By default, there's no automatic conversion for a function argument, so you must cast.</span>
    <span class="SCmt">// Here, this will create a 'Struct' on the stack, initialized with a call to 'opAffect(s32)'</span>
    <span class="SFct">toto</span>(<span class="SKwd">cast</span>(<span class="SCst">Struct</span>) <span class="SNum">5</span>'<span class="STpe">s32</span>)

    <span class="SCmt">// But if opAffect is marked with #[Swag.Implicit], automatic conversion can occur.</span>
    <span class="SCmt">// No need for an explicit cast.</span>
    <span class="SFct">toto</span>(<span class="SNum">5</span>'<span class="STpe">u16</span>)
}</span></div>
<p>A structure can be converted to a constant by a call to <span class="code-inline">opAffect</span> if the function is marked with <span class="code-inline">Swag.ConstExpr</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Vector2</span>
{
    x, y: <span class="STpe">f32</span>
}

<span class="SKwd">impl</span> <span class="SCst">Vector2</span>
{
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">mtd</span> <span class="SFct">opAffect</span>(one: <span class="STpe">f32</span>)
    {
        x, y = one
    }
}

<span class="SKwd">const</span> <span class="SCst">One</span>: <span class="SCst">Vector2</span> = <span class="SNum">1.0</span>    <span class="SCmt">// This will call opAffect(1.0) at compile time</span>
<span class="SCmp">#assert</span> <span class="SCst">One</span>.x == <span class="SNum">1.0</span>
<span class="SCmp">#assert</span> <span class="SCst">One</span>.y == <span class="SNum">1.0</span></span></div>

<h3 id="060_struct_064_005_count">Count</h3><div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
{
}

<span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">opCount</span>() =&gt; <span class="SNum">4</span>'<span class="STpe">u64</span>
}</span></div>
<p>You can loop on a struct value if <span class="code-inline">opCount</span> has been defined. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v = <span class="SCst">MyStruct</span>{}

    <span class="SCmt">// '@countof' will call 'opCount'</span>
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(v) == <span class="SNum">4</span>)

    <span class="SCmt">// You can then loop on a struct value if 'opCount' has been defined</span>
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>
    <span class="SLgc">loop</span> v
        cpt += <span class="SNum">1</span>

    <span class="SItr">@assert</span>(cpt == <span class="SNum">4</span>)
}</span></div>

<h3 id="060_struct_064_006_post_copy_and_post_move">Post copy and post move</h3><p>Swag accepts copy and move semantics for structures. In this examples, we use a <span class="code-inline">Vector3</span> to illustrate, even if of course that kind of struct does not need a move semantic, as there's no heap involved. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Vector3</span>
{
    x, y, z: <span class="STpe">s32</span> = <span class="SNum">666</span>
}

<span class="SKwd">impl</span> <span class="SCst">Vector3</span>
{
    <span class="SCmt">// This is used for 'copy semantic'.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opPostCopy</span>()
    {
        x, y, z += <span class="SNum">1</span>
    }

    <span class="SCmt">// This is used for 'move semantic'.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opPostMove</span>()
    {
        x, y, z += <span class="SNum">2</span>
    }

    <span class="SCmt">// Just imagine that we have something to drop. Like a memory allocated buffer.</span>
    <span class="SKwd">mtd</span> <span class="SFct">opDrop</span>()
    {
    }
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SCst">Vector3</span>{}
    <span class="SKwd">var</span> b = <span class="SCst">Vector3</span>{<span class="SNum">100</span>, <span class="SNum">200</span>, <span class="SNum">300</span>}

    <span class="SCmt">// "copy semantic". The default behaviour.</span>
    <span class="SCmt">// 1. This will call 'opDrop' on 'a' if the function exists because 'a' could already be assigned.</span>
    <span class="SCmt">// 2. This will raw copy 'b' to 'a'.</span>
    <span class="SCmt">// 3. This will call 'opPostCopy' on 'a' if it exists.</span>
    a = b
    <span class="SItr">@assert</span>(a.x == <span class="SNum">101</span>)     <span class="SCmt">// +1 because of the call to opPostCopy</span>
    <span class="SItr">@assert</span>(a.y == <span class="SNum">201</span>)
    <span class="SItr">@assert</span>(a.z == <span class="SNum">301</span>)

    <span class="SCmt">// "move semantic" by adding the modifier 'move' just after '='.</span>
    <span class="SCmt">// 1. This will call 'opDrop' on 'a' if it exists</span>
    <span class="SCmt">// 2. This will raw copy 'b' to 'a'</span>
    <span class="SCmt">// 3. This will call 'opPostMove' on 'a' if it exists</span>
    <span class="SCmt">// 4. This will reinitialize 'b' to the default values if 'opDrop' exists</span>
    a =<span class="SItr">,move</span> b
    <span class="SItr">@assert</span>(a.x == <span class="SNum">102</span>)     <span class="SCmt">// +2 because of the call to opPostMove</span>
    <span class="SItr">@assert</span>(a.y == <span class="SNum">202</span>)
    <span class="SItr">@assert</span>(a.z == <span class="SNum">302</span>)

    <span class="SCmt">// 'Vector3' contains an 'opDrop' special function, so 'b' will be reinitialized to</span>
    <span class="SCmt">// the default values after the 'move'. Default values are 666.</span>
    <span class="SItr">@assert</span>(b.x == <span class="SNum">666</span>)

    <span class="SCmt">// If you know what you're doing, you can avoid the first call to 'opDrop' with '=,nodrop'</span>
    <span class="SCmt">// Do it when you know the state of 'a' and do not want an extra unnecessary call</span>
    <span class="SCmt">// (for example if 'a' is in an undetermined state).</span>

    a =<span class="SItr">,nodrop</span> b            <span class="SCmt">// Copy b to a without dropping 'a' first</span>
    a =<span class="SItr">,nodrop</span><span class="SItr">,move</span> b       <span class="SCmt">// Move b to a without dropping 'a' first</span>

    <span class="SCmt">// For the 'move semantic', you can avoid the last reinitialization by using 'moveraw'. Of course, do this at your own risk, if you know that 'b' will never by dropped by the compiler or if you reinitialize its state yourself.</span>

    <span class="SCmt">// instead of 'move'</span>
    a =<span class="SItr">,moveraw</span> b
    a =<span class="SItr">,nodrop</span><span class="SItr">,moveraw</span> b
}</span></div>
<h4 id="060_struct_064_006_post_copy_and_post_move_moveref">moveref </h4>
<p><span class="code-inline">moveref</span> can be used instead of <span class="code-inline">ref</span> in a function parameter to declare a <b>move semantic</b> intention. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// This is the 'move' version of 'assign'. With 'moveref', we tell the compiler that this version will take the owership on 'from'.</span>
    <span class="SKwd">func</span> <span class="SFct">assign</span>(assignTo: <span class="SKwd">ref</span> <span class="SCst">Vector3</span>, from: <span class="SKwd">moveref</span> <span class="SCst">Vector3</span>)
    {
        assignTo =<span class="SItr">,move</span> from
    }

    <span class="SCmt">// This is the normal 'copy' version. In this version, 'from' will not be changed, that's why it's constant (not a ref).</span>
    <span class="SKwd">func</span> <span class="SFct">assign</span>(assignTo: <span class="SKwd">ref</span> <span class="SCst">Vector3</span>, from: <span class="SCst">Vector3</span>)
    {
        assignTo = from
    }

    <span class="SKwd">var</span> a = <span class="SCst">Vector3</span>{<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>}
    <span class="SKwd">var</span> b: <span class="SCst">Vector3</span>

    <span class="SCmt">// Call the 'copy' version of 'assign'.</span>
    <span class="SFct">assign</span>(&b, a)
    <span class="SCmt">// As this will call 'opPostCopy', we have +1 on each field.</span>
    <span class="SItr">@assert</span>(b.x == <span class="SNum">2</span> <span class="SLgc">and</span> b.y == <span class="SNum">3</span> <span class="SLgc">and</span> b.z == <span class="SNum">4</span>)
    <span class="SCmt">// 'a' remains unchanged</span>
    <span class="SItr">@assert</span>(a.x == <span class="SNum">1</span> <span class="SLgc">and</span> a.y == <span class="SNum">2</span> <span class="SLgc">and</span> a.z == <span class="SNum">3</span>)

    <span class="SCmt">// Now we tell the compiler to use the 'moveref' version of 'assign'.</span>
    <span class="SFct">assign</span>(&b, <span class="SKwd">moveref</span> &a)
    <span class="SCmt">// As 'opPostMove' has been called, we have +2 on each field.</span>
    <span class="SItr">@assert</span>(b.x == <span class="SNum">3</span> <span class="SLgc">and</span> b.y == <span class="SNum">4</span> <span class="SLgc">and</span> b.z == <span class="SNum">5</span>)
    <span class="SCmt">// And as this is a move, then 'a' is now reinitialized to its default values.</span>
    <span class="SItr">@assert</span>(a.x == <span class="SNum">666</span> <span class="SLgc">and</span> a.y == <span class="SNum">666</span> <span class="SLgc">and</span> a.z == <span class="SNum">666</span>)
}</span></div>

<h3 id="060_struct_064_007_visit">Visit</h3><div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
{
    x: <span class="STpe">s32</span> = <span class="SNum">10</span>
    y: <span class="STpe">s32</span> = <span class="SNum">20</span>
    z: <span class="STpe">s32</span> = <span class="SNum">30</span>
}</span></div>
<p>You can visit a struct variable if a macro <span class="code-inline">opVisit</span> has been defined. This is the equivalent of an <b>iterator</b>. </p>
<p><span class="code-inline">opVisit</span> is a macro, so it should be marked with the <span class="code-inline">#[Swag.Macro]</span> attribute. <span class="code-inline">opVisit</span> is also a generic function which takes two compile time generic parameters of type <span class="code-inline">bool</span>. </p>
<ul>
<li>if <span class="code-inline">ptr</span> is <span class="code-inline">true</span>, indicates that we should visit by address</li>
<li>if <span class="code-inline">back</span> is 'true", indicated that we want to visit in reverse order (from back to front)</li>
</ul>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisit</span>(<span class="SKwd">self</span>, stmt: <span class="STpe">code</span>)
    {
        <span class="SCmt">// 'ptr' is a generic parameter that tells if we want to visit by pointer or by value.</span>
        <span class="SCmt">// We do not use it in this example, so we check at compile time that it's not true.</span>
        <span class="SCmp">#if</span> ptr <span class="SCmp">#error</span> <span class="SStr">"visiting myStruct by pointer is not supported"</span>

        <span class="SCmt">// 'back' is a generic parameter that tells if we want to visit in reverse order.</span>
        <span class="SCmt">// We do not use it in this example, so we check at compile time that it's not true.</span>
        <span class="SCmp">#if</span> ptr <span class="SCmp">#error</span> <span class="SStr">"visiting myStruct in reverse order is not supported"</span>

        <span class="SCmt">// Loop on the 3 fields</span>
        <span class="SLgc">loop</span> idx: <span class="SNum">3</span>
        {
            <span class="SCmt">// The '#macro' keyword forces its body to be in the scope of the caller</span>
            <span class="SCmp">#macro</span>
            {
                <span class="SCmt">// @alias0 will be the value</span>
                <span class="SKwd">var</span> <span class="SItr">@alias0</span>: <span class="STpe">s32</span> = <span class="SKwd">undefined</span>

                <span class="SCmt">// As this code is in the caller scope, with need to add a '#up' before 'idx' to</span>
                <span class="SCmt">// reference the variable of this function (and not a potential variable in</span>
                <span class="SCmt">// the caller scope)</span>
                <span class="SLgc">switch</span> <span class="SCmp">#up</span> idx
                {
                <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@alias0</span> = <span class="SCmp">#up</span> <span class="SKwd">self</span>.x   <span class="SCmt">// Same for function parameter 'self'</span>
                <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@alias0</span> = <span class="SCmp">#up</span> <span class="SKwd">self</span>.y
                <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@alias0</span> = <span class="SCmp">#up</span> <span class="SKwd">self</span>.z
                }

                <span class="SCmt">// @alias1 will be the index</span>
                <span class="SKwd">var</span> <span class="SItr">@alias1</span> = <span class="SItr">@index</span>

                <span class="SCmt">// include user code</span>
                <span class="SCmp">#mixin</span> <span class="SCmp">#up</span> stmt
            }
        }
    }
}</span></div>
<p>So now that the <span class="code-inline">opVisit</span> has been defined, we can <span class="code-inline">visit</span> it. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myStruct = <span class="SCst">MyStruct</span>{}
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// Visiting each field in declaration order</span>
    <span class="SCmt">// 'v' is an alias for @alias0 (value)</span>
    <span class="SCmt">// 'i' is an alias for @alias1 (index)</span>
    <span class="SLgc">visit</span> v, i: myStruct
    {
        <span class="SLgc">switch</span> i
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@assert</span>(v == <span class="SNum">10</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@assert</span>(v == <span class="SNum">20</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@assert</span>(v == <span class="SNum">30</span>)
        }

        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>
<p>You can have variants of <span class="code-inline">opVisit</span> by specifying an <b>additional name</b>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">MyStruct</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">mtd</span>(ptr: <span class="STpe">bool</span>, back: <span class="STpe">bool</span>) <span class="SFct">opVisitReverse</span>(stmt: <span class="STpe">code</span>)   <span class="SCmt">// We add 'Reverse' in the name</span>
    {
        <span class="SCmt">// Visit fields in reverse order (z, y then x).</span>
        <span class="SCmt">// Note that visiting in reverse order should be implemented in the normal 'opVisit'</span>
        <span class="SCmt">// function by checking the 'back' generic parameter. But this is just to make the</span>
        <span class="SCmt">// point of special dedicated visit versions.</span>
        <span class="SLgc">loop</span> idx: <span class="SNum">3</span>
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SKwd">var</span> <span class="SItr">@alias0</span>: <span class="STpe">s32</span> = <span class="SKwd">undefined</span>
                <span class="SLgc">switch</span> <span class="SCmp">#up</span> idx
                {
                <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@alias0</span> = <span class="SCmp">#up</span> <span class="SKwd">self</span>.z
                <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@alias0</span> = <span class="SCmp">#up</span> <span class="SKwd">self</span>.y
                <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@alias0</span> = <span class="SCmp">#up</span> <span class="SKwd">self</span>.x
                }

                <span class="SKwd">var</span> <span class="SItr">@alias1</span> = <span class="SItr">@index</span>
                <span class="SCmp">#mixin</span> <span class="SCmp">#up</span> stmt
            }
        }
    }
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myStruct = <span class="SCst">MyStruct</span>{}
    <span class="SKwd">var</span> cpt = <span class="SNum">0</span>

    <span class="SCmt">// To call a variant, add the extra name between parenthesis.</span>
    <span class="SLgc">visit</span>(<span class="SCst">Reverse</span>) v, i: myStruct
    {
        <span class="SLgc">switch</span> i
        {
        <span class="SLgc">case</span> <span class="SNum">0</span>: <span class="SItr">@assert</span>(v == <span class="SNum">30</span>)
        <span class="SLgc">case</span> <span class="SNum">1</span>: <span class="SItr">@assert</span>(v == <span class="SNum">20</span>)
        <span class="SLgc">case</span> <span class="SNum">2</span>: <span class="SItr">@assert</span>(v == <span class="SNum">10</span>)
        }

        cpt += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">3</span>)
}</span></div>

<h3 id="060_struct_067_008_offset">Offset</h3><p>You can force the layout of a field with the <span class="code-inline">Swag.Offset</span> attribute. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x: <span class="STpe">s32</span>

        <span class="SCmt">// 'y' is located at the same offset as 'x', so they share the same space</span>
        <span class="SAtr">#[Swag.Offset("x")]</span>
        y: <span class="STpe">s32</span>
    }

    <span class="SCmt">// They are 2 fields in the struct but stored in only one s32, so the total size is 4 bytes.</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct</span>) == <span class="SNum">4</span>

    <span class="SKwd">var</span> v = <span class="SCst">MyStruct</span>{}
    v.x = <span class="SNum">666</span>

    <span class="SCmt">// As 'y' and 'x' are sharing the same space, affecting to 'x' also affects to 'y'.</span>
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
}</span></div>
<p>An example to reference a field by index. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x, y, z:    <span class="STpe">f32</span>

        <span class="SAtr">#[Swag.Offset("x")]</span>
        idx:        [<span class="SNum">3</span>] <span class="STpe">f32</span>
    }

    <span class="SKwd">var</span> v: <span class="SCst">MyStruct</span>
    v.x = <span class="SNum">10</span>; v.y = <span class="SNum">20</span>; v.z = <span class="SNum">30</span>
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">0</span>] == v.x)
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">1</span>] == v.y)
    <span class="SItr">@assert</span>(v.idx[<span class="SNum">2</span>] == v.z)
}</span></div>

<h3 id="060_struct_068_009_packing">Packing</h3><p>You can also control the struct layout with two attributes: <span class="code-inline">#[Swag.Pack]</span> and <span class="code-inline">#[Swag.Align]</span>. </p>
<p>The default struct packing is the same as in C: each field is aligned to the size of the type. This is the equivalent of <span class="code-inline">#[Swag.Pack(0)]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        x: <span class="STpe">bool</span>     <span class="SCmt">// offset 0: aligned to 1 byte</span>
        y: <span class="STpe">s32</span>      <span class="SCmt">// offset 4: s32 is aligned to 4 bytes (so here there's 3 bytes of padding before)</span>
        z: <span class="STpe">s64</span>      <span class="SCmt">// offset 8: aligned to 8 bytes</span>
    }

    <span class="SCmt">// '@offsetof' can be used to retrieve the offset of a field</span>
    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct</span>.y) == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct</span>.z) == <span class="SNum">8</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct</span>)     == <span class="SNum">16</span>
}</span></div>
<p>You can <i>reduce</i> the packing of the fields with <span class="code-inline">#[Swag.Pack]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Pack(1)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x: <span class="STpe">bool</span> <span class="SCmt">// offset 0: 1 byte</span>
        y: <span class="STpe">s32</span>  <span class="SCmt">// offset 1: 4 bytes (no padding)</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct1</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct1</span>.y) == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct1</span>)     == <span class="SNum">5</span>

    <span class="SAtr">#[Swag.Pack(2)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x: <span class="STpe">bool</span> <span class="SCmt">// offset 0: 1 byte</span>
        y: <span class="STpe">s32</span>  <span class="SCmt">// offset 2: 4 bytes (1 byte of padding before)</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct2</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct2</span>.y) == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct2</span>)     == <span class="SNum">6</span>

    <span class="SAtr">#[Swag.Pack(4)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct3</span>
    {
        x: <span class="STpe">bool</span> <span class="SCmt">// offset 0: 1 byte</span>
        y: <span class="STpe">s64</span>  <span class="SCmt">// offset 4: 8 bytes (3 bytes of padding before)</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct3</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct3</span>.y) == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct3</span>)     == <span class="SNum">12</span>
}</span></div>
<p>The total struct size is always a multiple of the biggest alignement of the fields. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x: <span class="STpe">s32</span>  <span class="SCmt">// 4 bytes</span>
        y: <span class="STpe">bool</span> <span class="SCmt">// 1 byte</span>
        <span class="SCmt">// 3 bytes of padding because of 'x', to aligned on 's32'</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">8</span>
}</span></div>
<p>You can force the struct alignement with <span class="code-inline">#[Swag.Align]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x: <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
        y: <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct1</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct1</span>.y) == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct1</span>)     == <span class="SNum">2</span>

    <span class="SAtr">#[Swag.Align(8)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x: <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
        y: <span class="STpe">bool</span>     <span class="SCmt">// 1 byte</span>
        <span class="SCmt">// 6 bytes of padding to be a multiple of '8'</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct2</span>.x) == <span class="SNum">0</span>
    <span class="SCmp">#assert</span> <span class="SItr">@offsetof</span>(<span class="SCst">MyStruct2</span>.y) == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct2</span>)     == <span class="SNum">8</span>
}</span></div>
<p>You can also force each field to be aligned on a specific value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct1</span>
    {
        x: <span class="STpe">bool</span> <span class="SCmt">// offset 0: 1 byte</span>
        <span class="SAtr">#[Swag.Align(8)]</span>
        y: <span class="STpe">bool</span> <span class="SCmt">// offset 8: aligned to 8 (7 bytes of padding before)</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct1</span>) == <span class="SNum">9</span>

    <span class="SAtr">#[Swag.Align(8)]</span>
    <span class="SKwd">struct</span> <span class="SCst">MyStruct2</span>
    {
        x: <span class="STpe">bool</span> <span class="SCmt">// offset 0: 1 byte</span>
        <span class="SAtr">#[Swag.Align(4)]</span>
        y: <span class="STpe">bool</span> <span class="SCmt">// offset 4: aligned to 4 (3 bytes of padding before)</span>
        <span class="SCmt">// 3 bytes of padding to be a multiple of 8</span>
    }

    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(<span class="SCst">MyStruct2</span>) == <span class="SNum">8</span>
}</span></div>

<h2 id="070_union">Union</h2><p>An union is just a struct where all fields are located at offset 0. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">union</span> <span class="SCst">MyUnion</span>
        {
            x, y, z: <span class="STpe">f32</span>
        }

        <span class="SKwd">var</span> v = <span class="SCst">MyUnion</span>{x: <span class="SNum">666</span>}
        <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
        <span class="SItr">@assert</span>(v.z == <span class="SNum">666</span>)
    }
}</span></div>

<h2 id="075_interface">Interface</h2><p>Interfaces are <b>virtual tables</b> (a list of function pointers) that can be associated to a struct. </p>
<p>Unlike C++, the virtual table is not embedded with the struct. It is a separate object. You can then <i>implement</i> an interface for a given struct without changing the struct definition. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Point2</span>
{
    x, y: <span class="STpe">f32</span>
}

<span class="SKwd">struct</span> <span class="SCst">Point3</span>
{
    x, y, z: <span class="STpe">f32</span>
}</span></div>
<p>Here we declare an interface, with two functions <span class="code-inline">set</span> and <span class="code-inline">reset</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">interface</span> <span class="SCst">IReset</span>
{
    <span class="SCmt">// The first parameter must be 'self'</span>
    <span class="SKwd">func</span> <span class="SFct">set</span>(<span class="SKwd">self</span>, val: <span class="STpe">f32</span>)

    <span class="SCmt">// You can also use the 'mtd' declaration to avoid specifying the 'self' yourself</span>
    <span class="SKwd">mtd</span> <span class="SFct">reset</span>()
}</span></div>
<p>You can implement an interface for any given struct with <span class="code-inline">impl</span> and <span class="code-inline">for</span>. For example here, we implement interface <span class="code-inline">IReset</span> for struct <span class="code-inline">Point2</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">IReset</span> <span class="SLgc">for</span> <span class="SCst">Point2</span>
{
    <span class="SCmt">// You must add 'impl' to indicate that you want to implement a function of the interface.</span>
    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">set</span>(val: <span class="STpe">f32</span>)
    {
        x = val
        y = val+<span class="SNum">1</span>
    }

    <span class="SCmt">// Don't forget that 'mtd' is just syntaxic sugar. 'func' still works.</span>
    <span class="SKwd">func</span> <span class="SKwd">impl</span> <span class="SFct">reset</span>(<span class="SKwd">self</span>)
    {
        <span class="SKwd">self</span>.x, <span class="SKwd">self</span>.y = <span class="SNum">0</span>
    }

    <span class="SCmt">// Not that you can also declare 'normal' functions or methods in an 'impl block'.</span>
    <span class="SKwd">mtd</span> <span class="SFct">myOtherMethod</span>()
    {
    }
}</span></div>
<p>And we implement interface <span class="code-inline">IReset</span> also for struct <span class="code-inline">Point3</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">impl</span> <span class="SCst">IReset</span> <span class="SLgc">for</span> <span class="SCst">Point3</span>
{
    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">set</span>(val: <span class="STpe">f32</span>)
    {
        x = val
        y = val+<span class="SNum">1</span>
        z = val+<span class="SNum">2</span>
    }

    <span class="SKwd">mtd</span> <span class="SKwd">impl</span> <span class="SFct">reset</span>()
    {
        x, y, z = <span class="SNum">0</span>
    }
}</span></div>
<p>We can then use these interfaces on either <span class="code-inline">Vector2</span> or <span class="code-inline">Vector3</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>

    <span class="SCmt">// To get the interface associated to a given struct, use the 'cast' operator.</span>
    <span class="SCmt">// If the compiler does not find the corresponding implementation, it will raise an error.</span>
    <span class="SKwd">var</span> itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    itf.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt2.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt2.y == <span class="SNum">10</span>+<span class="SNum">1</span>)

    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    itf.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt3.x == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt3.y == <span class="SNum">10</span>+<span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt3.z == <span class="SNum">10</span>+<span class="SNum">2</span>)
    itf.<span class="SFct">reset</span>()
    <span class="SItr">@assert</span>(pt3.x == <span class="SNum">0</span> <span class="SLgc">and</span> pt3.y == <span class="SNum">0</span>)
}</span></div>
<p>You can also access, with a normal call, all functions declared in an interface implementation block for a given struct. They are located in a dedicated scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>

    <span class="SCmt">// The scope where all functions are located has the same name as the interface.</span>
    pt2.<span class="SCst">IReset</span>.<span class="SFct">set</span>(<span class="SNum">10</span>)
    pt2.<span class="SCst">IReset</span>.<span class="SFct">reset</span>()
    pt3.<span class="SCst">IReset</span>.<span class="SFct">set</span>(<span class="SNum">10</span>)
    pt3.<span class="SCst">IReset</span>.<span class="SFct">reset</span>()
}</span></div>
<p>An interface is a real type, with a size equivalent to 2 pointers. A pointer to the <i>object</i> and a pointer to the <i>virtual table</i>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt2: <span class="SCst">Point2</span>
    <span class="SKwd">var</span> pt3: <span class="SCst">Point3</span>
    <span class="SKwd">var</span> itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    <span class="SCmp">#assert</span> <span class="SItr">@sizeof</span>(itf) == <span class="SNum">2</span> * <span class="SItr">@sizeof</span>(*<span class="STpe">void</span>)

    <span class="SCmt">// You can retrieve the concrete type associated with an interface instance with '@kindof'.</span>
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(itf) == <span class="SCst">Point2</span>)
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(itf) == <span class="SCst">Point3</span>)

    <span class="SCmt">// You can retrieve the concrete data associated with an interface instance with '@dataof'</span>
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt2
    <span class="SItr">@assert</span>(<span class="SItr">@dataof</span>(itf) == &pt2)
    itf = <span class="SKwd">cast</span>(<span class="SCst">IReset</span>) pt3
    <span class="SItr">@assert</span>(<span class="SItr">@dataof</span>(itf) == &pt3)
}</span></div>

<h2 id="100_function">Function</h2>
<h3 id="100_function_101_001_declaration">Declaration</h3><p>A function declaration usually starts with the <span class="code-inline">func</span> keyword followed by the function name. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">toto</span>()
{
}</span></div>
<p>If the function needs to return a value, you must add <span class="code-inline">-&gt;</span> followed by the type. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">toto1</span>()-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">return</span> <span class="SNum">0</span>
}</span></div>
<p>The return type can be deduced in case of a simple expression, by using <span class="code-inline">=&gt;</span> instead of <span class="code-inline">-&gt;</span>. Here the return type will be deduced to be <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y</span></div>
<p>A short version exists, in case of a function returning nothing. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">print</span>(val: <span class="STpe">string</span>) = <span class="SItr">@print</span>(val)</span></div>
<p>Parameters are specified after the function name, between parenthesis. Here we declare two parameters <span class="code-inline">x</span> and <span class="code-inline">y</span> of type <span class="code-inline">s32</span>, and one last parameter of type <span class="code-inline">f32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum1</span>(x, y: <span class="STpe">s32</span>, unused: <span class="STpe">f32</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">return</span> x + y
}</span></div>
<p>Parameters can have default values. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum2</span>(x, y: <span class="STpe">s32</span>, unused: <span class="STpe">f32</span> = <span class="SNum">666</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">return</span> x + y
}</span></div>
<p>The type of the parameters can be deduced if you specify a default value. Here <span class="code-inline">x</span> and <span class="code-inline">y</span> have the type <span class="code-inline">f32</span> because <span class="code-inline">0.0</span> is a 32 bits floating point literal. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">sum3</span>(x, y = <span class="SNum">0.0</span>)
{
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(x) == <span class="STpe">f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(y) == <span class="STpe">f32</span>
}

<span class="SKwd">enum</span> <span class="SCst">Values</span> { <span class="SCst">A</span>; <span class="SCst">B</span>; }
<span class="SKwd">func</span> <span class="SFct">toto</span>(x: <span class="STpe">s32</span>, y = <span class="SCst">Values</span>.<span class="SCst">A</span>)
{
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(y) == <span class="SCst">Values</span>
}</span></div>
<p>Functions can be nested inside other functions. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// This are not closure but just functions in a sub scope.</span>
    <span class="SKwd">func</span> <span class="SFct">sub</span>(x, y: <span class="STpe">s32</span>) =&gt; x - y

    <span class="SCmt">// Simple call.</span>
    <span class="SKwd">let</span> x = <span class="SFct">sub</span>(<span class="SNum">5</span>, <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(x == <span class="SNum">3</span>)
}</span></div>
<p>You can name parameters, and don't have to respect parameters order in that case. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sub</span>(x, y: <span class="STpe">s32</span>) =&gt; x - y

    {
        <span class="SKwd">let</span> x1 = <span class="SFct">sub</span>(x: <span class="SNum">5</span>, y: <span class="SNum">2</span>)
        <span class="SItr">@assert</span>(x1 == <span class="SNum">3</span>)
        <span class="SKwd">let</span> x2 = <span class="SFct">sub</span>(y: <span class="SNum">5</span>, x: <span class="SNum">2</span>)
        <span class="SItr">@assert</span>(x2 == -<span class="SNum">3</span>)
    }

    {
        <span class="SKwd">func</span> <span class="SFct">returnMe</span>(x, y: <span class="STpe">s32</span> = <span class="SNum">0</span>) =&gt; x + y * <span class="SNum">2</span>
        <span class="SItr">@assert</span>(<span class="SFct">returnMe</span>(x: <span class="SNum">10</span>) == <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(<span class="SFct">returnMe</span>(y: <span class="SNum">10</span>) == <span class="SNum">20</span>)
    }
}</span></div>
<h4 id="100_function_101_001_declaration_Multiple_return_values">Multiple return values </h4>
<p>An <b>anonymous struct</b> can be used to return multiple values in a function. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>() -&gt; {x, y: <span class="STpe">f32</span>}
    {
        <span class="SLgc">return</span> {<span class="SNum">1.0</span>, <span class="SNum">2.0</span>}
    }

    <span class="SKwd">var</span> result = <span class="SFct">myFunction</span>()
    <span class="SItr">@assert</span>(result.item0 == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(result.item1 == <span class="SNum">2.0</span>)

    <span class="SKwd">let</span> (x, y) = <span class="SFct">myFunction</span>()
    <span class="SItr">@assert</span>(x == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">2.0</span>)

    <span class="SKwd">let</span> (z, w) = <span class="SFct">myFunction</span>()
    <span class="SItr">@assert</span>(z == <span class="SNum">1.0</span>)
    <span class="SItr">@assert</span>(w == <span class="SNum">2.0</span>)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">returns2</span>() -&gt; {x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span>}
    {
        <span class="SCmt">// You can return a tuple literal as long as the types match</span>
        <span class="SLgc">if</span> <span class="SKwd">false</span>
            <span class="SLgc">return</span> {<span class="SNum">1</span>, <span class="SNum">2</span>}

        <span class="SCmt">// Or use the specifal type 'retval' which is an typealias to the</span>
        <span class="SCmt">// function return type (but not only, we'll see later)</span>
        <span class="SKwd">using</span> <span class="SKwd">var</span> result: <span class="SKwd">retval</span>
        x = <span class="SNum">1</span>
        y = <span class="SNum">2</span>
        <span class="SLgc">return</span> result
    }

    <span class="SCmt">// You can access the struct fields with the names or with 'item?'</span>
    <span class="SKwd">var</span> result = <span class="SFct">returns2</span>()
    <span class="SItr">@assert</span>(result.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(result.item0 == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(result.y == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(result.item1 == <span class="SNum">2</span>)

    <span class="SCmt">// You can deconstruct the returned struct</span>
    <span class="SKwd">let</span> (x, y) = <span class="SFct">returns2</span>()
    <span class="SItr">@assert</span>(x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(y == <span class="SNum">2</span>)
}</span></div>

<h3 id="100_function_102_002_lambda">Lambda</h3><p>A lambda is just a <b>pointer to a function</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction0</span>() {}
    <span class="SKwd">func</span> <span class="SFct">myFunction1</span>(x: <span class="STpe">s32</span>) =&gt; x * x

    <span class="SCmt">// 'ptr0' is declared as a pointer to a function that takes no parameter, and returns nothing</span>
    <span class="SKwd">let</span> ptr0: <span class="SKwd">func</span>() = &myFunction0
    <span class="SFct">ptr0</span>()

    <span class="SCmt">// Here type of 'ptr1' is deduced from 'myFunction1'</span>
    <span class="SKwd">let</span> ptr1 = &myFunction1
    <span class="SItr">@assert</span>(<span class="SFct">myFunction1</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SFct">ptr1</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)
}</span></div>
<p>A lambda can be null. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> lambda: <span class="SKwd">func</span>()-&gt;<span class="STpe">bool</span>
    <span class="SItr">@assert</span>(lambda == <span class="SKwd">null</span>)
}</span></div>
<p>You can use a lambda as a function parameter type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">typealias</span> callback = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: callback)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value)

    <span class="SKwd">func</span> <span class="SFct">square</span>(x: <span class="STpe">s32</span>) =&gt; x * x
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, &square) == <span class="SNum">16</span>)
}</span></div>
<h4 id="100_function_102_002_lambda_Anonymous_functions">Anonymous functions </h4>
<p>You can also create <i>anonymous functions</i> (aka functions as literals). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cb = <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> =&gt; x * x
    <span class="SItr">@assert</span>(<span class="SFct">cb</span>(<span class="SNum">4</span>) == <span class="SNum">16</span>)
    cb = <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> =&gt; x * x * x
    <span class="SItr">@assert</span>(<span class="SFct">cb</span>(<span class="SNum">4</span>) == <span class="SNum">64</span>)
}</span></div>
<p>Anonymous functions can be passed as parameters to another function. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">typealias</span> callback = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: callback)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value)

    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>) =&gt; x * x) == <span class="SNum">16</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>) =&gt; x + x) == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> { <span class="SLgc">return</span> x - x; }) == <span class="SNum">0</span>)
}</span></div>
<p>The types of the parameters can be deduced. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">typealias</span> callback = <span class="SKwd">func</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
    <span class="SKwd">func</span> <span class="SFct">toDo</span>(value: <span class="STpe">s32</span>, ptr: callback)-&gt;<span class="STpe">s32</span> =&gt; <span class="SFct">ptr</span>(value)

    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) =&gt; x * x) == <span class="SNum">16</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) =&gt; x + x) == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SFct">toDo</span>(<span class="SNum">4</span>, <span class="SKwd">func</span>(x) { <span class="SLgc">return</span> x - x; }) == <span class="SNum">0</span>)
}</span></div>
<p>When you affect a lambda to a variable, the type of parameters and the return type can also be omitted, as they will be deduced from the variable type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> fct: <span class="SKwd">func</span>(<span class="STpe">s32</span>, <span class="STpe">s32</span>)-&gt;<span class="STpe">bool</span>

    fct = <span class="SKwd">func</span>(x, y) =&gt; x == y
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">10</span>, <span class="SNum">10</span>))

    fct = <span class="SKwd">func</span>(x, y) { <span class="SLgc">return</span> x != y; }
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">20</span>, <span class="SNum">120</span>))
}</span></div>
<p>Lambdas can have default parameters values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">let</span> x = <span class="SKwd">func</span>(val = <span class="SKwd">true</span>) {
            <span class="SItr">@assert</span>(val == <span class="SKwd">true</span>)
        }

        <span class="SFct">x</span>()
    }

    {
        <span class="SKwd">var</span> x: <span class="SKwd">func</span>(val: <span class="STpe">bool</span> = <span class="SKwd">true</span>)

        x = <span class="SKwd">func</span>(val) {
            <span class="SItr">@assert</span>(val == <span class="SKwd">true</span>)
        }

        <span class="SFct">x</span>()
        <span class="SFct">x</span>(<span class="SKwd">true</span>)
    }
}</span></div>

<h3 id="100_function_103_003_closure">Closure</h3><p>Swag supports a limited set of the <span class="code-inline">closure</span> concept. </p>
<p>Only a given amount of bytes of capture are possible (for now 48 bytes). That way there's never an hidden allocation. Another limitation is that you can only capture <span class="code-inline">simple</span> variables (no struct with <span class="code-inline">opDrop</span>, <span class="code-inline">opPostCopy</span>, <span class="code-inline">opPostMove</span> for example). </p>
<p>A closure is declared like a lambda, with the captured variables between <span class="code-inline">|...|</span> before the function parameters. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> a = <span class="SNum">125</span>
    <span class="SKwd">let</span> b = <span class="SNum">521</span>

    <span class="SCmt">// Capture 'a' and 'b'</span>
    <span class="SKwd">let</span> fct: <span class="SKwd">closure</span>() = <span class="SKwd">closure</span>|a, b|()
    {
        <span class="SItr">@assert</span>(a == <span class="SNum">125</span>)
        <span class="SItr">@assert</span>(b == <span class="SNum">521</span>)
    }

    <span class="SFct">fct</span>()
}</span></div>
<p>You can also capture by pointer with <span class="code-inline">&</span> (otherwise it's a copy). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SNum">125</span>

    <span class="SCmt">// Capture 'a' by pointer</span>
    <span class="SKwd">let</span> fct: <span class="SKwd">closure</span>() = <span class="SKwd">closure</span>|&a|()
    {
        <span class="SCmt">// We can change the value of the local variable 'a'</span>
        <span class="SKwd">dref</span> a += <span class="SNum">1</span>
    }

    <span class="SFct">fct</span>()
    <span class="SItr">@assert</span>(a == <span class="SNum">126</span>)
    <span class="SFct">fct</span>()
    <span class="SItr">@assert</span>(a == <span class="SNum">127</span>)
}</span></div>
<p>You can also capture by reference with <span class="code-inline">ref</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> a = <span class="SNum">125</span>

    <span class="SCmt">// Capture 'a' by reference</span>
    <span class="SKwd">let</span> fct = <span class="SKwd">closure</span>|<span class="SKwd">ref</span> a|()
    {
        <span class="SCmt">// We can change the value of the local variable 'a'</span>
        a += <span class="SNum">1</span>
    }

    <span class="SFct">fct</span>()
    <span class="SItr">@assert</span>(a == <span class="SNum">126</span>)
    <span class="SFct">fct</span>()
    <span class="SItr">@assert</span>(a == <span class="SNum">127</span>)
}</span></div>
<p>You can assign a normal lambda (no capture) to a closure variable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> fct: <span class="SKwd">closure</span>(<span class="STpe">s32</span>, <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>

    fct = <span class="SKwd">func</span>(x, y) =&gt; x + y
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>(<span class="SNum">1</span>, <span class="SNum">2</span>) == <span class="SNum">3</span>)
}</span></div>
<p>You can capture arrays, structs, slices etc... as long as it fits in the maximum storage of <span class="code-inline">n</span> bytes (and as long as the struct is a pod). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>]

    <span class="SKwd">var</span> fct: <span class="SKwd">closure</span>(<span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>

    <span class="SCmt">// Capture the array 'x' by making a copy</span>
    fct = <span class="SKwd">closure</span>|x|(toAdd)
    {
        <span class="SKwd">var</span> res = <span class="SNum">0</span>
        <span class="SLgc">visit</span> v: x
            res += v
        res += toAdd
        <span class="SLgc">return</span> res
    }

    <span class="SKwd">let</span> result = <span class="SFct">fct</span>(<span class="SNum">4</span>)
    <span class="SItr">@assert</span>(result == <span class="SNum">1</span> + <span class="SNum">2</span> + <span class="SNum">3</span> + <span class="SNum">4</span>)
}</span></div>
<p>Captured variables are mutable, and part of the closure. So you can modify them. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">getInc</span>()-&gt;<span class="SKwd">closure</span>()-&gt;<span class="STpe">s32</span>
    {
        <span class="SKwd">let</span> x = <span class="SNum">10</span>

        <span class="SLgc">return</span> <span class="SKwd">closure</span>|x|()-&gt;<span class="STpe">s32</span> {
            x += <span class="SNum">1</span>
            <span class="SLgc">return</span> x
        }
    }

    <span class="SKwd">let</span> fct = <span class="SFct">getInc</span>()
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">11</span>)
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">12</span>)
    <span class="SItr">@assert</span>(<span class="SFct">fct</span>() == <span class="SNum">13</span>)
}</span></div>

<h3 id="100_function_104_004_mixin">Mixin</h3><p>A mixin is declared like a function, with the attribute <span class="code-inline">#[Swag.Mixin]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>()
    {
    }
}</span></div>
<p>A mixin function is inserted in the scope of the caller. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>()
    {
        a += <span class="SNum">1</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">myMixin</span>()   <span class="SCmt">// Equivalent to 'a += 1'</span>
    <span class="SFct">myMixin</span>()   <span class="SCmt">// Equivalent to 'a += 1'</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<p>This behaves like a function, so you can add parameters, some default values, you can return something... </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">myMixin</span>(increment: <span class="STpe">s32</span> = <span class="SNum">1</span>)
    {
        a += increment
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">myMixin</span>()   <span class="SCmt">// Equivalent to 'a += 1'</span>
    <span class="SFct">myMixin</span>(<span class="SNum">2</span>)  <span class="SCmt">// Equivalent to 'a += 2'</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">3</span>)
}</span></div>
<p>A mixin accepts a special parameter of type <span class="code-inline">code</span>. This represents a Swag <b>piece of code</b> defined at the caller site. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">doItTwice</span>(what: <span class="STpe">code</span>)
    {
        <span class="SCmt">// You can then insert the code with '#mixin'.</span>
        <span class="SCmt">// So here, we insert it two times</span>
        <span class="SCmp">#mixin</span> what
        <span class="SCmp">#mixin</span> what
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SCmt">// You can use '#code' to specify some code when calling the mixin function.</span>
    <span class="SFct">doItTwice</span>(<span class="SCmp">#code</span> {a += <span class="SNum">1</span>;})
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<p>When the last parameter of a mixin is of type <span class="code-inline">code</span>, the caller can declare that code in a statement just after the call. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">doItTwice</span>(value: <span class="STpe">s32</span>, what: <span class="STpe">code</span>)
    {
        <span class="SCmp">#mixin</span> what
        <span class="SCmp">#mixin</span> what
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SCmt">// This form of passing a code to the mixing...</span>
    <span class="SFct">doItTwice</span>(<span class="SNum">4</span>, <span class="SCmp">#code</span> { a += value; })

    <span class="SCmt">// ...is equivalent to this other form, which is more simple and natural.</span>
    <span class="SCmt">// You can also notice that 'value' is a parameter from the mixin itself</span>
    <span class="SFct">doItTwice</span>(<span class="SNum">2</span>)
    {
        a += value
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">12</span>)
}</span></div>
<p>You can use the special name <span class="code-inline">@alias</span> to create a named alias for an identifier. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">inc10</span>()
    {
        <span class="SItr">@alias0</span> += <span class="SNum">10</span>
    }

    <span class="SKwd">var</span> a, b = <span class="SNum">0</span>
    <span class="SFct">inc10</span>(|a|)  <span class="SCmt">// Passing alias name 'a'</span>
    <span class="SFct">inc10</span>(|b|)  <span class="SCmt">// Passing alias name 'b'</span>
    <span class="SItr">@assert</span>(a == b <span class="SLgc">and</span> b == <span class="SNum">10</span>)
}

<span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">setVar</span>(value: <span class="STpe">s32</span>)
    {
        <span class="SKwd">let</span> <span class="SItr">@alias0</span> = value
    }

    <span class="SFct">setVar</span>(|a| <span class="SNum">10</span>)  <span class="SCmt">// Passing alias name 'a'</span>
    <span class="SFct">setVar</span>(|b| <span class="SNum">20</span>)  <span class="SCmt">// Passing alias name 'b'</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">10</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">20</span>)
    <span class="SFct">setVar</span>(<span class="SNum">30</span>)      <span class="SCmt">// No typealias, so name is @alias0</span>
    <span class="SItr">@assert</span>(<span class="SItr">@alias0</span> == <span class="SNum">30</span>)
}</span></div>
<p>You can declare special variables named <span class="code-inline">@mixin?</span>. Those variables will have a unique name each time the mixin is used. So the same mixin, even if it declares local variables, can be used multiple time in the same scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> total: <span class="STpe">s32</span>

    <span class="SAtr">#[Swag.Mixin]</span>
    <span class="SKwd">func</span> <span class="SFct">toScope</span>()
    {
        <span class="SKwd">var</span> <span class="SItr">@mixin0</span>: <span class="STpe">s32</span> = <span class="SNum">1</span>
        total += <span class="SItr">@mixin0</span>
    }

    <span class="SFct">toScope</span>()
    <span class="SFct">toScope</span>()
    <span class="SFct">toScope</span>()

    <span class="SItr">@assert</span>(total == <span class="SNum">3</span>)
}</span></div>

<h3 id="100_function_105_005_macro">Macro</h3><p>A macro, like a mixin, is declared like a function, but with the attribute <span class="code-inline">Swag.Macro</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>()
    {
    }
}</span></div>
<p>Unlike a mixin, a macro has its own scope, and cannot conflict with the function it is inserted inside. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>()
    {
        <span class="SKwd">var</span> a = <span class="SNum">666</span>    <span class="SCmt">// 'a' is declared in the scope of 'myMacro'</span>
    }

    <span class="SKwd">let</span> a = <span class="SNum">0</span>
    <span class="SFct">myMacro</span>()   <span class="SCmt">// no conflict with the 'a' declared above</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">0</span>)
}</span></div>
<p>But you can force an identifier to be found <b>outside</b> of the scope of the macro with <span class="code-inline">#up</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>()
    {
        <span class="SCmp">#up</span> a += <span class="SNum">1</span> <span class="SCmt">// Add '#up' before the identifier to reference the 'a' of the caller</span>
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">myMacro</span>()   <span class="SCmt">// This will change the 'a' above</span>
    <span class="SFct">myMacro</span>()   <span class="SCmt">// This will change the 'a' above</span>
    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<p>Like a mixin, macro accepts <span class="code-inline">code</span> parameters. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>(what: <span class="STpe">code</span>)
    {
        <span class="SCmp">#mixin</span> what
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>

    <span class="SFct">myMacro</span>(<span class="SCmp">#code</span> { <span class="SCmp">#up</span> a += <span class="SNum">1</span>; } )

    <span class="SFct">myMacro</span>()
    {
        <span class="SCmp">#up</span> a += <span class="SNum">1</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">2</span>)
}</span></div>
<p>You can use <span class="code-inline">#macro</span> inside a macro to force the code after to be in the same scope of the caller. That is, no <span class="code-inline">#up</span> is necessary to reference variables of the caller. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">myMacro</span>(what: <span class="STpe">code</span>)
    {
        <span class="SCmt">// No conflict, in its own scope</span>
        <span class="SKwd">var</span> a = <span class="SNum">666</span>

        <span class="SCmt">// Isolate the caller code, to avoid conflicts with the macro internals</span>
        <span class="SCmp">#macro</span>
        {
            <span class="SCmt">// In the scope of the caller</span>
            <span class="SCmp">#mixin</span> <span class="SCmp">#up</span> what
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">1</span>
    <span class="SFct">myMacro</span>()
    {
        a += <span class="SNum">2</span>  <span class="SCmt">// will reference the 'a' above because this code has been inserted inside '#macro'</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">3</span>)
}</span></div>
<p>You can extend the language with macros, without using pointers to functions (no lambda call cost). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">repeat</span>(count: <span class="STpe">s32</span>, what: <span class="STpe">code</span>)
    {
        <span class="SKwd">var</span> a = <span class="SNum">0</span>
        <span class="SLgc">while</span> a &lt; count
        {
            <span class="SCmp">#macro</span>
            {
                <span class="SKwd">var</span> index = <span class="SCmp">#up</span> a
                <span class="SCmp">#mixin</span> <span class="SCmp">#up</span> what
            }

            a += <span class="SNum">1</span>
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">repeat</span>(<span class="SNum">5</span>) { a += index; }
    <span class="SItr">@assert</span>(a == <span class="SNum">0</span>+<span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)
    <span class="SFct">repeat</span>(<span class="SNum">3</span>) { a += index; }
    <span class="SItr">@assert</span>(a == <span class="SNum">10</span>+<span class="SNum">3</span>)
}</span></div>
<p>When you need <span class="code-inline">break</span> in the user code to break outside of a multi loop. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">repeatSquare</span>(count: <span class="STpe">u32</span>, what: <span class="STpe">code</span>)
    {
        <span class="SCmp">#scope</span> <span class="SCst">Up</span> <span class="SLgc">loop</span> count
        {
            <span class="SLgc">loop</span> count
            {
                <span class="SCmp">#macro</span>
                {
                    <span class="SCmt">// 'break' in the user code will be replaced by 'break Up'</span>
                    <span class="SCmt">// So it will break outside the outer loop</span>
                    <span class="SCmp">#mixin</span> <span class="SCmp">#up</span> what { <span class="SLgc">break</span> = <span class="SLgc">break</span> <span class="SCst">Up</span>; }
                }
            }
        }
    }

    <span class="SKwd">var</span> a = <span class="SNum">0</span>
    <span class="SFct">repeatSquare</span>(<span class="SNum">5</span>)
    {
        a += <span class="SNum">1</span>
        <span class="SLgc">if</span> a == <span class="SNum">10</span>
            <span class="SLgc">break</span>
    }

    <span class="SItr">@assert</span>(a == <span class="SNum">10</span>)
}</span></div>
<p>In a macro, you can use special variables named <span class="code-inline">@alias&lt;num&gt;</span>. Note that this is also valid for mixins. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Macro]</span>
    <span class="SKwd">func</span> <span class="SFct">call</span>(v: <span class="STpe">s32</span>, stmt: <span class="STpe">code</span>)
    {
        <span class="SKwd">var</span> <span class="SItr">@alias0</span> = v
        <span class="SKwd">var</span> <span class="SItr">@alias1</span> = v * <span class="SNum">2</span>
        <span class="SCmp">#mixin</span> stmt
    }

    <span class="SFct">call</span>(<span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(<span class="SItr">@alias0</span> == <span class="SNum">20</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@alias1</span> == <span class="SNum">40</span>)
    }

    <span class="SCmt">// The caller can then name those special variables</span>
    <span class="SCmt">// Use |name0, name1, ...| before the function call parameters</span>
    <span class="SFct">call</span>(|x| <span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(x == <span class="SNum">20</span>)        <span class="SCmt">// x is @alias0</span>
        <span class="SItr">@assert</span>(<span class="SItr">@alias1</span> == <span class="SNum">40</span>)  <span class="SCmt">// @alias1 is not renamed</span>
    }

    <span class="SFct">call</span>(|x, y| <span class="SNum">20</span>)
    {
        <span class="SItr">@assert</span>(x == <span class="SNum">20</span>)   <span class="SCmt">// x is @alias0</span>
        <span class="SItr">@assert</span>(y == <span class="SNum">40</span>)   <span class="SCmt">// y is @alias1</span>
    }
}</span></div>

<h3 id="100_function_105_006_variadic_parameters">Variadic parameters</h3><p>A function can take a variable number of arguments with <span class="code-inline">...</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(value: <span class="STpe">bool</span>, parameters: ...)
    {
    }

    <span class="SFct">myFunction</span>(<span class="SKwd">true</span>, <span class="SNum">4</span>, <span class="SStr">"true"</span>, <span class="SNum">5.6</span>)
}</span></div>
<p>In that case, <span class="code-inline">parameters</span> is a slice of <span class="code-inline">any</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(parameters: ...)
    {
        <span class="SCmt">// We can know the number of parameters at runtime with '@countof'</span>
        <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(parameters) == <span class="SNum">3</span>)

        <span class="SCmt">// Each parameter is a type 'any'</span>
        <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(parameters[<span class="SNum">0</span>]) == <span class="STpe">any</span>
        <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(parameters[<span class="SNum">1</span>]) == <span class="STpe">any</span>
        <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">any</span>

        <span class="SCmt">// But you can use '@kindof' to get the real type (at runtime) of the parameter</span>
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">0</span>]) == <span class="STpe">s32</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">1</span>]) == <span class="STpe">string</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">f32</span>)
    }

    <span class="SFct">myFunction</span>(<span class="SNum">4</span>, <span class="SStr">"true"</span>, <span class="SNum">5.6</span>)
}</span></div>
<p>If all variadic parameters are of the same type, you can force it. Parameters then won't be of type <span class="code-inline">any</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunction</span>(value: <span class="STpe">bool</span>, parameters: <span class="STpe">s32</span>...)
    {
        <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(parameters[<span class="SNum">0</span>]).name == <span class="SStr">"s32"</span>
        <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(parameters[<span class="SNum">1</span>]).name == <span class="SStr">"s32"</span>
        <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(parameters[<span class="SNum">2</span>]) == <span class="STpe">s32</span>
        <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(parameters[<span class="SNum">3</span>]) == <span class="STpe">s32</span>

        <span class="SItr">@assert</span>(parameters[<span class="SNum">0</span>] == <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">1</span>] == <span class="SNum">20</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">2</span>] == <span class="SNum">30</span>)
        <span class="SItr">@assert</span>(parameters[<span class="SNum">3</span>] == <span class="SNum">40</span>)
    }

    <span class="SFct">myFunction</span>(<span class="SKwd">true</span>, <span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>, <span class="SNum">40</span>)
}</span></div>
<p>Variadic parameters can be passed from function to function. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SCst">A</span>(params: ...)
    {
        <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(params) == <span class="SNum">2</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(params[<span class="SNum">0</span>]) == <span class="STpe">string</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@kindof</span>(params[<span class="SNum">1</span>]) == <span class="STpe">bool</span>)
        <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) params[<span class="SNum">0</span>] == <span class="SStr">"value"</span>)
        <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">bool</span>) params[<span class="SNum">1</span>] == <span class="SKwd">true</span>)
    }

    <span class="SKwd">func</span> <span class="SCst">B</span>(params: ...)
    {
        <span class="SCst">A</span>(params)
    }

    <span class="SCst">B</span>(<span class="SStr">"value"</span>, <span class="SKwd">true</span>)
}</span></div>
<p>You can spread the content of an array or a slice to variadic parameters with <span class="code-inline">@spread</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sum</span>(params: <span class="STpe">s32</span>...)-&gt;<span class="STpe">s32</span>
    {
        <span class="SCmt">// Note that variadic parameters can be visited, as this is a slice</span>
        <span class="SKwd">var</span> total = <span class="SNum">0</span>
        <span class="SLgc">visit</span> v: params
            total += v
        <span class="SLgc">return</span> total
    }

    <span class="SKwd">var</span> arr = [<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>]
    <span class="SKwd">let</span> res = <span class="SFct">sum</span>(<span class="SItr">@spread</span>(arr)) <span class="SCmt">// is equivalent to sum(1, 2, 3, 4)</span>
    <span class="SItr">@assert</span>(res == <span class="SNum">1</span>+<span class="SNum">2</span>+<span class="SNum">3</span>+<span class="SNum">4</span>)

    <span class="SKwd">let</span> res1 = <span class="SFct">sum</span>(<span class="SItr">@spread</span>(arr[<span class="SNum">1.</span>.<span class="SNum">2</span>])) <span class="SCmt">// is equivalent to sum(2, 3)</span>
    <span class="SItr">@assert</span>(res1 == <span class="SNum">2</span>+<span class="SNum">3</span>)
}</span></div>

<h3 id="100_function_106_007_ufcs">Ufcs</h3><p><i>ufcs</i> stands for <i>uniform function call syntax</i>. It allows every functions to be called with a <span class="code-inline">param.func()</span> form when the first parameter of <span class="code-inline">func()</span> is of the same type as <span class="code-inline">param</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">myFunc</span>(param: <span class="STpe">bool</span>) =&gt; param

    <span class="SKwd">let</span> b = <span class="SKwd">false</span>
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(b) == b.<span class="SFct">myFunc</span>())
}</span></div>
<p>This means that in Swag, there are only <i>static</i> functions, but which can be called like <i>methods</i>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x, y: <span class="STpe">s32</span>; }
    <span class="SKwd">func</span> <span class="SFct">set</span>(<span class="SKwd">using</span> pt: *<span class="SCst">Point</span>, value: <span class="STpe">s32</span>) { x, y = value; }

    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>

    <span class="SCmt">// Ufcs call</span>
    pt.<span class="SFct">set</span>(<span class="SNum">10</span>)
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">10</span>)

    <span class="SCmt">// Normal call</span>
    <span class="SFct">set</span>(&pt, <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">20</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}</span></div>

<h3 id="100_function_107_008_constexpr">Constexpr</h3><p>A function marked with <span class="code-inline">Swag.ConstExpr</span> can be executed by the compiler if it can. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">f32</span>) =&gt; x + y</span></div>
<p>Here <span class="code-inline">G</span> will be baked to 3 by the compiler. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">G</span> = <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)
<span class="SCmp">#assert</span> <span class="SCst">G</span> == <span class="SNum">3</span></span></div>
<p>If a function is not <span class="code-inline">ConstExpr</span>, you can force the compile time call with <span class="code-inline">#run</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">mul</span>(x, y: <span class="STpe">f32</span>) =&gt; x * y
<span class="SKwd">const</span> <span class="SCst">G1</span> = <span class="SFct">#run</span> <span class="SFct">mul</span>(<span class="SNum">3</span>, <span class="SNum">6</span>)
<span class="SCmp">#assert</span> <span class="SCst">G1</span> == <span class="SNum">18</span></span></div>

<h3 id="100_function_108_009_function_overloading">Function overloading</h3><p>Functions can have the same names as long as their parameters are different. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
{
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y, z: <span class="STpe">s32</span>) =&gt; x + y + z
}

<span class="SCmp">#assert</span> <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>) == <span class="SNum">3</span>
<span class="SCmp">#assert</span> <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>) == <span class="SNum">6</span></span></div>
<p>Note that in Swag, there is no implicit cast for function parameters. So you must always specify the right type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">over</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y
    <span class="SKwd">func</span> <span class="SFct">over</span>(x, y: <span class="STpe">s64</span>) =&gt; x * y

    <span class="SCmt">// This would generate an error because it's ambiguous, as 1 and 2 are not strong types</span>
    <span class="SCmt">// var res0 = over(1, 2)</span>

    <span class="SKwd">let</span> res0 = <span class="SFct">over</span>(<span class="SNum">1</span>'<span class="STpe">s32</span>, <span class="SNum">2</span>'<span class="STpe">s32</span>)
    <span class="SItr">@assert</span>(res0 == <span class="SNum">3</span>)
    <span class="SKwd">let</span> res1 = <span class="SFct">over</span>(<span class="SNum">1</span>'<span class="STpe">s64</span>, <span class="SNum">2</span>'<span class="STpe">s64</span>)
    <span class="SItr">@assert</span>(res1 == <span class="SNum">2</span>)
}</span></div>

<h3 id="100_function_109_010_discard">Discard</h3><p>By default, you must always use the returned value of a function, otherwise the compiler will generate an error. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">sum</span>(x, y: <span class="STpe">s32</span>) =&gt; x + y

    <span class="SCmt">// This would generated an error, because the return value of 'sum' is not used</span>
    <span class="SCmt">// sum(2, 3)</span>

    <span class="SCmt">// To force the return value to be ignored, you can use 'discard' at the call site</span>
    <span class="SKwd">discard</span> <span class="SFct">sum</span>(<span class="SNum">2</span>, <span class="SNum">3</span>)

}</span></div>
<p>If a function authorizes the caller to not use its return value, because it's not that important, it can be marked with <span class="code-inline">Swag.Discardable</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Discardable]</span>
    <span class="SKwd">func</span> <span class="SFct">mul</span>(x, y: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span> =&gt; x * y

    <span class="SCmt">// This is fine to ignore the return value of 'mul' (even if strange)</span>
    <span class="SFct">mul</span>(<span class="SNum">2</span>, <span class="SNum">4</span>)
}</span></div>

<h3 id="100_function_110_011_retval">Retval</h3><p>Inside a function, you can use the <span class="code-inline">retval</span> type which is an alias to the function return type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>()-&gt;<span class="STpe">s32</span>
    {
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span>
        result = <span class="SNum">10</span>
        <span class="SLgc">return</span> result
    }

    <span class="SItr">@assert</span>(<span class="SFct">toto</span>() == <span class="SNum">10</span>)
}</span></div>
<p>But <span class="code-inline">retval</span> will also make a direct reference to the caller storage, to avoid an unnecessary copy (if possible). So this is mostly a hint for the compiler, and usefull when the function returns a complexe type like a struct, a tuple or an array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> { x, y, z: <span class="STpe">f64</span>; }

    <span class="SKwd">func</span> <span class="SFct">getWhite</span>()-&gt;<span class="SCst">RGB</span>
    {
        <span class="SCmt">// To avoid the clear of the returned struct, we use = undefined</span>
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span> = <span class="SKwd">undefined</span>
        result.x = <span class="SNum">0.5</span>
        result.y = <span class="SNum">0.1</span>
        result.z = <span class="SNum">1.0</span>
        <span class="SLgc">return</span> result
    }

    <span class="SCmt">// Here the 'getWhite' function can directly modify r, g and b without storing</span>
    <span class="SCmt">// a temporary value on the stack.</span>
    <span class="SKwd">let</span> (r, g, b) = <span class="SFct">getWhite</span>()
    <span class="SItr">@assert</span>(r == <span class="SNum">0.5</span>)
    <span class="SItr">@assert</span>(g == <span class="SNum">0.1</span>)
    <span class="SItr">@assert</span>(b == <span class="SNum">1.0</span>)
}</span></div>
<p>This is the preferred way (because optimal) to return a struct or an array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">toto</span>()-&gt;[<span class="SNum">255</span>] <span class="STpe">s32</span>
    {
        <span class="SCmt">// To avoid the clear of the array, we use = undefined</span>
        <span class="SKwd">var</span> result: <span class="SKwd">retval</span> = <span class="SKwd">undefined</span>
        <span class="SLgc">loop</span> i: <span class="SNum">255</span>
            result[i] = i
        <span class="SLgc">return</span> result
    }

    <span class="SKwd">var</span> arr = <span class="SFct">toto</span>()
    <span class="SItr">@assert</span>(arr[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(arr[<span class="SNum">100</span>] == <span class="SNum">100</span>)
    <span class="SItr">@assert</span>(arr[<span class="SNum">254</span>] == <span class="SNum">254</span>)
}</span></div>

<h3 id="100_function_111_012_foreign">Foreign</h3><p>Swag can interop with external "modules" (dlls under windows), which contain exported C functions. </p>
<p>Put a special attribute <span class="code-inline">Swag.Foreign</span> before the function prototype, and specify the module name where the function is located. </p>
<p>The module name can be a swag compiled module, or an external system module (where the location depends on the OS). </p>
<p>In the case below, the function is located in <span class="code-inline">kernel32.dll</span> (under windows) </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Foreign("kernel32")]</span>
<span class="SKwd">func</span> <span class="SCst">ExitProcess</span>(uExitCode: <span class="STpe">u32</span>);

<span class="SCmt">// Like for other attributes, you can use a block.</span>
<span class="SAtr">#[Swag.Foreign("kernel32")]</span>
{
    <span class="SKwd">func</span> <span class="SCst">ExitProcess</span>(uExitCode: <span class="STpe">u32</span>);
    <span class="SKwd">func</span> <span class="SCst">Sleep</span>(dwMilliseconds: <span class="STpe">u32</span>);
}</span></div>
<p>Note that in the case of an external module, you will have to declare somewhere the imported library too. </p>
<p><span class="code-inline">#foreignlib</span> is here to force a link to the given library (when generating executables). </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#foreignlib</span> <span class="SStr">"kernel32"</span></span></div>

<h2 id="120_intrinsics">Intrinsics</h2><p>This is the list of all intrinsics. All intrinsics start with <span class="code-inline">@</span>, which is reserved for them. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip</span></div>
<h3 id="120_intrinsics_Base">Base </h3>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@assert</span>(value: <span class="STpe">bool</span>);
<span class="SKwd">func</span> <span class="SItr">@breakpoint</span>();
<span class="SKwd">func</span> <span class="SItr">@getcontext</span>()-&gt;*<span class="SCst">Swag</span>.<span class="SCst">Context</span>;
<span class="SKwd">func</span> <span class="SItr">@setcontext</span>(context: <span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">Context</span>);
<span class="SKwd">func</span> <span class="SItr">@isbytecode</span>()-&gt;<span class="STpe">bool</span>;
<span class="SKwd">func</span> <span class="SItr">@compiler</span>()-&gt;<span class="SCst">Swag</span>.<span class="SCst">ICompiler</span>;

<span class="SKwd">func</span> <span class="SItr">@args</span>()-&gt;<span class="SKwd">const</span> [..] <span class="STpe">string</span>;
<span class="SItr">@panic</span>()
<span class="SItr">@compilererror</span>()
<span class="SItr">@compilerwarning</span>()</span></div>
<h3 id="120_intrinsics_Buildin">Buildin </h3>
<div class="code-block"><span class="SCde"><span class="SItr">@spread</span>()
<span class="SItr">@init</span>()
<span class="SItr">@drop</span>()
<span class="SItr">@postmove</span>()
<span class="SItr">@postcopy</span>()
<span class="SItr">@sizeof</span>()
<span class="SItr">@alignof</span>()
<span class="SItr">@offsetof</span>()
<span class="SItr">@typeof</span>()
<span class="SItr">@kindof</span>()
<span class="SItr">@countof</span>()
<span class="SItr">@stringof</span>()
<span class="SItr">@dataof</span>()
<span class="SItr">@mkslice</span>()
<span class="SItr">@mkstring</span>()
<span class="SItr">@mkany</span>()
<span class="SItr">@mkinterface</span>()
<span class="SItr">@mkcallback</span>()
<span class="SItr">@getpinfos</span>()
<span class="SItr">@isconstexpr</span>()
<span class="SItr">@itftableof</span>()

<span class="SItr">@index</span></span></div>
<h3 id="120_intrinsics_Memory_related">Memory related </h3>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@alloc</span>(size: <span class="STpe">u64</span>)-&gt;*<span class="STpe">void</span>;
<span class="SKwd">func</span> <span class="SItr">@realloc</span>(ptr: *<span class="STpe">void</span>, size: <span class="STpe">u64</span>)-&gt;*<span class="STpe">void</span>;
<span class="SKwd">func</span> <span class="SItr">@free</span>(ptr: *<span class="STpe">void</span>);
<span class="SKwd">func</span> <span class="SItr">@memset</span>(dst: *<span class="STpe">void</span>, value: <span class="STpe">u8</span>, size: <span class="STpe">u64</span>);
<span class="SKwd">func</span> <span class="SItr">@memcpy</span>(dst: *<span class="STpe">void</span>, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>);
<span class="SKwd">func</span> <span class="SItr">@memmove</span>(dst: *<span class="STpe">void</span>, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>);
<span class="SKwd">func</span> <span class="SItr">@memcmp</span>(dst, src: <span class="SKwd">const</span> *<span class="STpe">void</span>, size: <span class="STpe">u64</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@strlen</span>(value: <span class="SKwd">const</span> *<span class="STpe">u8</span>)-&gt;<span class="STpe">u64</span>;</span></div>
<h3 id="120_intrinsics_Atomic_operations">Atomic operations </h3>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s8</span>, value: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u8</span>, value: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomadd</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s8</span>, value: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u8</span>, value: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomand</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s8</span>, value: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u8</span>, value: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomor</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s8</span>, value: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s16</span>, value: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s32</span>, value: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">s64</span>, value: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u8</span>, value: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u16</span>, value: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u32</span>, value: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxor</span>(addr: *<span class="STpe">u64</span>, value: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s8</span>,  exchangeWith: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s16</span>, exchangeWith: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s32</span>, exchangeWith: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">s64</span>, exchangeWith: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u8</span>,  exchangeWith: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u16</span>, exchangeWith: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u32</span>, exchangeWith: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomxchg</span>(addr: *<span class="STpe">u64</span>, exchangeWith: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s8</span>,  compareTo, exchangeWith: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s16</span>, compareTo, exchangeWith: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s32</span>, compareTo, exchangeWith: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">s64</span>, compareTo, exchangeWith: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u8</span>,  compareTo, exchangeWith: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u16</span>, compareTo, exchangeWith: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u32</span>, compareTo, exchangeWith: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@atomcmpxchg</span>(addr: *<span class="STpe">u64</span>, compareTo, exchangeWith: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;</span></div>
<h3 id="120_intrinsics_Math">Math </h3>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SItr">@sqrt</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@sqrt</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@sin</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@sin</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@cos</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@cos</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@tan</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@tan</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@sinh</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@sinh</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@cosh</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@cosh</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@tanh</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@tanh</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@asin</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@asin</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@acos</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@acos</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@atan</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@atan</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@log</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@log</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@log2</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@log2</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@log10</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@log10</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@floor</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@floor</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@ceil</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@ceil</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@trunc</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@trunc</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@round</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@round</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@abs</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@exp</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@exp</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@exp2</span>(value: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@exp2</span>(value: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;
<span class="SKwd">func</span> <span class="SItr">@pow</span>(value1, value2: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@pow</span>(value1, value2: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@min</span>(value1, value2: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">s8</span>)-&gt;<span class="STpe">s8</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">s16</span>)-&gt;<span class="STpe">s16</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">s64</span>)-&gt;<span class="STpe">s64</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@max</span>(value1, value2: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;

<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountnz</span>(value: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcounttz</span>(value: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u8</span>)-&gt;<span class="STpe">u8</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@bitcountlz</span>(value: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u16</span>)-&gt;<span class="STpe">u16</span>;
<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u32</span>)-&gt;<span class="STpe">u32</span>;
<span class="SKwd">func</span> <span class="SItr">@byteswap</span>(value: <span class="STpe">u64</span>)-&gt;<span class="STpe">u64</span>;

<span class="SKwd">func</span> <span class="SItr">@muladd</span>(val1, val2, val3: <span class="STpe">f32</span>)-&gt;<span class="STpe">f32</span>;
<span class="SKwd">func</span> <span class="SItr">@muladd</span>(val1, val2, val3: <span class="STpe">f64</span>)-&gt;<span class="STpe">f64</span>;</span></div>

<h2 id="121_init">Init</h2><h3 id="121_init_@init">@init </h3>
<p><span class="code-inline">@init</span> can be used to reinitialize a variable/array to the default value. </p>
<p>For a simple variable, the default value is 0. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">666</span>
    <span class="SItr">@init</span>(&x)
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)
}</span></div>
<p>Work also for an array, as you can specify the number of elements you want to initialize. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@init</span>(&x, <span class="SNum">2</span>)    <span class="SCmt">// Initialize 2 elements</span>
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">0</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">0</span>)
}</span></div>
<p>You can also specify a <i>value</i> to initialize, instead of the default one. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">666</span>'<span class="STpe">f32</span>
    <span class="SItr">@init</span>(&x)(<span class="SNum">3.14</span>)  <span class="SCmt">// Initialize to 3.14 instead of zero</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">3.14</span>)
}</span></div>
<p>Same for an array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SItr">@init</span>(&x, <span class="SNum">2</span>)(<span class="SNum">555</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">0</span>] == <span class="SNum">555</span>)
    <span class="SItr">@assert</span>(x[<span class="SNum">1</span>] == <span class="SNum">555</span>)
}</span></div>
<p>When called on a struct, the struct will be restored to the values defined in it. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span>{r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span>}

    <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span>{<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>}
    <span class="SItr">@init</span>(&rgb)
    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">3</span>)
}</span></div>
<p>But you can also specified the values. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span>{r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span>}

    <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span>{<span class="SNum">10</span>, <span class="SNum">20</span>, <span class="SNum">30</span>}
    <span class="SItr">@init</span>(&rgb)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>)
    <span class="SItr">@assert</span>(rgb.r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb.g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb.b == <span class="SNum">7</span>)
}</span></div>
<p>And this works also for array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span>{r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span>}

    <span class="SKwd">var</span> rgb: [<span class="SNum">4</span>] <span class="SCst">RGB</span>
    <span class="SItr">@init</span>(&rgb, <span class="SNum">4</span>)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].b == <span class="SNum">7</span>)
}</span></div>
<h3 id="121_init_@drop">@drop </h3>
<p>For a struct, <span class="code-inline">@init</span> will <b>not</b> call <span class="code-inline">opDrop</span>, so this is mostly useful to initialize a plain old data. </p>
<p>But there is also <span class="code-inline">@drop</span> intrinsic, which works the same, except that it will <span class="code-inline">drop</span> all the content by calling <span class="code-inline">opDrop</span> if it is defined. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span>{r = <span class="SNum">1</span>, g = <span class="SNum">2</span>, b = <span class="SNum">3</span>}

    <span class="SKwd">var</span> rgb: [<span class="SNum">4</span>] <span class="SCst">RGB</span>

    <span class="SCmt">// In fact this is a no op, as struct RGB is plain old data, without a defined 'opDrop'</span>
    <span class="SItr">@drop</span>(&rgb, <span class="SNum">4</span>)

    <span class="SItr">@init</span>(&rgb, <span class="SNum">4</span>)(<span class="SNum">5</span>, <span class="SNum">6</span>, <span class="SNum">7</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].r == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].g == <span class="SNum">6</span>)
    <span class="SItr">@assert</span>(rgb[<span class="SNum">3</span>].b == <span class="SNum">7</span>)
}</span></div>

<h2 id="130_generic">Generic</h2>
<h3 id="130_generic_131_001_declaration">Declaration</h3><p>A function can be generic by specifying some parameters after <span class="code-inline">func</span>. At the call site, you specify the generic parameters with <span class="code-inline">funcCall</span>(type1, type2, ...)(parameters)<span class="code-inline">.</code> Note that parenthesis can be omitted if there's only one generic parameter. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// Here 'T' is a generic type.</span>
        <span class="SKwd">func</span>(<span class="SKwd">var</span> <span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">s32</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>)
    }

    {
        <span class="SCmt">// You can omit 'var' to declare the generic type, because a single identifier</span>
        <span class="SCmt">// is considered to be a type.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">s32</span>(<span class="SNum">2</span>) == <span class="SNum">4</span>)
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>)
    }

    {
        <span class="SCmt">// You can set a default value to the type.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span> = <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">4</span>)
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'<span class="STpe">f32</span>(<span class="SNum">2.0</span>) == <span class="SNum">4.0</span>)
    }

    {
        <span class="SCmt">// Of course you can specify more than one generic parameter</span>
        <span class="SKwd">func</span>(<span class="SCst">K</span>, <span class="SCst">V</span>) <span class="SFct">myFunc</span>(key: <span class="SCst">K</span>, value: <span class="SCst">V</span>) =&gt; value

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>, <span class="SStr">"value"</span>) == <span class="SStr">"value"</span>)              <span class="SCmt">// K and V are deduced</span>
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="STpe">string</span>)(<span class="SNum">2</span>, <span class="SStr">"value"</span>) == <span class="SStr">"value"</span>)    <span class="SCmt">// K and V are explicit</span>

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>, <span class="SKwd">true</span>) == <span class="SKwd">true</span>)
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="STpe">bool</span>)(<span class="SNum">2</span>, <span class="SKwd">true</span>) == <span class="SKwd">true</span>)
    }
}</span></div>
<p>Generic types can be deduced from parameters, so <span class="code-inline">func</span>type()<span class="code-inline"> is not always necessary.</code> </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">myFunc</span>(val: <span class="SCst">T</span>) =&gt; <span class="SNum">2</span> * val

    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">4</span>)         <span class="SCmt">// T is deduced to be s32</span>
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">2.0</span>'<span class="STpe">f32</span>) == <span class="SNum">4.0</span>)     <span class="SCmt">// T is deduced to be f32</span>
}</span></div>
<p>You can also specify constants as generic parameters. </p>
<p><span class="code-inline">N</span> is a constant a type <span class="code-inline">s32</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SKwd">const</span> <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() = <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>'<span class="SNum">10</span>()
}</span></div>
<p><span class="code-inline">const</span> can also be omitted, as an identifier followed by a type definition is considered to be a constant and not a type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() = <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>'<span class="SNum">10</span>()
}</span></div>
<p>You can also assign a default value to the constant. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">N</span>: <span class="STpe">s32</span> = <span class="SNum">10</span>) <span class="SFct">myFunc</span>() = <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>()
}</span></div>
<p>You can ommit the type if you declare the constant with <span class="code-inline">const</span>. It will be deduced from the assignment expression. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SKwd">const</span> <span class="SCst">N</span> = <span class="SNum">10</span>) <span class="SFct">myFunc</span>() = <span class="SItr">@assert</span>(<span class="SCst">N</span> == <span class="SNum">10</span>)
    <span class="SFct">myFunc</span>()
}</span></div>
<p>You can mix types and constants. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SCmt">// `T` is a type, `N` is a constant of type `s32`, because remember that an identifier</span>
        <span class="SCmt">// alone is considered to be a generic type.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(x: <span class="SCst">T</span>) =&gt; x * <span class="SCst">N</span>

        <span class="SKwd">namealias</span> call = <span class="SFct">myFunc</span>'(<span class="STpe">s32</span>, <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(<span class="SFct">call</span>(<span class="SNum">2</span>) == <span class="SNum">20</span>)
        <span class="SItr">@assert</span>(<span class="SFct">call</span>(<span class="SNum">100</span>) == <span class="SNum">1000</span>)
    }

    {
        <span class="SCmt">// So if you want to declare multiple constants, specify the type (or 'const') for each.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span>: <span class="STpe">s32</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SFct">myFunc</span>() =&gt; <span class="SCst">T</span> * <span class="SCst">N</span>

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>'(<span class="SNum">5</span>, <span class="SNum">10</span>)() == <span class="SNum">50</span>)
    }

    {
        <span class="SCmt">// And if you want to declare multiple types with default values, specify the value for each.</span>
        <span class="SKwd">func</span>(<span class="SCst">T</span> = <span class="STpe">s32</span>, <span class="SCst">V</span> = <span class="STpe">s32</span>) <span class="SFct">myFunc</span>(x: <span class="SCst">T</span>, y: <span class="SCst">V</span>) =&gt; x * y

        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">1</span>'<span class="STpe">s32</span>, <span class="SNum">2</span>'<span class="STpe">f32</span>) == <span class="SNum">2.0</span>)
        <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">1</span>'<span class="STpe">s32</span>, <span class="SNum">2</span>'<span class="STpe">s32</span>) == <span class="SNum">2</span>)
    }
}</span></div>
<p>Like functions, a struct can also be generic. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">Struct</span>
        {
            val: <span class="SCst">T</span>
        }

        <span class="SKwd">var</span> x: <span class="SCst">Struct</span>'<span class="STpe">s32</span>
        <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(x.val) == <span class="STpe">s32</span>)
        <span class="SKwd">var</span> x1: <span class="SCst">Struct</span>'<span class="STpe">f32</span>
        <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(x1.val) == <span class="STpe">f32</span>)
    }

    {
        <span class="SKwd">struct</span>(<span class="SCst">T</span>, <span class="SCst">N</span>: <span class="STpe">s32</span>) <span class="SCst">Struct</span>
        {
            val: [<span class="SCst">N</span>] <span class="SCst">T</span>
        }

        <span class="SKwd">var</span> x: <span class="SCst">Struct</span>'(<span class="STpe">bool</span>, <span class="SNum">10</span>)
        <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(x.val) == <span class="STpe">#type</span> [<span class="SNum">10</span>] <span class="STpe">bool</span>)
    }
}</span></div>

<h3 id="130_generic_132_002_validif">Validif</h3><h4 id="130_generic_132_002_validif_One_time_evaluation">One time evaluation </h4>
<p>On a function, you can use <span class="code-inline">#validif</span> to check if the usage of the function is correct. </p>
<p>If the <span class="code-inline">#validif</span> expression returns false, then the function will not be considered for the call. If there's no other overload to match, then the compiler will raise an error. </p>
<p>The <span class="code-inline">#validif</span> expression is evaluated <b>only once</b>, whatever the call, so it is typically used to check generic parameters. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// Here we validate the function only if the generic type is `s32` or `s64`.</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x: <span class="SCst">T</span>...)-&gt;<span class="SCst">T</span>
        <span class="SCmp">#validif</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s64</span>
    {
        <span class="SKwd">var</span> total = <span class="SNum">0</span>'<span class="SCst">T</span>
        <span class="SLgc">visit</span> it: x
            total += it
        <span class="SLgc">return</span> total
    }

    <span class="SCmt">// This is ok.</span>
    <span class="SKwd">let</span> res1 = <span class="SFct">sum</span>'<span class="STpe">s32</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(res1 == <span class="SNum">3</span>)
    <span class="SKwd">let</span> res2 = <span class="SFct">sum</span>'<span class="STpe">s64</span>(<span class="SNum">10</span>, <span class="SNum">20</span>)
    <span class="SItr">@assert</span>(res2 == <span class="SNum">30</span>)

    <span class="SCmt">// But the following would generate an error because the type is `f32`.</span>
    <span class="SCmt">// So there's no match possible for that type.</span>

    <span class="SCmt">// var res1 = sum'f32(1, 2)</span>
}</span></div>
<p>You can use <span class="code-inline">#validif</span> to make a kind of a generic specialisation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// s32 version</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">isNull</span>(x: <span class="SCst">T</span>)-&gt;<span class="STpe">bool</span>
        <span class="SCmp">#validif</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s32</span>
    {
        <span class="SLgc">return</span> x == <span class="SNum">0</span>
    }

    <span class="SCmt">// f32/f64 version</span>
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">isNull</span>(x: <span class="SCst">T</span>)-&gt;<span class="STpe">bool</span>
        <span class="SCmp">#validif</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">f32</span> <span class="SLgc">or</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">f64</span>
    {
        <span class="SLgc">return</span> <span class="SItr">@abs</span>(x) &lt; <span class="SNum">0.01</span>
    }

    <span class="SItr">@assert</span>(<span class="SFct">isNull</span>(<span class="SNum">0</span>'<span class="STpe">s32</span>))
    <span class="SItr">@assert</span>(<span class="SFct">isNull</span>(<span class="SNum">0.001</span>'<span class="STpe">f32</span>))
}</span></div>
<p>Instead of a single expression, <span class="code-inline">#validif</span> can be followed by a block that returns a <span class="code-inline">bool</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x: <span class="SCst">T</span>...)-&gt;<span class="SCst">T</span>
        <span class="SCmp">#validif</span>
        {
            <span class="SLgc">if</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s64</span>
                <span class="SLgc">return</span> <span class="SKwd">true</span>
            <span class="SLgc">return</span> <span class="SKwd">false</span>
        }
    {
        <span class="SKwd">var</span> total = <span class="SNum">0</span>'<span class="SCst">T</span>
        <span class="SLgc">visit</span> it: x
            total += it
        <span class="SLgc">return</span> total
    }
}</span></div>
<p>By using <span class="code-inline">@compilererror</span>, you can then trigger your own errors at compile time if the type is incorrect. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span>(<span class="SCst">T</span>) <span class="SFct">sum</span>(x, y: <span class="SCst">T</span>)-&gt;<span class="SCst">T</span>
        <span class="SCmp">#validif</span>
        {
            <span class="SLgc">if</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s32</span> <span class="SLgc">or</span> <span class="SItr">@typeof</span>(<span class="SCst">T</span>) == <span class="STpe">s64</span>
                <span class="SLgc">return</span> <span class="SKwd">true</span>
            <span class="SItr">@compilererror</span>(<span class="SStr">"invalid type "</span> ++ <span class="SItr">@stringof</span>(<span class="SCst">T</span>), <span class="SItr">@location</span>(<span class="SCst">T</span>))
            <span class="SLgc">return</span> <span class="SKwd">false</span>
        }
    {
        <span class="SLgc">return</span> x + y
    }

    <span class="SCmt">// This will trigger an error</span>

    <span class="SCmt">// var x = sum'f32(1, 2)</span>
}</span></div>
<p><span class="code-inline">#validif</span> can also be used on a generic struct. Unlike functions, if the expression failed, then you will have an error right away because there's no overload in the case of structures. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">Point</span>
        <span class="SCmp">#validif</span> <span class="SCst">T</span> == <span class="STpe">f32</span> <span class="SLgc">or</span> <span class="SCst">T</span> == <span class="STpe">f64</span>
    {
        x, y: <span class="SCst">T</span>
    }

    <span class="SCmt">// Fine.</span>
    <span class="SKwd">var</span> v: <span class="SCst">Point</span>'<span class="STpe">f32</span>

    <span class="SCmt">// Error.</span>
    <span class="SCmt">//var v: Point's32</span>
}</span></div>
<h4 id="130_generic_132_002_validif_Multiple_evaluations">Multiple evaluations </h4>
<p>Instead of <span class="code-inline">#validif</span>, you can use <span class="code-inline">#validifx</span>. <span class="code-inline">#validifx</span> is evaluated for <b>each</b> call, so it can be used to check parameters, as long as they can be <b>evaluated at compile time</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    {
        <span class="SKwd">func</span> <span class="SFct">div</span>(x, y: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
            <span class="SCmp">#validifx</span>
            {
                <span class="SCmt">// Here we use '@isconstexpr'.</span>
                <span class="SCmt">// If 'y' cannot be evaluated at compile time, then we can do nothing about it.</span>
                <span class="SLgc">if</span> !<span class="SItr">@isconstexpr</span>(y)
                    <span class="SLgc">return</span> <span class="SKwd">true</span>
                <span class="SLgc">if</span> y == <span class="SNum">0</span>
                    <span class="SItr">@compilererror</span>(<span class="SStr">"division by zero"</span>, <span class="SItr">@location</span>(y))
                <span class="SLgc">return</span> <span class="SKwd">true</span>
            }
        {
            <span class="SLgc">return</span> x / y
        }

        <span class="SCmt">// Fine</span>
        <span class="SKwd">var</span> x1 = <span class="SFct">div</span>(<span class="SNum">1</span>, <span class="SNum">1</span>)

        <span class="SCmt">// Error at compile time, division by zero.</span>

        <span class="SCmt">// var x2 = div(1, 0)</span>
    }

    {
        <span class="SCmt">// A version of 'first' where 'x' is known at compile time.</span>
        <span class="SKwd">func</span> <span class="SFct">first</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
            <span class="SCmp">#validifx</span> <span class="SItr">@isconstexpr</span>(x)
        {
            <span class="SLgc">return</span> <span class="SNum">555</span>
        }

        <span class="SCmt">// A version of 'first' where 'x' is **not** known at compile time.</span>
        <span class="SKwd">func</span> <span class="SFct">first</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
            <span class="SCmp">#validifx</span> !<span class="SItr">@isconstexpr</span>(x)
        {
            <span class="SLgc">return</span> <span class="SNum">666</span>
        }

        <span class="SCmt">// Will call version 1 because parameter is a literal.</span>
        <span class="SItr">@assert</span>(<span class="SFct">first</span>(<span class="SNum">0</span>) == <span class="SNum">555</span>)

        <span class="SCmt">// Will call version 2 because parameter is a variable.</span>
        <span class="SKwd">var</span> a: <span class="STpe">s32</span>
        <span class="SItr">@assert</span>(<span class="SFct">first</span>(a) == <span class="SNum">666</span>)
    }
}</span></div>

<h3 id="130_generic_133_003_constraint">Constraint</h3><p>Swag provides also a simple way of checking generic parameters, without the need of <span class="code-inline">#validif</span>. A type constraint can be added when declaring a generic type. If a function or a struct is instantiated with a type that does not conform to the constraint, then an error will be raised. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// The type constraint is a compile time function (with #[Swag.ConstExpr]) that should return a bool.</span>
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">isS32</span>(t: <span class="STpe">typeinfo</span>) =&gt; t == <span class="STpe">s32</span>

    <span class="SCmt">// Here we check that the function generic type is 's32' by calling 'isS32'.</span>
    <span class="SKwd">func</span>(<span class="SKwd">var</span> <span class="SCst">T</span>: <span class="SFct">isS32</span>(<span class="SCst">T</span>)) <span class="SFct">sum</span>(x: <span class="SCst">T</span>...)-&gt;<span class="SCst">T</span>
    {
        <span class="SKwd">var</span> total = <span class="SNum">0</span>'<span class="SCst">T</span>
        <span class="SLgc">visit</span> it: x
            total += it
        <span class="SLgc">return</span> total
    }

    <span class="SCmt">// This is ok.</span>
    <span class="SKwd">let</span> res1 = <span class="SFct">sum</span>'<span class="STpe">s32</span>(<span class="SNum">1</span>, <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(res1 == <span class="SNum">3</span>)

    <span class="SCmt">// But the following would generate an error because the type is 'f32'.</span>
    <span class="SCmt">// let res1 = sum'f32(1, 2)</span>
}</span></div>
<p>The type constraint can be any compile time expression, as long as the resulting type is <span class="code-inline">bool</span>. So you could do something like this. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">isS32</span>(t: <span class="STpe">typeinfo</span>)  =&gt; t == <span class="STpe">s32</span>
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">isBool</span>(t: <span class="STpe">typeinfo</span>) =&gt; t == <span class="STpe">bool</span>

    <span class="SCmt">// Here we check that the function generic type is 's32' or 'bool'.</span>
    <span class="SKwd">func</span>(<span class="SKwd">var</span> <span class="SCst">T</span>: <span class="SFct">isS32</span>(<span class="SCst">T</span>) <span class="SLgc">or</span> <span class="SFct">isBool</span>(<span class="SCst">T</span>)) <span class="SFct">myFunc</span>(x: <span class="SCst">T</span>) =&gt; x

    <span class="SCmt">// This is ok.</span>
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">5</span>'<span class="STpe">s32</span>) == <span class="SNum">5</span>)
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SKwd">true</span>)  == <span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SKwd">false</span>) == <span class="SKwd">false</span>)
}</span></div>
<p>Works also for structs. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">isFloat</span>(t: <span class="STpe">typeinfo</span>) =&gt; t == <span class="STpe">f32</span> <span class="SLgc">or</span> t == <span class="STpe">f64</span>

    <span class="SKwd">struct</span>(<span class="SKwd">var</span> <span class="SCst">T</span>: <span class="SFct">isFloat</span>(<span class="SCst">T</span>)) <span class="SCst">Point</span>
    {
        x, y: <span class="SCst">T</span>
    }

    <span class="SKwd">var</span> pt:  <span class="SCst">Point</span>'<span class="STpe">f32</span>
    <span class="SKwd">var</span> pt1: <span class="SCst">Point</span>'<span class="STpe">f64</span>

    <span class="SCmt">// This will generate a type constraint error.</span>
    <span class="SCmt">//var pt: Point's32</span>
}</span></div>

<h2 id="140_attributes">Attributes</h2><p>Attributes are tags associated with functions, structures etc... </p>

<h3 id="140_attributes_141_001_user_attributes">User attributes</h3><p>User attributes are declared like functions, but with the <span class="code-inline">attr</span> keyword before instead of <span class="code-inline">func</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">using</span> <span class="SCst">Swag</span>
<span class="SKwd">attr</span> <span class="SCst">AttributeA</span>()</span></div>
<p>Like functions, attributes can have parameters. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">attr</span> <span class="SCst">AttributeB</span>(x, y: <span class="STpe">s32</span>, z: <span class="STpe">string</span>)</span></div>
<p>So attributes can also have default values. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">attr</span> <span class="SCst">AttributeBA</span>(x: <span class="STpe">s32</span>, y: <span class="STpe">string</span> = <span class="SStr">"string"</span>)</span></div>
<p>You can define a usage before the attribute definition to restrict its usage. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">AttributeC</span>()</span></div>
<p>To use an attribute, the syntax is <span class="code-inline">#[attribute, attribute...]</span>. It should be placed <b>before</b> the thing you want to tag. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttributeA, AttributeB(0, 0, "string")]</span>
<span class="SKwd">func</span> <span class="SFct">function1</span>()
{
}</span></div>
<p>You can declare multiple usages. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function | AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SCst">AttributeD</span>(x: <span class="STpe">s32</span>);

<span class="SAtr">#[AttributeD(6)]</span>
<span class="SKwd">func</span> <span class="SFct">function2</span>()
{
}

<span class="SAtr">#[AttributeD(150)]</span>
<span class="SKwd">struct</span> struct1
{
}</span></div>
<p>Finaly, attributes can be retrieved at runtime thanks to <b>type reflection</b>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> type = <span class="SItr">@typeof</span>(function2)                  <span class="SCmt">// Get the type of the function</span>
    <span class="SItr">@assert</span>(<span class="SItr">@countof</span>(type.attributes) == <span class="SNum">1</span>)     <span class="SCmt">// Check that the function has one attribute associated with it</span>
}</span></div>

<h3 id="140_attributes_142_002_predefined_attributes">Predefined attributes</h3><p>This is the list of predefined attributes. All are located in the reserved <span class="code-inline">Swag</span> namespace. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">ConstExpr</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function|AttributeUsage.Struct|AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SCst">PrintBc</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function|AttributeUsage.GlobalVariable)]</span>
<span class="SKwd">attr</span> <span class="SCst">Compiler</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Inline</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Macro</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Mixin</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Test</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Implicit</span>()

<span class="SCmt">// Hardcoded also for switch</span>
<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Complete</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">CalleeReturn</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Foreign</span>(module: <span class="STpe">string</span>, function: <span class="STpe">string</span> = <span class="SStr">""</span>);

<span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Callback</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function|AttributeUsage.Variable)]</span>
<span class="SKwd">attr</span> <span class="SCst">Discardable</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Function|AttributeUsage.Struct|AttributeUsage.Enum|AttributeUsage.EnumValue)]</span>
<span class="SKwd">attr</span> <span class="SCst">Deprecated</span>(msg: <span class="STpe">string</span> = <span class="SKwd">null</span>)

<span class="SCmt">// Hardcoded for type typealias</span>
<span class="SKwd">attr</span> <span class="SCst">Strict</span>()

<span class="SCmt">// Hardcoded for local variables</span>
<span class="SKwd">attr</span> <span class="SCst">Global</span>()

<span class="SCmt">// Hardcoded for struct and variables</span>
<span class="SKwd">attr</span> <span class="SCst">Align</span>(value: <span class="STpe">u8</span>)

<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SCst">Pack</span>(value: <span class="STpe">u8</span>)

<span class="SAtr">#[AttrUsage(AttributeUsage.Struct)]</span>
<span class="SKwd">attr</span> <span class="SCst">NoCopy</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.StructVariable)]</span>
<span class="SKwd">attr</span> <span class="SCst">Offset</span>(name: <span class="STpe">string</span>)

<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SCst">EnumFlags</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SCst">EnumIndex</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.Enum)]</span>
<span class="SKwd">attr</span> <span class="SCst">NoDuplicate</span>()

<span class="SAtr">#[AttrUsage(AttributeUsage.All|AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SCst">Safety</span>(what: <span class="STpe">string</span>, value: <span class="STpe">bool</span>)

<span class="SAtr">#[AttrUsage(AttributeUsage.All)]</span>
<span class="SKwd">attr</span> <span class="SCst">SelectIf</span>(value: <span class="STpe">bool</span>)

<span class="SAtr">#[AttrUsage(AttributeUsage.Function|AttributeUsage.File)]</span>
<span class="SKwd">attr</span> <span class="SCst">Optim</span>(what: <span class="STpe">string</span>, value: <span class="STpe">bool</span>)</span></div>

<h2 id="160_scoping">Scoping</h2>
<h3 id="160_scoping_161_001_defer">Defer</h3><p><span class="code-inline">defer</span> is used to call an expression when the current scope is left. It's purely compile time, so it does not evaluate until the block is left. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v = <span class="SNum">0</span>
    <span class="SLgc">defer</span> <span class="SItr">@assert</span>(v == <span class="SNum">1</span>)
    v += <span class="SNum">1</span>
    <span class="SCmt">// defer expression will be executed here</span>
}</span></div>
<p><span class="code-inline">defer</span> can also be used with a block. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> v = <span class="SNum">0</span>
    <span class="SLgc">defer</span>
    {
        v += <span class="SNum">10</span>
        <span class="SItr">@assert</span>(v == <span class="SNum">15</span>)
    }

    v += <span class="SNum">5</span>
    <span class="SCmt">// defer block will be executed here</span>
}</span></div>
<p><span class="code-inline">defer</span> expressions are called when leaving the corresponding scope, even with <span class="code-inline">return</span>, <span class="code-inline">break</span>, <span class="code-inline">continue</span> etc., and even inside a <span class="code-inline">loop/while/for</span> etc. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span>
    <span class="SLgc">loop</span> <span class="SNum">10</span>
    {
        <span class="SLgc">defer</span> <span class="SCst">G</span> += <span class="SNum">1</span>
        <span class="SLgc">if</span> <span class="SCst">G</span> == <span class="SNum">2</span>
            <span class="SLgc">break</span>   <span class="SCmt">// will be called here, before breaking the loop</span>
        <span class="SCmt">// will be called here also</span>
    }

    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">3</span>)
}</span></div>
<p><span class="code-inline">defer</span> are executed in reverse order of their declaration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>
    <span class="SLgc">defer</span> <span class="SItr">@assert</span>(x == <span class="SNum">2</span>)   <span class="SCmt">// Will be executed second</span>
    <span class="SLgc">defer</span> x *= <span class="SNum">2</span>            <span class="SCmt">// Will be executed first</span>
}</span></div>
<p>It's typically used to unregister/destroy a resource, by putting the release code just after the creation one. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">createResource</span>() =&gt; <span class="SKwd">true</span>
    <span class="SKwd">func</span> <span class="SFct">releaseResource</span>(resource: *<span class="STpe">bool</span>) = <span class="SKwd">dref</span> resource = <span class="SKwd">false</span>
    <span class="SKwd">func</span> <span class="SFct">isResourceCreated</span>(b: <span class="STpe">bool</span>) =&gt; b

    <span class="SKwd">var</span> resource = <span class="SKwd">false</span>
    <span class="SLgc">loop</span> <span class="SNum">10</span>
    {
        resource = <span class="SFct">createResource</span>()
        <span class="SLgc">defer</span>
        {
            <span class="SItr">@assert</span>(resource.<span class="SFct">isResourceCreated</span>())
            <span class="SFct">releaseResource</span>(&resource)
        }

        <span class="SLgc">if</span> <span class="SItr">@index</span> == <span class="SNum">2</span>
            <span class="SLgc">break</span>
    }

    <span class="SItr">@assert</span>(!resource.<span class="SFct">isResourceCreated</span>())
}</span></div>

<h3 id="160_scoping_162_002_using">Using</h3><p><span class="code-inline">using</span> brings the scope of a namespace, a struct or an enum in the current one. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>; <span class="SCst">G</span>; <span class="SCst">B</span>; }
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span> == <span class="SNum">0</span>)

    <span class="SKwd">using</span> <span class="SCst">RGB</span>
    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">1</span>)
}</span></div>
<p><span class="code-inline">using</span> can also be used with a variable </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x: <span class="STpe">s32</span>, y: <span class="STpe">s32</span> }

    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>

    <span class="SKwd">using</span> pt
    x = <span class="SNum">1</span> <span class="SCmt">// no need to specify 'pt'</span>
    y = <span class="SNum">2</span> <span class="SCmt">// no need to specify 'pt'</span>

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)
}</span></div>
<p>You can declare a variable with <span class="code-inline">using</span> just before. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x: <span class="STpe">s32</span>; y: <span class="STpe">s32</span>; }

    <span class="SKwd">using</span> <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    x = <span class="SNum">1</span> <span class="SCmt">// no need to specify 'pt'</span>
    y = <span class="SNum">2</span> <span class="SCmt">// no need to specify 'pt'</span>

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)
}</span></div>
<h4 id="160_scoping_162_002_using_For_a_function_parameter">For a function parameter </h4>
<p><span class="code-inline">using</span> applied to a function parameter can be seen as the equivalent of the hidden <span class="code-inline">this</span> in C++. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point</span> { x: <span class="STpe">s32</span>; y: <span class="STpe">s32</span>; }

    <span class="SKwd">func</span> <span class="SFct">setOne</span>(<span class="SKwd">using</span> point: *<span class="SCst">Point</span>)
    {
        <span class="SCmt">// Here there's no need to specify 'point'</span>
        x, y = <span class="SNum">1</span>
    }

    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    <span class="SFct">setOne</span>(&pt)
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">1</span>)

    <span class="SCmt">// ufcs</span>
    pt.<span class="SFct">setOne</span>()
    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">1</span>)
}</span></div>
<h4 id="160_scoping_162_002_using_For_a_field">For a field </h4>
<p><span class="code-inline">using</span> can also be used with a field inside a struct. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">Point2</span>
    {
        x, y: <span class="STpe">s32</span>
    }

    <span class="SKwd">struct</span> <span class="SCst">Point3</span>
    {
        <span class="SKwd">using</span> base: <span class="SCst">Point2</span>
        z: <span class="STpe">s32</span>
    }

    <span class="SCmt">// That way the content of the field can be referenced directly</span>
    <span class="SKwd">var</span> value: <span class="SCst">Point3</span>
    value.x = <span class="SNum">0</span> <span class="SCmt">// Equivalent to value.base.x = 0</span>
    value.y = <span class="SNum">0</span> <span class="SCmt">// Equivalent to value.base.y = 0</span>
    value.z = <span class="SNum">0</span>
    <span class="SItr">@assert</span>(&value.x == &value.base.x)
    <span class="SItr">@assert</span>(&value.y == &value.base.y)

    <span class="SCmt">// The compiler can then cast automatically 'Point3' to 'Point2'</span>
    <span class="SKwd">func</span> <span class="SFct">set1</span>(<span class="SKwd">using</span> ptr: *<span class="SCst">Point2</span>)
    {
        x, y = <span class="SNum">1</span>
    }

    <span class="SFct">set1</span>(&value) <span class="SCmt">// Here the cast is automatic thanks to the using</span>
    <span class="SItr">@assert</span>(value.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(value.y == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(value.base.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(value.base.y == <span class="SNum">1</span>)
}</span></div>

<h3 id="160_scoping_163_003_with">With</h3><p>You can use <span class="code-inline">with</span> to avoid repeating the same variable again and again. You can then access fields with a simple <span class="code-inline">.</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">Point</span> { x, y: <span class="STpe">s32</span>; }

<span class="SKwd">impl</span> <span class="SCst">Point</span>
{
    <span class="SKwd">mtd</span> <span class="SFct">setOne</span>()
    {
        x, y = <span class="SNum">1</span>
    }
}</span></div>
<p><span class="code-inline">with</span> on a variable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    <span class="SKwd">with</span> pt
    {
        .x = <span class="SNum">1</span>   <span class="SCmt">// equivalent to pt.x</span>
        .y = <span class="SNum">2</span>   <span class="SCmt">// equivalent to pt.y</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)
}</span></div>
<p>Works for function calls to. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    <span class="SKwd">with</span> pt
    {
        .<span class="SFct">setOne</span>()           <span class="SCmt">// equivalent to pt.setOne() or setOne(pt)</span>
        .y = <span class="SNum">2</span>              <span class="SCmt">// equivalent to pt.y</span>
        <span class="SItr">@assert</span>(.x == <span class="SNum">1</span>)    <span class="SCmt">// equivalent to pt.x</span>
        <span class="SItr">@assert</span>(.y == <span class="SNum">2</span>)    <span class="SCmt">// equivalent to pt.y</span>
        <span class="SItr">@assert</span>(pt.x == <span class="SNum">1</span>)
        <span class="SItr">@assert</span>(pt.y == <span class="SNum">2</span>)
    }
}</span></div>
<p>Works also with a namespace. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SCst">NameSpace</span>
    {
        .<span class="SFct">inside0</span>()
        .<span class="SFct">inside1</span>()
    }
}</span></div>
<p>Instead of an identifier name, <span class="code-inline">with</span> also accepts a variable declaration. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SKwd">var</span> pt = <span class="SCst">Point</span>{<span class="SNum">1</span>, <span class="SNum">2</span>}
    {
        .x = <span class="SNum">10</span>
        .y = <span class="SNum">20</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}

<span class="SFct">#test</span>
{
    <span class="SKwd">with</span> <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    {
        .x = <span class="SNum">10</span>
        .y = <span class="SNum">20</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}</span></div>
<p>Or an affectation statement. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> pt: <span class="SCst">Point</span>
    <span class="SKwd">with</span> pt = <span class="SCst">Point</span>{<span class="SNum">1</span>, <span class="SNum">2</span>}
    {
        .x = <span class="SNum">10</span>
        .y = <span class="SNum">20</span>
    }

    <span class="SItr">@assert</span>(pt.x == <span class="SNum">10</span> <span class="SLgc">and</span> pt.y == <span class="SNum">20</span>)
}


<span class="SKwd">namespace</span> <span class="SCst">NameSpace</span>
{
    <span class="SKwd">func</span> <span class="SFct">inside0</span>() {}
    <span class="SKwd">func</span> <span class="SFct">inside1</span>() {}
}</span></div>

<h2 id="164_alias">Alias</h2><h3 id="164_alias_Type_alias">Type alias </h3>
<p><span class="code-inline">typealias</span> is used to make a shortcut to another type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">enum</span> <span class="SCst">RGB</span> { <span class="SCst">R</span>; <span class="SCst">G</span>; <span class="SCst">B</span>; }
    <span class="SItr">@assert</span>(<span class="SCst">RGB</span>.<span class="SCst">R</span> == <span class="SNum">0</span>)

    <span class="SKwd">typealias</span> <span class="SCst">Color</span> = <span class="SCst">RGB</span>   <span class="SCmt">// 'Color' is now equivalent to 'RGB'</span>
    <span class="SItr">@assert</span>(<span class="SCst">Color</span>.<span class="SCst">G</span> == <span class="SNum">1</span>)
}</span></div>
<p>You can then use the new name in place of the original type. This does not create a new type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">typealias</span> <span class="SCst">Float32</span> = <span class="STpe">f32</span>
    <span class="SKwd">typealias</span> <span class="SCst">Float64</span> = <span class="STpe">f64</span>

    <span class="SKwd">var</span> x: <span class="SCst">Float32</span> = <span class="SNum">1.0</span>    <span class="SCmt">// Same as 'f32'</span>
    <span class="SKwd">var</span> y: <span class="SCst">Float64</span> = <span class="SNum">1.0</span>    <span class="SCmt">// Same as 'f64'</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SCst">Float32</span>) == <span class="STpe">f32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SCst">Float64</span>) == <span class="STpe">f64</span>
}</span></div>
<p>But to create a new type, a <span class="code-inline">typealias</span> can also be marked with the <span class="code-inline">Swag.Strict</span> attribute. In that case, all implicit casts won't be done. Explicit cast are still possible. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Strict]</span>
    <span class="SKwd">typealias</span> <span class="SCst">MyType</span> = <span class="STpe">s32</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(<span class="SCst">MyType</span>) != <span class="STpe">s32</span>
    <span class="SKwd">var</span> x: <span class="SCst">MyType</span> = <span class="SKwd">cast</span>(<span class="SCst">MyType</span>) <span class="SNum">0</span>
}</span></div>
<h3 id="164_alias_Name_alias">Name alias </h3>
<p>You can alias a function name with <span class="code-inline">namealias</span> </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">thisIsABigFunctionName</span>(x: <span class="STpe">s32</span>) =&gt; x * x
    <span class="SKwd">namealias</span> myFunc = thisIsABigFunctionName
    <span class="SItr">@assert</span>(<span class="SFct">myFunc</span>(<span class="SNum">4</span>) == <span class="SNum">16</span>)
}</span></div>
<p>You can also alias variables and namespaces </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> myLongVariableName: <span class="STpe">s32</span> = <span class="SNum">0</span>
    <span class="SKwd">namealias</span> short = myLongVariableName
    short += <span class="SNum">2</span>
    <span class="SItr">@assert</span>(myLongVariableName == <span class="SNum">2</span>)
}</span></div>

<h2 id="170_error_management">Error management</h2><p>Swag contains a <b>very</b> simple error system used to deal with function returning errors. It will probably be changed/improved at some point. </p>
<div class="blockquote blockquote-default">
<p> These are <b>not</b> exceptions ! </p>
</div>
<p>A function that can return an error must be marked with <span class="code-inline">throw</span>. It can then raise an error with the <span class="code-inline">throw</span> keyword, passing an error message. </p>
<div class="blockquote blockquote-default">
<p> When an error is raised by a function, the return value is always equal to the <b>default value</b>, depending on the return type. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">count</span>(name: <span class="STpe">string</span>)-&gt;<span class="STpe">u64</span> <span class="SKwd">throw</span>
{
    <span class="SLgc">if</span> name == <span class="SKwd">null</span>
    {
        <span class="SCmt">// This function will return 0 in case of an error, because this is the default</span>
        <span class="SCmt">// value for 'u64'.</span>
        <span class="SKwd">throw</span> <span class="SStr">"null pointer"</span>
    }

    <span class="SLgc">return</span> <span class="SItr">@countof</span>(name)
}</span></div>
<p>The caller will then have to deal with the error in some way. It can <span class="code-inline">catch</span> it, and test (or not) its value with the <span class="code-inline">@err()</span> intrinsic. The execution will continue at the call site. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc</span>()
{
    <span class="SCmt">// Dismiss the eventual error with 'catch' and continue execution</span>
    <span class="SKwd">let</span> cpt = <span class="SKwd">catch</span> <span class="SFct">count</span>(<span class="SStr">"fileName"</span>)

    <span class="SCmt">// And test it with @err(), which returns the 'throw' corresponding value</span>
    <span class="SLgc">if</span> <span class="SItr">@err</span>() != <span class="SKwd">null</span>
    {
        <span class="SItr">@assert</span>(cpt == <span class="SNum">0</span>)
        <span class="SItr">@print</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) <span class="SItr">@err</span>())
        <span class="SLgc">return</span>
    }

    <span class="SCmt">// You can also use 'trycatch', which will exit the current function in case</span>
    <span class="SCmt">// an error has been raised (returning the default value if necessary)</span>
    <span class="SKwd">var</span> cpt1 = <span class="SKwd">trycatch</span> <span class="SFct">count</span>(<span class="SStr">"fileName"</span>)
}</span></div>
<p>The caller can stop the execution with <span class="code-inline">try</span>, and return to its own caller with the same error raised. The function must then also be marked with <span class="code-inline">throw</span>. </p>
<p>Here, the caller of <span class="code-inline">myFunc1</span> will have to deal with the error at its turn. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc1</span>() <span class="SKwd">throw</span>
{
    <span class="SCmt">// If 'count()' raises an error, 'myFunc1' will return with the same error</span>
    <span class="SKwd">var</span> cpt = <span class="SKwd">try</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
}</span></div>
<p>The caller can also panic if an error is raised, with <span class="code-inline">assume</span>. </p>
<div class="blockquote blockquote-default">
<p> This can be disabled in release builds (in that case the behaviour is undefined). </p>
</div>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc2</span>()
{
    <span class="SCmt">// Here the program will stop with a panic message if 'count()' throws an error</span>
    <span class="SKwd">var</span> cpt = <span class="SKwd">assume</span> <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
}</span></div>
<p>Note that you can use a block instead of one single statement (this does not create a scope). </p>
<div class="code-block"><span class="SCde"><span class="SKwd">func</span> <span class="SFct">myFunc3</span>() <span class="SKwd">throw</span>
{
    <span class="SCmt">// This is not really necessary, see below, but this is just to show 'try' with a block</span>
    <span class="SCmt">// instead of one single call</span>
    <span class="SKwd">try</span>
    {
        <span class="SKwd">var</span> cpt0 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt1 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SKwd">assume</span>
    {
        <span class="SKwd">var</span> cpt2 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt3 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SCmt">// Works also for 'catch' if you do not want to deal with the error message.</span>
    <span class="SCmt">// 'cast(string) @err()' in that case is not really relevant.</span>
    <span class="SKwd">catch</span>
    {
        <span class="SKwd">var</span> cpt4 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt5 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }

    <span class="SCmt">// Works also for 'trycatch' if you do not want to deal with the error message</span>
    <span class="SCmt">// and you want to return as soon as an error is raised.</span>
    <span class="SKwd">trycatch</span>
    {
        <span class="SKwd">var</span> cpt6 = <span class="SFct">count</span>(<span class="SStr">"filename"</span>)
        <span class="SKwd">var</span> cpt7 = <span class="SFct">count</span>(<span class="SStr">"other filename"</span>)
    }
}</span></div>
<p>When a function is marked with <span class="code-inline">throw</span>, the <span class="code-inline">try</span> for a function call is automatic if not specified. That means that most of the time it's not necessary to specify it. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">func</span> <span class="SFct">mySubFunc2</span>() <span class="SKwd">throw</span>
    {
        <span class="SKwd">throw</span> <span class="SStr">"error"</span>
    }

    <span class="SKwd">func</span> <span class="SFct">mySubFunc1</span>() <span class="SKwd">throw</span>
    {
        <span class="SCmt">// In fact there's no need to add a 'try' before the call because 'mySubFunc1' is</span>
        <span class="SCmt">// marked with 'throw'</span>
        <span class="SCmt">// This is less verbose when you do not want to do something special in case</span>
        <span class="SCmt">// of errors (with 'assume', 'catch' or 'trycatch')</span>
        <span class="SFct">mySubFunc2</span>()
    }

    <span class="SKwd">catch</span> <span class="SFct">mySubFunc1</span>()
    <span class="SItr">@assert</span>(<span class="SKwd">cast</span>(<span class="STpe">string</span>) <span class="SItr">@err</span>() == <span class="SStr">"error"</span>)
}</span></div>
<h3 id="170_error_management_defer">defer </h3>
<p><span class="code-inline">defer</span> can have parameters like <span class="code-inline">defer(err)</span> or <span class="code-inline">defer(noerr)</span> to control if it should be executed depending on the error status. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">var</span> g_Defer = <span class="SNum">0</span>

<span class="SKwd">func</span> <span class="SFct">raiseError</span>() <span class="SKwd">throw</span>
{
    <span class="SKwd">throw</span> <span class="SStr">"error"</span>
}

<span class="SKwd">func</span> <span class="SFct">testDefer</span>(err: <span class="STpe">bool</span>) <span class="SKwd">throw</span>
{
    <span class="SLgc">defer</span>(err)      g_Defer += <span class="SNum">1</span>    <span class="SCmt">// This will be called in case an error is raised, before exiting</span>
    <span class="SLgc">defer</span>(noerr)    g_Defer += <span class="SNum">2</span>    <span class="SCmt">// This will only be called in case an error is not raised</span>
    <span class="SLgc">defer</span>           g_Defer += <span class="SNum">3</span>    <span class="SCmt">// This will be called in both cases</span>
    <span class="SLgc">if</span> err
        <span class="SFct">raiseError</span>()
}

<span class="SFct">#test</span>
{
    g_Defer = <span class="SNum">0</span>
    <span class="SKwd">catch</span> <span class="SFct">testDefer</span>(<span class="SKwd">true</span>)
    <span class="SItr">@assert</span>(g_Defer == <span class="SNum">4</span>)   <span class="SCmt">// Will call only defer(err) and the normal defer</span>

    g_Defer = <span class="SNum">0</span>
    <span class="SKwd">catch</span> <span class="SFct">testDefer</span>(<span class="SKwd">false</span>)
    <span class="SItr">@assert</span>(g_Defer == <span class="SNum">5</span>)   <span class="SCmt">// Will call only defer(noerr) and the normal defer</span>
}</span></div>

<h2 id="175_safety">Safety</h2><p>Swag comes with a bunch of safety checks which can be activated by module, function or even instruction with the <span class="code-inline">#[Swag.Safety]</span> attribute. </p>
<p>Safety checks can also be changed for a specific build configuration (<span class="code-inline">--cfg:&lt;config&gt;</span>) with <span class="code-inline">buildCfg.safetyGuards</span>. </p>
<div class="blockquote blockquote-default">
<p> Swag comes with four predefined configurations : <span class="code-inline">debug</span>, <span class="code-inline">fast-debug</span>, <span class="code-inline">fast-compile</span> and <span class="code-inline">release</span>. Safety checks are disabled in <span class="code-inline">fast-compile</span> and <span class="code-inline">release</span>. </p>
</div>
<h3 id="175_safety_overflow">overflow </h3>
<div class="code-block"><span class="SAtr">#[Swag.Safety("overflow", true)]</span></div>
<p>Swag will panic if some operators overflow and if we lose some bits during an integer conversion. </p>
<p>Operators that can overflow are : <span class="code-inline">+ - * &lt;&lt; &gt;&gt;</span> and their equivalent <span class="code-inline">+= -= *= &lt;&lt;= &gt;&gt;=</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>
    <span class="SCmt">// x += 1      // This would overflow, and panic, because we lose informations</span>
}</span></div>
<p>But if you know what your are doing, you can use a special version of those operators, which will not panic. Add the <span class="code-inline">,over</span> modifier after the operation. This will disable safety checks. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>
    x +=<span class="SItr">,over</span> <span class="SNum">1</span>     <span class="SCmt">// Overflow is expected, so this will wrap around</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)
}</span></div>
<p>You can also use <span class="code-inline">#[Swag.Overflow(true)]</span> to authorize overflow on a more global scale. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Overflow(true)]</span>
<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>
    x += <span class="SNum">1</span>     <span class="SCmt">// No need for operator modifier ',over'</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">0</span>)
}</span></div>
<p>For 8 or 16 bits, you can promote an operation to 32 bits by using <span class="code-inline">,up</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span> +<span class="SItr">,up</span> <span class="SNum">1</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">256</span>)
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(x) == <span class="STpe">u32</span>)
}</span></div>
<p>Swag will also check that a cast does not lose information. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x1 = <span class="SNum">255</span>'<span class="STpe">u8</span>

    <span class="SCmt">//var y0 = cast(s8) x1     // This would lose information and panic, as 255 cannot be encoded in 's8'</span>
    <span class="SCmt">//@print(y0)</span>

    <span class="SKwd">let</span> y1 = <span class="SKwd">cast</span><span class="SItr">,over</span>(<span class="STpe">s8</span>) x1  <span class="SCmt">// But ',over' can be used on the cast operation too</span>
    <span class="SItr">@assert</span>(y1 == -<span class="SNum">1</span>)

    <span class="SKwd">let</span> x2 = -<span class="SNum">1</span>'<span class="STpe">s8</span>
    <span class="SCmt">//var y2 = cast(u8) x2     // This cast also is not possible, because 'x2' is negative and 'y' is 'u8'</span>
    <span class="SCmt">//@print(y)</span>
    <span class="SKwd">let</span> y2 = <span class="SKwd">cast</span><span class="SItr">,over</span>(<span class="STpe">u8</span>) x2
    <span class="SItr">@assert</span>(y2 == <span class="SNum">255</span>)
}</span></div>
<p>Rember that you can disable these safety checks with the corresponding attribute. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.Overflow(true)]</span>
<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">255</span>'<span class="STpe">u8</span>
    x += <span class="SNum">255</span>    <span class="SCmt">// 254</span>
    x += <span class="SNum">1</span>      <span class="SCmt">// 255</span>
    x &gt;&gt;= <span class="SNum">1</span>     <span class="SCmt">// 127</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">127</span>)
}</span></div>
<h3 id="175_safety_any">any </h3>
<div class="code-block"><span class="SAtr">#[Swag.Safety("any", true)]</span></div>
<p>Swag will panic if a bad cast from <span class="code-inline">any</span> is performed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="STpe">any</span> = <span class="SStr">"1"</span>
    <span class="SKwd">let</span> y = <span class="SKwd">cast</span>(<span class="STpe">string</span>) x     <span class="SCmt">// This is valid, because this is the correct underlying type</span>
    <span class="SCmt">//var z = cast(s32) x      // This is not valid, and will panic</span>
    <span class="SCmt">//@assert(z == 0)</span>
}</span></div>
<h3 id="175_safety_boundcheck">boundcheck </h3>
<div class="code-block"><span class="SAtr">#[Swag.Safety("boundcheck", true)]</span></div>
<p>Swag will panic if an index is out of range when dereferencing a sized value like an array, a slice, a string... </p>
<p>Safety for fixed size arrays. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SKwd">var</span> idx = <span class="SNum">10</span>
    <span class="SCmt">//@assert(x[idx] == 1)     // '10' is out of range, will panic</span>
}</span></div>
<p>Safety when indexing a slice. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> x: <span class="SKwd">const</span> [..] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SKwd">var</span> idx = <span class="SNum">1</span>
    <span class="SItr">@assert</span>(x[idx] == <span class="SNum">1</span>)        <span class="SCmt">// '1' is in range, ok</span>
    idx += <span class="SNum">9</span>
    <span class="SCmt">//@assert(x[idx] == 1)      // '10' is out of range, will panic</span>
}</span></div>
<p>Safety when slicing a sized value. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="SKwd">const</span> [..] <span class="STpe">s32</span> = [<span class="SNum">0</span>, <span class="SNum">1</span>, <span class="SNum">2</span>]
    <span class="SCmt">//var slice = x[1..4]              // '4' is out of range, will panic</span>
    <span class="SCmt">//@assert(slice[0] == 1)</span>
}

<span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SStr">"string"</span>
    <span class="SKwd">var</span> idx = <span class="SNum">10</span>
    <span class="SCmt">//var slice = x[0..idx]            // '10' is out of range, will panic</span>
    <span class="SCmt">//@assert(slice[0] == `s`)</span>
}</span></div>
<h3 id="175_safety_math">math </h3>
<div class="code-block"><span class="SAtr">#[Swag.Safety("math", true)]</span></div>
<p>Swag will panic if some math operations are invalid. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x = <span class="SNum">1</span>'<span class="STpe">f32</span>
    <span class="SKwd">var</span> y = <span class="SNum">0</span>'<span class="STpe">f32</span>
    <span class="SCmt">//var z = x / y        // Division by zero, panic</span>
    <span class="SCmt">//@print(z)</span>
}</span></div>
<p>Swag will also check for invalid arguments on some math intrinsics. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SCmt">// All of this will panic if the arguments are unsupported.</span>

    <span class="SCmt">//@abs(-128)</span>
    <span class="SCmt">//@log(-2'f32)</span>
    <span class="SCmt">//@log2(-2'f32)</span>
    <span class="SCmt">//@log10(2'f64)</span>
    <span class="SCmt">//@sqrt(-2'f32)</span>
    <span class="SCmt">//@asin(-2'f32)</span>
    <span class="SCmt">//@acos(2'f32)</span>
}</span></div>
<h3 id="175_safety_switch">switch </h3>
<div class="code-block"><span class="SAtr">#[Swag.Safety("switch", true)]</span></div>
<p>Swag will panic if a switch is marked with <span class="code-inline">#[Swag.Complete]</span>, but the value is not covered by a <span class="code-inline">case</span>. </p>
<h3 id="175_safety_bool">bool </h3>
<div class="code-block"><span class="SAtr">#[Swag.Safety("bool", true)]</span></div>
<p>Swag will panic if a boolean value is not <span class="code-inline">true</span> (1) or <span class="code-inline">false</span> (0). </p>
<h3 id="175_safety_nan">nan </h3>
<div class="code-block"><span class="SAtr">#[Swag.Safety("nan", true)]</span></div>
<p>Swag will panic if a floating point <span class="code-inline">NaN</span> is used in an operation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
}</span></div>

<h2 id="180_type_reflection">Type reflection</h2><p>In Swag, <b>types are also values</b> that can be inspected at compile time or at runtime. The two main intrinsics for this are <span class="code-inline">@typeof</span> and <span class="code-inline">@kindof</span>. </p>
<p>You can get the type of an expression with <span class="code-inline">@typeof</span>, or just with the type itself. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> ptr1 = <span class="SItr">@typeof</span>(<span class="STpe">s8</span>)
    <span class="SItr">@assert</span>(ptr1.name == <span class="SStr">"s8"</span>)
    <span class="SItr">@assert</span>(ptr1 == <span class="STpe">s8</span>)

    <span class="SKwd">let</span> ptr2 = <span class="SItr">@typeof</span>(<span class="STpe">s16</span>)
    <span class="SItr">@assert</span>(ptr2.name == <span class="SStr">"s16"</span>)
    <span class="SItr">@assert</span>(ptr2 == <span class="STpe">s16</span>)

    <span class="SCmt">// See that '@typeof' is not really necessary if the expression on the right is a type.</span>
    <span class="SKwd">let</span> ptr3 = <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(ptr3.name == <span class="SStr">"s32"</span>)
    <span class="SItr">@assert</span>(ptr3 == <span class="SItr">@typeof</span>(<span class="STpe">s32</span>))

    <span class="SKwd">let</span> ptr4 = <span class="STpe">s64</span>
    <span class="SItr">@assert</span>(ptr4.name == <span class="SStr">"s64"</span>)
    <span class="SItr">@assert</span>(ptr4 == <span class="STpe">s64</span>)
}</span></div>
<p>The return result of <span class="code-inline">@typeof</span> is a const pointer to a <span class="code-inline">Swag.TypeInfo</span> kind of structure. This is a typealias for the <span class="code-inline">typeinfo</span> type. All types have a corresponding struct that can be found in the <span class="code-inline">Swag</span> namespace, which is part of the compiler runtime. </p>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> You can find all the type descriptors in the runtime <a href="https://www.swag-lang.org/swag.runtime.php">documentation</a> </p>
</div>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> ptr = <span class="STpe">bool</span>
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(ptr) == <span class="SItr">@typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoNative</span>))

    <span class="SCmt">// '#type' can be used when the right expression is ambiguous. In the case of arrays, it could be</span>
    <span class="SCmt">// a type or the start of an array literal, so '#type' tells the compiler this is a type.</span>
    <span class="SKwd">let</span> ptr1 = <span class="STpe">#type</span> [<span class="SNum">2</span>] <span class="STpe">s32</span>
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(ptr1) == <span class="SItr">@typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoArray</span>))
    <span class="SItr">@assert</span>(ptr1.name == <span class="SStr">"[2] s32"</span>)

    <span class="SKwd">let</span> ptr2 = <span class="SItr">@typeof</span>([<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>])
    <span class="SItr">@assert</span>(<span class="SItr">@typeof</span>(ptr2) == <span class="SItr">@typeof</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoArray</span>))
    <span class="SItr">@assert</span>(ptr2.name == <span class="SStr">"const [3] s32"</span>)
}</span></div>
<p>The <span class="code-inline">TypeInfo</span> structure contains a different enum value for each type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">let</span> typeOf = <span class="STpe">f64</span>
    <span class="SItr">@assert</span>(typeOf.kind == <span class="SCst">Swag</span>.<span class="SCst">TypeInfoKind</span>.<span class="SCst">Native</span>)

    <span class="SCmt">// This can be evaluated compile-time</span>
    <span class="SKwd">using</span> <span class="SCst">Swag</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(*<span class="STpe">u8</span>).kind       == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Pointer</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>([<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>]).kind == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Array</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>({<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>}).kind == <span class="SCst">TypeInfoKind</span>.<span class="SCst">Struct</span>
}</span></div>
<h3 id="180_type_reflection_@decltype">@decltype </h3>
<p><span class="code-inline">@decltype</span> can be used to transform a <span class="code-inline">typeinfo</span> to a real compiler type. This is the opposite of <span class="code-inline">@typeof</span> or <span class="code-inline">@kindof</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> x: <span class="SItr">@decltype</span>(<span class="SItr">@typeof</span>(<span class="STpe">s32</span>))
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(x) == <span class="STpe">s32</span>
}</span></div>
<p><span class="code-inline">@decltype</span> can evaluate a constexpr expression that returns a <span class="code-inline">typeinfo</span> to determine the real type. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.ConstExpr]</span>
    <span class="SKwd">func</span> <span class="SFct">getType</span>(needAString: <span class="STpe">bool</span>)-&gt;<span class="STpe">typeinfo</span>
    {
        <span class="SLgc">if</span> needAString
            <span class="SLgc">return</span> <span class="STpe">string</span>
        <span class="SLgc">else</span>
            <span class="SLgc">return</span> <span class="STpe">s32</span>
    }

    <span class="SKwd">var</span> x: <span class="SItr">@decltype</span>(<span class="SFct">getType</span>(needAString: <span class="SKwd">false</span>))
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(x) == <span class="STpe">s32</span>
    x = <span class="SNum">0</span>

    <span class="SKwd">var</span> x1: <span class="SItr">@decltype</span>(<span class="SFct">getType</span>(needAString: <span class="SKwd">true</span>))
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(x1) == <span class="STpe">string</span>
    x1 = <span class="SStr">"0"</span>
}</span></div>

<h2 id="190_compile-time_evaluation">Compile-time evaluation</h2><p>One thing which is very powerfull with Swag is that <b>everything</b> can be executed compile-time. This is the reason why you can also use it as a scripting language, where the compiler acts as an interpreter. </p>

<h3 id="190_compile-time_evaluation_191_001_constexpr">Constexpr</h3><p>The attribute <span class="code-inline">#[Swag.ConstExpr]</span> can be used to mark functions. It tells the compiler that this specific function can be called compile-time if possible. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// 'isThisDebug' is marked with 'Swag.ConstExpr', so it can be automatically evaluated</span>
<span class="SCmt">// at compile time</span>
<span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">isThisDebug</span>() =&gt; <span class="SKwd">true</span>

<span class="SCmt">// This call is valid, and will be done by the compiler. As 'isThisDebug' returns</span>
<span class="SCmt">// true, then the '#error' inside the '#if' will never be compiled.</span>
<span class="SCmp">#if</span> <span class="SFct">isThisDebug</span>() == <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span> <span class="SStr">"this should not be called !"</span>
}</span></div>
<p>A more complicated compile-time <span class="code-inline">#assert</span>. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[Swag.ConstExpr]</span>
<span class="SKwd">func</span> <span class="SFct">factorial</span>(x: <span class="STpe">s32</span>)-&gt;<span class="STpe">s32</span>
{
    <span class="SLgc">if</span> x == <span class="SNum">1</span> <span class="SLgc">return</span> <span class="SNum">1</span>
    <span class="SLgc">return</span> x * <span class="SFct">factorial</span>(x - <span class="SNum">1</span>)
}

<span class="SCmp">#assert</span> <span class="SFct">factorial</span>(<span class="SNum">4</span>) == <span class="SNum">24</span> <span class="SCmt">// Evaluated at compile time</span></span></div>

<h3 id="190_compile-time_evaluation_192_002_run">Run</h3><h4 id="190_compile-time_evaluation_192_002_run_Force_compile-time_call">Force compile-time call </h4>
<p><span class="code-inline">#run</span> can be used to call a function that is not marked with <span class="code-inline">#[Swag.ConstExpr]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This time 'isThisRelease' is not marked with 'Swag.ConstExpr'</span>
<span class="SKwd">func</span> <span class="SFct">isThisRelease</span>() =&gt; <span class="SKwd">true</span>

<span class="SCmt">// But this call is still valid because we force the compile time execution with '#run'</span>
<span class="SCmp">#if</span> <span class="SFct">#run</span> <span class="SFct">isThisRelease</span>() == <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span> <span class="SStr">"this should not be called !"</span>
}</span></div>
<p>So that means that you can call everything compile-time, even a function from an external module, a system function etc. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This function was not 'prepared' for compile-time evaluation, because there's no</span>
<span class="SCmt">// specific attribute</span>
<span class="SKwd">func</span> <span class="SFct">sum</span>(values: <span class="STpe">s32</span>...)-&gt;<span class="STpe">s32</span>
{
    <span class="SKwd">var</span> result = <span class="SNum">0</span>'<span class="STpe">s32</span>
    <span class="SLgc">visit</span> v: values
        result += v
    <span class="SLgc">return</span> result
}

<span class="SCmt">// But you can call it compile-time with '#run'</span>
<span class="SKwd">const</span> <span class="SCst">SumValue</span> = <span class="SFct">#run</span> <span class="SFct">sum</span>(<span class="SNum">1</span>, <span class="SNum">2</span>, <span class="SNum">3</span>, <span class="SNum">4</span>) + <span class="SNum">10</span>
<span class="SCmp">#assert</span> <span class="SCst">SumValue</span> == <span class="SNum">20</span></span></div>
<h4 id="190_compile-time_evaluation_192_002_run_#run_block">#run block </h4>
<p><span class="code-inline">#run</span> is also a special function that will be called by the compiler. You can have as many <span class="code-inline">#run</span> block as you want, but be aware that the execution order in that case is random. </p>
<p>It can be used to precompute some global values for example. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// A global variable we would like to initialize in a 'complexe' way.</span>
<span class="SKwd">var</span> <span class="SCst">G</span>: [<span class="SNum">5</span>] <span class="STpe">f32</span> = <span class="SKwd">undefined</span></span></div>
<p>Initialize <span class="code-inline">G</span> with <span class="code-inline">[1,2,4,8,16]</span> at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#run</span>
{
    <span class="SKwd">var</span> value = <span class="SNum">1</span>'<span class="STpe">f32</span>
    <span class="SLgc">loop</span> i: <span class="SItr">@countof</span>(<span class="SCst">G</span>)
    {
        <span class="SCst">G</span>[i] = value
        value *= <span class="SNum">2</span>
    }
}</span></div>
<p><span class="code-inline">#test</span> blocks are executed after <span class="code-inline">#run</span>, even at compile time (during testing). So we can test the values of <span class="code-inline">G</span> here. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">1</span>] == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">2</span>] == <span class="SNum">4</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">3</span>] == <span class="SNum">8</span>)
    <span class="SItr">@assert</span>(<span class="SCst">G</span>[<span class="SNum">4</span>] == <span class="SNum">16</span>)
}</span></div>
<p>This is where we can see that Swag can be used as a scripting language, because if you have a project with just some <span class="code-inline">#run</span> blocks, you have in fact a... script. </p>
<h4 id="190_compile-time_evaluation_192_002_run_#run_expression">#run expression </h4>
<p><span class="code-inline">#run</span> can also be used as an expression block. The return type is deduced from the <span class="code-inline">return</span> statement. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">Value</span> = <span class="SFct">#run</span>
        {
            <span class="SKwd">var</span> result: <span class="STpe">f32</span>
            <span class="SLgc">loop</span> <span class="SNum">10</span>
                result += <span class="SNum">1</span>
            <span class="SLgc">return</span> result   <span class="SCmt">// 'Value' will be of type 'f32'</span>
        }
    <span class="SCmp">#assert</span> <span class="SCst">Value</span> == <span class="SNum">10.0</span>
}</span></div>
<p>Can also be used to initialize a static array. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">N</span> = <span class="SNum">4</span>
    <span class="SKwd">const</span> <span class="SCst">PowerOfTwo</span>: [<span class="SCst">N</span>] <span class="STpe">s32</span> = <span class="SFct">#run</span>
        {
            <span class="SKwd">var</span> arr: [<span class="SCst">N</span>] <span class="STpe">s32</span>
            <span class="SLgc">loop</span> i: arr
                arr[i] = <span class="SNum">1</span> &lt;&lt; <span class="SKwd">cast</span>(<span class="STpe">u32</span>) i
            <span class="SLgc">return</span> arr
        }

    <span class="SCmp">#assert</span> <span class="SCst">PowerOfTwo</span>[<span class="SNum">0</span>] == <span class="SNum">1</span>
    <span class="SCmp">#assert</span> <span class="SCst">PowerOfTwo</span>[<span class="SNum">1</span>] == <span class="SNum">2</span>
    <span class="SCmp">#assert</span> <span class="SCst">PowerOfTwo</span>[<span class="SNum">2</span>] == <span class="SNum">4</span>
    <span class="SCmp">#assert</span> <span class="SCst">PowerOfTwo</span>[<span class="SNum">3</span>] == <span class="SNum">8</span>
}</span></div>
<p>Can also be used to initialize a string. </p>
<p>This is legit to return a string that is constructed on the stack, because the <span class="code-inline">#run</span> block will make a copy. Remember that a string is a pointer to the bytes (in UTF8 format) and a length. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">const</span> <span class="SCst">MyString</span>: <span class="STpe">string</span> = <span class="SFct">#run</span>
        {
            <span class="SKwd">var</span> str: [<span class="SNum">3</span>] <span class="STpe">u8</span>
            str[<span class="SNum">0</span>] = <span class="SStr">`a`</span>
            str[<span class="SNum">1</span>] = <span class="SStr">`b`</span>
            str[<span class="SNum">2</span>] = str[<span class="SNum">1</span>] + <span class="SNum">1</span>
            <span class="SLgc">return</span> <span class="SKwd">cast</span>(<span class="STpe">string</span>) str
        }
    <span class="SCmp">#assert</span> <span class="SCst">MyString</span> == <span class="SStr">"abc"</span>
}</span></div>
<p>Can also be used to initialize a plain old data struct. Note that you can also force the struct to be considered as a POD by tagging it with <span class="code-inline">#[Swag.ConstExpr]</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">RGB</span> {r, g, b: <span class="STpe">u8</span>}
    <span class="SKwd">const</span> <span class="SCst">White</span>: <span class="SCst">RGB</span> = <span class="SFct">#run</span>
        {
            <span class="SKwd">var</span> rgb: <span class="SCst">RGB</span> = <span class="SKwd">undefined</span>
            rgb.r = <span class="SNum">255</span>
            rgb.g = rgb.r
            rgb.b = rgb.r
            <span class="SLgc">return</span> rgb
        }
    <span class="SCmp">#assert</span> <span class="SCst">White</span>.r == <span class="SNum">255</span> <span class="SLgc">and</span> <span class="SCst">White</span>.g == <span class="SNum">255</span> <span class="SLgc">and</span> <span class="SCst">White</span>.b == <span class="SNum">255</span>
}</span></div>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> You can also convert a complex struct (which uses the heap for example), as long the struct implements <span class="code-inline">opCount</span> and <span class="code-inline">opSlice</span>. In that case, the resulting type will be a static array. The compiler will call <span class="code-inline">opcount</span> to get the size of the array, and <span class="code-inline">opSlice</span> to initialize its content. If the struct implements <span class="code-inline">opDrop</span>, then it will be called after the conversion to an array has been done. </p>
</div>

<h3 id="190_compile-time_evaluation_193_003_special_functions">Special functions</h3><div class="code-block"><span class="SCde"><span class="SCmp">#global</span> skip</span></div>
<h4 id="190_compile-time_evaluation_193_003_special_functions_#main">#main </h4>
<p><span class="code-inline">#main</span> is the program entry point. It can only be defined <b>once</b> per module, and has meaning only for an executable. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
}</span></div>
<p>Unlike the C function <span class="code-inline">main()</span>, there's no argument, but you can use the intrinsic <span class="code-inline">@args</span> to get a slice of all the parameters. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#main</span>
{
    <span class="SKwd">var</span> myArgs = <span class="SItr">@args</span>()
    <span class="SKwd">var</span> count = <span class="SItr">@countof</span>(myArgs)
    <span class="SLgc">if</span> myArgs[<span class="SNum">0</span>] == <span class="SStr">"fullscreen"</span>
    {
        ...
    }
}</span></div>
<h4 id="190_compile-time_evaluation_193_003_special_functions_#premain">#premain </h4>
<p><span class="code-inline">#premain</span> will be called after all the modules have done their <span class="code-inline">#init</span> code, but before the <span class="code-inline">#main</span> function is called. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#premain</span>
{
}</span></div>
<h4 id="190_compile-time_evaluation_193_003_special_functions_#init">#init </h4>
<p><span class="code-inline">#init</span> will be called at runtime, during the module initialization. You can have as many <span class="code-inline">#init</span> as you want, but the execution order in the same module is undefined. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#init</span>
{
}</span></div>
<h4 id="190_compile-time_evaluation_193_003_special_functions_#drop">#drop </h4>
<p><span class="code-inline">#drop</span> will be called at runtime, when module is unloaded. You can have as many <span class="code-inline">#drop</span> as you want. The execution order in the same module is undefined, but is always the inverse order of <span class="code-inline">#init</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#drop</span>
{
}</span></div>
<h4 id="190_compile-time_evaluation_193_003_special_functions_#test">#test </h4>
<p><span class="code-inline">#test</span> is a special function than can be used in the <span class="code-inline">tests/</span> folder of the workspace. All <span class="code-inline">#test</span> will be executed only if swag is running in test mode. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
}</span></div>

<h3 id="190_compile-time_evaluation_194_004_compiler_instructions">Compiler instructions</h3><h4 id="190_compile-time_evaluation_194_004_compiler_instructions_#assert">#assert </h4>
<p><span class="code-inline">#assert</span> is a static assert (at compile time). </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span> <span class="SKwd">true</span></span></div>
<p><span class="code-inline">@defined(SYMBOL)</span> returns true, at compile time, if the given symbol exists in the current context. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span> !<span class="SItr">@defined</span>(<span class="SCst">DOES_NOT_EXISTS</span>)
<span class="SCmp">#assert</span> <span class="SItr">@defined</span>(<span class="SCst">Global</span>)
<span class="SKwd">var</span> <span class="SCst">Global</span> = <span class="SNum">0</span></span></div>
<h4 id="190_compile-time_evaluation_194_004_compiler_instructions_#if/#else">#if/#else </h4>
<p>A static <span class="code-inline">#if/#elif/#else</span>, with an expression that can be evaluated at compile time. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">DEBUG</span> = <span class="SNum">1</span>
<span class="SKwd">const</span> <span class="SCst">RELEASE</span> = <span class="SNum">0</span>
<span class="SCmp">#if</span> <span class="SCst">DEBUG</span>
{
}
<span class="SCmp">#elif</span> <span class="SCst">RELEASE</span>
{
}
<span class="SCmp">#else</span>
{
}</span></div>
<h4 id="190_compile-time_evaluation_194_004_compiler_instructions_#error/#warning">#error/#warning </h4>
<p><span class="code-inline">#error</span> to raise a compile-time error, and <span class="code-inline">#warning</span> to raise a compile-time warning. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#if</span> <span class="SKwd">false</span>
{
    <span class="SCmp">#error</span>   <span class="SStr">"this is an error"</span>
    <span class="SCmp">#warning</span> <span class="SStr">"this is a warning"</span>
}</span></div>
<h4 id="190_compile-time_evaluation_194_004_compiler_instructions_#global">#global </h4>
<p>A bunch of <span class="code-inline">#global</span> can be put <b>at the top</b> of a source file. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// Skip the content of the file (but must be a valid swag file)</span>
<span class="SCmp">#global</span> skip

<span class="SCmt">// All symbols in the file will be public/internal</span>
<span class="SCmp">#global</span> <span class="SKwd">public</span>
<span class="SCmp">#global</span> <span class="SKwd">internal</span>

<span class="SCmt">// All symbols in the file will go in the namespace 'Toto'</span>
<span class="SCmp">#global</span> <span class="SKwd">namespace</span> <span class="SCst">Toto</span>

<span class="SCmt">// A #if for the whole file</span>
<span class="SCmp">#global</span> <span class="SCmp">#if</span> <span class="SCst">DEBUG</span> == <span class="SKwd">true</span>

<span class="SCmt">// Some attributes can be assigned to the full file</span>
<span class="SCmp">#global</span> <span class="SAtr">#[Swag.Safety("", true)]</span>

<span class="SCmt">// The file will be exported for external usage</span>
<span class="SCmt">// It's like putting everything in public, except that the file will</span>
<span class="SCmt">// be copied in its totality in the public folder</span>
<span class="SCmp">#global</span> export</span></div>
<h4 id="190_compile-time_evaluation_194_004_compiler_instructions_#foreignlib">#foreignlib </h4>
<p>Link with a given external library. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#foreignlib</span> <span class="SStr">"windows.lib"</span></span></div>

<h2 id="210_code_inspection">Code inspection</h2><p><span class="code-inline">#message</span> is a special function that will be called by the compiler when something specific occurs during the build. The parameter of <span class="code-inline">#message</span> is a mask that tells the compiler when to call the function. </p>
<p>With the <span class="code-inline">Swag.CompilerMsgMask.SemFunctions</span> flag, for example, <span class="code-inline">#message</span> will be called each time a function of the module <b>has been typed</b>. You can then use <span class="code-inline">getMessage()</span> in the <span class="code-inline">@compiler()</span> interface to retrieve some informations about the reason of the call. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemFunctions</span>)
{
    <span class="SCmt">// Get the interface to communicate with the compiler</span>
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()

    <span class="SCmt">// Get the current message</span>
    <span class="SKwd">let</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// We know that the type in the message is a function because of the '#message' mask.</span>
    <span class="SCmt">// So we can safely cast.</span>
    <span class="SKwd">let</span> typeFunc = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="SCst">Swag</span>.<span class="SCst">TypeInfoFunc</span>) msg.type

    <span class="SCmt">// The message name, for `Swag.CompilerMsgMask.SemFunctions`, is the name of the</span>
    <span class="SCmt">// function being compiled.</span>
    <span class="SKwd">let</span> nameFunc = msg.name

    <span class="SCmt">// As an example, we count that name if it starts with "XX".</span>
    <span class="SCmt">// But we could use custom function attributes instead...</span>
    <span class="SLgc">if</span> <span class="SItr">@countof</span>(nameFunc) &gt; <span class="SNum">2</span> <span class="SLgc">and</span> nameFunc[<span class="SNum">0</span>] == <span class="SStr">`X`</span> <span class="SLgc">and</span> nameFunc[<span class="SNum">1</span>] == <span class="SStr">`X`</span>
        <span class="SCst">G</span> += <span class="SNum">1</span>
}

<span class="SKwd">var</span> <span class="SCst">G</span> = <span class="SNum">0</span>

<span class="SKwd">func</span> <span class="SCst">XXTestFunc1</span>() {}
<span class="SKwd">func</span> <span class="SCst">XXTestFunc2</span>() {}
<span class="SKwd">func</span> <span class="SCst">XXTestFunc3</span>() {}</span></div>
<p>The compiler will call the following function after the semantic pass. So after <b>all the functions</b> of the module have been parsed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">PassAfterSemantic</span>)
{
    <span class="SCmt">// We should have found 3 functions starting with "XX"</span>
    <span class="SItr">@assert</span>(<span class="SCst">G</span> == <span class="SNum">3</span>)
}</span></div>
<p>This will be called for every global variables of the module. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemGlobals</span>)
{
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()
}</span></div>
<p>This will be called for every global types of the module (structs, enums, interfaces...). </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">Swag</span>.<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemTypes</span>)
{
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()
}</span></div>

<h2 id="220_meta_programming">Meta programming</h2><p>In Swag you can construct some source code at compile time, which will then be compiled. The source code you provide in the form of a <b>string</b> must be a valid Swag program. </p>

<h3 id="220_meta_programming_221_001_ast">Ast</h3><p>The most simple way to produce a string which contains the Swag code to compile is with an <span class="code-inline">#ast</span> block. An <span class="code-inline">#ast</span> block is executed at compile time and the string it returns will be compiled <b>inplace</b>. </p>
<p>The <span class="code-inline">#ast</span> can be a simple expression with the string to compile. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SFct">#ast</span> <span class="SStr">"var x = 666"</span>
    <span class="SItr">@assert</span>(x == <span class="SNum">666</span>)
}</span></div>
<p>Or it can be a block, with an explicit <span class="code-inline">return</span> </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">var</span> cpt = <span class="SNum">2</span>
    <span class="SFct">#ast</span>
    {
        <span class="SKwd">const</span> <span class="SCst">INC</span> = <span class="SNum">5</span>
        <span class="SLgc">return</span> <span class="SStr">"cpt += "</span> ++ <span class="SCst">INC</span>   <span class="SCmt">// Equivalent to 'cpt += 5'</span>
    }

    <span class="SItr">@assert</span>(cpt == <span class="SNum">7</span>)
}</span></div>
<h4 id="220_meta_programming_221_001_ast_Struct_and_enums">Struct and enums </h4>
<p><span class="code-inline">#ast</span> can for example be used to generate the content of a <span class="code-inline">struct</span> or <span class="code-inline">enum</span>. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span> <span class="SCst">MyStruct</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SLgc">return</span> <span class="SStr">"x, y: s32 = 666"</span>
        }
    }

    <span class="SKwd">var</span> v: <span class="SCst">MyStruct</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">666</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">666</span>)
}</span></div>
<p>It works with generics too, and can be mixed with static declarations. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">MyStruct</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SLgc">return</span> <span class="SStr">"x, y: "</span> ++ <span class="SItr">@typeof</span>(<span class="SCst">T</span>).name
        }

        z: <span class="STpe">string</span>
    }

    <span class="SKwd">var</span> v: <span class="SCst">MyStruct</span>'<span class="STpe">bool</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(v.x) == <span class="STpe">bool</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(v.y) == <span class="STpe">bool</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(v.z) == <span class="STpe">string</span>

    <span class="SKwd">var</span> v1: <span class="SCst">MyStruct</span>'<span class="STpe">f64</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(v1.x) == <span class="STpe">f64</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(v1.y) == <span class="STpe">f64</span>
    <span class="SCmp">#assert</span> <span class="SItr">@typeof</span>(v1.z) == <span class="STpe">string</span>
}</span></div>
<p><span class="code-inline">#ast</span> needs to return a <i>string like</i> value, which can of course be dynamically constructed. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#test</span>
{
    <span class="SAtr">#[Swag.Compiler]</span>
    <span class="SKwd">func</span> <span class="SFct">append</span>(buf: ^<span class="STpe">u8</span>, val: <span class="STpe">string</span>)
    {
        <span class="SKwd">var</span> len = <span class="SNum">0</span>
        <span class="SLgc">while</span> buf[len] len += <span class="SNum">1</span>
        <span class="SItr">@memcpy</span>(buf + len, <span class="SItr">@dataof</span>(val), <span class="SKwd">cast</span>(<span class="STpe">u64</span>) <span class="SItr">@countof</span>(val) + <span class="SNum">1</span>)
    }

    <span class="SKwd">struct</span> <span class="SCst">Vector3</span>
    {
        <span class="SFct">#ast</span>
        {
            <span class="SCmt">// We construct the code to compile in this local array</span>
            <span class="SKwd">var</span> buf: [<span class="SNum">256</span>] <span class="STpe">u8</span>
            <span class="SFct">append</span>(buf, <span class="SStr">"x: f32 = 1\n"</span>)
            <span class="SFct">append</span>(buf, <span class="SStr">"y: f32 = 2\n"</span>)
            <span class="SFct">append</span>(buf, <span class="SStr">"z: f32 = 3\n"</span>)

            <span class="SCmt">// And returns to the compiler the corresponding *code*</span>
            <span class="SLgc">return</span> <span class="SKwd">cast</span>(<span class="STpe">string</span>) buf
        }
    }

    <span class="SKwd">var</span> v: <span class="SCst">Vector3</span>
    <span class="SItr">@assert</span>(v.x == <span class="SNum">1</span>)
    <span class="SItr">@assert</span>(v.y == <span class="SNum">2</span>)
    <span class="SItr">@assert</span>(v.z == <span class="SNum">3</span>)
}</span></div>
<h4 id="220_meta_programming_221_001_ast_For_example">For example </h4>
<p>This is a real life example of an <span class="code-inline">#ast</span> usage from the <span class="code-inline">Std.Core</span> module. Here we generate a structure which contains all the fields of an original other structure, but where the types are forced to be <span class="code-inline">bool</span>. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span>(<span class="SCst">T</span>) <span class="SCst">IsSet</span>
{
    <span class="SFct">#ast</span>
    {
        <span class="SCmt">// A `StringBuilder` is used to manipulate dynamic strings.</span>
        <span class="SKwd">var</span> str = <span class="SCst">StrConv</span>.<span class="SCst">StringBuilder</span>{}

        <span class="SCmt">// We get the type of the generic parameter 'T'</span>
        <span class="SKwd">let</span> typeof = <span class="SItr">@typeof</span>(<span class="SCst">T</span>)

        <span class="SCmt">// Then we visit all the fields, assuming the type is a struct (or this will not compile).</span>
        <span class="SCmt">// For each original field, we create one with the same name, but with a `bool` type.</span>
        <span class="SLgc">visit</span> f: typeof.fields
            str.<span class="SFct">appendFormat</span>(<span class="SStr">"%: bool\n"</span>, f.name)

        <span class="SCmt">// Then we return the constructed source code.</span>
        <span class="SCmt">// It will be used by the compiler to generate the content of the `IsSet` struct.</span>
        <span class="SLgc">return</span> str.<span class="SFct">toString</span>()
    }
}</span></div>
<h4 id="220_meta_programming_221_001_ast_At_global_scope">At global scope </h4>
<p><span class="code-inline">#ast</span> can also be called at the global scope. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#ast</span>
{
    <span class="SKwd">const</span> value = <span class="SNum">666</span>
    <span class="SLgc">return</span> <span class="SStr">"const myGeneratedConst = "</span> ++ value
}</span></div>
<p>But be aware that you must use <span class="code-inline">#placeholder</span> in case you are generating global symbols that can be used by something else in the code. This will tell Swag that <i>this symbol</i> will exist at some point, so please wait for it to <i>exist</i> before complaining. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#placeholder</span> myGeneratedConst   <span class="SCmt">// Symbol `myGeneratedConst` will be generated</span></span></div>
<p>Here for example, thanks to the <span class="code-inline">#placeholder</span>, the <span class="code-inline">#assert</span> will wait for the symbol <span class="code-inline">myGeneratedConst</span> to be replaced with its real content. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#assert</span> myGeneratedConst == <span class="SNum">666</span></span></div>

<h3 id="220_meta_programming_222_002_compiler_interface">Compiler interface</h3><p>The other method to compile generated code is to use the function <span class="code-inline">compileString()</span> in the <span class="code-inline">@compiler()</span> interface. Of course this should be called at compile time, and mostly during a <span class="code-inline">#message</span> call. </p>
<p>Here is a real life example from the <span class="code-inline">Std.Ogl</span> module (opengl wrapper), which uses <span class="code-inline">#message</span> to track functions marked with a specific <b>user attribute</b> <span class="code-inline">Ogl.Extension</span>, and generates some code for each function that has been found. </p>
<p>First we declare a new specific attribute, which can then be associated with a function. </p>
<div class="code-block"><span class="SCde"><span class="SAtr">#[AttrUsage(AttributeUsage.Function)]</span>
<span class="SKwd">attr</span> <span class="SCst">Extension</span>()

<span class="SCmt">// Here is an example of usage of that attribute.</span>
<span class="SAtr">#[Extension]</span>
{
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix2x3fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix2x4fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix3x2fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix3x4fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix4x2fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
    <span class="SKwd">func</span> <span class="SFct">glUniformMatrix4x3fv</span>(location: <span class="SCst">GLint</span>, count: <span class="SCst">GLsizei</span>, transpose: <span class="SCst">GLboolean</span>, value: <span class="SKwd">const</span> *<span class="SCst">GLfloat</span>);
}</span></div>
<p>The following will be used to track the functions with that specific attribute. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">struct</span> <span class="SCst">OneFunc</span>
{
    type: <span class="STpe">typeinfo</span>
    name: <span class="STpe">string</span>
}

<span class="SAtr">#[Compiler]</span>
<span class="SKwd">var</span> g_Functions: <span class="SCst">Array</span>'<span class="SCst">OneFunc</span></span></div>
<p>This <span class="code-inline">#message</span> will be called for each function of the <span class="code-inline">Ogl</span> module. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">CompilerMsgMask</span>.<span class="SCst">SemFunctions</span>)
{
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
    <span class="SKwd">var</span> msg = itf.<span class="SFct">getMessage</span>()

    <span class="SCmt">// If the function does not have our attribute, forget it</span>
    <span class="SLgc">if</span> !<span class="SCst">Reflection</span>.<span class="SFct">hasAttribute</span>(msg.type, <span class="SCst">Extension</span>)
        <span class="SLgc">return</span>

    <span class="SCmt">// We just track all the functions with the given attribute</span>
    g_Functions.<span class="SFct">add</span>({msg.type, msg.name})
}</span></div>
<p>We will generate a <span class="code-inline">glInitExtensions</span> global function, so we register it as a placeholder. </p>
<div class="code-block"><span class="SCde"><span class="SCmp">#placeholder</span> glInitExtensions</span></div>
<p>This is called once all functions of the module have been typed, and this is the main code generation. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#message</span>(<span class="SCst">CompilerMsgMask</span>.<span class="SCst">PassAfterSemantic</span>)
{
    <span class="SKwd">var</span> builderVars: <span class="SCst">StringBuilder</span>
    <span class="SKwd">var</span> builderInit: <span class="SCst">StringBuilder</span>

    <span class="SCmt">// Generate the `glInitExtensions` function</span>
    builderInit.<span class="SFct">appendString</span>(<span class="SStr">"public func glInitExtensions()\n{\n"</span>);

    <span class="SCmt">// Visit all functions we have registered, i.e. all functions with the `Ogl.Extension` attribute.</span>
    <span class="SLgc">visit</span> e: g_Functions
    {
        <span class="SKwd">let</span> typeFunc = <span class="SKwd">cast</span>(<span class="SKwd">const</span> *<span class="SCst">TypeInfoFunc</span>) e.type

        <span class="SCmt">// Declare a lambda variable for that extension</span>
        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"var ext_%: %\n"</span>, e.name, typeFunc.name)

        <span class="SCmt">// Make a wrapper function</span>
        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"public func %("</span>, e.name)
        <span class="SLgc">visit</span> p, i: typeFunc.parameters
        {
            <span class="SLgc">if</span> i != <span class="SNum">0</span> builderVars.<span class="SFct">appendString</span>(<span class="SStr">", "</span>)
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"p%: %"</span>, i, p.pointedType.name)
        }

        <span class="SLgc">if</span> typeFunc.returnType == <span class="STpe">void</span>
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">")\n{\n"</span>)
        <span class="SLgc">else</span>
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">")-&gt;%\n{\n"</span>, typeFunc.returnType.name)
        builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"\treturn ext_%("</span>, e.name)
        <span class="SLgc">visit</span> p, i: typeFunc.parameters
        {
            <span class="SLgc">if</span> i != <span class="SNum">0</span> builderVars.<span class="SFct">appendString</span>(<span class="SStr">", "</span>)
            builderVars.<span class="SFct">appendFormat</span>(<span class="SStr">"p%"</span>, i)
        }

        builderVars.<span class="SFct">appendString</span>(<span class="SStr">");\n}\n\n"</span>)

        <span class="SCmt">// Initialize the variable with the getExtensionAddress</span>
        builderInit.<span class="SFct">appendFormat</span>(<span class="SStr">"\text_% = cast(%) getExtensionAddress(@dataof(\"%\"))\n"</span>, e.name, typeFunc.name, e.name);
    }

    <span class="SCmt">// Compile !!</span>
    <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
    <span class="SKwd">var</span> str = builderVars.<span class="SFct">toString</span>()
    itf.<span class="SFct">compileString</span>(str.<span class="SFct">toString</span>())

    builderInit.<span class="SFct">appendString</span>(<span class="SStr">"}\n"</span>);
    str = builderInit.<span class="SFct">toString</span>()
    itf.<span class="SFct">compileString</span>(str.<span class="SFct">toString</span>())
}</span></div>

<h2 id="230_documentation">Documentation</h2><p>The Swag compiler can generate documentation for all the modules of a given workspace. </p>
<div class="code-block"><span class="SCde">swag doc -w:myWorkspaceFolder</span></div>
<p>Swag can generate documentations in various modes. That mode should be specified in the <span class="code-inline">module.swg</span> file, in the <a href="swag.runtime.php#Swag_BuildCfg">Swag.BuildCfg</a> struct. </p>
<div class="code-block"><span class="SCde"><span class="SFct">#dependencies</span>
{
    <span class="SCmp">#import</span> <span class="SStr">"pixel"</span>

    <span class="SFct">#run</span>
    {
        <span class="SKwd">let</span> itf = <span class="SItr">@compiler</span>()
        <span class="SKwd">let</span> cfg = itf.<span class="SFct">getBuildCfg</span>()
        cfg.genDoc.kind = .<span class="SCst">Api</span> <span class="SCmt">// Specify the documentation generation mode</span>
    }
}</span></div>
<table class="table-markdown">
<tr><th style="text-align: left;">Kind</th><th style="text-align: left;">Purpose</th></tr><tr><td style="text-align: left;"> Swag.DocKind.Api      </td><td style="text-align: left;"> Generates an api documentation (all public symbols)</td></tr>
<tr><td style="text-align: left;"> Swag.DocKind.Examples </td><td style="text-align: left;"> Generates a documentation like this one</td></tr>
<tr><td style="text-align: left;"> Swag.DocKind.Pages    </td><td style="text-align: left;"> Generates different pages, where each file is a page (a variation of  <span class="code-inline">Examples</span>)</td></tr>
</table>
<h3 id="230_documentation_Markdown_files">Markdown files </h3>
<p>If the module contains <b>markdown</b> files with the <span class="code-inline">.md</span> extension, they will be processed as if they were Swag comments. </p>
<h3 id="230_documentation_Format_of_comments">Format of comments </h3>
<h4 id="230_documentation_Format_of_comments_Paragraphs">Paragraphs </h4>
<div class="code-block"><span class="SCde"><span class="SCmt">// Everything between empty lines is considered to be a simple paragraph. Which</span>
<span class="SCmt">// means that if you put several comments on several lines like this, they all</span>
<span class="SCmt">// will be part of the same paragraph.</span>
<span class="SCmt">//</span>
<span class="SCmt">// This is another paragraph because there's an empty line before.</span>
<span class="SCmt">//</span>
<span class="SCmt">// This is yet another paragraph.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> Everything between empty lines is considered to be a simple paragraph. Which  means that if you put several comments on several lines like this, they all  will be part of the same paragraph. </p>
<p> This is another paragraph because there's an empty line before. </p>
<p> This is yet another paragraph. </p>
</div>
<p>Inside a paragraph, you can end of line with <span class="code-inline">\</span> to force a break without creating a new paragraph. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// First line.</span>
<span class="SCmt">// Second line is on first line.\</span>
<span class="SCmt">// But third line has a break before.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> First line.  Second line is on first line.<br/>  But third line has a break before. </p>
</div>
<p>A paragraph that starts with <span class="code-inline">---</span> is a <b>verbatim</b> paragraph where every blanks and end of lines are respected. The paragraph will be generated <b>as is</b> without any markdown change. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// ---</span>
<span class="SCmt">// Even...</span>
<span class="SCmt">//</span>
<span class="SCmt">// ...empty lines are preserved.</span>
<span class="SCmt">//</span>
<span class="SCmt">// You end that kind of paragraph with another '---' alone on its line.</span>
<span class="SCmt">// Note that **everything** is not bold, put printed 'as it is'.</span>
<span class="SCmt">// ---</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p style="white-space: break-spaces"> Even...

 ...empty lines are preserved.

 You end that kind of paragraph with another '---' alone on its line.
 Note that **everything** is not bold, put printed 'as it is'.</p>
</div>
<h4 id="230_documentation_Format_of_comments_Lists">Lists </h4>
<p>You can create a <b>list</b> of bullet points with <span class="code-inline">*</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// * This is a bullet point</span>
<span class="SCmt">// * This is a bullet point</span>
<span class="SCmt">// * This is a bullet point</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><ul>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
<li>This is a bullet point</li>
</ul>
</div>
<p>You can create an <b>ordered</b> list by starting the line with a digit followed by a <span class="code-inline">.</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// 1. This is an ordered list</span>
<span class="SCmt">// 1. The digit itself does not matter, real numbers will be computed</span>
<span class="SCmt">// 0. This is another one</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><ol>
<li>This is an ordered list</li>
<li>The digit itself does not matter, real numbers will be computed</li>
<li>This is another one</li>
</ol>
</div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> Swag only supports single line list items. You cannot have complex paragraphs (or sub lists). </p>
</div>
<h4 id="230_documentation_Format_of_comments_Definition_Lists">Definition Lists </h4>
<p>You can add a definition title with the <span class="code-inline">+</span> character followed by a blank, and then the title. The description paragraph should come just after the title, with at least 4 blanks or one tabulation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Title</span>
<span class="SCmt">//     This is the description.</span>
<span class="SCmt">// + Other title</span>
<span class="SCmt">//     This is the other description.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Title</p></div>
<div class="description-list-block">
<p> This is the description. </p>
</div>
<div class="description-list-title"><p>Other title</p></div>
<div class="description-list-block">
<p> This is the other description. </p>
</div>
</div>
<p>A description can contain complex paragraphs. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Title</span>
<span class="SCmt">//     This is an embedded list.</span>
<span class="SCmt">//     * Item1</span>
<span class="SCmt">//     * Item2</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Title</p></div>
<div class="description-list-block">
<p> This is an embedded list. </p>
<ul>
<li>Item1</li>
<li>Item2</li>
</ul>
</div>
</div>
<p>The description paragraph can contain some empty lines. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// + Other title</span>
<span class="SCmt">//</span>
<span class="SCmt">//     This is the other description</span>
<span class="SCmt">//     on more than one line.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="description-list-title"><p>Other title</p></div>
<div class="description-list-block">
<p> This is the other description  on more than one line. </p>
</div>
</div>
<h4 id="230_documentation_Format_of_comments_Quotes">Quotes </h4>
<p>You can create a <b>quote</b> with <span class="code-inline">&gt;</span> </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; This is a block quote on multiple</span>
<span class="SCmt">// &gt; lines.</span>
<span class="SCmt">// &gt;</span>
<span class="SCmt">// &gt; End of the quote.</span></span></div>
<div class="blockquote blockquote-default">
<p> This is a block quote on multiple  lines. </p>
<p> End of the quote. </p>
</div>
<p>You can create a special quote by adding a title on the first line. There must be exactly one blank between <span class="code-inline">&gt;</span> and the title, and the title case should be respected. </p>
<ul>
<li><span class="code-inline">NOTE:</span></li>
<li><span class="code-inline">TIP:</span></li>
<li><span class="code-inline">WARNING:</span></li>
<li><span class="code-inline">ATTENTION:</span></li>
<li><span class="code-inline">EXAMPLE:</span></li>
</ul>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; NOTE:</span>
<span class="SCmt">// &gt; This is the note content</span></span></div>
<div class="blockquote blockquote-note">
<div class="blockquote-title-block"><i class="fa fa-info-circle"></i>  <span class="blockquote-title">Note</span></div><p> This is the note content </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; TIP:</span>
<span class="SCmt">// &gt; This is a tip.</span></span></div>
<div class="blockquote blockquote-tip">
<div class="blockquote-title-block"><i class="fa fa-lightbulb-o"></i>  <span class="blockquote-title">Tip</span></div><p> This is a tip. </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; WARNING:</span>
<span class="SCmt">// &gt; This is the warning content</span>
<span class="SCmt">// &gt;</span>
<span class="SCmt">// &gt; Another paragraph</span></span></div>
<div class="blockquote blockquote-warning">
<div class="blockquote-title-block"><i class="fa fa-exclamation-triangle"></i>  <span class="blockquote-title">Warning</span></div><p> This is the warning content </p>
<p> Another paragraph </p>
</div>
<div class="code-block"><span class="SCmt">// &gt; ATTENTION: The content of the quote can be written on the same line as the title</span></div>
<div class="blockquote blockquote-attention">
<div class="blockquote-title-block"><i class="fa fa-ban"></i>  <span class="blockquote-title">Attention</span></div><p> The content of the quote can be written on the same line as the title </p>
</div>
<div class="code-block"><span class="SCde"><span class="SCmt">// &gt; EXAMPLE:</span>
<span class="SCmt">// &gt; In the 'module.swg' file, we have changed the 'example' title to be `"Result"` instead of `"Example"`.</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> In the <span class="code-inline">module.swg</span> file, we have changed the <span class="code-inline">example</span> title to be <span class="code-inline">"Result"</span> instead of <span class="code-inline">"Example"</span>. </p>
</div>
<h4 id="230_documentation_Format_of_comments_Tables">Tables </h4>
<p>You can create a <b>table</b> by starting a line with <span class="code-inline">|</span>. Each column must then be separated with <span class="code-inline">|</span>. The last column can end with <span class="code-inline">|</span>, but this is not mandatory. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// A table with 4 lines of 2 columns:</span>
<span class="SCmt">// | boundcheck   | Check out of bound access</span>
<span class="SCmt">// | overflow     | Check type conversion lost of bits or precision</span>
<span class="SCmt">// | math         | Various math checks (like a negative '@sqrt')        |</span>
<span class="SCmt">// | switch       | Check an invalid case in a '#[Swag.Complete]' switch |</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><td> boundcheck   </td><td> Check out of bound access</td></tr>
<tr><td> overflow     </td><td> Check type conversion lost of bits or precision</td></tr>
<tr><td> math         </td><td> Various math checks (like a negative <span class="code-inline">@sqrt</span>)        </td></tr>
<tr><td> switch       </td><td> Check an invalid case in a <span class="code-inline">#[Swag.Complete]</span> switch </td></tr>
</table>
</div>
<p>You can define a header to the table if you separate the first line from the second one with a separator like <span class="code-inline">---</span>. A valid separator must have a length of at least 3 characters, and must only contain <span class="code-inline">-</span> or <span class="code-inline">:</span>. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// | Title1 | Title2</span>
<span class="SCmt">// | ------ | ------</span>
<span class="SCmt">// | Item1  | Item2</span>
<span class="SCmt">// | Item1  | Item2</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><th style="text-align: left;">Title1</th><th style="text-align: left;">Title2</th></tr><tr><td style="text-align: left;"> Item1  </td><td style="text-align: left;"> Item2</td></tr>
<tr><td style="text-align: left;"> Item1  </td><td style="text-align: left;"> Item2</td></tr>
</table>
</div>
<p>You can define the <b>column alignment</b> by adding <span class="code-inline">:</span> at the start and/or at the end of a separator. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// | Title1     | Title2       | Title3</span>
<span class="SCmt">// | :-----     | :----:       | -----:</span>
<span class="SCmt">// | Align left | Align center | Align right</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><table class="table-markdown">
<tr><th style="text-align: left;">Title1</th><th style="text-align: center;">Title2</th><th style="text-align: right;">Title3</th></tr><tr><td style="text-align: left;"> Align left </td><td style="text-align: center;"> Align center </td><td style="text-align: right;"> Align right</td></tr>
</table>
</div>
<h4 id="230_documentation_Format_of_comments_Code">Code </h4>
<p>You can create a simple <b>code paragraph</b> with three backticks before and after the code. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// ```</span>
<span class="SCmt">// if a == true</span>
<span class="SCmt">//   @print("true")</span>
<span class="SCmt">// ```</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="code-block"><span class="SCde">if a == true
   @print("true")</span></div>
</div>
<p>You can also create that kind of paragraph by simply indenting the code with four blanks or one tabulation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">//    if a == false</span>
<span class="SCmt">//        @print("false")</span></span></div>
<p>And if you want <b>syntax coloration</b>, add <span class="code-inline">swag</span> after the three backticks. Only Swag syntax is supported right now. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// ```swag</span>
<span class="SCmt">// if a == true</span>
<span class="SCmt">//   @print("true")</span>
<span class="SCmt">// ```</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><div class="code-block"><span class="SCde"><span class="SLgc">if</span> a == <span class="SKwd">true</span>
   <span class="SItr">@print</span>(<span class="SStr">"true"</span>)</span></div>
</div>
<h4 id="230_documentation_Format_of_comments_Titles">Titles </h4>
<p>You can define <b>titles</b> with <span class="code-inline">#</span>, <span class="code-inline">##</span> ... followed by a blank, and then the text. The real level of the title will depend on the context and the generated documentation kind. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// # Title 1</span>
<span class="SCmt">// ## Title 2</span>
<span class="SCmt">// ### Title 3</span>
<span class="SCmt">// #### Title 4</span>
<span class="SCmt">// ##### Title 5</span>
<span class="SCmt">// ###### Title 6</span></span></div>
<h4 id="230_documentation_Format_of_comments_References">References </h4>
<p>You can create an external <b>reference</b> with <span class="code-inline">[name](link)</span>. </p>
<div class="code-block"><span class="SCmt">// This is a [reference](https://github.com/swag-lang/swag) to the Swag repository on GitHub.</span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> This is a <a href="https://github.com/swag-lang/swag">reference</a> to the Swag repository on GitHub. </p>
</div>
<h4 id="230_documentation_Format_of_comments_Images">Images </h4>
<p>You can insert an external <b>image</b> with <span class="code-inline">![name](link)</span>. </p>
<div class="code-block"><span class="SCmt">// This is an image ![image](https://swag-lang/imgs/swag_icon.png).</span></div>
<h4 id="230_documentation_Format_of_comments_Markdown">Markdown </h4>
<p>Some other markers are also supported inside texts. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is `inline code` with back ticks.\</span>
<span class="SCmt">// This is inline 'code' with normal ticks, but just for a single word (no blanks).\</span>
<span class="SCmt">// This is **bold**.\</span>
<span class="SCmt">// This is *italic*.\</span>
<span class="SCmt">// This is ***bold and italic***.\</span>
<span class="SCmt">// This is ~~strikethrough~~.\</span>
<span class="SCmt">// This character \n is escaped, and 'n' will be output as is.\</span></span></div>
<div class="blockquote blockquote-example">
<div class="blockquote-title-block"><i class="fa fa-magnifying-glass"></i>  <span class="blockquote-title">Result</span></div><p> This is <span class="code-inline">inline code</span> with back ticks.<br/>  This is inline <span class="code-inline">code</span> with normal ticks, but just for a single word (no blanks).<br/>  This is <b>bold</b>.<br/>  This is <i>italic</i>.<br/>  This is <b><i>bold and italic</i></b>.<br/>  This is <span class="strikethrough-text">strikethrough</span>.<br/>  This character n is escaped, and <span class="code-inline">n</span> will be output as is.<br/> </p>
</div>

<h3 id="230_documentation_231_001_Api">Api</h3><p>In <span class="code-inline">Swag.DocKind.Api</span> mode, swag will collect all <b>public definitions</b> to generate the documentation. <a href="std.core.php">Std.Core</a> is an example of documentation generated in that mode. </p>
<p>The main module documentation should be placed at the top of the corresponding <span class="code-inline">module.swg</span> file. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is the main module documentation.</span>
<span class="SFct">#dependencies</span>
{
}</span></div>
<p>Other comments need to be placed just before a function, struct or enum. </p>
<p>The first paragraph is considered to be the <b>short description</b> which can appear on specific parts of the documentation. So make it... short. </p>
<p>If the first line ends with a dot <span class="code-inline">.</span>, then this marks the end of the paragraph, i.e. the end of the short description. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This first paragraph is the short description of function 'test1'</span>
<span class="SCmt">//</span>
<span class="SCmt">// This second paragraph should be the long description.</span>
<span class="SKwd">func</span> <span class="SFct">test1</span>()
{
}

<span class="SCmt">// This is the short description of 'test'.</span>
<span class="SCmt">// As the previous first line ends with '.', this is another paragraph, so this should be</span>
<span class="SCmt">// the long description. No need for an empty line before.</span>
<span class="SKwd">func</span> <span class="SFct">test</span>()
{
}</span></div>
<p>For constants or enum values, the document comment is the one declared at the end of the line. </p>
<div class="code-block"><span class="SCde"><span class="SKwd">const</span> <span class="SCst">A</span> = <span class="SNum">0</span>     <span class="SCmt">// This is the documentation comment of constant 'A'</span>

<span class="SKwd">enum</span> <span class="SCst">Color</span>
{
    <span class="SCst">Red</span>         <span class="SCmt">// This is the documentation comment of enum value 'Red'</span>
    <span class="SCst">Blue</span>        <span class="SCmt">// This is the documentation comment of enum value 'Blue'</span>
}</span></div>
<h4 id="230_documentation_231_001_Api_References">References </h4>
<p>You can create a <b>reference</b> to something in the current module with <span class="code-inline">[[name]]</span> or <span class="code-inline">[[name1.name2 etc.]]</span> </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// This is a function with a 'value' parameter.</span>
<span class="SKwd">func</span> <span class="SFct">one</span>(value: <span class="STpe">s32</span>)
{
}

<span class="SCmt">// This is a reference to [[one]]</span>
<span class="SKwd">func</span> <span class="SFct">two</span>()
{
}</span></div>
<h4 id="230_documentation_231_001_Api_NoDoc">NoDoc </h4>
<p>You can use the <span class="code-inline">#[Swag.NoDoc]</span> attribute to prevent a certain element from showing up in the documentation. </p>
<div class="code-block"><span class="SCde"><span class="SCmt">// The function 'one' will be ignored when generating the documentation.</span>
<span class="SAtr">#[Swag.NoDoc]</span>
<span class="SKwd">func</span> <span class="SFct">one</span>()
{
}</span></div>

<h3 id="230_documentation_231_002_Examples">Examples</h3><p>In <span class="code-inline">Swag.DocKind.Examples</span> mode, swag will generate a documentation like this one. Each file will be a chapter or a sub chapter. </p>
<p>File names must start with a number of 3 digits, and can be followed by another number for a sub part. </p>
<div class="code-block"><span class="SCde">100_my_title.swg            =&gt; will generate a '&lt;h1&gt;My title&lt;&lt;h1&gt;' heading
101_001_my_sub_title.swg    =&gt; will generate a '&lt;h2&gt;My sub title&lt;&lt;h2&gt;' heading
102_002_my_sub_title.swg    =&gt; will generate a '&lt;h2&gt;My sub title&lt;&lt;h2&gt;' heading
110_my_other_title.swg      =&gt; will generate a '&lt;h1&gt;My other title&lt;&lt;h1&gt;' heading
111_my_other_title.md       =&gt; you can mix with '.md' files</span></div>
<p>In that mode, the comments in the code you want to be interpreted as documentation (and not swag comments) must start with <span class="code-inline">/**</span>. </p>
<div class="code-block"><span class="SCde">/**
This is a valid documentation comment.
The comment must start with /** and end with */, which should be alone on their respective line.
*/</span></div>
<p>Note that the documentation you are reading right now has been generated in that mode, from the <a href="https://github.com/swag-lang/swag/tree/master/bin/reference/tests/language">std/reference/language</a> module. </p>

<h3 id="230_documentation_231_003_Pages">Pages</h3><p>In <span class="code-inline">Swag.DocKind.Pages</span> mode, each file will generate its own page, with the same name. Other than that, it's the same behavior as the <span class="code-inline">Swag.DocKind.Examples</span> mode. </p>
<p>Can be usefull to generate web pages for <a href="https://github.com/swag-lang/swag/tree/master/bin/reference/tests/web">example</a>. </p>
<div class="swag-watermark">
Generated on 02-11-2023 with <a href="https://swag-lang.org/index.php">swag</a> 0.26.0</div>
</div>
</div>
</div>
</body>
</html>
